<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>Instrument使用Signposts工具 - 习七</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="iTBoyer"><meta name=description content="引言 性能是实现卓越的用户体验的关键之一。当应用或者游戏表现的运行迅速，反应灵敏时，用户会更喜欢。但是软件是很复杂的，当你的应用视图做某事时，例如只是点了一个按钮，但程序也有可能做了很多的事情，这就意味着你可以在一些看似不太可能的地方找到一些优化点。但这样做，挖掘性能的优化点，有时就需要深入理解你的程序正在做些什么。它需要您知道代码什么时候执行的，以及特定的操作需要多长时间。所以这就体验出来了有一个好的测试工具是多么的重要。
"><meta name=keywords content="swift,iOS,积极主动,以终为始,要事第一,效能平衡"><meta name=generator content="Hugo 0.150.0 with theme even"><link rel=canonical href=https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/Instrument%E4%BD%BF%E7%94%A8Signposts%E5%B7%A5%E5%85%B7/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link href=/sass/main.min.d4d0dce78b3ec6333437bc36540c4749ae9a27ff4ca2d7562da2dbfbf991dde3.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/search.css><link rel=stylesheet href=/css/copy-to-clipboard.css><link rel=stylesheet href=/css/todo.css><meta property="og:url" content="https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/Instrument%E4%BD%BF%E7%94%A8Signposts%E5%B7%A5%E5%85%B7/"><meta property="og:site_name" content="习七"><meta property="og:title" content="Instrument使用Signposts工具"><meta property="og:description" content="引言 性能是实现卓越的用户体验的关键之一。当应用或者游戏表现的运行迅速，反应灵敏时，用户会更喜欢。但是软件是很复杂的，当你的应用视图做某事时，例如只是点了一个按钮，但程序也有可能做了很多的事情，这就意味着你可以在一些看似不太可能的地方找到一些优化点。但这样做，挖掘性能的优化点，有时就需要深入理解你的程序正在做些什么。它需要您知道代码什么时候执行的，以及特定的操作需要多长时间。所以这就体验出来了有一个好的测试工具是多么的重要。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2018-10-02T23:19:55+00:00"><meta property="article:modified_time" content="2018-10-02T23:19:55+00:00"><meta property="article:tag" content="IOS"><meta property="article:tag" content="调试"><meta itemprop=name content="Instrument使用Signposts工具"><meta itemprop=description content="引言 性能是实现卓越的用户体验的关键之一。当应用或者游戏表现的运行迅速，反应灵敏时，用户会更喜欢。但是软件是很复杂的，当你的应用视图做某事时，例如只是点了一个按钮，但程序也有可能做了很多的事情，这就意味着你可以在一些看似不太可能的地方找到一些优化点。但这样做，挖掘性能的优化点，有时就需要深入理解你的程序正在做些什么。它需要您知道代码什么时候执行的，以及特定的操作需要多长时间。所以这就体验出来了有一个好的测试工具是多么的重要。"><meta itemprop=datePublished content="2018-10-02T23:19:55+00:00"><meta itemprop=dateModified content="2018-10-02T23:19:55+00:00"><meta itemprop=wordCount content="6341"><meta itemprop=keywords content="IOS,调试"><meta name=twitter:card content="summary"><meta name=twitter:title content="Instrument使用Signposts工具"><meta name=twitter:description content="引言 性能是实现卓越的用户体验的关键之一。当应用或者游戏表现的运行迅速，反应灵敏时，用户会更喜欢。但是软件是很复杂的，当你的应用视图做某事时，例如只是点了一个按钮，但程序也有可能做了很多的事情，这就意味着你可以在一些看似不太可能的地方找到一些优化点。但这样做，挖掘性能的优化点，有时就需要深入理解你的程序正在做些什么。它需要您知道代码什么时候执行的，以及特定的操作需要多长时间。所以这就体验出来了有一个好的测试工具是多么的重要。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--><script>(function(){""&&prompt("请输入文章密码")!==""&&(alert("密码错误！"),history.back())})()</script></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>习七</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>主页</li></a><a href=/post/><li class=mobile-menu-item>归档</li></a><a href=/tags/><li class=mobile-menu-item>标签</li></a><a href=/categories/><li class=mobile-menu-item>分类</li></a><a href=/categories/%E5%91%A8%E6%8A%A5/><li class=mobile-menu-item>周报</li></a><a href=/iDocs/><li class=mobile-menu-item>文档</li></a><a href=/authors/itboyer/><li class=mobile-menu-item>关于</li></a><a href=/resume><li class=mobile-menu-item>认识我</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>习七</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>主页</a></li><li class=menu-item><a class=menu-item-link href=/post/>归档</a></li><li class=menu-item><a class=menu-item-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-item-link href=/categories/%E5%91%A8%E6%8A%A5/>周报</a></li><li class=menu-item><a class=menu-item-link href=/iDocs/>文档</a></li><li class=menu-item><a class=menu-item-link href=/authors/itboyer/>关于</a></li><li class=menu-item><a class=menu-item-link href=/resume>认识我</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>Instrument使用Signposts工具</h1><div class=post-meta><span class=post-time>2018-10-02</span><div class=post-category><a href=/categories/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/>解决方案</a></div><span class=more-meta>约 6341 字 </span><span class=more-meta>预计阅读 13 分钟 </span><span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读 </span><span class=more-meta>by</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#>引言</a></li><li><a href=#>介绍Signposts及历史</a></li><li><a href=#>使用Signposts</a><ul><li><a href=#>异步用例：测量异步任务的时间</a></li><li><a href=#>在Signposts中添加元数据</a></li><li><a href=#>添加独立事件</a></li></ul></li><li><a href=#>有条件启动Signposts</a></li><li><a href=#>C语言中的Signposts</a></li><li><a href=#>Instruments中使用路标</a><ul><li><a href=#>路标</a></li><li><a href=#>兴趣点</a></li></ul></li><li><a href=#>自定义Instruments</a></li></ul></nav></div></div><div class=post-outdated><div class=warn><p>【注意】最后更新于 <span class=timeago datetime=2018-10-02T23:19:55 title="October 2, 2018">October 2, 2018</span>，文中内容可能已过时，请谨慎使用。</p></div></div><div class=post-content><h2>引言</h2><p>性能是实现卓越的用户体验的关键之一。当应用或者游戏表现的运行迅速，反应灵敏时，用户会更喜欢。但是软件是很复杂的，当你的应用视图做某事时，例如只是点了一个按钮，但程序也有可能做了很多的事情，这就意味着你可以在一些看似不太可能的地方找到一些优化点。但这样做，挖掘性能的优化点，有时就需要深入理解你的程序正在做些什么。它需要您知道代码什么时候执行的，以及特定的操作需要多长时间。所以这就体验出来了有一个好的测试工具是多么的重要。</p><p>我们知道开发更好的工具，并让开发者使用这些工具，是我们帮助您成为更高效的开发人员的方法之一。所以今天我们要谈谈其中的一个工具——<code>Signposts</code>（路标）。</p><h2>介绍Signposts及历史</h2><p><code>Signposts</code>是<code>OSLog</code>家族的新成员，我们正准备让它支持<code>iOS</code>和<code>macOs</code>。您可以在swift和C中使用它们，但最酷的是我们把它和<code>Instruments</code>集成在了一起。这就意味着<code>Instruments</code>可以获取<code>Signposts</code>所产生的数据，并且让深入你理解你的程序正在做什么。</p><p>首先要介绍一点历史，几年前我们介绍了<code>OSLog</code>。这是我们现代化的呈现日志记录的工具。这是我们从系统中获取调试信息的方法。它是在我们“效率”、“隐私”的目标下完成的。具体了解，请查看<a href=https://developer.apple.com/videos/play/wwdc2016/721/>WWDC 2016 Unified Logging and Activity Tracing</a>。</p><p>这里你可以看到一个<code>OSLog</code>的例子，创建一个简单的日志句柄，并且像它发送了一个Hello world。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let logHandle = OSLog(subsystem: &#34;com.example.widget&#34;, category: &#34;Setup&#34;)
</span></span><span class=line><span class=cl>os_log(.info, log: logHandle, &#34;Hello, %{public}s!&#34;, world)
</span></span></code></pre></td></tr></table></div></div><p><code>Signposts</code>扩展了<code>OSLogAPI</code>，但它们是为性能用例而做的。这意味着它们正在传达与性能相关的信息，并且它们与我们的开发工具集成在一起，您可以使用<code>Signposts</code>对代码进行标注，然后启动<code>Instruments</code>查看类似的内容。因此，<code>Instruments</code>向您展示了您的程序正在做的事情的可视化时间轴，以及<code>Signposts</code>展示在上面。然后底部有个表，统计汇总和分析<code>Signposts</code>数据，数据分成一块一块的，可以让您看到程序到底做了些什么。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/1.jpg alt>
在文章中，我将谈谈如何在您的代码中使用<code>Signposts</code>，以及展示一下他们的作用。然后展示<code>Instruments</code>中<code>Signposts</code>的可视化界面，让您了解<code>Instruments</code>和<code>Signpost</code>是如何协同工作的。</p><h2>使用Signposts</h2><ol><li><code>Siginposts</code>的两个函数:<code>os_signpost(.begin, ...)</code>和<code>os_signpost(.end, ...)</code>.</li><li>日志句柄:<code>日志句柄</code>需要两个参数一个是<code>子系统</code>，一个是<code>类别</code>.
让我们从一个非常基础的例子开始。想象一下这是你的应用。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/2.jpg alt>
你要研究的就是一个接口特定部分刷新所需要的时间。你知道你需要加载一些图片并在屏幕上展示。所以，在这个简单、抽象的视图中，可能你需要做的就是获取图片资源。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/3.jpg alt>
所有操作完成后，界面会刷新。<code>Signposts</code>允许我们在一系列工作的<code>开始</code>和<code>结尾</code>进行标记，然后将这两个时间点关联起来，同时这两个日志事件也会互相关联。这就需要调用<code>Siginposts</code>的两个函数。<code>os_signpost(.begin, ...)</code>和<code>os_signpost(.end, ...)</code>。图中<code>b</code>箭头代表开始，<code>e</code>箭头代表结束。然后我们将这两个时间点互相关联，让您了解这一段经过的时间。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/4.jpg alt>
在代码中，有一个简单的算法实现，对于我们接口中的每个元素，我们将获取该资源，这正是我们想要去测量的。</li></ol><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=k>for</span> <span class=n>element</span> <span class=k>in</span> <span class=n>panel</span><span class=p>.</span><span class=n>elements</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>fetchAsset</span><span class=p>(</span><span class=k>for</span><span class=p>:</span> <span class=n>element</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>因此，为了将<code>Signposts</code>代码加入到基本的代码中，我们需要导入<code>import os</code>模块，然后由于<code>Siginposts</code>是<code>OSLog</code>的一部分，所以我们需要创建一个<code>日志句柄</code>。这个<code>日志句柄</code>需要两个参数一个是<code>子系统</code>，一个是<code>类别</code>。</p><ul><li>子系统: 在整个项目中可能都是相同的，它看起来很像您的app的包名。它代表了组件或者软件，或者是您正在使用的框架。</li><li>类别: 用于关联，将相关的操作或者<code>Signposts</code>绑定在一起。之后我们会讲到这么做的好处。</li></ul><p>当我们拥有了日志句柄，我们只需要调用<code>Siginposts</code>的<code>.begin</code>和<code>.end</code>两个函数即可。参数中，我们将日志句柄传递过去，然后再传递一个<code>Signpost</code>的名字。名字是一个字符串，用来标识我们感兴趣的操作的时间间隔。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span><span class=lnt>5
</span><span class=lnt>6
</span><span class=lnt>7
</span><span class=lnt>8
</span><span class=lnt>9
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>import</span> <span class=nc>os</span><span class=p>.</span><span class=nc>signpost</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>refreshLog</span> <span class=p>=</span> <span class=n>OSLog</span><span class=p>(</span><span class=n>subsystem</span><span class=p>:</span> <span class=s>&#34;com.example.your-app&#34;</span><span class=p>,</span> <span class=n>category</span><span class=p>:</span> <span class=s>&#34;RefreshOperations&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>element</span> <span class=k>in</span> <span class=n>panel</span><span class=p>.</span><span class=n>elements</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>fetchAsset</span><span class=p>(</span><span class=k>for</span><span class=p>:</span> <span class=n>element</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>os_signpost</span><span class=p>(.</span><span class=n>end</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p><img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/5.jpg alt>
所以返回之前的时间轴，它就变成了这个样子。在每次开始、结束获取资源时，我们都添加了一个<code>路标</code>。因为在开始和结束的路标的标识一样，所以我们可以将他们两者匹配在一起。但是，如果我们还想要测试整个操作的全部时间，整个刷新过程是怎样的，该如何去做呢？我们在代码中，只需要再添加一对新路标即可（新的名字）。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>import</span> <span class=nc>os</span><span class=p>.</span><span class=nc>signpost</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>refreshLog</span> <span class=p>=</span> <span class=n>OSLog</span><span class=p>(</span><span class=n>subsystem</span><span class=p>:</span> <span class=s>&#34;com.example.your-app&#34;</span><span class=p>,</span> <span class=n>category</span><span class=p>:</span> <span class=s>&#34;RefreshOperations&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Refresh Panel&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>element</span> <span class=k>in</span> <span class=n>panel</span><span class=p>.</span><span class=n>elements</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>fetchAsset</span><span class=p>(</span><span class=k>for</span><span class=p>:</span> <span class=n>element</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>os_signpost</span><span class=p>(.</span><span class=n>end</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>end</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Refresh Panel&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>这时，我们的时间轴又发生了变化。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/6.jpg alt></p><h3>异步用例：测量异步任务的时间</h3><ol><li><code>Signpost IDs</code>路标ID:区分重叠时间间隔的方法，将告诉系统哪些是相同类型的操作，但每个操作彼此不同。</li><li></li></ol><p>上面是一个很简单的例子。如果你的应用顺序执行第一步、第二步、第三步等等，那么这样测量是非常有效的。但是我们会经常用到一些异步的工作，他们可能同时发生，他们之间也可能会有重叠或者交叉。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/7.jpg alt>
在这种情况下，我们需要向系统提供一些额外的信息，以便系统可以将这些路标彼此区分开来。到现在为止，我们在调用方法的时候只用到了名字，通过名字将相同路标的绑定在一起。名字已经确定了时间间隔，但是没有给我们一种区分重叠时间间隔的方法，所以在这里引入了<code>Signpost IDs</code>。路标ID将告诉系统哪些是相同类型的操作，但每个操作彼此不同。在路标开始和结尾传递相同的id，则系统知道这两个是关联的。你可以通过日志句柄来得到一个路标ID。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span><span class=lnt>4
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>spid</span> <span class=p>=</span> <span class=n>OSSignpostID</span><span class=p>(</span><span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>,</span> <span class=n>signpostID</span><span class=p>:</span> <span class=n>spid</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=c1>//  some code or even async...</span>
</span></span><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>end</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>,</span> <span class=n>signpostID</span><span class=p>:</span> <span class=n>spid</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>同样你也可以通过一个对象来得到<code>日志句柄</code>。如果你有一些对象代表您正在尝试的工作，只要您使用该对象实例就会生成相同的路标ID。这就意味着您不用去存放路标ID，只需要通过对象去管理ID就好了。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>let spid = OSSignpostID(log: refreshLog, object: element)
</span></span></code></pre></td></tr></table></div></div><p>在视觉上，您可以将路标ID视为允许我们向每一个路标调用传递一些额外的上下文，这可以将特定操作的开始和结束标记互相关联。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/8.jpg alt>
这很重要，因为这些操作不仅仅可以重叠，而且通常他们需要的时间也不同。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/9.jpg alt>
我们现在把示例中的<code>fetchAsset</code>从同步调用改为异步调用。并且由于是异步的，这些时间间隔可能会相互重叠，所以我们还要在创建路标时加上路标ID。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>refreshLog</span> <span class=p>=</span> <span class=n>OSLog</span><span class=p>(</span><span class=n>subsystem</span><span class=p>:</span> <span class=s>&#34;com.example.your-app&#34;</span><span class=p>,</span> <span class=n>category</span><span class=p>:</span> <span class=s>&#34;RefreshOperations&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=kd>let</span> <span class=nv>spidForRefresh</span> <span class=p>=</span> <span class=n>OSSignpostID</span><span class=p>(</span><span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Refresh Panel&#34;</span><span class=p>,</span> <span class=n>signpostID</span><span class=p>:</span> <span class=n>spidForRefresh</span><span class=p>)</span>
</span></span><span class=line><span class=cl>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>element</span> <span class=k>in</span> <span class=n>panel</span><span class=p>.</span><span class=n>elements</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=c1>//通过对象去创建路标ID</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>spid</span> <span class=p>=</span> <span class=n>OSSignpostID</span><span class=p>(</span><span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>object</span><span class=p>:</span> <span class=n>element</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=c1>//通过ID去记录一个路标</span>
</span></span><span class=line><span class=cl>    <span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>,</span> <span class=n>signpostID</span><span class=p>:</span><span class=n>spid</span><span class=p>)</span>    
</span></span><span class=line><span class=cl>    <span class=n>fetchAssetAsync</span><span class=p>(</span><span class=k>for</span><span class=p>:</span> <span class=n>element</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>        <span class=c1>//每一个完成之后的回调</span>
</span></span><span class=line><span class=cl>        <span class=n>os_signpost</span><span class=p>(.</span><span class=n>end</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>,</span> <span class=n>signpostID</span><span class=p>:</span> <span class=n>spid</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=p>}</span> 
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=c1>//  全部完成完成的回调</span>
</span></span><span class=line><span class=cl><span class=n>notifyWhenDone</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>os_signpost</span><span class=p>(.</span><span class=n>end</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Refresh Panel&#34;</span><span class=p>,</span> <span class=n>signpostID</span><span class=p>:</span> <span class=n>spidForRefresh</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><p>这样就完成了，您可以将<code>Signposts</code>视为一种分类或等级制度。所有的操作都通过日志句柄相关联，这意味着日志分类。然后对我们感兴趣的每个操作，我们给它一个路标名字，如果可能有重叠，我们在给他们<code>路标ID</code>，告诉系统虽然名字相同了，但是我希望通过ID区分。</p><p>这个接口设计的特别灵活，所以你可以控制起始点和结束点的所有参数，日志句柄，路标名字及ID。只要传递的参数是一致的，起始点与结束点就可以对应上，即便他们写在了不同的方法或者文件中。我们之所以这样做是因为希望您能够将它应用到实际开发中。</p><h3>在Signposts中添加元数据</h3><p>您可能希望在路标中传达一些额外的信息，额外的性能相关的信息。很巧，我们有一个方法来为路标添加元数据。下面是一个基本的路标。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>log</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Compute Physics&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>我们可以添加一个额外的<code>字符串</code>（OSLog格式化的）参数。这允许您向开始点与结束点添加一些上下文。我们可以通过<code>%d</code>来传递<code>整数</code>。当然也可以传递<code>其他的格式化类型</code>的参数。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>log</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Compute Physics&#34;</span><span class=p>,</span> <span class=s>&#34;%d %d %d %d&#34;</span><span class=p>,</span><span class=n>x1</span><span class=p>,</span> <span class=n>y1</span><span class=p>,</span> <span class=n>x2</span><span class=p>,</span> <span class=n>y2</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>log</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Compute Physics&#34;</span><span class=p>,</span><span class=s>&#34;%{public}s %.1f %.1f %.2f %.1f %.1f&#34;</span><span class=p>,</span> <span class=n>description</span><span class=p>,</span> <span class=n>x1</span><span class=p>,</span> <span class=n>y1</span><span class=p>,</span> <span class=n>m</span><span class=p>,</span> <span class=n>x2</span><span class=p>,</span> <span class=n>y2</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>至于字符串的长度，不用担心，您可以自由、随意的使用。该字符串也会全部渲染到Instruments的界面中，或者仍然可以在程序中访问附加的数据。</p><h3>添加独立事件</h3><p>除了元数据之外，您可能还希望及时添加单独的时间点。这就表示，除了开始的路标以及结尾的路标外，你可能还有一个路标，该路标没有连接到特定的时间间隔，而是一些固定的时刻。为此，我们提供了一个带有事件类型的路标。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/10.jpg alt>
用法与设置开始、结束的路标类似，只不过它标识一个单一的时间点。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>event</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>log</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>,</span> <span class=s>&#34;Fetched first chunk, size %u&#34;</span><span class=p>,</span> <span class=n>size</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>event</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>log</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Swipe&#34;</span><span class=p>,</span> <span class=s>&#34;For action 0x%x&#34;</span><span class=p>,</span> <span class=n>actionCode</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p>您可以在间隔的上下文中使用该方法，或者一些您想追踪的与用户交互无关等时间间隔无关的内容。如果您真的在调查一个性能上的问题，您可能会大量使用它。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/11.jpg alt></p><h2>有条件启动Signposts</h2><ol><li>路标通常默认是开启
如果你启用了一些路标，那么他们通常默认是开启的，但我想谈谈有条件的打开和关闭它们。首先我要强调一下，路标是轻量级的。这说明我们已经做了很多优化。我们通过编译器优化来完成这些工作，这些优化在编译时就做了，而不是在运行时完成的。我们还推迟了很多工作，以便他们在Instruments后端完成。这意味着路标应该占用很少的系统资源。我们之所有这样做是因为我们希望尽量减少对您代码的影响。我们也做到了这一点，因为我们确保即使您的时间跨度非常小，也可以发出许多路标来获取一些细粒度的测量结果。</li><li>关闭路标
但您可能希望能够关闭路标。要做到一这点，我们将利用<code>OSLog</code>的功能，即禁用的<code>日志句柄</code>。禁用的<code>日志句柄</code>也是一个简单的句柄。它的作用是针对该句柄进行的每个<code>OSLog</code>和<code>os_signpost</code>调用都会几乎会变为无操作。事实上，如果你在C中采用这个，我们甚至会对你进行检查，然后我们甚至不会评估其余的参数。所以你可以在运行时更改这个句柄。</li></ol><p>举个例子，让我们回到第一个示例的代码上。我以一个环境变量作为条件，来初始化。如果包含该变量，那么使用普通的<code>os日志构造函数</code>；如果不包含，那么将使用禁用的<code>日志句柄</code>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=kd>let</span> <span class=nv>refreshLog</span><span class=p>:</span> <span class=n>OSLog</span>
</span></span><span class=line><span class=cl><span class=k>if</span> <span class=n>ProcessInfo</span><span class=p>.</span><span class=n>processInfo</span><span class=p>.</span><span class=n>environment</span><span class=p>.</span><span class=n>keys</span><span class=p>.</span><span class=bp>contains</span><span class=p>(</span><span class=s>&#34;SIGNPOSTS_FOR_REFRESH&#34;</span><span class=p>)</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>refreshLog</span> <span class=p>=</span> <span class=n>OSLog</span><span class=p>(</span><span class=n>subsystem</span><span class=p>:</span> <span class=s>&#34;com.example.your-app&#34;</span><span class=p>,</span> <span class=n>category</span><span class=p>:</span> <span class=s>&#34;RefreshOperations&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span> <span class=k>else</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>refreshLog</span> <span class=p>=</span> <span class=p>.</span><span class=n>disabled</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Refresh Panel&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=k>for</span> <span class=n>element</span> <span class=k>in</span> <span class=n>panel</span><span class=p>.</span><span class=n>elements</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=n>os_signpost</span><span class=p>(.</span><span class=n>begin</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>fetchAsset</span><span class=p>(</span><span class=k>for</span><span class=p>:</span> <span class=n>element</span><span class=p>)</span>
</span></span><span class=line><span class=cl>    <span class=n>os_signpost</span><span class=p>(.</span><span class=n>end</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Fetch Asset&#34;</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span><span class=line><span class=cl><span class=n>os_signpost</span><span class=p>(.</span><span class=n>end</span><span class=p>,</span> <span class=n>log</span><span class=p>:</span> <span class=n>refreshLog</span><span class=p>,</span> <span class=n>name</span><span class=p>:</span> <span class=s>&#34;Refresh Panel&#34;</span><span class=p>)</span>
</span></span></code></pre></td></tr></table></div></div><p><code>环境变量</code>是您在调试程序时可以在<code>Xcode scheme</code>中设置的内容。现在我说你不必在调用中进行更改，但这种方式相当昂贵并且只适用于调试时。因此如果您有一些基于<code>Instruments</code>的特定的功能，你可以检查特定的<code>日志句柄</code>，查看它是否打开了<code>siginposts enabled</code>属性。然后试用该属性来控制添加该附加操作。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span><span class=lnt>3
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-swift data-lang=swift><span class=line><span class=cl><span class=k>if</span> <span class=n>refreshLog</span><span class=p>.</span><span class=n>signpostsEnabled</span> <span class=p>{</span>
</span></span><span class=line><span class=cl>    <span class=kd>let</span> <span class=nv>information</span> <span class=p>=</span> <span class=n>copyDescription</span><span class=p>()</span> <span class=n>os_signpost</span><span class=p>(...,</span> <span class=n>information</span><span class=p>)</span>
</span></span><span class=line><span class=cl><span class=p>}</span>
</span></span></code></pre></td></tr></table></div></div><h2>C语言中的Signposts</h2><p>上面我们所有示例都是swift的，但是C语言中也提供了路标。到目前为止，上述功能都是可用的：长句柄、使用不用的路标、以及管理路标标识符。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/12.jpg alt>
那些对C语言中使用路标感兴趣的人，推荐你们阅读头文件中的文档。文档中包含了所有信息，都是从C语言开发人员的角度考虑的。</p><h2>Instruments中使用路标</h2><p>现在介绍完如何在代码中应用<code>路标</code>，接下来很开心为大家介绍<code>路标</code>和<code>Instruments</code>是如何在一起工作的。向大家展示<code>Instruments 10</code>中三个重要的新功能，来帮助您使用路标数据。</p><ul><li>路标工具:该工具允许您记录、查看和分析应用程序中所有的路标活动。</li><li>兴趣点:谈谈什么是兴趣点，以及何时您要设置一个兴趣点</li><li>自定义工具: 介绍新的自定义工具，以及如何将它与路标一起使用，以获得更精致的路标展示。</li></ul><h3>路标</h3><p>接下来就看下例子吧。示例的app名叫开拓者，主要是展示一些风景。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/13.jpg alt>
当我们滚动时，最初展示一个白色的背景，当图片下载完之后，会填充到白色背景区域。这是一种常见的设计，尽管这样设计可以提升一些用户体验，但很难分析它的性能，因为在这个过程中进行了很多异步的活动。如果用户快速滚动，那么有可能出现某个单元格还没有下载完毕之前，就已经要被重用了，那么就必须取消下载。如果不取消的话，可能会有几个并行下载，而展示出来的图也不一定是我们想要的（图和标题不对应）。接下来看看如何通过路标来分析这个应用吧。
首先，在每个单元格中，有一个<code>startImageDownload</code>方法。当我们需要下载图片时会调用它，并传递要下载图片的名字。方法内部，有一个图片下载类，我们通过图片名字和设置自己为委托来初始化该类。在这种情况下，由于<code>downloader</code>对象代表正在进行的并发活动，因为下载是异步的，所以可以通过<code>downloader</code>来创建一个<code>路标ID</code>。接着在下载开始之前，调用<code>os_signpost(.begin，...)</code>方法，设置<code>日志句柄</code>、<code>名称</code>、<code>ID</code>、以及一些元数据。然后开始下载图片，并且将<code>downloader</code>设置为当前单元格正在运行的下载器。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/14.jpg alt>
图片下载完毕的回调中将图片展示到屏幕上，然后调用<code>os_siginpost(.end, ...</code>方法，设置<code>日志句柄</code>、<code>名称</code>、<code>ID</code>、以及一些元数据。您会注意到，我们用<code>xcode:size-in-bytes</code>注释了这个参数。它的作用是告诉<code>Xcode</code>和<code>Instruments</code>这个参数应该被视为展示和分析字节大小。这种被称作为<code>工程类型</code>。可以<code>Instruments</code>开发人员帮助文档中找到他们的详细介绍。最后，我们下载完毕了，将下载器设置为空。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/15.jpg alt>
当然下载除了成功以外，还有失败的情况，在单元格准备重用时，进行相关的路标设置。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/16.jpg alt>
设置完之后，就可以来进行分析了。打开Instruments后，可以选择一个空白的文档。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/17.jpg alt>
然后从右侧添加中选择os_signpost工具，并推动到轨迹中。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/18.jpg alt>
接下来就可以在app中操作了，一阵操作猛如虎之后，我们回到<code>Instruments</code>来看一下。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/20.jpg alt>
通过选择某一段时间，可以查看这段时间内的情况。我们可以看到左侧的路标名称<code>Background Image</code>，以及右侧的一些使用元数据来注释的时间段。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/19.jpg alt>
现在再缩小然后看看其他未知的追踪，我们注意到我们最多只有五个并行下载图片的任务，这是一件好事，证明我们取消了。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/21.jpg alt>
查看底部间隔的摘要，我们看到是按照类别、路标的名字、开始的消息和结束的消息来区分的。我们来看一共触发了93次的图片下载请求。其中location1触发了12次，7次取消，5次下载成功，下载成功时间共计3.04秒，3.31MB。并且可以查看每次请求时间的最小值、最大值和平均值。如果对某类数据感兴趣，可以点击进入查看详细内容。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/22.jpg alt>
如果要查看元数据相关的内容，可以进行筛选，然后查看数据。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/23.jpg alt>
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/24.jpg alt>
这是一种很好的方式来查看您通过元数据传达的值的统计分析.</p><h3>兴趣点</h3><p>接下里，我们看看<code>兴趣点</code>。回到应用，我们我们在主页点击一个单元格，就会进入详情页面。<br><img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/26.jpg alt>
如果现在我们每次都能追踪这些详情页面出现的时间就太好了，因为这样我们就可以知道用户正在做什么，并且我们知道用户在app中的哪个页面。当然可以通过路标完成这件事，但是你需要在<code>Instruments</code>中把它拖到轨迹中，并且记录所有的活动。这样有点淡化了导航事件的重要性。所以我们提供了兴趣点。</p><p>点在我们在详情页面的代码中查看<code>viewDidAppear</code>方法，我们通过<code>os_signpost(.event, ...</code>来创建一个<code>路标事件</code>。这个事件要发送到我们创建的称之为<code>兴趣点</code>的<code>日志句柄</code>中。<code>类别</code>设置为<code>兴趣点</code>，这正是<code>Instruments</code>寻找的一个特殊类别。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/27.jpg alt>
我们回到再次打开<code>Instruments</code>选择时间分析，会发现自动有了兴趣点这一项。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/28.jpg alt>
然后开始录制，从首页进入详情页，选择不同的单元格反复执行，然后返回Instruments，就可以看到这些兴趣点了。
<img src=https://raw.githubusercontent.com/kingsword/BlogSnapShot/master/WWDC%202018%20sessions/405/29.jpg alt>
因此您可以在看到用户在哪个页面，并且将其与其他性能数据相关联。</p><h2>自定义Instruments</h2><p>视频中，具体没有讲如何创建，如果想了解如何创建的话，可以参考一下<a href=https://developer.apple.com/wwdc18/410>WWDC 2018 Creating Custom Instruments</a>。
<a href=https://developer.apple.com/videos/play/wwdc2018/405/>WWDC 2018 session 405</a>
转自<a href=https://blog.csdn.net/tugele/article/details/81252603>使用日志记录来衡量性能</a></p></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>iTBoyer</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2018-10-02</span></p></div><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=/img/reward/weixin.jpg>
<span>微信打赏</span>
</label><label class=qr-code-image for=reward><img class=image src=/img/reward/zhifubao.jpg>
<span>支付宝打赏</span></label></div></div><footer class=post-footer><div class=post-tags><a href=/tags/iOS/>iOS</a>
<a href=/tags/%E8%B0%83%E8%AF%95/>调试</a></div><nav class=post-nav><a class=prev href=/post/old/hexo/hexo%E9%9B%86%E6%88%90gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">hexo集成gitment评论系统</span>
<span class="prev-text nav-mobile">上一篇</span>
</a><a class=next href=/post/old/xcode/Xcode10%E6%96%B0%E7%89%B9%E6%80%A7/><span class="next-text nav-default">Xcode10新特性</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js crossorigin=anonymous></script><script type=text/javascript>var gitalk=new Gitalk({id:"2018-10-02 23:19:55 +0000 UTC",title:"Instrument使用Signposts工具",clientID:"d46ea301857e36a08319",clientSecret:"9da00f1f475c4166b96fbe157d0afdbd64cc613c",repo:"it-boyer.github.io",owner:"it-boyer",admin:["it-boyer"],body:decodeURI(location.href)});gitalk.render("gitalk-container")</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:iTBoyer@qq.com class="iconfont icon-email" title=email></a><a href=https://github.com/it-boyer class="iconfont icon-github" title=github></a><a href=http://weibo.com/1791281385 class="iconfont icon-weibo" title=weibo></a><a href=http://www.zhihu.com/people/boyers class="iconfont icon-zhihu" title=zhihu></a><a href=http://douban.com/people/boyers class="iconfont icon-douban" title=douban></a><a href=https://space.bilibili.com/67083417 class="iconfont icon-bilibili" title=bilibili></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动
</span><span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次
</span><span class=division>|</span> <span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy; 2017 - 2025<span class=heart><i class="iconfont icon-heart"></i></span><span>iTBoyer</span></span></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script><script src=/js/copy-to-clipboard.js></script></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script><script>var languageCode="zh-cn".replace(/-/g,"_").replace(/_(.*)/,function(e,t){return e.replace(t,t.toUpperCase())});timeago().render(document.querySelectorAll(".timeago"),languageCode),timeago.cancel()</script><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html><style>#fastSearch{visibility:hidden;position:absolute;left:10px;top:10px;display:inline-block;width:320px;margin:0 10px 0 0;padding:0}#fastSearch input{padding:4px;width:100%;height:31px;font-size:1.6em;color:#222129;font-weight:700;background-color:gray;border-radius:3px 3px 0 0;border:none;outline:none;text-align:left;display:inline-block}#searchResults li{list-style:none;margin-left:0;background-color:gray;border-bottom:1px dotted #000}#searchResults li .title{font-size:1.1em;margin:0;display:inline-block}#searchResults{visibility:inherit;display:inline-block;width:320px;margin:0;max-height:calc(100vh - 120px);overflow:hidden}#searchResults a{text-decoration:none!important;padding:10px;display:inline-block;width:100%}#searchResults a:hover,#searchResults a:focus{outline:0;background-color:#666;color:#fff}#search-btn{position:absolute;top:10px;right:20px;font-size:24px}@media(max-width:683px){#fastSearch,#search-btn{top:64px}}</style><div id=fastSearch><input id=searchInput tabindex=0><ul id=searchResults></ul></div><script src=/js/fuse.js></script><script src=/js/fastsearch.js></script>