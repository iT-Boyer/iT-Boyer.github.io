<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta http-equiv=X-UA-Compatible content="IE=edge,chrome=1"><title>iOS面试题大集合[转] - 习七</title><meta name=renderer content="webkit"><meta name=viewport content="width=device-width,initial-scale=1,maximum-scale=1"><meta http-equiv=Cache-Control content="no-transform"><meta http-equiv=Cache-Control content="no-siteapp"><meta name=theme-color content="#f8f5ec"><meta name=msapplication-navbutton-color content="#f8f5ec"><meta name=apple-mobile-web-app-capable content="yes"><meta name=apple-mobile-web-app-status-bar-style content="#f8f5ec"><meta name=author content="iTBoyer"><meta name=description content="iOS有用的面试题大集合 面试题从何处得来 招聘一个靠谱的 iOS 知乎－如何面试 iOS 工程师？ 阅读面试题之前 在正式开始之前，我期望你能对iOS/Mac OS X平台开发有所了解，在iOS开发中已经很少需要自己写复杂的算法了，一般情况下很少会在面试中出现算法的考核，如果你了解一些基础的算法，还是有帮助的。
"><meta name=keywords content="iOS,面试,z资源"><meta name=generator content="Hugo 0.150.0 with theme even"><link rel=canonical href=https://it-boyer.github.io/post/old/swift/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E9%9B%86%E5%90%88/><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=manifest href=/manifest.json><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link href=/sass/main.min.d4d0dce78b3ec6333437bc36540c4749ae9a27ff4ca2d7562da2dbfbf991dde3.css rel=stylesheet><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.css integrity="sha256-7TyXnr2YU040zfSP+rEcz29ggW4j56/ujTPwjMzyqFY=" crossorigin=anonymous><link rel=stylesheet href=/css/search.css><link rel=stylesheet href=/css/copy-to-clipboard.css><link rel=stylesheet href=/css/todo.css><meta property="og:url" content="https://it-boyer.github.io/post/old/swift/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E9%9B%86%E5%90%88/"><meta property="og:site_name" content="习七"><meta property="og:title" content="iOS面试题大集合[转]"><meta property="og:description" content="iOS有用的面试题大集合 面试题从何处得来 招聘一个靠谱的 iOS 知乎－如何面试 iOS 工程师？ 阅读面试题之前 在正式开始之前，我期望你能对iOS/Mac OS X平台开发有所了解，在iOS开发中已经很少需要自己写复杂的算法了，一般情况下很少会在面试中出现算法的考核，如果你了解一些基础的算法，还是有帮助的。"><meta property="og:locale" content="zh_cn"><meta property="og:type" content="article"><meta property="article:section" content="post"><meta property="article:published_time" content="2017-01-22T18:55:21+00:00"><meta property="article:modified_time" content="2017-01-22T18:55:21+00:00"><meta property="article:tag" content="IOS"><meta property="article:tag" content="资源"><meta itemprop=name content="iOS面试题大集合[转]"><meta itemprop=description content="iOS有用的面试题大集合 面试题从何处得来 招聘一个靠谱的 iOS 知乎－如何面试 iOS 工程师？ 阅读面试题之前 在正式开始之前，我期望你能对iOS/Mac OS X平台开发有所了解，在iOS开发中已经很少需要自己写复杂的算法了，一般情况下很少会在面试中出现算法的考核，如果你了解一些基础的算法，还是有帮助的。"><meta itemprop=datePublished content="2017-01-22T18:55:21+00:00"><meta itemprop=dateModified content="2017-01-22T18:55:21+00:00"><meta itemprop=wordCount content="6495"><meta itemprop=keywords content="iOS,面试,z资源"><meta name=twitter:card content="summary"><meta name=twitter:title content="iOS面试题大集合[转]"><meta name=twitter:description content="iOS有用的面试题大集合 面试题从何处得来 招聘一个靠谱的 iOS 知乎－如何面试 iOS 工程师？ 阅读面试题之前 在正式开始之前，我期望你能对iOS/Mac OS X平台开发有所了解，在iOS开发中已经很少需要自己写复杂的算法了，一般情况下很少会在面试中出现算法的考核，如果你了解一些基础的算法，还是有帮助的。"><!--[if lte IE 9]><script src=https://cdnjs.cloudflare.com/ajax/libs/classlist/1.1.20170427/classList.min.js></script><![endif]--><!--[if lt IE 9]><script src=https://cdn.jsdelivr.net/npm/html5shiv@3.7.3/dist/html5shiv.min.js></script><script src=https://cdn.jsdelivr.net/npm/respond.js@1.4.2/dest/respond.min.js></script><![endif]--><script>(function(){""&&prompt("请输入文章密码")!==""&&(alert("密码错误！"),history.back())})()</script></head><body><div id=mobile-navbar class=mobile-navbar><div class=mobile-header-logo><a href=/ class=logo>习七</a></div><div class=mobile-navbar-icon><span></span>
<span></span>
<span></span></div></div><nav id=mobile-menu class="mobile-menu slideout-menu"><ul class=mobile-menu-list><a href=/><li class=mobile-menu-item>主页</li></a><a href=/post/><li class=mobile-menu-item>归档</li></a><a href=/tags/><li class=mobile-menu-item>标签</li></a><a href=/categories/><li class=mobile-menu-item>分类</li></a><a href=/categories/%E5%91%A8%E6%8A%A5/><li class=mobile-menu-item>周报</li></a><a href=/iDocs/><li class=mobile-menu-item>文档</li></a><a href=/authors/itboyer/><li class=mobile-menu-item>关于</li></a><a href=/resume><li class=mobile-menu-item>认识我</li></a></ul></nav><div class=container id=mobile-panel><header id=header class=header><div class=logo-wrapper><a href=/ class=logo>习七</a></div><nav class=site-navbar><ul id=menu class=menu><li class=menu-item><a class=menu-item-link href=/>主页</a></li><li class=menu-item><a class=menu-item-link href=/post/>归档</a></li><li class=menu-item><a class=menu-item-link href=/tags/>标签</a></li><li class=menu-item><a class=menu-item-link href=/categories/>分类</a></li><li class=menu-item><a class=menu-item-link href=/categories/%E5%91%A8%E6%8A%A5/>周报</a></li><li class=menu-item><a class=menu-item-link href=/iDocs/>文档</a></li><li class=menu-item><a class=menu-item-link href=/authors/itboyer/>关于</a></li><li class=menu-item><a class=menu-item-link href=/resume>认识我</a></li></ul></nav></header><main id=main class=main><div class=content-wrapper><div id=content class=content><article class=post><header class=post-header><h1 class=post-title>iOS面试题大集合[转]</h1><div class=post-meta><span class=post-time>2017-01-22</span><div class=post-category><a href=/categories/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/>学习笔记</a></div><span class=more-meta>约 6495 字 </span><span class=more-meta>预计阅读 13 分钟 </span><span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次阅读 </span><span class=more-meta>by</span></div></header><div class=post-toc id=post-toc><h2 class=post-toc-title>文章目录</h2><div class=post-toc-content><nav id=TableOfContents><ul><li><a href=#>面试题从何处得来</a></li><li><a href=#>阅读面试题之前</a><ul><li><a href=#>什么是iOS开发</a></li><li><a href=#>拼写正确的重要性</a></li><li><a href=#>Swift和Objective-C的比较</a></li><li><a href=#>了解Watch OS</a></li></ul></li><li><a href=#>iOS面试</a></li><li><a href=#>实战</a></li><li><a href=#>Hybrid 混合开发</a></li></ul></nav></div></div><div class=post-outdated><div class=warn><p>【注意】最后更新于 <span class=timeago datetime=2017-01-22T18:55:21 title="January 22, 2017">January 22, 2017</span>，文中内容可能已过时，请谨慎使用。</p></div></div><div class=post-content><h1 align=center>iOS有用的面试题大集合</h1><h2>面试题从何处得来</h2><ul><li><a href=http://blog.sunnyxx.com/2015/07/04/ios-interview/>招聘一个靠谱的 iOS</a></li><li><a href=http://www.zhihu.com/question/19604641>知乎－如何面试 iOS 工程师？</a></li></ul><h2>阅读面试题之前</h2><p>在正式开始之前，我期望你能对iOS/Mac OS X平台开发有所了解，在iOS开发中已经很少需要自己写复杂的算法了，一般情况下很少会在面试中出现算法的考核，如果你了解一些基础的算法，还是有帮助的。</p><p>Now！！请使用ARC</p><h3>什么是iOS开发</h3><p>iOS是iPhone iPad等手持设备的操作系统，所谓的iOS开发就是开发运行在iOS系统上的应用或者游戏，比如支付宝，微信，微博等，当然这也包括了iPad版的应用，iOS开发可以归纳到<strong>移动开发</strong>领域。</p><p><strong>有时候面试官是那种&rsquo;脑残粉&rsquo;，了解一下Apple的发展历史，可能比较聊的开。</strong></p><p><a href=http://digi.tech.qq.com/a/20150127/021898.htm>苹果Mac计算机31年发展历程回顾</a></p><p><a href="http://baike.baidu.com/link?url=68F4Bl4llkNvdFJ1Md0fkZDDudN-NS46JeZoLrgPeqEbZmm8oBKG92Ocyd983yNQU6FVuDTFZOnjjPjfUHnuoePdfh6zJJ973pXFKYcbIKp5bCnQy_WvUVNJ6P84s8HE1xAlRaGdLVuoCb2p_8uaMa">苹果公司</a></p><p><a href=http://www.zhihu.com/topic/19551762>苹果公司在知乎上的话题</a></p><p><a href="http://www.amazon.cn/%E5%8F%B2%E8%92%82%E5%A4%AB%C2%B7%E4%B9%94%E5%B8%83%E6%96%AF%E4%BC%A0-%E6%B2%83%E5%B0%94%E7%89%B9%C2%B7%E8%89%BE%E8%90%A8%E5%85%8B%E6%A3%AE/dp/B00IM4IFL2/ref=sr_1_1?ie=UTF8&amp;qid=1436592631&amp;sr=8-1&amp;keywords=%E4%B9%94%E5%B8%83%E6%96%AF">乔布斯个人传记</a></p><h3>拼写正确的重要性</h3><p>有些面试官可能更注重细节，所以，拼写的单词一定要对，比如iOS，Xcode，iPhone，Objective-C，JSON等，良好的拼写习惯，会让面试官觉得你细心靠谱。</p><h3>Swift和Objective-C的比较</h3><p>仁者见仁智者见智，从个人的使用角度上来看，Swift在某些情况上比Objective-C更加的严谨了，入门非常简单，但是想开发应用，还是需要学习cocoa框架，这玩意路子还是Objective-C的，所以有基础可能更好的理解Swift在iOS/Mac OS X 中的开发和应用。</p><p><a href=http://www.zhihu.com/question/24002984>知乎原文</a></p><h3>了解Watch OS</h3><p><code>Watch OS</code>是苹果公司推出的应用在手表上的一个操作系统，<code>Watch OS 1.0</code>需要跟iPhone相结合才能工作。</p><p><a href=https://stratechery.com/2014/apple-watch-asking-saying/>Apple Watch</a></p><p><a href="http://mp.weixin.qq.com/s?__biz=MjM5NTIyNTUyMQ==&amp;mid=208847424&amp;idx=1&amp;sn=fac57c5da8136b07fe9cdf53d1ec9f4c#rd">Watch OS 2.0 开发概述</a></p><hr><h2>iOS面试</h2><h5>property 后面可以有哪些修饰符</h5><ol><li><p>读写修饰符 <code>readwrite</code> | <code>readonly</code></p><p><code>readwrite</code> Xcode会帮助我们创建<code>setter</code>，<code>getter</code>方法，<code>readonly</code> Xcode只会帮助我们创建<code>getter</code>方法，不会创建<code>setter</code>方法。</p></li><li><p><code>setter</code>相关的修饰符 <code>assign</code> | <code>retain</code> | <code>copy</code></p><p>2.1 <code>setter</code>相关的修饰符表明了<code>setter</code>方法该如何实现，<code>assign</code>用于基本数据类型<code>NSInteger</code>，<code>CGFloat</code>，C数据类型<code>int</code>，<code>float</code>，<code>id</code>类型等，这个符号不会涉及内存管理，但是如果是对象类使用了它，可能会导致内存泄漏或者<code>EXC_BAD_ACCESS</code>错误。</p><p>2.2 <code>retain</code>用于对象类的内存管理，如果基本数据类型使用它，<code>Xcode</code>会直接报错。当对象类使用此修饰符时，<code>setter</code>方法的实现是先<code>release</code>一次，然后再对新的对象做一次<code>retain</code>操作。</p><p>2.3 <code>copy</code>主要用于<code>NSString</code>，用于内容复制。</p></li><li><p>原子性修饰符 <code>atomic</code> | <code>nonatomic</code></p><p><code>atomic</code> 表示线程安全</p><p><code>nonatomic</code> 表示非线程安全，使用此修饰符会提高性能</p></li><li><p><code>getter</code>，<code>setter</code>修饰符</p><p>这两个修饰符用于设置生成的getter，setter的方法名</p></li><li><p><code>strong</code>，<code>weak</code>修饰符（ARC）
在ARC中内存管理都只需要使用这两个修饰符，而且<code>strong</code>是默认全局的，只要你写了<code>Objective-C</code>的对象，不自己添加<code>weak</code>的话，默认就是<code>strong</code>。
5.1 <code>strong</code>表示这个对象的拥有者
一个对象可以有多个拥有者，<code>strong</code>就是用来表示对这个对象的拥有。比如在往<code>NSMutableArray</code>中添加<code>Objective-C</code>对象，当你从数组中删除时，这个对象并不会释放。需要你手动设置为<code>nil</code>，或者在控制器的生命周期内，由系统来释放。
5.2 <code>weak</code>指针变量仍然可以指向一个对象，但不是这个对象的拥有者
<code>weak</code>修饰的指针变量也可以指向对象，但不是这个对象的实际拥有者，也就是说<code>weak</code>修饰的指针变量如果想要释放，需要<code>strong</code>修饰的指针变量设置为<code>nil</code>，<code>weak</code>修饰的指针变量也会是一个<code>nil</code>，它指向的对象已经没有了，还需要设置<code>weak</code>修饰的指针变量为<code>nil</code>。</p></li><li><p><code>nonnull</code> <code>nullable</code> <code>null_resettable</code></p></li></ol><p>Xcode 6.3推出的<code>nullability annotations</code>，主要是为了更好的Swift与Objective-C混编，在Swift中有可选型的概念<code>!</code>,<code>?</code>，但是Objective-C中木有这玩意，于是Xcode 6.3中才有了这个，
从字面可以看出:
<code>nonnull</code> 表示对象不应该为空，如果是这个修饰符对应的就是Swift中已经解包的对象或者<code>!</code>
<code>nullable</code>表示可以为<code>nil</code>或者<code>NULL</code>,对应是Swift中的可选<code>?</code>
<code>null_resettable</code>则是表达属性的空属性，该属性<code>setter</code>访问器允许将其设置为<code>nil</code>（设置该属性为默认值），但是它的<code>getter</code>访问器不会提供一个<code>nil</code>值（因为它提供了默认值），有一个这样的属性如UIView’s tintColor，如果没有tint颜色指定时它会提供一个默认的tint颜色值，对应的Swift使用是var tintColor:UIColor!</p><h2>实战</h2><ol><li>使用 <code>weak</code> 关键字，相比 <code>assign</code> 有什么不同
一般情况下使用<code>weak</code>是避免循环引用，因为它不是对象的拥有者。而<code>assign</code>则是用于基本数据类型，或者C类型，而且<code>assign</code>是直接赋值，可能会导致一个问题。比如我想a和b共用一块内存，a是用<code>assign</code>修饰的，<code>a = b</code>，现在a使用的目的已经完成，我想释放这个内存，但是a并不知道b到底用没用完，如果此时a释放内存，而b还在使用，那么会导致应用程序crash，使用<code>weak</code>就能避免这样的问题。</li><li>怎么用 copy 关键字
<code>copy</code>拷贝的是内容,<code>retain</code>是拷贝的指针
* 以<code>string</code>为例,如果<code>string</code>的属性为<code>copy</code>的话,那么传入参数为<code>NSString</code>的话,即为不可变<code>string</code>,<code>retain</code>,<code>copy</code>效果一样.
* 如果传入参数是<code>mutable</code>的话,那么<code>copy</code>拷贝内容,源随意变化不影响该属性的值.<code>retain</code>拷贝指针,源变化则属性值着变化,因为属性和源指向如何使用呢,通常在需要拷贝内容,但是副本和源不要互相影响的情况下使用.<code>*</code> 同一内存地址.
* 例如<code>array/dictionary</code>中,可能会需要一个副本来做一些操作(筛选,排序等),但是并不希望影响原始值,则可以使用<code>copy</code></li><li>@property (copy) NSMutableArray *array; 这样写有什么问题吗
因为用了<code>copy</code>, 内部会深拷贝一次, 指针实际指向的是<code>NSArray</code>, 所以如果调用<code>removeObject</code>和<code>addObject</code>方法的话, 会<code>unRecognized selector</code></li><li>如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？
当一个对象发生改变时不影响另外一个对象，这里就需要使用<code>copy</code>关键字了，实现<code>NSCopying</code>协议，重写- <code>(id)copyWithZone:(NSZone *)zone</code>方法。
{% codeblock lang:objc %}</li></ol><ul><li>(void)setName:(NSString *)name
{
if(_name != name)
{
_name = [name copy];
}
}
{% endcodeblock %}</li></ul><ol start=5><li>@protocol 和 category 中如何使用 @property
<code>@protocol</code>可以通过关键字:<code>@synthesize</code>或者在继承的类里面重新定义一次该属性(<code>extension</code>里面定义是不行的)
<code>category</code>通过关联:<code>objc_setAssociatedObject</code>/<code>objc_getAssociatedObject</code></li><li><code>@property</code> 的本质是什么？<code>ivar</code>、<code>getter</code>、<code>setter</code> 是如何生成并添加到这个类中的
<code>@property</code>本质是定义一个<code>objc_property</code>结构体
<strong>如何生成目前不清楚</strong></li><li><code>weak</code>属性需要在<code>dealloc</code>中置<code>nil</code>么
不需要，因为weak会自动设置nil</li><li><code>@synthesize</code>和@<code>dynamic</code>分别有什么作用
关于@synthesize（现在已经不需要在写这个属性了，它是用来生成getter和setter方法）
<code>@dynamic</code> 就是要告诉编译器<code>getter</code>和<code>setter</code>方法会在程序运行或者用到动态绑定的方式，以便让编译器通过编译，这个主要要在<code>NSManagerObject</code>上。</li><li><code>ARC</code>下，不显式指定任何属性关键字时，默认的关键字都有哪些
在默认情况下，所有的实例变量和局部变量都是<code>strong</code>类型的。</li><li>用<code>@property</code>声明的<code>NSString</code>（或<code>NSArray</code>，<code>NSDictionary</code>）经常使用<code>copy</code>关键字，为什么？如果改用strong关键字，可能造成什么问题
因为不想改变了其中的值后把原来的值也跟着改变了，用了<code>strong</code>后会出现这样的状况。</li><li>什么是ARC
请阅读，然后随便谈谈你的理解即可。
ARC是为了解决下面几个问题<ul><li>当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被<code>release</code>了。（避免提前释放）</li><li>释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次。（<code>MRC</code>下即谁创建，谁释放，避免重复释放）</li><li>模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放。</li><li>多线程操作时，不确定哪个线程最后使用完毕
<a href=http://onevcat.com/2012/06/arc-hand-by-hand/>手把手教你ARC——iOS/Mac开发ARC入门和使用</a>
<a href=http://www.oschina.net/translate/objc-automatic-reference-counting-in-xcode-explained>理解 Objective-C 的 ARC</a></li></ul></li><li>请解释以下keywords的区别： <code>assign</code> vs <code>weak</code>, <code>block</code> vs <code>weak</code>
<code>assign</code>适用于基本数据类型，<code>weak</code>是适用于<code>NSObject</code>对象，并且是一个弱引用。<ul><li><code>assign</code>其实也可以用来修饰对象，那么我们为什么不用它呢？
因为被<code>assign</code>修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为<code>nil</code>。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。</li><li><code>weak</code>修饰的对象在释放之后，指针地址会被置为<code>nil</code>。所以现在一般弱引用就是用<code>weak</code>。</li><li><code>block</code>是用来修饰一个变量，这个变量就可以在<code>block</code>中被修改，使用<code>block</code>修饰的变量在<code>block</code>代码快中会被<code>retain</code>（<code>ARC</code>下，<code>MRC</code>下不会<code>retain</code>）</li><li><code>weak</code>：使用<code>weak</code>修饰的变量不会在<code>block</code>代码块中被<code>retain</code>同时，在ARC下，要避免<code>block</code>出现循环引用 <code>weak typedof(self)weakSelf = self</code></li></ul></li><li><code>__block</code>在<code>arc</code>和<code>非arc</code>下含义一样吗
是不一样的，ARC会retain，非ARC不会。</li><li>描述一个你遇到过的<code>retain</code> cycle例子
在<code>viewController</code>中避免循环引用
{% codeblock lang:objc %}
[ downloadData:^(id responseData){
_data = responseData;
}];
{% endcodeblock %}<br>解决办法
{% codeblock lang:objc %}
__weak ViewController *weakSelf = self;
[ downloadData:^(id responseData){
weakSelf.data = responseData;
}];
{% endcodeblock %}</li><li><code>+(void)load;</code> <code>+(void)initialize;</code>有什么用处
在Objective-C中，<code>runtime</code>会自动调用每个类的两个方法。<code>+load</code>会在类初始加载时调用，<code>+initialize</code>会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。
共同点：两个方法都只会被调用一次。</li><li><code>UIView</code>和<code>CALayer</code>有什么关系<ul><li><code>UIView</code>是iOS界面元素的基础，所有的界面元素都继承于它。它本身是由<code>CoreAnimation</code>来实现的，它真正绘图的部分是由一个<code>CALayer</code>的类来管理的，<code>UIView</code>本身更像是一个<code>CALayer</code>的管理器。</li><li><code>UIView</code>都存在一个<code>layer</code>属性，可以访问到<code>CALayer</code>的实例。</li><li><code>UIView</code>的<code>CALayer</code>类也存在一个<code>view</code>树结构，可以像<code>UIView</code>一样进行添加</li><li><code>UIView</code>的<code>layer</code>树在系统内部，由系统来维护，它存在着三棵树，分别是逻辑树，动画树，显示树</li></ul></li><li>如何高性能的给<code>UIImageView</code>加个圆角<ul><li>使用贝塞尔曲线来切割图片</li><li>使用<code>Quartz2D</code>直接绘制图片</li></ul></li><li>使用<code>drawRect</code>有什么影响
<code>drawRect</code>方法依赖<code>Core Graphics</code>框架来进行自定义的绘制，但这种方法主要的缺点就是它处理<code>touch</code>事件的方式：每次按钮被点击后，都会用<code>setNeddsDisplay</code>进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对<code>CPU</code>和内存来说都是欠佳的。</li><li>SDWebImage里面给UIImageView加载图片的逻辑是什么样的
详情看<a href=http://www.cnblogs.com/6duxz/p/4159572.html>最新版SDWebImage的使用</a></li><li>麻烦你设计个简单的图片内存缓存器
图片的内存缓存，可以考虑将图片数据保存到一个数据模型中，所以在程序运行时这个模型都存在内存中，一定要具备移除策略，即释放数据模型。</li><li>讲讲你用<code>Instrument</code>优化动画性能的经历
<a href=http://www.hrchen.com/2013/05/performance-with-instruments/>怎么使用instrument</a></li><li><code>loadView</code>是干嘛用的
当你访问一个<code>ViewController</code>的<code>view</code>属性时，如果此时<code>view</code>的值是<code>nil</code>，那么，<code>ViewController</code>就会自动调用<code>loadView</code>这个方法。这个方法就会加载或者创建一个<code>view</code>对象，赋值给<code>view</code>属性。
<code>loadView</code>默认做的事情是：如果此<code>ViewController</code>存在一个对应的<code>nib</code>文件，那么就加载这个<code>nib</code>。否则，就创建一个<code>UIView</code>对象。
如果你用<code>Interface Builder</code>来创建界面，那么不应该重载这个方法。
如果你想自己创建<code>view</code>对象，那么可以重载这个方法。此时你需要自己给<code>view</code>属性赋值。你自定义的方法不应该调用<code>super</code>。如果你需要对<code>view</code>做一些其他的定制操作，在<code>viewDidLoad</code>里面去做。
<a href=http://www.cnblogs.com/dyllove98/archive/2013/06/06/3123005.html>iOS 的loadView 及使用loadView中初始化View注意的问题</a></li><li>用过<code>CoreData</code>或者<code>SQLite</code>吗？读写是分线程的吗？遇到过死锁没？咋解决的
参考<a href=http://blog.csdn.net/hanangellove/article/details/44966769>CoreData与SQLite的线程安全</a></li><li><code>GCD</code>里面有哪几种<code>Queue</code>？你自己建立过串行<code>queue</code>吗？背后的线程模型是什么样的<ul><li>主队列 <code>dispatch_main_queue();</code> 串行 ，更新UI</li><li>全局队列 <code>dispatch_global_queue();</code> 并行，四个优先级：<code>background</code>，<code>low</code>，<code>default</code>，<code>high</code></li><li>自定义队列 <code>dispatch_queue_t queue;</code> 可以自定义是并行：<code>DISPATCH_QUEUE_CONCURRENT</code>或者串行<code>DISPATCH_QUEUE_SERIAL</code></li></ul></li><li>为什么其他语言里叫函数调用， <code>Objective-C</code>里则是给对象发消息（或者谈下对<code>runtime</code>的理解）
网上关于<code>runtime</code>的资料非常多，其实这方面在平时的开发中使用非常非常之少，底层的黑魔法。
<a href=http://www.jianshu.com/p/25a319aee33d>Objective-C特性：Runtime</a>
<a href=http://tech.glowing.com/cn/objective-c-runtime/>Objective-C Runtime</a></li><li>什么是<code>method swizzling</code>
在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是<code>selector</code>的名字。利用<code>Objective-C</code>的动态特性，可以实现在运行时偷换<code>selector</code>对应的方法实现，达到给方法挂钩的目的。
<a href=http://blog.csdn.net/yiyaaixuexi/article/details/9374411>详细的案例</a></li><li>runtime 如何实现 weak 属性
{% codeblock lang:objc %}
OBJC_ASSOCIATION_ASSIGN
OBJC_ASSOCIATION_RETAIN_NONATOMIC
OBJC_ASSOCIATION_COPY_NONATOMIC
OBJC_ASSOCIATION_RETAIN
OBJC_ASSOCIATION_COPY
objc_setAssociatedObject(self, &amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN);
{% endcodeblock %}
可以自定义<code>weak</code>来实现内存管理，Apple已经为我们准备了常量。
参考
<a href=http://nshipster.cn/associated-objects/>Associated Objects</a>
<a href=http://southpeak.github.io/blog/2014/10/30/objective-c-runtime-yun-xing-shi-zhi-er-:cheng-yuan-bian-liang-yu-shu-xing/>Objective-C Runtime 运行时之二：成员变量与属性</a></li><li><code>objc</code>中向一个<code>nil</code>对象发送消息将会发生什么
<code>objc</code>的特性是允许对一个 <code>nil</code> 对象发送消息不会 Crash，因为会被忽略掉。</li><li>什么时候会报<code>unrecognized selector</code>的异常
调用一个不存在的方法</li><li><code>objc</code>中向一个对象发送消息<code>[obj foo]</code>和<code>objc_msgSend()</code>函数之间有什么关系
{% codeblock lang:objc %}
[obj foo];
//编译时会变成
objc_msgSend(obj,@selector(foo));</li></ol><p>[obj foo:parameter];
//编译时会变成
objc_msgSend(obj,@selector(foo:),parameter);
{% endcodeblock %}
31. 一个objc对象如何进行内存布局
可参考<a href=http://www.cnblogs.com/csutanyu/archive/2011/12/12/objective-c_memory_layout.html>Objective-C内存布局</a>
32. 一个objc对象的isa的指针指向什么？有什么作用？
isa是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类，而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。
33. 下面的代码输出什么
{% codeblock lang:objc %}
@implementation Son : Father</p><ul><li>(id)init
{
self = [super init];
if (self)
{
NSLog(@"%@", NSStringFromClass([self class]));
NSLog(@"%@", NSStringFromClass([super class]));
}
return self;
}
@end
{% endcodeblock %}
输出Son</li></ul><ol start=34><li>runtime如何通过selector找到对应的IMP地址
id (*IMP)(id, SEL, &mldr;)
这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。
前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。
通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。</li></ol><h2>Hybrid 混合开发</h2></div><div class=post-copyright><p class=copyright-item><span class=item-title>文章作者</span>
<span class=item-content>iTBoyer</span></p><p class=copyright-item><span class=item-title>上次更新</span>
<span class=item-content>2017-01-22</span></p></div><div class=post-reward><input type=checkbox name=reward id=reward hidden>
<label class=reward-button for=reward>赞赏支持</label><div class=qr-code><label class=qr-code-image for=reward><img class=image src=/img/reward/weixin.jpg>
<span>微信打赏</span>
</label><label class=qr-code-image for=reward><img class=image src=/img/reward/zhifubao.jpg>
<span>支付宝打赏</span></label></div></div><footer class=post-footer><div class=post-tags><a href=/tags/iOS/>iOS</a>
<a href=/tags/%E8%B5%84%E6%BA%90/>资源</a></div><nav class=post-nav><a class=prev href=/post/old/swift/AwsomeAppleDevelopGuide/><i class="iconfont icon-left"></i>
<span class="prev-text nav-default">Awsome Apple Develop Guide[转]</span>
<span class="prev-text nav-mobile">上一篇</span>
</a><a class=next href=/post/old/%E5%85%B6%E4%BB%96/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B9%8B%E5%B0%8F%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/><span class="next-text nav-default">腾讯云之小直播开发</span>
<span class="next-text nav-mobile">下一篇</span>
<i class="iconfont icon-right"></i></a></nav></footer></article></div><div id=gitalk-container></div><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css crossorigin=anonymous><script src=https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js crossorigin=anonymous></script><script type=text/javascript>var gitalk=new Gitalk({id:"2017-01-22 18:55:21 +0000 UTC",title:"iOS面试题大集合[转]",clientID:"d46ea301857e36a08319",clientSecret:"9da00f1f475c4166b96fbe157d0afdbd64cc613c",repo:"it-boyer.github.io",owner:"it-boyer",admin:["it-boyer"],body:decodeURI(location.href)});gitalk.render("gitalk-container")</script><noscript>Please enable JavaScript to view the <a href=https://github.com/gitalk/gitalk>comments powered by gitalk.</a></noscript></div></main><footer id=footer class=footer><div class=social-links><a href=mailto:iTBoyer@qq.com class="iconfont icon-email" title=email></a><a href=https://github.com/it-boyer class="iconfont icon-github" title=github></a><a href=http://weibo.com/1791281385 class="iconfont icon-weibo" title=weibo></a><a href=http://www.zhihu.com/people/boyers class="iconfont icon-zhihu" title=zhihu></a><a href=http://douban.com/people/boyers class="iconfont icon-douban" title=douban></a><a href=https://space.bilibili.com/67083417 class="iconfont icon-bilibili" title=bilibili></a></div><div class=copyright><span class=power-by>由 <a class=hexo-link href=https://gohugo.io>Hugo</a> 强力驱动
</span><span class=division>|</span>
<span class=theme-info>主题 -
<a class=theme-link href=https://github.com/olOwOlo/hugo-theme-even>Even</a></span><div class=busuanzi-footer><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/img/spinner.svg alt=spinner.svg></span> 次
</span><span class=division>|</span> <span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/img/spinner.svg alt=spinner.svg></span> 人</span></div><span class=copyright-year>&copy; 2017 - 2025<span class=heart><i class="iconfont icon-heart"></i></span><span>iTBoyer</span></span></div><script src=https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js></script><script>mermaid.initialize({startOnLoad:!0})</script><script src=/js/copy-to-clipboard.js></script></footer><div class=back-to-top id=back-to-top><i class="iconfont icon-up"></i></div></div><script src=https://cdn.jsdelivr.net/npm/jquery@3.2.1/dist/jquery.min.js integrity="sha256-hwg4gsxgFZhOsEEamdOYGBf13FyQuiTwlAQgxVSNgt4=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/slideout@1.0.1/dist/slideout.min.js integrity="sha256-t+zJ/g8/KXIJMjSVQdnibt4dlaDxc9zXr/9oNPeWqdg=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/@fancyapps/fancybox@3.1.20/dist/jquery.fancybox.min.js integrity="sha256-XVLffZaxoWfGUEbdzuLi7pwaUJv1cecsQJQqGLe7axY=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.min.js integrity="sha256-jwCP0NAdCBloaIWTWHmW4i3snUNMHUNO+jr9rYd2iOI=" crossorigin=anonymous></script><script src=https://cdn.jsdelivr.net/npm/timeago.js@3.0.2/dist/timeago.locales.min.js integrity="sha256-ZwofwC1Lf/faQCzN7nZtfijVV6hSwxjQMwXL4gn9qU8=" crossorigin=anonymous></script><script>var languageCode="zh-cn".replace(/-/g,"_").replace(/_(.*)/,function(e,t){return e.replace(t,t.toUpperCase())});timeago().render(document.querySelectorAll(".timeago"),languageCode),timeago.cancel()</script><script type=text/javascript src=/js/main.min.4ae89da218555efa0e7093a20b92017d2e1202b66fff9fc2edf4cb8d44b44c6e.js></script></body></html><style>#fastSearch{visibility:hidden;position:absolute;left:10px;top:10px;display:inline-block;width:320px;margin:0 10px 0 0;padding:0}#fastSearch input{padding:4px;width:100%;height:31px;font-size:1.6em;color:#222129;font-weight:700;background-color:gray;border-radius:3px 3px 0 0;border:none;outline:none;text-align:left;display:inline-block}#searchResults li{list-style:none;margin-left:0;background-color:gray;border-bottom:1px dotted #000}#searchResults li .title{font-size:1.1em;margin:0;display:inline-block}#searchResults{visibility:inherit;display:inline-block;width:320px;margin:0;max-height:calc(100vh - 120px);overflow:hidden}#searchResults a{text-decoration:none!important;padding:10px;display:inline-block;width:100%}#searchResults a:hover,#searchResults a:focus{outline:0;background-color:#666;color:#fff}#search-btn{position:absolute;top:10px;right:20px;font-size:24px}@media(max-width:683px){#fastSearch,#search-btn{top:64px}}</style><div id=fastSearch><input id=searchInput tabindex=0><ul id=searchResults></ul></div><script src=/js/fuse.js></script><script src=/js/fastsearch.js></script>