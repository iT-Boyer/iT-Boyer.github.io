[{"categories":null,"contents":"美团外卖平台为商家提供了门店自营销活动。商家通过设置门店活动可以有效提升订单 量、排名，是商家自营销的有力工具。商家可以通过美团外卖商家版\u0026gt;店铺\u0026gt;活动报名\u0026gt;自营销活动，查看所有商家自营销工具。注:活动介绍排序按照新商家成长经营建议从高到低排序。\n减配送费 减配送费，即帮助用户承担一部分配送费，在用户支付时，自动减去一定额度的配送费金额，从而鼓励用户下单，提高店铺单量。活动上线后用户端展示资源位如下:\n活动经营建议 商家适用类型：所有商家\n其它适配活动 减配送费活动适用商家类型多样，可结合商家实际情况灵活搭配\n配送费较高的商家，可通过该活动减低配送费 配置的金额可在1-3元之间 \u0026gt; 备注:支持自动延期，勾选自动延期之后活动到期后按照原活动配置信息自动延期30天(支持随时取消:开通自动延期后，可以随时在我的活动-减配送费中进行关闭。)\n满减活动 满减活动是美团外卖为商家提供的店铺营销工具之一。商家配置满减活动，用户下单 满足条件后即可享受减免优惠。活动上线后用户端展示资源位如下:\n活动经营建议 商家适用类型：所有商家 其它适配活动 与折扣商品活动无法叠加使用，商家在配置门店活动时可根据店铺实际情况灵活搭配。\n满减的精髓在于设置门槛和优惠力度。\n各档满减的目的\n第一档:提高曝光和进店转化率，所以第一档力度要大，使用门槛要低， 满足基本顾客需求，提高进店转化率 第二档:提高下单量和客单价，所以第二档定价要价格偏高，可结合餐品，搭配一定套餐，第二档要高于套餐价格，顾客会购买更多有需要的产品进行凑单 第三档:防拆单，针对多人套餐，比如3-5人套餐，价格比单次订购合适，防止顾客下单多次 满减金额的设置\n可根据顾客消费金额选择满减额度(可以登陆外卖商家端-顾客管理-顾客分析-查看顾客的实付金额分布进行参考)\n新商家:可根据店内商品的价格进行满减梯度设置。\n会员红包 会员红包是美团外卖为美团外卖会员提供的一项增值服务，会员每月可领取6张*5元无门槛通用红包。目前美团会员量已超千万，活跃度高、下单量高。商家您开通会员红包后，平台将在特定场景下为商家追加补贴，升级优惠力度，用更大面额的红包吸引用户下单，助力商家在竞争中突围。\n会员红包权益 会员通用红包可免费升级为更大面额的外卖商家红包，助力您门店用户下单转换。 会员6张通用红包使用完后，有效期内还可自行购买规格不等的加量包权益。 商家红包权益 专属免费曝光位置，助力订单增长; 平台强势追加补贴，提高进店转化率; 吸引平台更优质用户，拉新+提升复购。 活动设置路径 美团外卖商家版APP \u0026ndash;\u0026gt; 店铺 \u0026ndash;\u0026gt; 美团会员 \u0026ndash;\u0026gt; 启活动\n商家开通美团会员红包后，可以查看活动效果数据，包括美团会员红包活动订单数、订单净收入、订单补贴支出、平均客单价、平均投入产出比。即将增加库存提醒、商圈开通会 员情况、关闭活动时提醒功能。\n天天神券 “天天神券”是美团外卖的一款C端营销工具。参与天天神券商家您可以获得真金白银补贴、千万流量曝光、节约营销成本，从而帮助商家您提高曝光，增加订单转化、提高订单。\n展示位置 活动优势 天天神券引流，平台专属页面优质流量曝光，专属资源位免费上，专属标签帮您引流。首页金刚位曝光，提升用户粘性，通过专属资源位，帮您持续引流，扩大门店订单转化。神券专属标签\u0026amp;专属页面，打造属于您的神券专区，免费帮商家吸引顾客。平台真金白银扶持优质商户，提升商家订单及收入，每月18日免费帮商家打造营销活动，节约商家营销成本。\n活动设置路径 美团外卖商家版 -\u0026gt; 店铺 -\u0026gt; 活动报名 -\u0026gt; 流量活动 \u0026gt; 注意:天天神券活动报名规则、活动样式以城市展示为准，具体报名规则及活动详情请咨询业务经理。\n折扣商品 折扣商品是美团外卖平台为外卖商家提供的营销工具。商家设置折扣商品后，用户购买指定商品可享受折扣优惠，适用于店铺推新品、爆品、促销时使用。活动上线后用户端展示资源位如下:\n活动经营建议 商家适用类型：菜品价格较高的商家\n其它适配活动 一个商品仅可参与一个活动，商家应控制店铺商品类活动的数量，搭配更多除商品类活动 以外的其它活动，活动叠加使用效果更好\n首选高毛利餐品，这样才能在保证促销的情况下，有利可赚。 折扣活动尽量以梯度展示，如4折、6折、8折呈现，给用户更多选择。 折扣餐品，具有引流作用，应首选一款价格公道，口感不错的餐品，可迅 速打开市场，赢得口碑。 收藏有礼 收藏有礼是指当您希望顾客收藏商家店铺，可通过设置优惠券，吸引顾客收藏。当顾客收藏店铺后，商家店铺将有更多机会曝光在商家的外卖列表，提高商家复购率。\n活动经营建议 商家适用类型：所有商家、新商家、想要招揽新顾客的商家\n仅限未关注过门店的新粉丝可以参加活动，取消关注再次关注的顾客不会获得优惠券。粉丝收藏店铺后也可以与【精准营销】-【场景营销】-【粉丝 营销】结合使用，对粉丝顾客定向营销，提升目标客户的复购率。\n","date":"2024-04-02T10:16:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%95%86%E5%AE%B6%E6%B4%BB%E5%8A%A8%E8%AE%BE%E7%BD%AE/","section":"post","tags":null,"title":"商家自营销开启促销活动"},{"categories":null,"contents":"商家入驻是指从非外卖商家通过录入信息、审核、签约成为外卖商家的过程，入驻完成后，商家即可获得账号，在外卖平台上进行交易，该过程简称为上单。\n门店在入驻为外卖商家前，需要先认领，然后在认领的页面进行上单操作，录入信息、审核、签约；商家入驻完成后，如果需要修改认证信息或者重新签约，可以进入到商家详情页进行操作。\n下面是商家上单的详细步骤：\n①上单 在认领的门店列表中选择需要上单的门店，点击上单，进入上单流程页，详见下图所示：\n②录入基本信息 需要注意的是，商家必须关联到一个客户，客户可以在已有客户列表中选择，也可以新建一个客户（客户新建和管理功能详见下个章节）。\n基本信息主要包括门店的名称、品类信息、地址信息和环境信息，详见下图所示：\n③录入资质信息 资质信息内容较多，包括商家的个人证件、营业执照、许可证等\n如果该门店关联客户有多个门店，可以尝试复用已有门店资质，详见下图区域1； 营业信息可以尝试自动录入，减少打字输入的成本，详见下图区域3； 每个需输入的信息在填写的位置都有专门的提示信息可以参考，详见下图区域4； 资质信息提交后会上传到审核平台进行审核，审核不通过需要修改后再次提交，详见下图区域2； ④录入门店的配送信息 完成资质信息录入后，可以录入门店的配送信息，主要包括配送方式、分成比例、配送范围等信息，其中：\n配送范围以地图区域标识，可以手动调整； 可以针对不同时段新增配送范围，详见下图区域1所示； 配送信息设置或修改后，会触发和商家客户的签约流程，签约后配送范围才会生效（签约流程详见客户管理模块） 配送信息的录入过程详见下图所示：\n⑤录入结算信息 主要包括商家的账户信息和结算设置信息，其中：\n商家的账户信息可以尝试自动带入，详见下图区域 1； 商家账号可以通过拍照识别录入，详见下图区域 2 及图 2 所示； 结算信息只可以设置单店商家的结算信息，多店商家的结算信息需要到 PC 系统进行设置； 结算信息设置或修改后，会触发和商家客户的签约流程，签约后结算信息才会生效（签约流程详见客户管理模块） ⑥录入营业信息 主要包括营业时间段和门店联系方，详见下图所示：\n⑦录入商品信息 可以分组录入商品信息，主要包括商品名称、分类、加个、库存等，详见下图所示：\n⑧上单状态展示 信息录入完成后，可以在详情页查看门店各信息的状态，具体包括：\n资质信息审核不通过会显示驳回，点击进入详情可以查看驳回原因重新提交； 配送信息商家取消签约或其他原因导致失败，会显示签约失败，可以进入详情页查看失败原因或重新发起签约； 结算信息商家取消签约或其他原因导致失败，会显示签约失败，可以进入详情页查看失败原因或重新发起签约； 支付合规校验不通过会显示支付合规失败，可以点击查看失败原因 展示效果如下图所示：\n","date":"2024-03-31T15:36:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E7%BE%8E%E5%9B%A2%E5%A4%96%E5%8D%96%E9%97%A8%E5%BA%97%E5%85%A5%E9%A9%BB%E6%B5%81%E7%A8%8B/","section":"post","tags":null,"title":"门店入驻流程"},{"categories":null,"contents":"必读人员：渠道经理、城市经理、合作商伙伴重要等级：需知晓\n一 背景和目标 月初整体沟通整月零售方向的策略地图与任务地图，帮助合作商合理规划整月节奏。 拉齐零售方向策略和任务的优先级、重要性，提升BD执行效率以及策略落地效果。 二 零售策略地图一览 四月重点策略：\n清明节活动：4.4-4.7重点做清明节的营销工作，围绕超市便利、水果、食材等核心品类，完成活动招商和城市推广 五一活动：4.27-5.5重点做五一的营销工作，围绕超市便利、水果、食材、美妆、3C等核心品类，完成活动招商和城市推广 闪购活动： 品类商家券招商，3月动销门店统一发作战重点追进 水果散店需补充4月时令水果 数码家电代理城市招商加码 医药活动： 根据过敏季、清明旅游重点场景做活动营销 推动本地大药房商家上线应季药品。 供给建设： 完成非餐供给绩效考核目标，重点新签果切、酒水、超市便利门店。（新增酒水、非食门店） 24小时供给与运力双推动 仓店扩量：仓店项目进入扩量阶段，每个大区3个区域启动第2批推进工作、启动第三批8个区域仓店扩量工作 三 营销月历 闪购营销月历重点活动：五一大促活动时间：4月27日~5月5日\n核心品类：假期聚会/聚餐场景：超市便利、水果、食材；假期出游/返乡场景：美妆、成人、服饰、日百、数码；\n","date":"2024-03-31T09:19:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/4%E6%9C%88%E5%95%86%E5%AE%B6%E6%B4%BB%E5%8A%A8%E4%BF%83%E9%94%80%E8%AE%A1%E5%88%92/","section":"post","tags":null,"title":"4月商家活动促销计划"},{"categories":["周报"],"contents":"场景演练万事先，何苦人生无彩排书到用时方恨少，古来世人阅历深万卷速食碎片化，信息爆炸日日新经验难成无系统，人如浮萍薄纸命何以成长集大成，轻重缓急拎得清学习达人责任重，方格笔记勤应用善用利器助效能，探索原则习技能随机应变解困境，临场方可稳中赢\n","date":"2023-10-13T11:25:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%9F%A5%E8%AF%86%E5%BA%93/","section":"post","tags":null,"title":"重新定义知识库：临场发挥，不要局限于经验，要善用AI大数据"},{"categories":null,"contents":"从业 6 年来，我发现刚开始做短视频的人都会问一个问题，就是为什么那些制作看着特别普通的短视频能够成为爆款，而自己花了好几个小时，甚至是好几天用心创作的视频，观看者却寥寥无几呢？\n我们来看一个具体的例子。就像 这个Vlog，拍摄者只是拿着手机对着自己拍，用很简单的方式去记录自己所受到的情感创伤，制作水平并不高，甚至后期字幕也可以依靠剪辑工具一键生成。与运用了专业的镜头语言、场景转换等高质量的视频相比，这条短视频看起来没有任何优势，但是它的观看量却能突破百万，留言几万条。\n那么，这种好像不用花费精力就能拍的视频，能够成为爆款的底层逻辑究竟是什么呢？\n01 | 爆款短视频的底层逻辑：用心拍的短视频为啥没人看？ 我认为是 基本盘 。基本盘就像是计算机的操作系统、网络协议，你可以把它理解为是一个事物最本真的样子，是不管在什么情况下都丢不掉、夺不走的东西。\n在我看来，一个短视频能够受到欢迎的前提就是要拥有自己的基本盘，而后才是制作水平的高低。这个道理也很容易理解，我们喜欢高制作水准的好莱坞大片，但这并不妨碍工我们喜欢小成本制作但感情真挚的影视剧，因为它们都迎合了观影人群的不同审美需求。\n理解了这一点之后，我们再重新来思考一下刚才的问题： 为什么在你眼里看似制作简单的视频内容，有时候要比制作精良的短视频更受欢迎？\n其实，这个问题的逻辑就是错的。当我们用“制作水平”这个维度来衡量短视频受欢迎程度的时候，那么作为对照的案例，其基本盘也需要是以制作为维度。就拿前面这个例子来说，情感向短视频之所以受到了欢迎，是因为它拥有让观众产生共鸣的基本盘，那么作为对照的案例，同样也需要是情感向的短视频，而非什么制作精不精良。\n所以现在你理解了吗？*基本盘就是一个短视频能够成为爆款的根本，或者说不可或缺的因素。*那么接下来，我就会花两节课的时间，带你找到隐藏在那些爆款短视频背后的“基本盘”，即马斯洛需求层次理论、编程思维、稀缺价值法、改良创新法。\n今天这节课，我们先来看看马斯洛需求层次理论、编程思维这两种理论在爆款短视频中是如何应用的，以此去看清不同内容类型的短视频能够成为爆款的决定因素，从而理解在创作时首先要考虑的着眼点是什么。\n马斯洛需求层次理论：打造爆款的底层创作方法 这个理论你应该比较熟悉，它是美国心理学家亚伯拉罕·马斯洛创造一种金字塔式的需求理论，由下至上分别是生理需求、安全需求、社交需求、尊重需求以及自我实现，分别对应了人在现实生活中不同阶段、不同时期所面临的核心诉求。\n巧妙的是，短视频事实上就是现实生活的投射，因此不同爆款内容的背后其实都对应着马斯洛原理的不同核心诉求。下面，我们就来一一解析下这五种需求和据此外延的短视频内容，以此来清晰地看透一个爆款短视频的基本盘。\n生理需求 最底层的是生理需求顾名思义它代表的是人类赖以生存的根本比如食物水呼吸、睡眠，等等。\n那么在短视频领域，我们要如何去判断生理需求的应用呢？\n在我看来，大部分的爆款短视频，其基本盘都对应着用户对这层需求的现实投射，因为 生理需求是人通用的一种底层需求，谁也离不了 。举个简单的例子，各大短视频平台上最受欢迎的内容领域，一定会有美食、赚钱知识等等，它们分别对应了这层需求中的食物、生存。\n生理需求就像是盖房子时要打造的地基、作画时要选取的底色，在短视频领域中，同样也要基于人最基本的需求进行创作，这是打造成爆款内容的基本盘之一。\n如此，当你明白了这一点之后，在创作时其实就可以先去找到能抓住所有用户生理需求层次的关键点，比如就像前面提过的美食领域，然后你再在这个已经得到过验证的创作领域上，根据自己的具体条件进行二次创新，这样你的创作就会变得比较简单和有目标参考了。\n安全需求 第二层是安全需求每个人都会本能地去避免或摆脱外界威胁以求获得安全感在马斯洛原理中，它解释为人身安全、财产安全、道德保障，等等。\n而放在短视频领域中，我们归结起来其实主要有三点：\n渴望得到安全、摆脱危险，如身体健康、人身安全等。 受到保护、免除焦虑与恐惧，如母婴知识、职业成长类。 与“失去”关联的内容，如财富理财、情感指导类。 给你举个例子。在疫情下，我们现在出门戴口罩是一件很正常的事情，但是不正确的佩戴方式所带来的风险很大，因此有些创作者就从如何正确佩戴口罩的角度，去告诉用户别忽视一些重要细节。这样的视频也成了用户关注的热点，而其背后的底层逻辑就是人们渴望得到安全、摆脱危险。\n这里请注意一点，当你要做一个切合用户安全需求的短视频时，你需要做好 “失去与获得的权衡” ，也就是这条内容对外传递的观点一定是： 如果你不重视就会失去安全，而一旦重视了就会获得安全 。因为这就像一枚硬币的两面，它是不可分割的。而且每个人不管在什么样的情况下，一定都正在“失去”与“拥有”，而且往往也正是因为这两方面，才会让我们感受到真实的存在。\n社交需求 社交需求又可以理解为情感需求在马斯洛原理中强调的是亲情友情爱情等各种感情的诉求。\n为了便于你更好地理解这层需求，这里我想引用下哲学家梁漱溟的一段话：\n人的一生要处理好三层关系：第一层是自己与世界的关系；第二层是自己与他人的关系；第三层是自己与自己的关系 。\n也就是说，在短视频创作中所体现的社交需求，就是用户可以通过视频所展现的情感关系，观察到自己与世界、他人与内心的关系。比如，这条爆款短视频的内容是讲述了父母为孩子做康复训练的过程：视频中，儿子的年纪似乎并不小了，但是因为需要进行康复训练，年迈的父亲佝偻着背搀扶着儿子，而母亲则是趴在地上用手挪动儿子的双脚向前走。\n这个视频一下就击中了我的内心，因为它让我看到的是我们与父母的关系，我能从视频中真实地感知到：不管孩子多大，在父母的眼中永远都是孩子，父母对孩子的爱永远都是纯粹与无私的。\n这就是利用情感需求这一基本盘来打造爆款的关键因素。\n说到这里，我们也回过头来看看一开始举的那个例子：短视频创作者用 Vlog 的形式记录了自己的情感经历，面对镜头诉说自己内心最真实的独白。这些内容能成为爆款，就是因为它符合了马斯洛原理中的情感需求，我们能够在拍摄者所讲述的这段关系中看到自己的样子，产生共鸣。\n所以，当你去用马斯洛原理来判断一条爆款短视频是否符合情感需求时，就可以用前面提到的这三层关系来对号入座。同样，当你在创作情感类的短视频时，你首先就要考虑清楚，你创作的内容内核可以反映出什么情感关系，然后再去思考具体的呈现形式。\n尊重需求 对于尊重需求我们可以从内部与外部两个方面来理解:\n内部就是指自尊，代表着人渴望拥有自信、成就感、满足感等心理； 外部就是指他人对自己的尊重，代表着人渴望得到认可、信赖，以及找到自我价值。 尊重需求在短视频领域里，也可以分为这两种。\n首先是对内的，这类爆款视频会通过行为上的自我证明，比如展现过往经历等，来获取自尊、自信和成就感。像一些记录个人生活的Vlogger，如清华圆圆陪你读英语等，他们就是记录自己真实的经历，来对外传递出自己的信念、目标、梦想，从而树立自信。\n其次是对外的，这类爆款视频会通过展现一些独特的能力、优秀的成绩等，来获得外界的认可。比如说，在抖音上挑战各种难度的博主玲爷，就是这个类型的代表。\n除了展现个人优势之外，在短视频内容中，尊重需求也可以是一种动态的自我展示。比如展示自己由坏到好、由幼稚到成熟，或者是自己克服困难、解决问题的过程，等等，这都是尊重需求在短视频内容中最佳的表现形态。\n自我实现需求 在马斯洛原理中最后一层是自我实现需求自我实现需求其实与尊重需求有本质的区别，前者强调的是结果，也就是一定达成了自己的目标，拥有了最理想的结果；而后者则是展现一种不屈的真实，更多的是强调过程，结果并不一定是美好的。\n每个人都有挑战自我、实现自我的需求，只不过是受困于各种原因没有实现，那么在看到了这样的短视频内容之后，其实就会唤醒最初上路的初心，因而这样以自我实现需求为基本盘的内容也就可以成为爆款。\n在这类视频中，我们经常会看到两种类型的内容：突破自我的极限展示；不断挑战后的自我实现。\n突破自我的极限展示主要是来自一般人所不能触及的高超才艺。比如说，展示野外生存技能的“户外平头哥”、利用生活中随处可见的物品设计出精美服装的杨杨服装设计师，他们创作的内容就属于这个类型。\n不断挑战后的自我实现，是从自我的立场出发，分享最终实现目标的心得、经验，等等。比如说减肥、健身类的短视频。\nOK，这就是马斯洛原理中的五个不同需求，以及不同需求背后对应的爆款内容类型。\n这里我还需要提醒你一点，当你去创作自己的短视频内容时，首先应该思考的是你的内容要符合马斯洛原理中哪一个需求，然后再围绕这个需求所展现的特点进行放大化的创作处理。比如，你是情感类的短视频创作者，那么每一次传递的情感要让用户感觉到，该笑的时候要开心大笑，该哭的时候要放声大哭，让用户感觉到真实可信，这就是在情感点上做放大化的处理结果。\n接下来，我们再来看看另一种能够让短视频成为爆款的基本盘：编程思维。\n编程思维：利用平台的推荐算法打造爆款内容 如果你是做技术的，那你对“编程思维”这个词肯定很熟悉，它主要的意思就是用计算机的方式来观察和思考世界，在遇到各种问题时，可以用计算机听得懂的指令来帮助自己达成目的。但在这里，我并不是要讲如何去写代码，而是说我们要用编程思维，去识别爆款短视频背后的本质。\n那么，短视频创作中的编程思维具体是指什么呢？\n答案是要理解和掌握平台的 “分发机制” 与 “识别流程” ，能够 站在机器的角度 来创作内容。\n现在各个短视频平台都是依靠人工智能的算法推荐，来进行内容与用户的匹配。所谓的分发机制，是指在不同平台上对于内容推荐的一套算法模式；而识别流程是指站在机器的角度创作内容，理解机器的工作流程，其大致的过程是这样的a ：\n首先，你在上传新内容的时候，可以添加合适的关键词、话题热点、分类标签、封面关键词，等等，让机器第一时间减少识别难度，快速推荐给更多精准的用户； 然后，机器将你的新内容根据一些维度（用户浏览、社交关系等）分发推荐给一部分用户，通过用户的反馈来决定是否推荐给更多的人，而后吸引更多的用户流量，从而扩大流量池，你的视频也就会成为热门内容。 有一些爆款短视频在发布之后的简介中，还会@一些本地的账号，目的就是为了让机器快速理解其内容与这些本地账号的粉丝相同，以此减少识别流程进行精准匹配。\n可以说，之所以爆款短视频可以成为爆款短视频，正是因为它们满足了机器背后设置的各种门槛，才会一次次进入更大的推荐流量池，背后的底层逻辑就是来自于此。\n小结 一个短视频之所以能够成为爆款就是因为它具备了基本盘这节课我们从马斯洛原理和编程思维这两种理论开始，了解了不同爆款短视频背后的逻辑本质。你需要记住以下几个重点：\n短视频是现实生活的投射，每个爆款短视频的背后都对应着一个底层逻辑。 在马斯洛原理中，五类需求不仅代表着人在不同阶段的真实需求，同样也映射着爆款短视频的内容形式，它们是短视频创作中最不能缺少的核心要素。 在短视频创作中，编程思维就是要懂得平台的“分发机制”和“识别流程”，站在机器的角度来创作内容。 最后我想说的是，随着不断实践和积累，你的短视频制作水平一定会越来越高，但是如果不了解一个爆款短视频最本质的“精髓”，就容易让自己陷入到“为了创作而创作”的漩涡之中。在下节课，我们还会继续探讨稀缺价值法、改良创新法这两种隐藏在爆款短视频背后的“基本盘”。\n思考题 请你结合今天的学习内容找找哪些爆款短视频的底层逻辑是符合马斯洛需求原理哪些是符合编程思维的？当然，你也可以讲讲学习了今天的内容后，你最大的体会是什么？\n欢迎给我留言，分享你的答案和见解。相信经过深度思考的回答，你在学习或创作短视频的时候会有更深的理解与收获。\n留言 Lisaxox 老师你好，分享记录自己平时的生活怎么对应到具体的需求层次里呢？另外，像抖音，微信视频号的推送机制会有不同，请问什么有系统的方法通过算法这块基本盘去提升视频的曝光吗？\n作者回复: 您好。\n如果是记录自己的生活，拍摄Vlog类型的短视频的话，恭喜你，其实这是对应了马斯洛原理的多层次需求，也就是说里面可以涉及到最底层的需求，也可以是最高层的自我实现需求，当然，也可以是其中的社交（情感需求）。只要你创作的每一条内容都可以具体对应其中的一个需求，就可以成为创作短视频的基本盘了。但是，拍摄Vlog记录自己的生活，最怕是流水账，最重要的是人设，这个后面的课程会具体讲到的，别担心。\n抖音、视频号的推送机制还是不一样的，关于算法推荐这一块内容后面的课程会重点去讲述，如果还不够，我还会加课的，别着急，跟着课程一点点来。\n一步 现在正在进行有关钢琴弹奏的短视频，好像对应需求层次中的尊重需求，但是又好像不完全符合。老师对这一类内容的创作有什么好的建议？在创作过程需要放大处理哪一方面的？\n你好！有关钢琴弹奏的短视频？是你通过教授别人如何弹钢琴的知识类短视频吗？如果是这一类短视频类型的话，是符合尊重需求的底层逻辑的，你通过专业的钢琴弹奏技巧赢得用户的喜爱、尊重与认可，用户通过学习弹奏钢琴知识，让自己变得越来越好，充满自信。\n如果是这种类型的创作，我个人建议你刚开始多展现自己的优势之处，而且要降低用户学习的门槛。换句话说，就是用户看完你的视频之后能够上手操作，这一点一定要放大处理。\n为什么呢？很简单，用户跟着你能学习到自己掌握的知识，会有特别大满足感，然后在学习的过程中也会越来越认可你。\n弥勒硕 2021-03-19 老师好，之前也做过很多类型的短视频，涨粉很容易，但是后期变现特别难，可能是刚开始比较好做，但是我都放弃了，我目前在做零食评测类的短视频，但是发现我涨粉特别难，播放量难突破500，点赞量只有几个，评论基本没有，更别说转发了，现在都搞的有点盲目了，我目前主做抖音头条系，抖音号是pangchao6，希望能够得到老师的指点\n作者回复: 你好，我看了你的抖音号，站在我的角度上有三个问题，与你分享下：\n在抖音上一直很推崇的9:16的竖屏视频，视觉体验感会很好，也会得到平台与用户的喜爱，毕竟抖音主打的就是“沉浸式”的视频体验。你为什么选择制作16:9的横屏视频？如果想要做横屏视频，可以去B站或者西瓜视频、好看视频等等，这些重度推荐横屏的短视频平台，喜欢的是长时段、重内容提供。抖音则是需要在较短时间内抓住用户注意力，虽然也支持横屏播放，但不如竖屏更受欢迎。 现在人设化很重要，最基本的要露个脸，算法推荐也会从这个维度认为你的内容真实、原创、可信，也会推荐给更多的用户。用户最后可以信赖、认可你，随着时间越久或许会忘记你创作的内容，但是会一直记住你对外传递的形象。还有，你做零食评测去解说食物好坏，用户都看不到你的表情，怎么感知到这款食物传递的味道是怎么样的？ 你说自己主打的是零食评测，说实话，我不太理解这个评测存在的价值与意义。更何况你每次只是针对一些小零食尝试一下好吃不好吃，能帮助用户解决什么？能给用户带来什么？比如，我看到你发布了一个吃柚子的视频，就是自己将柚子打开，品尝了一下味道。这个内容让用户看了可以感知什么？？ 在我看来，所谓评测应该是以最专业的态度去帮助用户解决在具体场景下遇到的难题。你如果去做零食评测，但是制作的内容又是以谁都能做到的方式告诉大家非常浅显的内容，用户为什么要看？平台为什么要推荐呢？我个人觉得做评测内容是很容易涨粉的，但前提是要让自己专业起来，你在评测的时候围绕一款零食好吃不好吃不能只是简单说好或不好，用户感知不到。\n举个最简单的例子。做汽车评测的创作者，为什么每一次的内容要通过多种方式，静态、动态、绕桩等等各种方式来解说，就是因为要通过多个维度、专业去解读什么是好、什么坏，它们的判断标准是什么。\n说的这三点，希望你好好想想，可以帮助你。\n大帅 通过学习本节课，明白做好短视频并不是随意的，而是有基本的底层逻辑思维的，而且是可以系统学习的，很高兴周老师开设这门课，能够跟着大神学习打造爆款短视频。\n作者回复: 感谢感谢。记得多做笔记、多思考、多提问、多实践。\nGeek_a33d6c 老师你好，我的新家去年装修完了，中间有很多磕磕绊绊的小插曲，虽有遗憾但总体还是自己比较满意的结果。想拍一些新家装修的短视频，分区域将一些好的成果展示出来，目标是引起有家裝需求的用户的关注，提供参考、得到认可。尝试从家裝内容上吸引一些流量。但有几个问题，麻烦老师给予答疑：1、从马斯洛需求层次分析，我开始认为我要表达的内容形式属于外在尊重需求，但是感觉又偏向自我实现，是装修心得的展示，这两个\u0026hellip;\n作者回复: 你好。\n如果你的创作初衷是为了通过自身的内容引起家装用户的需求，那么你必须提供的是有价值的知识输出，或者是在家装某一方面的解决方案。只有提供价值，才能赢得用户的喜爱。所以，如果你的内容是站在自我尊重需求层面，展现的内容必须是完美、优秀的一面。如果你站在自我实现需求层面，结果未必是美好的，你只是展现了自己如何家装的一个过程而已。自我尊重适合知识类内容输出方式，自我实现可以转化成真实生活的记录。\n对于家装领域的内容创作，如果你不能从呈现强烈对比的方式去帮助用户解决问题，或者说不能通过前后对比的方式凸显自己的专业，那么带给用户直观、具象的价值就少了很多。另外，如果没有对比，就没有结果放大化的说法。放大化是前提有不好的一面，才会放大好的一面，如果没有对比，放大的说法也不成立。不过，还可以采用多种创作模式，比如可以围绕用户在家装面临的具体问题时，自己是如何解决的，可以真人出镜，画面搭配一些其他视频素材等等。其实，最重要的是还是能给出切实可行、具体上手、用户能明白的价值内容，一条一条给用户说清楚就可以了。\n记住，你提供有价值的内容就可以，其他的手段是辅助而已。\n莹 刚刚为因病去世的宠物狗狗做完了一个纪念视频。看了这篇课程，才意识到这个视频对应的是马斯洛需求层次中的亲情。我这个视频的着眼点在纪念狗狗带给我们的快乐时光，分成成长故事与第二条狗狗相处来讲。为了故事更加完整，在视频开头和结尾加上了一些内容，比如狗狗去世的情况，和最后一首关于宠物离世的小诗。目标人群主要是亲人和朋友，还有其他有狗狗的能够感同身受的朋友。我觉得从他们的反应看，他们也感受了到\u0026hellip;\n作者回复: 握爪。\n我也是一个有宠物的人，与我假可爱的猫咪陪伴十多年了，从它最小的时候就开始在一起了，真没想到一转眼它开始慢慢老去。说实话，我都害怕想象它离开的那一天，因为我们早已是一家人了。我相信养过宠物的人，对于这样的感情体会更加透彻。\n因为，我们早已将这些小精灵们当成了自己的家人。所以，很多人看到这样的视频内容也都会身同感受。在短视频内容中，越是来自内心真情实感的流露，越能打动更多的人，因为这样的情感是共同的，也是可以让自己看到自己与外界、他人的关系。所以，我们用短视频记录了一段不能遗忘的时光，在别人眼里看到的是这个世界上最暖心的一页。\n玄德是我大哥 不要想着大而全，不然谁都不讨好，还是选好一层好好创作\n作者回复: 一针见血\nzhanyd 上面那个vlog能吸引人，主要是表达了真实的感情，毫无表演的痕迹，让人产生了共鸣，属于马斯洛的社交需求层。\n作者回复: 赞！\n我们的征途是星辰大海 听君一言，有醍醐灌顶感很高兴参加周维老师这套课程，感谢老师分享了那么好的短视频经验。目标是好好学习短视频的创作方法，能将有用的有趣的内容分享给更多人。\n本章阅读心得：了解基本盘。有点像文章的主线，或视频的基调。原来是对应这马斯洛需求层次理论\u0026hellip;\n作者回复:\n欢迎加入到打造爆款短视频的学习之旅中。\n给你用心写下的学习心得点个赞。我一直觉得学习这件事就是要看了之后就要过一过脑子，那么看完之后写下来是最好的途径，然后再去结合自身的实际情况去实践，就是学以致用。\n编程思维就是站在一个平台算法推荐的角度看待短视频创作，这其中其实是有两个层面，一个是代表的是“机器”对于平台的理解，一个是“机器”对于用户的理解。所谓的机器要么是通过人找内容，要么是通过内容找人，这背后是围绕了多重复杂的交叉维度。标签只是编程思维创作的一个方面，现在内容的标签化越来越成熟了，比如相关的话题榜、兴趣榜、热点榜等等，甚至当你想要将自己的内容归结到某一个内容领域时，刚打出一个词语，平台就会自动给出相关联的很多标签，任你选择。\n比如，我做了一期自我成长类的短视频内容，我为了让机器第一时间识别自己的内容，在打标签的时候输入#学习#时，在这个平台上会自动出现跟学习相关的#学习心得#、#学习感悟#、#学习笔记#等等众多标签，而且，你还会看到每个标签的热度，供你选择。\n标签不会固定、不变，而是动态的，我们要掌握的是具备打适合标签的能力。这一点，你需要在后期的实践中不断去总结，总结出适合自己的标签选用方法。\n当然了，标签只是编程思维中很小的一个体现，还包括很多方面，后续如果有需要，我会加课详说。\n祝你学有所获！\n健身咸鱼 看完之后，感觉方法很好。自己没做过短视频，视频剪辑也是一个小白，不知道做啥，先看下去再说吧。\n作者回复: 剪辑只是短视频创作中的一个环节，而且现在剪辑的门槛越来越低，很多时候只需要通过手机端的剪辑工具就可以轻松搞定。当你学习剪辑的时候，需要跟整体的创作联系起来。不过别着急，后面有专门讲剪辑的底层逻辑与避坑指南，肯定会帮到你。加油！\nOpticsvalley 老师您好，我自己刚刚开了一家线下的婚戒定制店，想把网上的渠道也做起来，还没有开始，主要是小红书、抖音、快手。我看了一些相关的视频，品牌号的视频主要还是美美的走品牌路线的感觉，拍一些漂亮的款式或者传统广告片那种，还有讲述爱情故事什么的（这种感觉格外吃力不讨好），感觉效果也不是很好，点赞播放都挺低的。不过像小红书平台上款式类的视频下面一般都有一些人询价，这是我感觉比较特别的；但是感觉应该\u0026hellip;\n作者回复: HI，你好。\n我觉得你站在不同平台的角度去分析内容的差异，这是非常好的一点。另外，这里有个问题你可能搞混了，因为很多人也都会这样认为，没有意识到其中存在的差异化。\n那就是做品牌不等于就是赤裸裸去展示产品的优秀，去做高大上、有逼格的展示广告。你看到的有一些去做所谓“美美的”品牌展示内容，是因为他们之前已经在用户心中有了一定的价值基础。不管哪个行业，真正品牌的建立是先从给用户提供某一方面的价值、解决一个具体场景的问题切入，渐渐从小到大成长起来的。你可以把你想到的一些大品牌对号入座。\n如果你的产品是自己创造的，想要在短视频平台上打造自己的品牌，其实你想要先想好自己的切入点是什么？也就是说你如果想要打造平价、内敛、经典风格，你用内容的方式如何去展现出来？比较难，因为如果你直接去展示自己产品有多优秀，就是直接的广告内容了。不要忘了，短视频的本质是通过内容建立创作者与用户之间的信任，有了信任，才有了交易。所以，你先要做的不是如何展示自己的产品，而是如何建立自己与用户的信任。\n建立信任的方式有很多，我个人最推崇的是知识输出，帮助用户解决问题，在用户心中树立有价值的标签，然后再说自己的产品与别人的不同在哪里。请注意，品牌的建立是一个循序渐进的过程，不是通过做几次内容就能建立起来了。\n真正的品牌都是时间的产物，是随着你一点点对外的输出，慢慢在用户心中种下了信任与认可的种子，时间越久，信任越大。\n古月 不知道为什么，当看到“本质”、\u0026ldquo;底层逻辑\u0026quot;这些词眼时，就会觉得这篇文章内容应该会有所收获。看透问题的本质和底层逻辑才能解决问题。课程设计能从一开始就讲到底层逻辑，可见作者的认知水平是极高的，后面的课程应该是会更有收获\n作者回复: 感谢您的信任。\n希望课程能够带给你更多的帮助。遇到问题及时留言，通过提问的方式提升学习的效果！加油！\n未央 老师，做关于探店的中医领域视频，感觉应该是安全需求，尝试了一次探店，感觉难度有点大，老师有好的思路指导吗或者说中医有其他更好的形式输出？\n作者回复: 你好。如果是中医领域的话，是要归属到安全需求中的。如果是中医+探店这种形式，我个人感觉没有体现出内容的核心价值，毕竟对于中医领域来说，用户最直接的诉求可能并不是像了解有趣历史、文化一样有渴求，更多是来自带给自己更多健康方面的直接诉求。关于如何具体定位问题，建议你可以去课程中的定位篇中学习一下，尤其是二次创新实验法。\n从我个人角度来说，做中医方面的短视频创作，最直接的还是提供价值、解决问题，其实加上探店的元素并不能给自身带来更大的加分项。因为既然你选择了安全需求领域的创作，那么就要懂得在这层需求就是如何帮助用户解决问题就可以，这是最底层的逻辑。所以，可以在围绕用户在不同场景下的需求，提供解决方案才是正确的创作途径。\n当你明白了这个核心路径之后，然后在这个路径之上加入自己的个人优势就可以了。\n乐轩 个人觉得无论是快手还是抖音或者其他短视频平台的底层逻辑都是先让机器识别出来，通过一些常用的关键词，结合自己本身的创意和思路，让系统支持你给你流量，再利用马斯洛的五个需求层次，理解用户的需求或者说痛点，从而让用户对你产生感觉，就像恋爱一样，先有认知后有感情，是吧？\n作者回复: 如果站在推荐机制角度来说，如今各个短视频推荐内容的机制，都是根据自身定位的侧重点，比如一个内容受欢迎的程度，一个用户在平台观看内容的行为习惯，还有他在平台与现实中的社交关系等等不同维度来推荐一条内容。之后，通过用户对于内容的有效反馈，再推入更多的流量池，而能一次次进入到更大流量池的爆款内容，背后就是遵循了最底层的马斯洛需求理论。\nyer 你好，情侣想记录日常，不知道应该主要围绕着美食的生理需求类拍摄，还是记录日常情感的感情需求类去拍摄，两者哪个入手好一点呢？\n作者回复: 您好。\n我觉得这两类都可以入手拍摄，没有明显的区别，重点是你在这两个领域中的个人优势是什么。关于如何找到个人优势的方法，在课程定位篇中已经有了，强烈建议你按照方法自己写一次，你就会豁然开朗了。\nGeek_bdd0e7 你好，我在做亲子游戏的视频。是要把整个游戏的开心的过程呈现出来，和要捕捉到温馨的场面。请问这是属于亲情需求类吗？这种有哪些能放大的地方呢？\n作者回复: 您好。当我们把内容通过情感的层面传递出去时，都可以归结为情感需求，在这种需求中体现了什么样的关系。创作亲子游戏类的内容，体现的是孩子与父母之间的关系，而你将游戏中间开心的过程、温馨的场面记录下来，是一种不错的创作角度。另外，我给你一点建议，在你的内容中一定要体现出孩子通过参与一些游戏表达出快乐、可爱的一面，这样可以让很多父母感受到这种游戏带来的快乐价值，就会认可背后游戏的设置等环节。\nA陈晶 老师旅游景点介绍是属于自我实现类的吗？这一类的短视频怎么创作也\n作者回复: 您好。是的，单纯来说旅游的话是一种多层次需求，也其实包括在自我实现需求中。毕竟，旅游对于每个人来说是更高层次的一种内心需求。\n创作旅游景点的内容不是一种价值输出，而是一种伪需求，而围绕旅游景点提供某方面的用户需求、场景需求就是真需求。单纯展示景点风土人情只是内容的一个方面，不能持久。\n咱们的课程后面都有详细介绍，跟着学，你就能掌握创作适合自己内容的能力，加油！\n","date":"2023-10-10T12:58:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%9F%AD%E8%A7%86%E9%A2%91%E7%9A%84%E5%BA%95%E5%B1%82%E9%80%BB%E8%BE%91/","section":"post","tags":null,"title":"爆款视频的底层逻辑"},{"categories":null,"contents":"现在短视频的创作门槛越来越低，似乎每个人只要拿起手机就可以拍出一段短视频。拍短视频一夜爆火的现象当然有，但这只是个例。想要持续产出高质量的短视频，并不容易。\n我认为这背后的原理是，当技术与工具不再成为短视频入局的门槛时，大家比拼的往往是高效、正确的创作方法，以及 持续的自我学习能力 。\n如果你之前有过短视频创作的经历，我猜你肯定也遇到过以下这些问题:\n怀抱满腔的热情投入到短视频创作中，却不知道从哪里下手; 刚了解了一点，发现都是零碎的知识点，根本成不了体系，做了第一步，不知道第二步该如何办; 看了那么多短视频，感觉很容易，自己肯定要比别人强，而当真正踏入到创作这个阶段时，就发现完全是另外一回事，而且根本不知道问题在哪里。 其实会遇到这些问题也并不奇怪，这应该是很多短视频创作者的通病。\n跟短视频打交道这么多年，我见过太多颜值不错、能力很强，也有很好的知识背景的人，做事非常努力，但是唯独在短视频这一块，总是无法达成自己期望的目标值。\n我认为， 之所以会出现这种情况，归根结底是因为他们没有掌握短视频创作的底层能力。 在掌握了各大平台推出的剪辑工具技巧之外，更要注重内在产能的养成，要养成持续自我学习的能力，不断探索挖掘潜力，培养兴趣爱好，热爱生活才能发现美好的事物，带来灵感，创造想要的生活。\n实际上，短视频创作并不像编程、算法这种硬核的专业技术知识，有科班教育和系统全面的课程帮我们从 0 开始掌握一门技能。短视频创作中的很多方法都是零散的、不统一的，需要经过总结和梳理，沉淀出一套系统的方法论，这样才能帮助我们修炼好内功，夯实知识的根基，提升短视频创作能力。\n而要想总结出这套方法论，也没有那么轻松，你需要从头开始去实践、复盘、沉淀，投入很多的时间和精力，甚至可能需要踩很多的坑，才能摸索出一套短视频创作方法论，而这还很有可能是错误的，或者是过时的。\n为了避免这个问题，我将过去 6 年来在短视频行业中总结的实践经验与创作方法，进行了沉淀与升级，准备在这个课程里全部分享给你。我会深入解读短视频创作的底层逻辑和方法技巧，并融合众多真实的平台案例，帮你突破短视频创作瓶颈，让你能在创作的同时具备学习的能力，真正利用切实可行的方法论去解决遇到的实际难题。而且，这种学习方法会让你具备举一反三的解决问题的能力。\n我是如何规划课程的? 学习拍摄短视频绝对不是一蹴而就的事情，我们需要对平台、对自己建立起正确的认知，掌握拍摄、剪辑等技巧，同时学会运营和变现。根据我多年的创作经验，我把这个学习过程分为三个阶段，分别是认知阶段、实操阶段和变现阶段，如下图所示:\n\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD ]]\ne64edf9 (update)\n这三个学习阶段是从 0 到 1、由浅到深地掌握短视频创作能力的关键，不可偏废。根据这 个思路，我将课程主体划分为五个模块。\n导读篇 导读篇:我会带你梳理清楚那些热门短视频爆火背后的底层逻辑，并结合快手、抖音等平台上一些你耳熟能详的案例，让你掌握短视频创作的精髓，能够分辨出一条内容成为爆款需要具备的关键因素，拥有一双识别爆款短视频的“火眼金睛”，为后面的知识学习打好根基。\n开篇词：短视频时代下，怎么把握好变现风口？ 定位篇 定位篇:认清定位，对于短视频创作者来说非常关键，这能帮你找准正确的创作之路。因此在这个模块中，我会从个人、平台、内容、阶段等不同的维度切入，涵盖最常用的定位方法，并针对不同的定位方法，配合实际创作时会遇到的问题案例进行详细讲解。同时，为了便于你理解、把握每一种定位方法，我还会总结一些注意事项、避坑指南，帮你更加 精准地掌握知识重点。\n爆款短视频的底层逻辑：用心拍的视频为啥美人看？ 爆款短视频的底层逻辑：如何轻松打造自我特色？ 精益创业法：如何快速跨过从 0 到 1 这道坎？ SWOT 法：这么明显的个人优势你为啥就是看不到？ 效用函数法：如何用量化的方式进行高效创作？ 二次创作新实验法：如何打造个人的差异化定位？ 平台定位：如何选择最适合自己的创作平台？ 如何快速找到各大短视频平台的正确切入点？ 创作篇 创作篇:这个模块中，我会具体剖析如何选题、如何筛选素材、如何起标题、如何做封面、如何剪辑等重点内容，并且每一部分我都会采用可实操的方法、可参考的案例，从浅 到深一步步带你理解和掌握。在此过程中，我相信你会获得一个全新的看待问题的视角， 也能够形成正确的短视频创作习惯。\n选题：如何利用思考清单找到合适选题？ 选题下：如何利用不同的内容定制合适选题？ 优劣分析法：如何快速筛选适合创作的视频素材？ 标题上：如何利用微创新巧妙找到爆款标题？ 标题下：如何用对号入座的方式抓住标题的亮点？ 视频封面上：如何快速抓住用户的注意力？ 视频封面下：如何传递最有价值的信息？ 视频剪辑：如何轻松掌握视频化剪辑的三大公式？ 效果反馈法：剪辑很容易为什么你却一直学不会？ 剪辑对比上：如何避开常规的短视频剪辑陷阱？ 剪辑对比下：如何利用剪辑技巧提升视频质量？ 运营篇 运营篇:我会站在短视频运营的角度，为你详细阐述提高短视频各项数据指标的有效手段。同时，我还会根据多年的踩坑经验，告诉你怎样做是正确的、为什么这样做是正确的 方法，让你在运营中少走一些弯路。\n拉片法：用电影创作的方式学习爆款短视频运营技巧？ 用户留存率：为什么粉丝很多但忠实拥趸却很少？ 点赞率上：为什么受欢迎的短视频点赞数却很少？ 点赞率下：三种方法轻松提升用户对内容的认可度 上瘾机制：为什么视频观看量很高却没人留言？ 避坑指南：为什么很多短视频帐号中途做不下去了？ 变现篇 变现篇:俗话说授人以鱼，不如授人以渔。因此，在最后一个模块，我不会只列举短视频变现的种类，相反，我会给你讲解可执行的方法，帮你找到适合自身的变现模式，以此把握真正的赚钱之道。另外，为了防止你在变现之路上“误入歧途”，我还会针对不同的创作阶段，通过案例与总结方法的形式，让你了解什么样的变现模式需要牢牢把握，而什么样的变现模式需要缓一缓，不能着急。\n如何找到适合自己的短视频变现模式？ 多元化变现：如何明确不同创作阶段的变现任务？ 多内容变现：不同内容的主打变现模式是什么？ 结束语：视频化时代，每个人都会找到重塑自我的机会 总之，在课程中， 我不仅会给你讲解各种拍摄难题，还会用最容易理解的方式教会你剪辑技巧。同时，我会结合大量真实的案例，展示热门视频的套路，以及初学者最容易踩的坑。\n最重要的是，你要跟着我的讲解进行实操，千万不要停留在理解阶段。\n\u0026laquo;\u0026laquo;\u0026laquo;\u0026lt; HEAD\n抓住机会吧，短视频时代已经到来! 可以说，视频将会是未来新一代的信息革命，而由视频构建的内容生态已经开启了全新的社会协同方式，并且这种社会协同带来的价值正在影响我们每一个人。下一个十年，我们将通过视频的方式和世界建立连接，而短视频就是打开这扇大门的钥匙。\n所以我希望，这个课程也能成为你连接未来的一个窗口，或者是成为你人生的转折点。\n我最大的愿望，就是你通过学习这个课程，能够掌握一种学习知识的全新方法，并且借用视频化的思维和视角来提高自己的认知。当然，我更希望能帮助你在短视频的创作上跨越 从 0 到 1 的这个坎，去实现自己人生的最大价值，在职场中收获最大的回报。\n最后，如果你在学习课程和创作短视频的过程中遇到了什么问题，非常欢迎你给我留言，我都会认真给予解答。同时，如果你身边也有喜欢短视频创作的朋友，也可以邀请他们一起学习，彼此监督、鼓励，我相信，只有在互帮互助的学习氛围内，才能提高自己的学习能力。\n从现在起，让我们一起加油吧!\n=======\ne64edf9 (update)\n","date":"2023-10-09T22:06:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8C%81%E7%BB%AD%E4%BA%A7%E5%87%BA%E9%AB%98%E8%B4%A8%E9%87%8F%E7%9A%84%E7%9F%AD%E8%A7%86%E9%A2%91/","section":"post","tags":null,"title":"怎么持续产出高质量的短视频?"},{"categories":null,"contents":"一说起拍短视频的好处，我总是会想起我见证过的千千万万的小故事。故事的主角全部都是像你我一样的普通人，但是他们通过拍摄短视频，最终在人群中闪闪发亮。\n会拍短视频，是你职业发展的加分项 曾经，我在一个短视频创作者会议上认识了一位某互联网公司的工程师。看他的作品，我还以为他是职业摄影师。他告诉我说，他并不是很喜欢写代码，也不想总是加班加点儿地工作。他一直很喜欢摄影，但是却苦于没有渠道展示自己。\n短视频兴起后，他开始尝试在业余时间拍摄自己喜欢的题材，很快就积累了数万粉丝。同时，他从一名默默无闻的小员工变成了公司的“御用摄影师”，开始为公司策划、拍摄各种宣传视频，本职收入也实现了翻倍增长。\n这绝对不是个例。\n现在，实体店的售卖、企事业单位的宣传，都从线下转到了线上，各行各业都已经融入到视频化的大潮之中，短视频创作也成为了不可或缺的一种职业技能。越早掌握这项技能，越能尽快脱颖而出，不仅可以实现在公司内部的升职加薪，同时还可以把爱好变成副业，一生和喜欢的事情在一起。\n短视频变现，比你想象的还要简单 短视频变现，是这个时代非常普遍的获得收益的方式。虽说“某某网红月入数十万”的新闻距离我们太过于遥远，但是通过短视频增加收入，绝对比你想象的要容易。\n我之前公司的一个同事平时很喜欢旅行，每个假期都会出门游山玩水，并且通过短视频的方式记录下来。随着慢慢耕耘，他发现自己的账号有了流量收入，还有一些设备厂商找他做广告。这些收入就像越积越多的米粒一样，让他实现了财富的快速增长。\n类似的案例有很多很多，它们都在告诉我们，短视频变现，绝非难事。\n其实，在很多视频平台上，只要你发布的视频浏览量超过了一定的数字，你都可以收到一定的奖励金。当你的粉丝数积累到一定程度时，就会有广告商来找你，一条广告的费用可能是你好几个月的工资。\n不是只有每天 996，才能有可观的收入，短视频时代给我们提供了很好的发展机会，千万别局限住自己。\n把生活拍下来，留住记忆 在我看来，拍短视频最迷人的一点，就是可以记录生活。每个人都会匆匆老去，一瞬间，父母长了白发，孩子长大，我们需要把日常生活记下来，不是粗糙地记下来，而是让每个片刻都因为我们的独特思考，永远留存在记忆里。\n说到这儿，我还想再给你分享一个小故事。\n几年前，有个用户给我们公司的公共邮箱发邮件，恰好被我看到了，邮件大概的意思是她的账号无法登录了。问题挺简单，我就让开发同事帮忙解决了，这个事情也就这么过去了。\n但是没多久，我们收到了她寄来的一封感谢信和一些特产。我当时有点摸不着头脑:一个账号而已，就算挂了再重新注册也是很快的，至于这么重视吗?\n不过，当我看完信里的内容、翻看她的账号时，才发现这位用户是一位年轻妈妈，她发布了近千条短视频，全都是自己宝宝的成长记录。她在信里说:“从宝宝出生，我就在记录他的成长，如今宝宝三岁了，我也通过短视频记录了三年，我希望继续记录下去，等到他长大后给孩子看，这将成为我能给予孩子的最好的礼物。”\n那一刻，我有些泪目。一条条简短的，甚至创作手法略显拙劣的视频，就是一位母亲送给孩子最好的成长礼物。所以，有句话是这样说的:“日子被记录，日子才靠得住。”用形式的永恒去克服岁月的流逝，这就是拍短视频的意义和价值。\n总而言之，无论你是希望摆脱日复一日为了生计疲于奔命的状态，还是希望你的人生里多一种选择、多点记录，拍短视频这件事儿，都可以帮你实现。\n","date":"2023-10-09T19:43:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%8B%8D%E7%9F%AD%E8%A7%86%E9%A2%91%E7%9A%84%E5%A5%BD%E5%A4%84/","section":"post","tags":null,"title":"拍短视频可以给我们带来什么?"},{"categories":null,"contents":"左脚前踩，再后踩，双手两边甩\n左恰恰，右恰恰，左右左，右左右\n前点三次，手交叉，321 收，321 收\n左并步，右并步\n迈步前点，后点前，迈步前点，后点前\n迈步后点，交叉开，左右开车，并步踩\n","date":"2023-10-07T10:20:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E8%BF%AA%E6%96%AF%E7%A7%91%E8%88%9E%E6%AD%A5/","section":"post","tags":null,"title":"老年迪斯科慢动作口令"},{"categories":["周报"],"contents":"晨练开篇定基调，专注角色设愿景\n健康学习建社交，主角鲜明投精力\n试炼七天迭代起，打怪升级通关制\n均衡成长除恶习，效能达人造时势\n","date":"2023-10-01T20:46:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E6%99%A8%E7%BB%83/","section":"post","tags":null,"title":"重新定义晨练：开篇诗以角色为主题，激活心灵演练设计愿景"},{"categories":["周报"],"contents":"事无缓急志空谈，时不待人思易迁\n以终为始布全局，要事第一行亦艰\n","date":"2023-10-01T18:26:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%88%AA%E6%AD%A2%E6%97%B6%E9%97%B4/","section":"post","tags":null,"title":"截止时间"},{"categories":["周报"],"contents":"熙攘老友消食伴，怀旧 DJ 劲舞团\n碧绿湖心夜更艳，半轮皓月金秋单\n","date":"2023-10-01T18:25:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%B0%B4%E4%B8%8A%E8%88%9E%E5%8F%B0/","section":"post","tags":null,"title":"水上舞台"},{"categories":["日志随笔","周报"],"contents":"撰写剧本主人翁，构思推演江湖梦\n吸星大法集大成，藏经阁外扫地僧\n","date":"2023-10-01T18:23:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%BC%94%E7%BB%83%E4%BA%BA%E7%94%9F/","section":"post","tags":["灵感"],"title":"演练人生"},{"categories":["日志随笔","周报"],"contents":"银杏树下人妖娆，金风玉露贴花黄\n一叶知秋花见少，静待硕果满枝摇\n","date":"2023-10-01T18:22:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E7%A7%8B%E9%A3%8E%E5%87%89/","section":"post","tags":["灵感"],"title":"秋风凉"},{"categories":["日志随笔","周报"],"contents":"谈笑风生老来闲，独爱清晨万物鲜\n八卦趣事情报站，不图胜负逞口快\n","date":"2023-10-01T18:21:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%96%B7%E7%A9%BA%E5%84%BF/","section":"post","tags":["灵感"],"title":"喷空儿"},{"categories":["周报"],"contents":"深潭碧玉寒气胜，东升锋芒愿景宏\n早餐喊麦巷子深，练摊菜农扁担重\n","date":"2023-10-01T18:19:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%97%AD%E6%97%A5/","section":"post","tags":null,"title":"旭日"},{"categories":["周报"],"contents":"拳藉密谱八段锦，吐纳运气探永春\n行云流水寸拳劲，潜修论道参悟禅\n","date":"2023-10-01T18:18:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%8B%B3%E5%B8%88/","section":"post","tags":null,"title":"拳师"},{"categories":["周报"],"contents":"种子优选秋满仓，锄草施肥勤躬耕\n护苗防害枝叶修，旱涝霜寒保丰收\n","date":"2023-10-01T18:17:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E4%BB%8E%E6%92%AD%E7%A7%8D%E5%AD%A6%E4%B9%A0%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"从播种学管理"},{"categories":["周报"],"contents":"砍柴功成利器精，王者开挂逢必赢\n常识易用事难行，工具思维寻捷径\n","date":"2023-10-01T18:13:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E5%B7%A5%E5%85%B7%E5%88%B0%E4%B9%A0%E6%83%AF%E5%94%AF%E6%89%8B%E7%86%9F%E5%B0%94/","section":"post","tags":null,"title":"重新定义工具到习惯：唯手熟尔"},{"categories":["周报"],"contents":"山林无恙无波澜，听风闻鸟观水禅\n拳师抱拳东方升，静若风景舞灵动\n","date":"2023-10-01T18:07:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%90%91%E4%BA%91%E7%AB%AF/","section":"post","tags":null,"title":"向云端"},{"categories":["周报"],"contents":"人情世故杀伐重，爱憎分明性情真\n内修德性事躬行，倾听认同人为本\n不限亲朋交际圈，兴趣宽泛广结缘\n娱乐至死莫等闲，利器当用多发言\n","date":"2023-10-01T18:06:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E7%A4%BE%E4%BA%A4%E6%89%A9%E5%A4%A7%E5%BD%B1%E5%93%8D%E5%9C%88/","section":"post","tags":null,"title":"重新定义社交：扩大影响圈"},{"categories":["周报"],"contents":"云朵堪摘直须摘，风卷云集秋雨寒\n头脑风暴煮平板，美景自盛拼果盘\n","date":"2023-10-01T18:04:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%96%B0%E6%8A%80%E8%83%BD/","section":"post","tags":null,"title":"新技能"},{"categories":["周报"],"contents":"德艺双馨余年志，名流交际比比是\n何以善终享天伦，不待扬鞭自奋蹄\n","date":"2023-10-01T18:03:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E8%AE%BE%E8%AE%A1%E4%BA%BA%E7%94%9F%E4%BB%8E%E5%85%AC%E5%9B%AD%E5%BC%80%E5%A7%8B%E4%BB%A5%E7%BB%88%E4%B8%BA%E5%A7%8B/","section":"post","tags":null,"title":"设计人生从公园开始：以终为始"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-09-30T14:24:00Z 长枪短炮取景器，月下交流摄影技\n帧帧抓拍咔咔美，专注聚焦镜像位\n","date":"2023-10-01T17:59:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%91%84%E5%BD%B1%E9%A3%8E%E6%9A%B4%E4%BF%A1%E4%BB%B0%E7%9A%84%E5%8A%9B%E9%87%8F/","section":"post","tags":["fc"],"title":"摄影风暴：信仰的力量"},{"categories":["周报"],"contents":"重新定义锻炼身体：人不是跑步机，中国功夫不是花拳绣腿，是五劳七伤自我调理秘籍\n年轻体壮跑步器，举重拉力太心急\n过激绝食抗身体，斤斤计较人性失\n中国功夫养生学，五劳七伤人为本\n自我按摩五脏穴，全身理疗精神气\n","date":"2023-10-01T17:56:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E9%94%BB%E7%82%BC%E8%BA%AB%E4%BD%93/","section":"post","tags":null,"title":"八段锦：以人为本，养生之道"},{"categories":["周报"],"contents":"情绪为王无良媒，制造焦虑饮茹血\n盛气凌人好人师，对标抄袭洗脑语\n谨记原则辨是非，勤思推演多践行\n复盘互联牢记心，效能机器习惯是\n","date":"2023-10-01T17:35:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E8%BE%93%E5%87%BA%E6%B3%A8%E9%87%8D%E5%86%85%E4%BF%AE%E5%8E%9F%E5%88%99%E6%88%90%E4%B9%A0%E6%83%AF/","section":"post","tags":null,"title":"重新定义输出：不再情绪输出，强作愁，更注重内修外显"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-09-30T05:15:18Z 伫立石柱搭炮台，自成一派显眼包\n内修常引路人观，日复一日故人缘\n相互勉励问安好，共享此时晨曦早\n学拳闻道遇知音，忘年跨圈初自成\n","date":"2023-10-01T13:57:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E4%B9%A0%E6%83%AF%E5%9C%B0%E5%8A%9B%E9%87%8F/","section":"post","tags":["fc"],"title":"习惯的力量：影响圈扩大老年团"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-09-30T05:15:02Z 思维锻炼精于思，意识养成熟于技\n认知愿景工具系，思成文体诗成句\n子弹笔记作诗集，心灵演练神来笔\n知识扶摇技压群，何惧内卷残云噬\n","date":"2023-10-01T13:56:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E4%BD%9C%E8%AF%97%E8%BF%99%E4%BB%B6%E4%BA%8B/","section":"post","tags":["fc"],"title":"重新定义作诗这件事：以诗为中心，改变思维方式"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-09-30T05:14:55Z 亲子奶孙和睦群，保姆带娃零交流\n女娃踮脚唤阿姨，扮乖讨巧方如意\n秋千自荡羡奶爸，旁观冷眼随手离\n留守儿童何止村，城市父子冷暖知\n","date":"2023-10-01T13:55:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%B8%A6%E5%A8%83%E9%9A%BE%E9%A2%98/","section":"post","tags":["fc"],"title":"带娃难题"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-09-30T05:14:45Z 书法苍劲镌刻诗，手眼心诚笔自神\n壮汉挥毫试比高，花好月圆羞难当\n秒变迷弟仰慕请，湖心取墨拜服礼\n老者指点临摹技，言传身教贺中秋\n","date":"2023-10-01T13:54:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%96%97%E4%B9%A6%E6%B3%95/","section":"post","tags":["fc"],"title":"斗书法"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-09-30T05:14:34Z 一场思辨人生课，军队出身为人师\n泼墨珠玑习古语，思想碰撞解困局\n","date":"2023-10-01T13:52:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%9D%8E%E8%80%81%E5%B8%88/","section":"post","tags":["fc"],"title":"李老师：从兴趣扩大圈子，三人行必有我师"},{"categories":["周报"],"contents":":FC_CREATED: 2023-09-30T05:14:20Z :FC_TYPE: normal :ID: cebea52d-343b-4398-ba0e-fd1fe209b870\nposition ease box interval due front 2.5 0 0 2023-09-30T05:14:20Z 棋坛：耳濡目染激活创造力\n楚河汉界将帅旗，车马相士攻守技\n兵卒掠地跃城池，田日列阵炮迎敌\n自比诸葛笑公瑾，三十六计皆狠人\n步步为营练于心，半子未落局已定\n","date":"2023-10-01T13:51:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%87%8D%E6%96%B0%E5%AE%9A%E4%B9%89%E6%B8%B8%E6%88%8F/","section":"post","tags":["fc"],"title":"重新定义游戏：想象力，心灵演练的竞技场"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-09-30T14:23:20Z 白翁老太兴奋声，惊扰湖心灯下人\n偕老登高观景亭，遥指东方锃亮明\n脱口而出初来了，方知巨轮月色景\n闻声而动人齐涌，驻足朝圣新儿生\n","date":"2023-10-01T13:49:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%8D%81%E5%85%AD%E6%9C%88/","section":"post","tags":["fc"],"title":"十六圆月"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-09-30T14:23:44Z 月下起舞芳自赏，舞步交际心相通\n陶冶情操享盛况，心有舞台皆主角\n","date":"2023-10-01T13:03:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%9C%88%E4%B8%8B%E7%8B%AC%E8%88%9E%E7%9B%9B%E4%B8%96%E5%BA%94%E4%BA%AB/","section":"post","tags":["fc"],"title":"月下独舞，盛世应享"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-10-01T05:03:04Z 天地人和大局观，万物刍狗何其叹\n人人平等地球村，名利皆为身外物\n","date":"2023-10-01T13:02:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%B4%BB%E6%B3%95/","section":"post","tags":["fc"],"title":"活法"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-10-01T05:00:38Z 悠闲滑步信手舞，满面年轮暖阳舒\n跟学难分左右步，一句道破节拍悟\n心有所向路自明，情若至甄贵人助\n精力无价尽其用，效能均衡一杆秤\n","date":"2023-10-01T12:59:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%8F%A3%E5%AD%97%E8%88%9E/","section":"post","tags":["fc"],"title":"口字舞：一句话，一个字，启蒙新世界"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-10-01T04:59:13Z 有人既有江湖愁，金婚舞伴也醋浓\n靓婆亦惹老人抢，白翁应邀身难消\n人情世故量力行，闻听前夜血当场\n独舞自赏内修心，结伴却道恩怨生\n","date":"2023-10-01T12:57:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E4%BA%A4%E9%99%85%E9%A3%8E%E4%BA%91%E8%88%9E%E4%BC%B4%E9%86%8B%E6%B5%93/","section":"post","tags":["fc"],"title":"交际风云：抢舞伴，谈生死"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-10-01T01:51:00Z 眼光独到识人心，见我新人先试探\n毫无戒备坦诚现，转身再见皆利往\n文玩鉴宝口头禅，市场行情掐指算\n话术讨巧惑人心，老者喜闻暖心田\n","date":"2023-10-01T09:50:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E8%80%81%E7%82%AE/","section":"post","tags":["fc"],"title":"老炮：天南海北侃，老干部的团宠"},{"categories":["周报"],"contents":" position ease box interval due front 2.5 0 0 2023-10-01T00:34:35Z 重新定义圈子：由内而外，扩大影响圈，先着重培养智慧，安全感，方向，力量的源泉人是群居动物，有同理心，认同感，羞耻心，荣誉感，普天同庆的节日\n国庆节：同理心，普天同庆，自豪感油然而生\n党有主义著宣言，同心同德造盛世\n觉醒年代历程艰，探索真理抛头颅\n尝尽大众疾苦命，铸就铁流工农军\n圈子大可举国荣，小可治家祠堂律\n","date":"2023-10-01T08:22:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%9B%BD%E5%BA%86%E8%8A%82/","section":"post","tags":["fc"],"title":"国庆节重新定义圈子"},{"categories":null,"contents":"八段锦柔筋健骨，养气壮力，具有行气活血，畅通经脉，灵活盘骨，协调五脏六腑之功能，可以达到强身健体，怡养心神，益寿延年，防病治病的效果。春天练习可以生发阳气，疏肝理气，强健脾胃，所以很适合。\n每一个动作都能对某一局部起到应有的效能，并通过局部调节整体。既可防病健身，又能医治疾病，特别是对一些久治不愈的慢性病，亚健康人群尤其适宜。\n预备口诀 两足分开平行站，横步要与肩同宽头正身直腰松腹，两膝微屈对足尖双肩松沉掌下按，手指伸直要自然凝神调息垂双目，静默呼吸守丹田\n两手托天理三焦 fc position ease box interval due front 2.5 0 0 2023-09-30T15:36:40Z 十字交叉小腹前，翻掌向上意托天左右分掌拨云式，双手捧抱式还原式随气走要缓慢，一呼一吸一周旋呼吸尽时停片刻，随气而成要自然\n其中胸膈以上是上焦，胸膈与肚脐之间为中焦，肚脐一下为下焦，两手交叉，拔伸腰背，提拉胸腹，活动颈椎，使全身气机流动。\n作用：拉长脊椎，颈肩部肌肉，还可以调理气血，稳定情绪。\n左右开弓似射雕 fc position ease box interval due front 2.5 0 0 2023-09-30T15:36:45Z 马步下蹲要稳健，双手交叉左胸前左推右拉似射箭，左手食指指朝天势随腰转换右式，双手交叉右胸前右推左拉眼观指，双手收回式还原\n左右手如同拉弓射箭，使长期伏案工作的同学消除肩背部的酸痛不适，并增加肺活量，抒发胸气，消除胸闷，梳理肝气，治疗胁痛\n作用：可减轻胸闷与肩颈酸痛等症状。\n调理脾胃单臂举 fc position ease box interval due front 2.5 0 0 2023-09-30T15:36:49Z 双手重叠掌朝天，右上左下肩捧圆右掌悬臂托天去，左掌翻转至脾关双掌均沿胃经走，换臂托按一循环呼尽吸足勿用力，收式双掌回丹田\n左右上肢松紧，配合上下对拉拔伸，牵拉腹腔，按摩脾胃肝胆，对于久坐的同学，可以右助消化吸收，增强营养\n作用：增强脾胃功能，改善胃酸过多，手脚冰冷或四肢酸痛的症状。\n五劳七伤往后瞧 fc position ease box interval due front 2.5 0 0 2023-09-30T15:36:54Z 双掌捧抱似托天，双掌封按臂内旋头应随手向左转，引气向上至涌泉呼吸尽时平松静，双肩收回掌朝天继续运转成右式，收式提气回丹田\n五劳是五脏的劳损，七伤是七情的伤害，五劳七伤犹如今天的亚健康，这一式转头扭臂挺胸调整颈椎，刺激胸腺增强免疫力，去除亚健康\n作用：缓解肩颈僵硬，落枕等症状，适合久坐办公的上班族。\n摇头摆尾去心火 fc position ease box interval due front 2.5 0 0 2023-09-30T15:37:03Z 马步扑步可自选，双掌扶于膝上边头随呼气宜向左，双目却看右足尖呼吸还原接右式，摇头斜看左足尖如此往返随气练，气不可浮意要专\n上身前俯，臀部摆动，使心火下降，可以消除心烦，口疮，口臭，失眠多梦，小便热赤，便秘等症状\n作用：去心火，避免长暗疮，爆发青春痘，流鼻血，情绪暴躁，等情况的发生。动作较复杂，可量力而为。\n两手攀足固肾腰 fc position ease box interval due front 2.5 0 0 2023-09-30T15:37:08Z 两足横开一步宽，两手平扶小腹前平分左右向后转，吸气藏腰撑腰间式随气走定深浅，呼吸弯腰盘足圆手势引导勿用力，松腰收腹守涌关\n前屈后伸，双手攀足，使身体与腰部得到拉升牵制，调理腰背的肌肉，强肾健体\n作用：可使腹直肌以及脚内侧的经脉得以伸展，透过瘦的热量对肾脏进行按摩。两手如攀握不到两足脚趾，可不必勉强。\n攒拳怒目增气力 fc position ease box interval due front 2.5 0 0 2023-09-30T15:37:13Z 马步下蹲眼瞪圆，双拳束抱在胸前拳引内气随腰转，前打后拉两肩旋吸气收回呼气放，左右轮换眼看拳两拳收回胸前抱，手脚按掌式还原\n马步冲拳，怒目瞪眼，均可刺激肝经系统，使肝血充盈，肝气疏泄，强健筋骨，对长期静坐，气血多，有郁结，尤为适宜\n作用：集聚力量将体内浊气用力呼出，肩部肌肉自然跟着伸展，可增加气力。\n背后七颠百病消 fc position ease box interval due front 2.5 0 0 2023-09-30T15:37:17Z 两腿并立撇足尖，足尖用力足跟悬呼气上顶手下按，落足呼气一周天如此反复共七遍，全身气走回丹田全身放松做颤抖，自然呼吸态怡然\n整套套路的收功，动作简单，颠足而立，拔伸脊柱，下落振身，按摩五脏六腑，下落振荡，导致全身的抖动，可以消除百病\n作用：有提神醒脑的功能，还可以缓解膀胱无力，痔疮与子宫脱垂等症状。\n","date":"2023-10-01T00:19:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%AB%E6%AE%B5%E9%94%A6%E5%8F%A3%E8%AF%80/","section":"post","tags":null,"title":"八段锦口诀"},{"categories":["周报"],"contents":"登录mac 电脑时，输入正确密码，出现无法登录的情况，结合官方文档，分析一下原因，给出三个解决方案。\n出现输入正确密码无法登录的情况可能有几个原因：\n键盘布局问题：确保你的键盘布局设置正确，比如使用的是英文还是其他语言的键盘布局。\n账户被锁定：尝试重启电脑，并使用其他账户登录。如果其他账户能够登录，那么可能是你的账户被锁定了。你可以尝试在“系统偏好设置”中找到“用户与组”选项，然后点击你的用户名，解锁账户。\n登录项被破坏：可能是某些登录项被损坏或冲突，导致无法登录。你可以尝试在安全模式下启动电脑，并且删除最近安装的软件或造成问题的登录项。\n这只是一般的解决方案，具体情况可能需要更详细的分析和处理。请参考官方文档或者联系苹果官方支持以获取更准确的解决方案。\n","date":"2023-09-21T12:47:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/mac%E7%99%BB%E5%BD%95%E6%97%B6%E6%8F%90%E7%A4%BA%E5%AF%86%E7%A0%81%E9%94%99%E8%AF%AF/","section":"post","tags":null,"title":"mac 登录时提示密码错误"},{"categories":null,"contents":"我有两部手机分别是手机A 和 B,A可以上网和热点。 为了节省上网流量，手机B通过wifi链接手机A 的网络热点，手机B 怎么限制哪些APP 能用，哪些APP 禁止联网。\n方式一通过系统设置限制 app 联网权限 你可以通过以下步骤限制手机B上的应用程序的网络访问权限：\n打开手机B的设置界面。 在设置界面中找到“应用程序”或类似的选项。 点击进入“应用程序”列表，然后选择要限制的应用程序。 在应用程序的详细信息页面中，查找网络访问权限或类似的选项。 禁用应用程序的网络访问权限，这样该应用程序将无法使用手机A的热点进行联网。 请注意，手机的不同版本和操作系统可能会有所不同，上述步骤仅供参参考。\n例如：在荣耀 pad8 上，通过设置移动网络选项\u0026ndash;\u0026gt; 流量管理 \u0026ndash; 在 app 列表中，可以禁止 app 联网。\n方式二：借助代理工具，例如 clash 限制 app 联网 在 clash 中，通过设置\u0026ndash; 网络 \u0026ndash; 网络访问控制：支持三种方式（全部应用，仅允许已选应用访问，不允许已选应用访问）\n经过测试，设置为仅允许已选应用访问，不选择 chrome 时，还是可以访问百度。clash 只限制代理，不限制联网。\n","date":"2023-09-21T12:17:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%89%8B%E6%9C%BA%E7%83%AD%E7%82%B9%E5%A6%82%E4%BD%95%E9%99%90%E5%88%B6app/","section":"post","tags":null,"title":"手机在开启热点时，如何限制接入热点的手机上的APP"},{"categories":["学习笔记"],"contents":"以下内容包含来自 Emms 实战配置的示例,展示了人们对 Emms 默认设置所做的各种各样广泛的修改。\n下面的摘录包括:通过 dbus 集成,为 See The Browser 定义一个 “recent” 的过滤器,通过 emms-history.el 实现持久播放列表,并通过 emms-librefm-stream.el 发送音轨信息:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 ;; notifications (require \u0026#39;emms-dbus) (emms-dbus-enable) ;; covers (setq emms-browser-covers #\u0026#39;emms-browser-cache-thumbnail-async) (setq emms-browser-thumbnail-small-size 64) (setq emms-browser-thumbnail-medium-size 128) ;; filters (emms-browser-make-filter \u0026#34;all\u0026#34; #\u0026#39;ignore) (emms-browser-make-filter \u0026#34;recent\u0026#34; (lambda (track) (\u0026lt; 30 (time-to-number-of-days (time-subtract (current-time) (emms-info-track-file-mtime track)))))) (emms-browser-set-filter (assoc \u0026#34;all\u0026#34; emms-browser-filters)) ;; history (emms-history-load) ;; libre-fm (emms-librefm-scrobbler-enable) 在以下内容中,可以看到有关保存播放列表、播放列表交互以及向特定播放器后端添加特殊参数的一些默认设置。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (setq-default emms-source-file-default-directory \u0026#34;/mnt/db/mediaCore/sound_music/\u0026#34; emms-source-playlist-default-format \u0026#39;m3u emms-playlist-mode-center-when-go t emms-playlist-default-major-mode \u0026#39;emms-playlist-mode emms-show-format \u0026#34;NP: %s\u0026#34; emms-player-list \u0026#39;(emms-player-mpv) emms-player-mpv-environment \u0026#39;(\u0026#34;PULSE_PROP_media.role=music\u0026#34;) ;; 1 emms-player-mpv-parameters \u0026#39;(\u0026#34;--quiet\u0026#34; \u0026#34;--really-quiet\u0026#34; ;; 2 \u0026#34;--no-audio-display\u0026#34; \u0026#34;--force-window=no\u0026#34; \u0026#34;--vo=null\u0026#34;)) 在设置 EMMS 使用 MPV 播放器时,可以通过 emms-player-mpv-environment 变量为 MPV 设置环境变量。\n例如,可以设置环境变量 PULSE_PROP_media.role=music,将 MPV 播放的音频流设置为 music 角色。这样当 MPV 播放音频时,PulseAudio 会将其识别为音乐,应用音乐 DSP 等效果。\n可以在配置文件中加入以下代码: (setq emms-player-mpv-environment '(\u0026quot;PULSE_PROP_media.role=music\u0026quot;))\n当 EMMS 调用 MPV 播放音频或视频时,会为 MPV 设置这个环境变量。MPV Inherits 这个环境变量,PulseAudio 获取到设置,将 MPV 的音频流识别为音乐。\n这使得我们可以更深入地定制 MPV 的行为。除了将音频流设置为 music 外,还可以:\n设置视频画面颜色属性等。 选择视频输出方式,如 vo=opengl 等。 其他 MPV 支持的任何选项。 emms-player-mpv-parameters 变量可以为 EMMS 调用的 MPV 播放器设置命令行参数。\n这会让 MPV 具有以下行为:\n--quiet 和 --really-quiet: MPV 不输出任何信息,静默运行。\n--no-audio-display: MPV 不显示音频波形等视觉化信息。\n--force-window=no: MPV 不创建自己的窗口,在后台运行。\n--vo=null: MPV 不进行任何视频输出,只有音频输出。\n所以通过设置这些参数,我们让 MPV 以静默后台模式运行,没有任何视频和最小的音频输出(只在后端通过 PulseAudio 播放音频)。\n这种设置非常适合只播放音乐,让 EMMS 完全控制 MPV,不在桌面环境中创建任何视频或音频窗口,不产生任何干扰,获得最纯净的音乐播放体验。\n当然,我们也可以根据需要设置其他 MPV 支持的任意命令行参数。EMMS 通过调用命令启动 MPV,所以整个 MPV 的功能和选项,都可以通过 emms-player-mpv-parameters 变量设置的命令行参数提供给 EMMS 使用。\n","date":"2023-06-07T13:50:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/emms%E9%85%8D%E7%BD%AE%E4%B8%80%E4%B8%AAmpv%E7%9A%84%E6%A1%88%E4%BE%8B/","section":"post","tags":["翻译"],"title":"通过 emms 定制 mpv 播放器的案例"},{"categories":["学习笔记"],"contents":"使用 emms-tag-editor.el,emms 可以设置曲目的标签信息,并在外部程序(如\u0026rsquo;mid3v2\u0026lsquo;和\u0026rsquo;vorbiscomment\u0026rsquo;)的帮助下将其写回文件。\n使用键绑定 E 来编辑播放列表中光标处的曲目标签或所有标记的曲目(有关如何标记曲目,请参阅可标记的播放列表)。曲目的标签信息在特殊缓冲区 “*Emms-TAGS*” 中以文本格式列出。\n以 加粗字体 标记字段名称不可编辑。任何标签信息都放在等号 = 后面,并且可以更改。特殊字段“Name”是曲目的文件名。 如果在此字段中进行任何更改,则将重命名曲目文件名称。\n编辑完成标签信息后,使用 C-c C-c (调用 emms-tag-editor-submit-and-exit)提交更改并关闭 “*Emms-TAGS*” 缓冲区。\n有几个命令可以对所有曲目进行更改。\n函数: emms-tag-editor-set-all tag value 在所有曲目中设置 TAG 为 VALUE 。\n如果打开了\u0026rsquo;transient-mark-mode\u0026lsquo;且标记处于活动状态,则更改只会对选定区域中的曲目生效。\n函数: emms-tag-editor-replace-in-tag tag from to 在选定的 TAG 中查找和替换文本。\n例如,如果选择了 info-title 标记,则仅在标题标签中执行替换。\n如果打开了\u0026rsquo;transient-mark-mode\u0026lsquo;且标记处于活动状态,则更改只会对选定区域中的曲目生效。\n函数: emms-tag-editor-transpose-tag tag1 tag2 互换 TAG1 和 TAG2 的值。\n如果打开了\u0026rsquo;transient-mark-mode\u0026lsquo;且标记处于活动状态,则更改只会对区域中的曲目生效。\n函数: emms-tag-editor-submit arg 使修改后的标签生效。\n使用 prefix 参数，隐藏标记编辑缓冲区。\n如果要扩展标签编辑器以与 mp3 和 ogg 之外的文件格式一起工作,请查看这些变量。\n变量: emms-tag-editor-formats 此变量确定如何将曲目字段插入\u0026rsquo;emms-tag-editor-edit-buffer\u0026rsquo;。\nEmms 标签信息可编辑字段通常由曲目名称的扩展名确定。变量\u0026rsquo;emms-tag-editor-tags\u0026lsquo;包含 emms 曲目可能拥有的所有标签。为使\u0026rsquo;emms-tag-editor-formats\u0026lsquo;更容易生成,将一个字符分配给标签。\n变量: emms-tag-editor-tagfile-functions 要将标签写回曲目文件,此变量中应指定外部程序。\n重命名文件 标签编辑器还能够根据此变量的值重命名光标处曲目的文件或所有标记曲目的文件。\n用户选项: emms-tag-editor-rename-format 当调用\u0026rsquo;emms-tag-editor-rename\u0026lsquo;时,曲目的文件将根据此格式规范重新命名。文件扩展名将自动添加。\n它使用 emms-tag-editor-tags 中定义的格式说明符。\n默认值为 \u0026quot;%a - %l - %n - %t\u0026quot; ,因此文件重命名后\n\u0026lt;艺术家\u0026gt; - \u0026lt;专辑\u0026gt; - \u0026lt;曲目编号\u0026gt; - \u0026lt;标题\u0026gt;.\u0026lt;扩展名\u0026gt;\n要执行重命名,请将光标放在要重命名的曲目上或标记一些曲目。然后按R调用此函数:\n函数: emms-tag-editor-rename 根据 emms-tag-editor-rename-format 的值重命名光标处曲目的文件或所有标记的曲目文件。\n","date":"2023-06-06T19:21:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%BC%96%E8%BE%91%E9%9F%B3%E9%A2%91%E6%96%87%E4%BB%B6%E5%85%83%E6%95%B0%E6%8D%AE/","section":"post","tags":["翻译"],"title":"编辑音频标签和文件名称"},{"categories":["学习笔记"],"contents":"Emms 可以有多个播放列表,因为播放列表只是带有曲目列表的其他缓冲区。\n您可以使用文件 emms-metaplaylist-mode.el 提供的\u0026rsquo;emms-metaplaylist-mode\u0026lsquo;管理多个播放列表。\n使用 M-x emms-metaplaylist-mode-go 启动播放列表管理器。播放列表管理器将列出播放列表并标记当前播放列表。\n可用的命令如下:\nRET 使光标处的缓冲区成为 Emms 播放列表缓冲区并切换到它。\nSPC 使光标处的缓冲区成为 Emms 播放列表缓冲区(但不切换到它)。\nn 将光标移到下一个播放列表。\np 将光标移到上一个播放列表。\ng 更新播放列表管理器缓冲区。\nC 创建一个新的 Emms 播放列表缓冲区。\nC-k 杀死光标处的 Emms 播放列表缓冲区。\nc 将光标移到当前播放列表缓冲区。\nq 杀死播放列表管理器。\n","date":"2023-06-06T19:05:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/emms%E7%AE%A1%E7%90%86%E6%92%AD%E6%94%BE%E5%88%97%E8%A1%A8/","section":"post","tags":["翻译"],"title":"使用EMMS管理多媒体播放列表"},{"categories":null,"contents":"GNU FM是一个用于运行音乐社区网站的自由软件。它是为音乐社区网站 Libre.fm 创建的。\nEmms 可以分别使用 emms-librefm-scrobbler.el 和 emms-librefm-stream.el 向GNU FM服务器发送曲目信息和流式音乐。\nEmms 默认配置为使用 Libre.fm,但可以通过配置变量 emms-librefm-scrobbler-handshake-url 为GNU FM服务器的URL来与任何GNU FM服务器一起使用。\n向GNU FM服务器提供凭据的推荐方式是使用 authinfo 文件。在 auth-info 文件(通常是 ~/.authinfo.gpg )中添加验证,如:\n1 machine libre.fm login USERNAME password PASSWORD 如果您使用的是 libre.fm 以外的其他服务器,请将 libre.fm 更改为匹配 emms-librefm-scrobbler-handshake-url 。\n另外,您可以通过设置这些变量在 init-file 中以纯文本形式保存密码:\n1 2 (setq emms-librefm-scrobbler-username \u0026#34;USERNAME\u0026#34; emms-librefm-scrobbler-password \u0026#34;PASSWORD\u0026#34;) 上传曲目信息\t如何提交已听曲目信息。 GNU FM流音乐 从GNU FM服务器流式音乐。 30.1 Uploading Track Information GNU FM服务器,如 Libre.fm 可以选择使用 Emms 发送到网站服务器的信息来存储用户的听力习惯。利用用户听力习惯的记录,网站旨在通过分析用户的音乐品味来为用户推荐音乐。\n使用以下内容将此功能加载到 Emms 中:\n1 (require \u0026#39;emms-librefm-scrobbler) 此功能也可以通过查看“emms-all”设置级别中的设置来启用。\n使用 emms-librefm-scrobbler-enable 启用上传 Emms 播放的曲目详细信息到GNU FM服务器。曲目的详细信息将在曲目播放结束时上传到服务器。您可以使用 emms-librefm-scrobbler-disable 禁用此行为。\n30.2 GNU FM Streaming 如果GNU FM服务器提供流媒体音乐服务,您可以通过加载以下内容来利用它:\n1 (require \u0026#39;emms-librefm-stream) 此功能也可以通过查看“emms-all”设置级别中的设置来启用。\n然后调用 emms-librefm-stream 并输入您要听的电台的URL,例如“librefm://globaltags/Classical”。\n31 D-Bus Emms 可以提供 MPRIS 接口,允许通过 D-Bus 进行控制。\n要启用此功能,首先加载:\n1 (require \u0026#39;emms-mpris) 然后使用 emms-mpris-enable 打开它。您可以使用 emms-mpris-disable 关闭它。\n目前,Emms 对MPRIS规范的实现不完整:当前不支持更改音量。\n","date":"2023-06-06T18:59:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E9%85%8D%E7%BD%AEemmsFM%E5%B9%B3%E5%8F%B0%E5%92%8C%E4%B8%AA%E4%BA%BA%E9%9F%B3%E9%A2%91%E6%B5%81%E5%AA%92%E4%BD%93/","section":"post","tags":["翻译"],"title":"配置emmsFM平台和个人音频流媒体"},{"categories":null,"contents":"Emms 引入了一个用于播放音乐的高级抽象层,以便您可以根据需要对其进行定制。\n新建播放器\t如何定义新的播放器。 简单的播放器 `play\u0026rsquo;\t使用 play 的播放器示例。 更复杂的播放器\t使用 mpg321 的复杂播放器示例。 新建播放器 文件 emms-player-simple.el 定义了一些简单的播放器作为开始,但为您最喜欢的播放器提供一个函数应该不难。我们将从一个简单的示例开始,演示如何在 Unix 下使用 play 命令播放我们的WAV文件。\n定制播放控制 “play” 命令 Play 是一个非常简单的命令行播放器,支持各种格式。如果您希望您的 emms 播放WAV文件,只需在你的 .emacs 中放置以下行:\n1 2 (require \u0026#39;emms-player-simple) (define-emms-simple-player play \u0026#39;(file) \u0026#34;\\\\.wav$\u0026#34; \u0026#34;play\u0026#34;) 哈!这不是很简单吗?\n宏函数 define-emms-simple-player 至少需要三个参数。\n第一个参数(在我们的示例中为 play)定义播放器的名称。它用于命名播放器函数。 第二个是正则表达式,用于定义我们的播放器将播放的文件。 \\\\.wav$ 匹配任何以点和字符串 wav 结尾的文件名。 最后一个参数是我们实际用于播放我们文件的命令行命令。 您还可以添加路径,但我们只假设该命令在当前路径下执行。这三个参数之外的所有参数都是可选的。它们用于向您的参数添加要添加的命令行参数。\n如果您希望以最大可能的音量收听最喜欢的艺术家的WAV文件,请使用以下行:\n1 2 3 4 5 6 (require \u0026#39;emms-player-simple) (define-emms-simple-player play \u0026#39;(file) \u0026#34;\\\\artist-*.wav$\u0026#34; \u0026#34;play\u0026#34; \u0026#34;--volume=100\u0026#34;) 请注意,您必须将参数添加为字符串!\n用于 define-emms-simple-player 的命令行工具必须以一首歌作为参数,并在播放该特定歌曲后停止。对于任何其他概念,您将需要对 emms 进行更多定制\u0026hellip;\n使用 define-emms-player 定制更复杂的播放器 如果简单的播放器能满足基本需求,那么您不需要阅读本章节。但是,如果您好奇如何在 emms 中使用(几乎)任何播放器,请继续阅读\u0026hellip;\n在本章中,我们将使用mpg321构建一个可以暂停、重启并显示剩余时间的播放器。我们不会实现所有这些功能,但在本章结束后,您将知道如何定义它。\n命令 define-emms-simple-player 只是为 define-emms-player 提供一个抽象层,后者略微复杂但功能更强大!\n1 2 3 4 (define-emms-player \u0026#34;emms-mpg321-remote\u0026#34; :start \u0026#39;emms-mpg321-remote-start :stop \u0026#39;emms-mpg321-remote-stop :playablep \u0026#39;emms-mpg321-remote-playable-p) 所以,这几乎就是全部！\ndefine-emms-player 至少需要三个参数。第一个是 播放器的名称 。其余的是带函数调用的方法。\n需要三种方法:启动 start 、 stop 停止和 playable 可播放。\nstart 告诉 Emms 如何启动 track 曲目(原文如此!), stop 告诉 Emms 如何停止播放器, playable 返回非 nil,如果播放器可以播放曲目。 所以,我们只需要这三个函数来获得我们的 mpg321-remote :\n首先,我们编写 start 函数我们将检查是否有打开的进程,如果没有,则启动一个进程。然后,我们将文件名和过滤器的字符串发送到进程。\n1 2 3 4 5 6 7 8 (defun emms-mpg321-remote-start () (unless (get-process ``mpg321-remote\u0026#39;\u0026#39;) (setq emms-mpg321-remote-process (start-process \u0026#34;mpg321-remote-process\u0026#34; \u0026#34;*mpg321*\u0026#34; \u0026#34;mpg321\u0026#34; \u0026#34;-R\u0026#34; \u0026#34;abc\u0026#34;)) (process-send-string \u0026#34;mpg321-remote-process\u0026#34; (concat \u0026#34;l \u0026#34; (emms-track-name track))) (set-process-filter emms-mpg321-remote-process \u0026#39;emms-mpg321-remote-filter))) 我们需要过滤器,因为 mpg321-remote 在播放曲目后不会退出,就像简单的播放器一样。我们等待进程将输出 “(at-sign)P 0” (mpg321曲目结束的信号)发送到过滤器,然后调用 emms-mpg321-remote-stop 。\n1 2 3 (defun emms-mpg321-remote-filter (process output) (when (string-match \u0026#34;(at-sign)P 0\u0026#34; output) (emms-mpg321-remote-stop))) 编写 emms-mpg321-remote-stop 函数它只是测试是否有其他文件要播放,否则关闭进程。\n1 2 3 (defun emms-mpg321-remote-stop () (unless emms-playlist (process-send-string \u0026#34;mpg321-remote-process\u0026#34; \u0026#34;Q\\n\u0026#34;)) 编写 emms-mpg321-remote-playablep 函数为了使其成为可播放的示例，其实我只是从 emms-player-simple.el 中窃取的。\n1 2 3 (defun emms-mpg321-remote-playablep (track) \u0026#34;Return non-nil when we can play this track.\u0026#34; (and (emms-track-file-p track) 现在,我们有了一个准备就绪的播放器,我们可以添加像 emms-mpg321-remote-pause 这样的命令。\n","date":"2023-06-06T16:51:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/emms%E9%85%8D%E7%BD%AE%E6%96%B0%E6%92%AD%E6%94%BE%E5%99%A8/","section":"post","tags":null,"title":"在emacs中如何配置emms新播放器"},{"categories":["学习笔记"],"contents":"我们可以使用包\u0026rsquo;emms-mode-line\u0026rsquo;(由文件 emms-mode-line.el 提供)在 Emacs 模式行上显示当前播放曲目的信息。\n要激活此功能,请调用:\n1 2 (require \u0026#39;emms-mode-line) (emms-mode-line 1) 也可以显示曲目播放了多长时间。此功能由文件 emms-playing-time.el 提供的 emms-playing-time 包定义。\n要使用此功能,请调用:\n1 2 (require \u0026#39;emms-playing-time) (emms-playing-time 1) Emms 播放时,可以在 modeline 上显示图形图标。此功能由 emms-mode-line-icon.el 提供。要启用,请调用以下内容并确保 emms-mode-line-icon-enabled-p 设置为非 nil 值:\n1 (require emms-mode-line-icon) 注意:\u0026rsquo;(emms-playing-time -1)\u0026lsquo;将完全禁用 emms-playing-time 模块,不推荐使用。(因为其他 emms 模块可能依赖于它)\n相反,要在模式行上切换显示播放时间,可以调用\u0026rsquo;emms-playing-time-enable-display\u0026lsquo;和\u0026rsquo;emms-playing-time-disable-display\u0026rsquo;。\n函数: emms-playing-time-enable-display 在模式行上显示播放时间。\n函数: emms-playing-time-disable-display 从模式行中删除播放时间。\n我们可以使用包\u0026rsquo;emms-mode-line\u0026rsquo;(由文件 emms-mode-line.el 提供)在 Emacs 模式行上显示当前播放曲目的信息。\n","date":"2023-06-06T08:10:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%AE%BE%E7%BD%AEmodeline%E6%92%AD%E6%94%BE%E7%8A%B6%E6%80%81/","section":"post","tags":["翻译"],"title":"设置音频播放状态在modeline上的展示样式"},{"categories":null,"contents":"如果你能利用 Obsidian 中现有的所有工作流程,通过几个简单步骤就添加人工智能的功能,那会是什么样的体验?\n想象一下:\n创建一个新笔记,人工智能会根据你已经建立的链接推荐写作提建议,这样你就不会再面临空白页面。 在写笔记时,人工智能可以作为知识搏斗的伙伴。 通过简单的英语指示轻松改变你写作的结构。 以上这些,以及更多功能,现在都可以在 Obsidian 中实现。\n用于 QuickAdd 的新人工智能助手是一个强大的工具,它集成了 OpenAI 的 GPT-3 和GPT-4模型,在你的思维环境中提供功能强大的人工智能助手。它可以自动化琐碎的任务,节省时间专注于重要的事情,并通过作为知识对手来增强你的思考。\n你只需要 QuickAdd 插件和一个OpenAI API 密钥。这里有TfTHacker 的精彩指南来获取这样的 API 密钥。\n这里有一个 Twitter 主题 展示了你可以用人工智能助手做什么。我将在本指南中展示所有这些示例。\n从0到AI驱动 在 Obsidian 中,创建一个AI提示模板文件夹。记住这个文件夹的路径,以后会需要。例如 bins/ai_prompts 。 打开 QuickAdd 设置。打开 “AI Assistant” 设置,将其路径设置为AI提示模板文件夹。 在同一选项卡设置中,将 OpenAI API 密钥粘贴到\u0026quot;OpenAI API 密钥\u0026quot;字段中。 这就是所有的设置了。现在你可以使用AI助手了。\n基本思想是设置一个 QuickAdd 宏,它将触发AI助手。AI助手将使用你指定的提示模板生成一个提示,然后将其发送到 OpenAI。OpenAI 将返回一个响应,AI助手将该响应传递给 QuickAdd 宏。然后,您可以在宏的后续步骤中使用该响应,例如捕获到笔记或创建新笔记。\n创建提示模板很简单:只需在提示模板文件夹中创建一个笔记。\n你可以使用 QuickAdd格式语法或QuickAdd内嵌脚本的任何语法。您将在我的工作流部分中看到一些此功能的强大示例。\n这里有一个非常简单的示例设置,仅仅通过几个步骤就从0到AI驱动。\n我有一个AI提示模板文件夹,如推荐。我的基本AI助手宏设置只使用AI助手和捕获,如上图GIF所示。\n插入当前文档唯一的区别是我的捕获使用以下捕获格式:\n1 2 3 {{selected}} {{value:output}} {{selected}} 可以为空或选择的任何文本,这使得它非常适合在活动文件中使用AI。 {{value:output}} 是助手的输出。\n但是AI助手可以被用作更复杂宏中的构建块,正如我们将看到的。\nThe AI Assistant Settings 在 AI 助手的主要设置中,可以通过 QuickAdd 设置访问,您可以设置以下选项:\nOpenAI 的API密钥 提示模板文件夹,包含您的所有提示模板 默认模型,确定 OpenAI 将使用的模型 是否显示助手,用于切换状态消息 默认系统提示模板,将确定模型的行为 然后,对于宏中的每个AI助手命令,您可以设置以下选项:\n提示模板,确定要使用的提示模板。如果不指定,AI助手将要求您从提示模板文件夹中选择一个。 模型,确定 OpenAI 将使用的模型。这将覆盖主设置中设置的默认模型。 输出名称变量,确定将包含AI助手输出的变量的名称。如果要在宏的后续步骤中使用输出,这很有用。默认情况下,这是 output,即 {{value:output}} 。还将有一个 {{value:output-quoted}} 变量,其中将包含输出,但使用 markdown 块引用格式。例如,如果要在提示中使用输出,这很有用。 系统提示模板,确定模型的行为。这将覆盖主设置中设置的默认系统提示模板。 My AI-Powered Workflows 下面是我在工作中发现的一些有用的工作流。\n我将整个提示模板作为一个整体包括在内,以便您可以将其复制并粘贴到自己的AI提示模板文件夹中。这些工作流中的一些涉及一些脚本编程,但我试图注释代码,以便易于理解您正在运行的内容。\nGenerating writing prompts 输入链接,AI 根据与该笔记相关的笔记生成10个写作提示。\n这个提示模板使用 Dataview (必需的插件)来获取与您输入的笔记相关的所有笔记。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 这里是与{{value:Link}}相关的 Obsidian(Markdown)链接列表。 请使用这些链接以项目符号形式给出关于{{value:Link}}的10个写作提示。 在段落中将链接作为句子的一部分使用。 ```js quickadd //使用DataView API的简称 const dv = DataviewAPI; //提示用户输入MoC笔记的链接 const targetLink = await this.quickAddApi.inputPrompt( \u0026#39;MoC链接\u0026#39;, \u0026#34;输入我们将使用的链接以获取所有与其链接的笔记。\u0026#34; ); this.variables[\u0026#39;Link\u0026#39;] = targetLink; //获取与目标链接链接的所有笔记的列表 const healthPages = dv.pages(targetLink).values; //将笔记格式化为[[links]] const links = healthPages.map((f) =\u0026gt; { const tf = app.vault.getAbstractFileByPath(f.file.path); return app.fileManager.generateMarkdownLink(tf, \u0026#39;/\u0026#39;); }); //将列表连接起来,使其成为文本格式,每个链接占一行 return links.join(\u0026#39;\\n\u0026#39;); ``` MOC Creator 这是我在 Twitter工作流 中展示的MOC大纲创建者。生成文档导航和内容这是一个改进版本,与上面的提示一样,它会要求您输入一个链接,然后为该笔记生成一个MOC。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 这里是与{{value:Link}}相关的Obsidian(Markdown)链接列表。 请使用这些链接为关于{{value:Link}}的笔记写出大纲。最多不超过200字。 在段落中将markdown链接作为句子的一部分使用。 ```js quickadd //使用DataView API的简称 const dv = DataviewAPI; //提示用户输入MoC笔记的链接 const targetLink = await this.quickAddApi.inputPrompt( \u0026#39;MoC链接\u0026#39;, \u0026#34;输入我们将使用的链接以获取所有与其链接的笔记。\u0026#34; ); this.variables[\u0026#39;Link\u0026#39;] = targetLink; //获取与目标链接链接的所有笔记的列表 const healthPages = dv.pages(targetLink).values; //将笔记格式化为[[links]] const links = healthPages.map((f) =\u0026gt; { const tf = app.vault.getAbstractFileByPath(f.file.path); return app.fileManager.generateMarkdownLink(tf, \u0026#39;/\u0026#39;); }); //将列表连接起来,使其成为文本格式,每个链接占一行 return links.join(\u0026#39;\\n\u0026#39;); ``` MOC Creator with content 这是MOC创建者的延伸,它还包括您要为其创建MOC的笔记的内容。文档导航和内容\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 这里是与{{value:Link}}相关的Obsidian(Markdown)链接列表,以及它们的内容。 请使用这些链接为关于{{value:Link}}的笔记写出大纲，最不超过多200个词。 在段落中将markdown链接作为句子的一部分使用。 ```js quickadd //使用DataView API的简称 const dv = DataviewAPI; //提示用户输入MoC笔记的链接 const targetLink = await this.quickAddApi.inputPrompt( \u0026#34;MoC链接\u0026#34;, \u0026#34;输入我们将使用的链接以获取所有与其链接的笔记。\u0026#34; ); this.variables[\u0026#34;Link\u0026#34;] = targetLink; //获取与目标链接链接的所有笔记的列表 const healthPages = dv.pages(targetLink).values; //将笔记格式化为[[links]] const links = await Promise.all(healthPages.map(async f =\u0026gt; { const tf = app.vault.getAbstractFileByPath(f.file.path); const fileContent = await app.vault.cachedRead(tf); const link = app.fileManager.generateMarkdownLink(tf, \u0026#39;/\u0026#39;); return `## ${link}\\n${fileContent}` })); //将列表连接起来,使其成为文本格式,每个链接占一行 return links.join(\u0026#34;\\n\u0026#34;); ``` Summarizer 这是一个简单的提示,您选择一些文本,然后使用该提示调用助手。然后,它将吐出一个AI生成的摘要:\n1 2 请摘要如下文本。仅使用文本本身作为摘要材料,不要添加任何新内容。为简洁起见,以大纲形式重写此内容: {{value}} Transform selected 这个提示模板将要求您提供说明,它将使用这些说明来转换您选择的文本。\n它基本上可以做任何事情 - 不仅仅是转换。\n您可以通过提供与摘要提示中类似的说明来要求它概述文本,解释您选择的文本,以大纲形式重写某些内容,或任何您想要的内容。\n我要求它通过使用符号作为参考来解释我选择的 LaTeX 方程式,它完美地解释了每个符号以及整个公式。\n1 2 3 4 5 说明: {{VALUE:Instructions}} 请按上述说明转换文本: {{selected}} Flashcard creator 这个提示模板根据选择的文本生成背诵卡。\n1 2 3 4 5 6 7 8 9 10 11 12 请以以下形式创建记忆卡: Q: 问题在这里 A: 答案在这里 问题应该简洁、简明、简单,不应该是一个双重问题。避免一般性问题和双重否定问题。 答案也应该简短简单。 如果无法将材料包含在一个问题中,请创建多个记忆卡。 --- {{value}} Get me started writing about\u0026hellip; 为了启动您的写作:\n1 2 3 4 5 6 7 8 我正在写关于{{value:Topic}}的文章。 请给我一些要点来开始: - 相关主题是什么? - 主题的基础知识是什么? - 为什么创建\u0026#34;{{value:Topic}}\u0026#34;主题? - 它解决了什么问题? Manual prompt 我认为这几乎是必不可少的。它类似于简单地打开 ChatGPT 并提示它。\n该模板将要求您提供一些输入,这是整个提示。\n1 {{value}} 这也是我在简单设置示例中演示的一个模板。\n它允许您输入任何 Prompt,将其发送到AI,并将其响应捕获到宏中以进行进一步使用。非常强大,几乎可以实现任何功能。\nAlternative viewpoints 当我陷入困境时,这个模板对我很有帮助。从另一个角度看问题总是很好的。您需要选择一些文本(您的草稿),然后在提示时输入一个主题。\n1 2 3 4 5 我正在写关于{{value:Topic}}的文章。这里是我的草稿: {{value}} 请提出3个改进建议,3个不同观点和3个用于进一步思考的问题。 它会分析您的草稿并提供:\n3个改进建议 - 可以改进的方面 3个不同观点 - 另一种看问题的方式 3个问题进行进一步思考 - 推动您在写作中更深入思考的问题 这真的有助于打破思维定势,找到新的灵感来源,并激发创造性思维。人工智能可以以全新的方式审视问题,这真的很有价值。\n我经常在写作时使用这个模板。它不仅可以解决特定的写作难题,还可以在更广泛的层面上扩展我的思维。\nPrompt Chaining 好的,让我们来看一些更高级的东西。\n提示链是指一个提示使用前一个提示的输出。从本质上讲,您正在使AI逐步思考——就像遵循配方。\n这里有一个疯狂的例子可以生成初创企业名称→商业计划、目标用户等→为您提供一步一步的实施指南。\n正如我前面提到的,AI助手可以被视为一个建筑块。您可以把它们堆叠在一起以获得强大的结果。\n这里有三个提示的堆栈,每个提示都使用前一个提示的结果。\n当您配置每个提示以具有特定设置时,您可以完全自动化它:\n例如,这是第一步。它使用 ChainPrompt1 模板并在 {{value:out1}} 中输出其值。而且由于这是一个宏,每个输出变量可以在后续步骤中使用。\n通过堆叠助手许多次并使用每个步骤消耗前一个步骤的输出变量的模板,我们得到了提示链。\n最终捕获的格式如下:\n1 2 3 4 5 6 7 8 9 10 11 ## Iteration 1 {{value:out1}} ## Iteration 2 {{value:out2}} ## Output {{value:out_final}} Summarize book notes 这是我使用AI助手构建的第一个工作流之一。\n这里是我以前将书籍笔记导入 Obsidian 的工作流程:\n从 Readwise 获取高亮部分 在笔记本中创建笔记 新的AI驱动的工作流程:\n从 Readwise 获取高亮部分 AI助手根据高亮部分概括书籍 在笔记本中创建带有摘要的笔记 核心工作流程实际上是相同的。我只需要选择一本书,就可以导入,所以我的输入没有改变。\n您也可以获得这个工作流程!这里是我们需要设置的宏:\n第一个和最后一个步骤都来自我的博客文章我如何将文献笔记导入Obsidian。如果您以前已经遵循过,您需要再次这样做,因为我最近更新了脚本和说明,以实现更强大的工作流程(在制作AI助手之前)。\n中间步骤是AI助手。您需要将其设置为使用GPT-4模型以获得更大的上下文大小。我发现GPT-3.5对于这个任务来说太局限了。然后,您需要配置AI助手使用特定的模板,我称之为 概括书籍笔记 。\n这里是模板:\n1 2 3 请概括如下书籍\u0026#34;{{value:title}}\u0026#34;作者{{value:author}}。仅使用文本本身作为摘要材料,不要添加任何新内容。为简洁起见重写此内容: {{value:highlights}} 这些值中的每一个都来自 EzImport 脚本,这就是为什么宏的排序必须是 EzImport → AI助手 → 捕获。\n所以,请先按照指南进行操作。在工作流程的中间注入AI助手,设置如上所示\u0026hellip;就是这样。\n除了摘要之外,您可以在宏中添加另一个步骤来创建可操作的要点。使用下面的模板进行此操作。\n最后,这里是我用于所有书籍笔记的书籍笔记模板。非AI版本在上述指南中找到:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 --- image: tags: in/books state/process aliases: - \u0026#34;{{VALUE:title}}\u0026#34; cssclass: lastHighlightAt: {{VALUE:lastHighlightAt}} shouldPublish: true --- # {{VALUE:title}} ## 元数据 标签:: {{VALUE:tags}} 类型:: [[{]] 作者:: {{VALUE:author}} 参考:: 评级:: {{VALUE:10,9,8,7,6,5,4,3,2,1,0}} 审阅日期:: ==更新此处== 完成年份:: [[{{DATE:gggg}}]] # 想法 # 采取的行动/变化 \u0026gt; [!todo] 可操作要点 - AI {{value:actionable-takeaways-quoted}} # 主要要点摘要 \u0026gt; [!tip] AI 摘要 {{value:summary-quoted}} # 高亮和笔记 Actionable takeaways 根据您提供的文本创建可操作的要点。这需要一个 summary 变量,您可以从宏中的前一步(例如使用“概括书籍笔记”工作流程)获得。\n1 2 3 根据以下文本编写可操作的要点。编写一步一步的计划。首先给我一些我可以立即采取行动的东西,然后告诉我根据文本我还可以做什么。使用80/20原则优先考虑最重要的要点。 {{value:summary}} YouTube Summarizer 这个提示模板将允许您获取 YouTube 视频的字幕,然后对其进行摘要。\n您需要提供的只是希望创建新笔记时的 YouTube 视频 URL。\n我将此与Actionable takeaways提示模板结合使用,以创建具有摘要和可操作要点的笔记。\n因此,我的宏看起来像这样:\nYouTube 摘要 - AI助手步骤获取字幕并进行摘要。它还为下一步设置了几个变量。 可操作要点 - AI助手步骤根据摘要创建可操作要点。 创建笔记 - 创建具有视频标题、摘要和可操作要点的新笔记。 第三步- 创建新笔记 - 是一个模板操作,它创建一个文件名为 + {{VALUE:safeTitle}} 的新笔记。 safeTitle 来自宏的第一步,表示视频的标题,但移除了所有非法字符。\n对YT摘要的GPT-4限制似乎是~20分钟的视频长度。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 请对以下文本进行摘要。仅使用文本本身作为摘要材料,不要添加任何新内容。为简洁起见,以提纲形式重写: ```js quickadd const videoUrl = await this.quickAddApi.inputPrompt(\u0026#34;Video URL\u0026#34;); const url = new URL(videoUrl); const videoId = url.searchParams.get(\u0026#39;v\u0026#39;); this.variables[\u0026#34;📺 YouTube Video ID\u0026#34;] = videoId; const transcriptBody = await requestUrl(`https://youtubetranscript.com/?server_vid=${videoId}`).text; const videoPage = await requestUrl(videoUrl).text; console.log(transcriptBody); console.log(videoPage); const dp = new DOMParser(); const dom = dp.parseFromString(transcriptBody, \u0026#39;text/xml\u0026#39;); const transcriptEl = dom.getElementsByTagName(\u0026#39;transcript\u0026#39;)[0]; if (!transcriptEl) { new Notice(\u0026#34;No transcript found.\u0026#34;); throw new Error(\u0026#34;No transcript found.\u0026#34;) } const textElements = transcriptEl.getElementsByTagName(\u0026#39;text\u0026#39;); const textArr = []; for (let i = 0; i \u0026lt; textElements.length; i++) { const text = textElements[i]; textArr.push(text.textContent); } const transcript = textArr.join(\u0026#34;\\n\u0026#34;); const title = videoPage.split(\u0026#39;\u0026#39;)[1].split(\u0026#39;\u0026#39;)[0].replace(\u0026#34; - YouTube\u0026#34;, \u0026#39;\u0026#39;).trim(); function sanitizeFileName(fileName) { const illegalChars = /[\\/\\?\u0026lt;\u0026gt;\\\\:\\*\\|\u0026#34;]/g; const undesiredChars = /\u0026#34;/g; const replacementChar = \u0026#39;_\u0026#39;; return fileName.replace(illegalChars, replacementChar).replace(undesiredChars, \u0026#34;\u0026#34;); } function sanetizeTitle(text) { const undesiredChars = /\u0026#34;/g; const replacementChar = \u0026#34;\u0026#34;; return text.replace(undesiredChars, replacementChar); } this.variables[\u0026#34;title\u0026#34;] = sanetizeTitle(title); this.variables[\u0026#34;safeTitle\u0026#34;] = sanitizeFileName(title); return transcript; ``` 这里是我的 YouTube 视频笔记模板:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 --- tags: in/video state/process aliases: - \u0026#34;+ {{VALUE:title}}\u0026#34; cssclass: null image: https://i.ytimg.com/vi/{{VALUE:📺 YouTube Video ID}}/hqdefault.jpg --- Title:: {{VALUE:title}} Type:: [[+]] Tags:: URL:: https://www.youtube.com/watch?v={{VALUE:📺 YouTube Video ID}} Channel:: Rating:: {{VALUE:10,9,8,7,6,5,4,3,2,1,0}} Reference:: Publish Date:: Reviewed Date:: ==UPDATE THIS== --- \u0026lt;center\u0026gt;\u0026lt;iframe width=\u0026#34;560\u0026#34; height=\u0026#34;315\u0026#34; src=\u0026#34;https://www.youtube.com/embed/{{VALUE:📺 YouTube Video ID}}\u0026#34; frameborder=\u0026#34;0\u0026#34; allow=\u0026#34;accelerometer; autoplay; encrypted-media; gyroscope; picture-in-picture\u0026#34; allowfullscreen\u0026gt;\u0026lt;/iframe\u0026gt;\u0026lt;/center\u0026gt; --- \u0026gt; [!info] AI Summary {{value:summary-quoted}} \u0026gt; [!todo] Actionable Takeaways {{value:actionable-takeaways-quoted}} \u0026lt;% tp.file.cursor(0) %\u0026gt; Final words 这还处于初期阶段。我有那么多的工作流程想法,提示和其他我们可以与AI助手一起做的酷事情。\n如果您有任何问题,请让我知道。所有我的提示模板也可以在AI助手的同一页面上找到。\n我很想知道您如何在保险库中使用AI。欢迎在 Twitter 上@我。\n请记住,使用API会产生货币成本。GPT-3.5相当便宜,但过度使用GPT-4可能会造成高昂的成本。出于这个原因,我强烈建议您在 OpenAI 账户上设置支出限额。尝试玩转模型以了解适合您的模型。\n这个工具——以及AI一般来说——是一个重大的生产力乘数。它绝不应取代您的思考,只应增强它。让它处理PKM的琐碎部分,这样您可以专注于最重要的事情。\n","date":"2023-06-05T00:05:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/ObsidianAI%E5%B7%A5%E4%BD%9C%E6%B5%81%E5%AE%9E%E7%8E%B0%E5%8A%A9%E6%89%8B/","section":"post","tags":null,"title":"QuickAdd 插件实现 ObsidianAI 工作流助手"},{"categories":["学习笔记"],"contents":"The Org-roam Node 在使用手册时,我们首先介绍一些术语。我们将 Org-roam 中的基本单位称为节点。我们将节点定义如下:\n一个节点是任何具有ID的标题或顶级文件。\n例如,使用此示例文件内容:\n1 2 3 4 5 6 7 8 9 :PROPERTIES: :ID: foo :END: #+title: Foo * Bar :PROPERTIES: :ID: bar :END: 我们创建两个节点:\n一个文件节点“Foo”,ID为 foo。\n一个标题节点“Bar”,ID为 bar。\n没有 ID 的标题将不被视为 Org-roam 节点。可以通过交互命令 M-x org-id-get-create 向文件或标题添加 Org ID。\n接着,我们将文件内容分解为节点层次结构,称为 Org-roam 网络。每个节点都链接到其父节点和子节点。例如,上述示例的网络结构为:\n1 2 3 - Foo - Bar 其中:\nFoo 是文件节点,ID为 foo,链接到子节点 Bar 。 Bar 是标题节点,ID为 bar,链接到父节点 Foo 。 网络的根节点为文件节点。文件节点可以链接到其他文件节点,构建更大的网络。网络提供一种视觉表示,用于在头脑中构建和探索思想之间的关联。\n接下来,我们将更详细地探讨节点类型和网络。我们还将看到 Org-roam 如何帮助构建和维护此网络。\nLinks between Nodes 我们使用 Org 的标准ID链接(例如 id:foo)在节点之间建立链接。在计算节点之间的链接时,只考虑ID链接,但 Org-roam 会缓存文档中的所有其他链接以供外部使用。\n例如,给定文件:\n1 2 3 4 5 6 7 8 :PROPERTIES: :ID: foo :END: * [[http://example.com][Example]] * Bar :PROPERTIES: :ID: bar :END: 其网络为:\n1 2 3 - Foo - Bar 其中, Org-roam 忽略链接 Example , 但会在 Org-roam 缓存中记录该链接,以供外部使用。只有ID链接 id:bar 会用于计算网络结构。\n通过只使用ID链接来构建网络,Org-roam 可以跟踪节点之间的父子关系,并构建层次结构。如果考虑所有的链接,网络可能变得杂乱和难以理解。但是,通过缓存其他链接,Org-roam 仍然允许复杂的跨文档链接,这些链接可供外部工具和进程使用。\n此外,Org-roam 网络是有向无环图(DAG)。这意味着:\n网络中的每个节点至多有一个父节点。这避免了在网络中形成\u0026quot;环\u0026quot;。\n网络可以由多个根节点组成。文件节点始终是网络中的根节点。\n网络中的路径可以是单向的,也可以是双向的。双向路径通过在两个节点之间建立双向链接来实现。\n理解 Org-roam 网络的这些属性对于在 Org-roam 中有效导航和组织信息至关重要。\nSetting up Org-roam Org-roam 的功能源于其积极的缓存:它爬取 org-roam-directory 中的所有文件,并维护所有链接和节点的缓存。\n要开始使用 Org-roam,请选择一个位置存储 Org-roam 文件。包含您笔记的目录由变量 org-roam-directory 指定。Org-roam 在 org-roam-directory 中递归搜索笔记。在调用 Org-roam 函数之前,需要设置此变量。\n对于本教程,创建一个空目录,并设置 org-roam-directory:\n1 2 (make-directory \u0026#34;~/org-roam\u0026#34;) (setq org-roam-directory (file-truename \u0026#34;~/org-roam\u0026#34;)) file-truename 函数仅在 org-roam-directory 内使用符号链接时必要:Org-roam 不解析符号链接。但是,可以指示 Emacs 始终解析符号链接,代价是性能损失:\n1 (setq find-file-visit-truename t) 接下来,我们设置 Org-roam 以在文件更改时运行函数以维持缓存一致性。这通过运行 M-x org-roam-db-autosync-mode 来实现。要确保 Org-Roam 在启动时可用,请将此内容放入 Emacs 配置中:\n1 (org-roam-db-autosync-mode) 要手动构建缓存,请运行 M-x org-roam-db-sync 。第一次构建缓存可能需要一段时间,但后续构建通常是瞬间的,因为它们只重新处理已修改的文件。\norg-roam-directory 是您存储 Org-roam 文件的位置。设置 org-roam-directory 是使用 Org-roam 的第一步。\norg-roam 通过运行 org-roam-db-autosync-mode 来保持缓存与文件系统同步。这会在保存 Org-roam 文件时同步缓存。\norg-roam-db-sync 手动构建缓存。首次构建缓存需要较长时间,但后续构建通常很快,因为它们只需要重新处理已修改的文件。\n理解 Org-roam 的缓存机制对于高效使用 Org-roam 至关重要。缓存为许多 Org-roam 功能提供支持,如果缓存过期,这些功能的性能和正确性可能会受到影响。\n创建和链接节点 Org-roam 使创建笔记并将其链接在一起变得容易。有2个主要函数用于创建节点:\norg-roam-node-insert:如果不存在则创建一个节点,并在点处插入到节点的链接。 org-roam-node-find:如果不存在则创建一个节点,并访问该节点。 org-roam-capture:如果不存在则创建一个节点,并在完成后恢复当前窗口配置。 首先尝试 org-roam-node-find 。调用 M-x org-roam-node-find 将显示 org-roam-directory 中节点的标题列表。目前应该什么也不显示,因为目录中没有笔记。输入要创建的笔记的标题,然后按 RET 。这将启动笔记创建过程。此过程使用 org-capture 的模板系统,可以定制(见 The Templating System )。使用默认模板,按 C-c C-c 完成笔记捕获。\n现在我们有一个节点,可以使用 M-x org-roam-node-insert 插入到节点的链接。这会带出节点列表,其中应包含您刚刚创建的节点。选择节点将插入到节点的 id: 链接。如果您输入的标题不存在,您将再次通过节点创建过程。\n也可以方便地通过 Org-roam 提供的 completion-at-point 功能插入链接(见 Completion 补全 )。\norg-roam-node-insert 和 org-roam-node-find 是创建新节点的主要方法。这些命令将引导您通过节点创建过程,要么插入到现有节点的链接,要么创建新节点。理解这些命令使您能够快速而方便地构建网络。\n使用 completion-at-point 功能,可以轻松地通过键入节点标题或标签来插入链接,这不需要显示节点列表。这使链接到现有节点变得非常高效。\n创建新节点和手动将它们链接在一起是构建 Org-roam 网络的基础。熟悉这些功能将使您在使用 Org-roam 中变得更加自如。\n自定义节点补全 节点选择是通过 completing-read 接口实现的,通常通过 org-roam-node-read 。这些节点的呈现由 org-roam-node-display-template 管理。\n变量: org-roam-node-display-template 配置 Org-roam 节点的显示格式。\n${field-name:length} 形式的模式根据当前节点进行插值。\n每个 field-name 都由 org-roam-node 的每个对应访问器函数的返回值替换,例如 ${title} 将由 org-roam-node-title 的结果插值。您也可以使用 cl-defmethod 定义自定义访问器。例如,您可以定义:\n1 2 (cl-defmethod org-roam-node-my-title ((node org-roam-node)) (concat \u0026#34;My \u0026#34; (org-roam-node-title node))) 然后在这里或在捕获模板中将其引用为 ${my-title} 。\nlength 是可选的指定符,声明可以使用多少个字符来显示对应字段的值。如果未指定,该字段将原样插入,即它不会对齐或修剪。如果它是一个整数,则该字段将相应地对齐,所有超出的字符将被修剪。如果它是 “*”,则该字段将尽可能使用许多字符,并将相应地对齐。\n这个变量也可以分配一个闭包,在这种情况下,闭包被求值,其返回值被用作模板。闭包必须求值为有效的模板字符串。\n如果您使用垂直完成框架,例如 Ivy 和 Selectrum ,Org-roam 支持生成对齐的表格式完成界面。例如,要包括最多10个字符宽的标签列, 可以将 org-roam-node-display-template 设置如下:\n1 2 3 (setq org-roam-node-display-template (concat \u0026#34;${title:*} \u0026#34; (propertize \u0026#34;${tags:10}\u0026#34; \u0026#39;face \u0026#39;org-tag))) 这将产生类似于:\n1 2 My Title todo Another Note blog 的完成接口,其中 Title 被对齐,标签被修剪到10个字符。\n理解 org-roam-node-display-template 对于定制 Org-roam 节点选择界面至关重要。通过调整此变量,您可以生成对您的工作流最有意义的界面。\n","date":"2023-06-04T19:01:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/roam/org-roam%E6%96%B0%E6%89%8B%E5%85%A5%E9%97%A8/","section":"post","tags":["翻译","org-roam"],"title":"org-roam新手入门"},{"categories":null,"contents":"Org-roam 是一个用于联想思维的工具。它在Org mode中模拟Roam Research 的一些关键功能。\nOrg-roam 允许轻松地进行非层次化的记笔记:使用 Org-roam,笔记会自然流畅地记录,这使得记笔记变得有趣和容易。Org-roam 增强了 Org mode 语法,任何已经使用 Org mode 进行个人知识库的人都可以使用它。\nOrg-roam 利用 Org mode 周围成熟的生态系统。例如,它对org-ref提供首要支持以进行引文管理,并能够利用 Org 的优秀 LaTeX 和源码块评估功能。\n相比其他工具,Org-roam 提供以下优势:\n隐私和安全性: 你的个人知识库只属于你,完全离线和由你控制。使用 GPG 加密你的笔记。\n纯文本的长期性: 与 Roam Research 等 web 解决方案不同,笔记首先是纯 Org mode 文件—— Org-roam 仅构建一个辅助数据库,以赋予个人知识库超能力。拥有纯文本笔记对知识库的长期性至关重要。无需担心专有 Web 解决方案被取消。即使 Org-roam 不复存在,笔记仍然有效。\n免费和开源: Org-roam 既免费又开源,这意味着如果你对 Org-roam 的任何部分感到不满意,你可以选择扩展 Org-roam 或打开 pull 请求。\n利用Org mode生态系统: 几十年来,Emacs 和 Org mode 已发展成为组织纯文本的成熟系统。在 Org mode 的基础上构建 Org-roam 已将其远远领先于许多其他解决方案。\n基于Emacs: Emacs 也是编辑文本的绝佳界面, Org-roam 继承了 Emacs 可提供的强大文本导航和编辑功能。\n目标受众 Org-roam 对不熟悉 Emacs 和 Org mode 的任何人来说看起来都不友好,但对愿意投入精力掌握其复杂性的人来说,它也是极其强大的。 Org-roam 站在巨人的肩膀上。Emacs 最初于1976年创建,至今仍然是许多人编辑文本和设计文本界面时的首选工具。Emacs 的可塑性允许创建 Org mode,这是一种通用的纯文本系统,用于维护待办事项列表、规划项目和撰写文档。这两种工具都非常广泛,需要花费大量时间才能充分掌握。\nOrg-roam 假定仅对这些工具有基本熟悉度。使用基本文本编辑功能轻松上手并不困难,但只有在使用这些工具变得更加高级时,人们才能充分意识到将 Roam 功能构建到 Emacs 和 Org mode 中的强大功能。\nOrg-roam 的一个关键优点是基于 Emacs,这使得它具有可塑性。这对于记笔记工作流程尤其重要。我们认为记笔记工作流程极其个人化, 没有一种工具能完美适合您。Org mode 和 Org-roam 允许您发现什么适合您,并为自己构建那个完美的工具。\n如果您是新手软件,选择相信这一飞跃,我希望您能像 Neal Stephenson 一样深深着迷。\n与其他编辑软件相比,Emacs 的优点就像正午的阳光比星星更大更亮一样,它不仅更大更亮,简直令其他所有东西消失无踪。——尼尔·斯蒂芬森,《一开始就是命令行》(1998年)\n简单介绍 zettelkasten 法 Org-roam 提供维护 slip-box 数字滑盒的实用程序。本节旨在简要介绍 slip-box 或 Zettelkasten 方法。通过提供有关该方法的背景知识,我们希望 Org-roam 的设计决定变得清晰,这将有助于适当使用 Org-roam。在本节中,我们将介绍 Zettelkasten 社区和 Org-roam 论坛中常用的术语。\nZettelkasten 是一种个人思考和写作工具。它非常重视观点之间的联系,建立起思维网络。因此,它非常适合知识工作者和智力任务,如进行研究。Zettelkasten 可以充当研究伙伴,与之交谈可能会产生新的和意想不到的思路。\n这种方法归功于德国社会学家尼克拉斯•卢曼,他使用这种方法产生了大量的著作。卢曼的滑盒简单地是一盒卡片。这些卡片很小——通常只够容纳一个概念。大小限制鼓励将想法分解成单独的概念。这些想法是显式链接在一起的。想法的分解鼓励对想法的离题探索,增加了思考的表面。在笔记之间明确建立链接也鼓励一个人考虑概念之间的联系。\n在每张卡片的角落,卢曼给每张卡片附加了一个有序ID,允许他链接和跳转到卡片之间。在 Org-roam 中,我们简单地使用超链接。\nOrg-roam 是数字化在 Org mode 中的滑盒。每个 zettel(卡片)都是纯文本 Org mode 文件。与维护纸质滑盒一样,Org-roam 使创建新 zettel 变得易于使用强大的模板系统预填写样板内容。\n暂时笔记\n滑盒需要一种快速捕获想法的方法。这些被称为 暂时笔记 :它们是稍后需要处理或删除的信息或想法的简单提醒。这通常使用 org-capture (见 Org Info: Capture)或使用 Org-roam 的每日笔记功能(见 *org-roam-dailies 来实现。这提供了一个收集思想的中心收件箱,以供日后处理成永久笔记。\n永久笔记 永久笔记进一步分为两类:文献笔记和概念笔记。文献笔记可以是对某一特定来源(例如书籍、网站或论文)的简要注释,以便日后访问。概念笔记在撰写时需要更多照顾:它们需要自解释和详细。Org-roam 的模板系统支持添加不同模板以促进这些笔记的创建。\n有关 Zettelkasten 方法的更多阅读,Sonke Ahrens 的《如何做到聪明记笔记》是一本不错的指南。\n","date":"2023-06-04T17:49:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/roam/org-roam%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/","section":"post","tags":null,"title":"org-roam文档翻译"},{"categories":null,"contents":"在 osx 终端如何使用 mv 命令移动大文件，遇到的问题：mv: fastcopy: write() failed: /Volumes/AIGO/file File too large\n当在Mac OSX终端使用mv命令移动大文件时,你可能会遇到\u0026quot;mv: fastcopy: write() failed: /Volumes/AIGO/file File too large\u0026quot;这样的错误。这是因为mv命令在后台使用fastcopy工具来高效移动文件,但fastcopy无法移动超过4GB的文件。\n要解决这个问题,你有几个选项:\n使用ditto命令代替mv。ditto是Mac自带的专用于高效移动大文件和文件夹的命令。你可以使用: bash ditto /Volumes/AIGO/file /destination/path 来移动文件。\n将文件切片为4GB以下的大小,逐个移动,然后重新组合。你可以使用: bash split -b 4g /Volumes/AIGO/file mv /Volumes/AIGO/file.\\* /destination/path cat /destination/path/file.\\* \u0026amp;amp;gt; /destination/path/file rm /destination/path/file.\\* 安装特定用于高效移动大文件的工具,如FastCopy或rsync。例如: bash brew install fastcopy fastcopy /Volumes/AIGO/file /destination/path 或者\nbash rsync -av /Volumes/AIGO/file /destination/path 临时将文件压缩为.zip或.gz文件,移动压缩文件,然后解压。例如: bash zip -r file.zip /Volumes/AIGO/file mv file.zip /destination/path unzip /destination/path/file.zip 这些都是移动Mac OSX上的大文件的可选方法。ditto和专门的文件移动工具可能是首选方法,因为无需重复的压缩和解压缩步骤。\n请让我知道如果你对在Mac OSX上移动大文件有任何其他问题!\n","date":"2023-06-02T19:14:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%A6%82%E4%BD%95%E5%9C%A8osx%E6%8B%B7%E8%B4%9D%E5%A4%A7%E6%96%87%E4%BB%B6/","section":"post","tags":null,"title":"在 osx 终端如何移动大文件？"},{"categories":["解决方案"],"contents":"制定要显示的是个区域的 org-ql 查询条件，和 org-supper-agenda 分组规则\n在使用 org-ql 导出数据之前，先确定四象限中，需要什么数据，例如，今日要务，一周安排等。再根据 org-ql 语法查询 org 文件中的日程安排，然后，使用 org-supper-agenda 分组的规则，导出自定义视图格式的任务清单，再将组的内容，更新替换到 README.md 文件中，最终达到同步的效果。\n按照自己的习惯，定义四象限区间将要显示的内容，然后，根据内容需求，编写 org-ql 查询和分组导出。\n今日毕：显示今天到期，开始，待处理的任务，显示项目内容的任务。 需要先确定查询语句，不能是项目，而是可行性的任务，不能有子条目。必须有父条目， 分组的规则，按时间，优先级排序即可。 周安排：显示本周的主要项目和任务目标。里程碑周任务的特殊性，需要是项目，目标，里程碑。 查询条件：需要按照 tag 来区分项目，列出每个项目的前三个任务。要限制在本周完成的任务。 分组规则：按优先级，条目等级分组即可 猴子法则：灵感和待处理的任务 收集箱灵感收集的条目，待处理状态。搜索条件，inbox 标签，todo 关键字。 分组规则：按优先级和时间消耗排序。 娱乐，健身，阅读，跑步。娱乐性的活动，主要为了健康和精神调节，充电的事项 有阅读，运动，跑步，习惯。查询条件，属性，habit 按习惯分组。按时间排序 编写查询今日任务和分组规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 (org-ql-search (current-buffer) \u0026#39;(and (ts-active :on today) (todo \u0026#34;TODO\u0026#34;) (ancestors (tags \u0026#34;project\u0026#34;)) (or (not (children)) (children (not (todo \u0026#34;TODO\u0026#34;)))) ) :sort \u0026#39;(todo priority date) :super-groups \u0026#39;((:name \u0026#34;今日毕\u0026#34; :scheduled today :deadline today :priority \u0026#34;A\u0026#34;)) ) 1 1 周任务查询条件和分组规则 周安排：显示本周的主要项目和任务目标。里程碑周任务的特殊性，需要是项目，目标，里程碑。\n查询条件：需要按照 tag 来区分项目，列出每个项目的前三个任务。要限制在本周完成的任务。 分组规则：按优先级，条目等级分组即可 1 2 3 4 5 6 7 8 9 10 11 12 13 14 (org-ql-search (current-buffer) \u0026#39;(and (parent (and (tags \u0026#34;project\u0026#34;) (not (parent)) )) (children (todo \u0026#34;TODO\u0026#34;)) ;(ancestors ; (and (tags \u0026#34;project\u0026#34;) ; (children))) ) :sort \u0026#39;(todo priority date) :super-groups \u0026#39;((:auto-parent t)) ) 1 1 TODO 如何在模板中动态指定本周期限 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (cons \u0026#34;README weekly\u0026#34; (lambda () (interactive) (let* ((plist) (ts (ts-now)) (beg-of-week (-\u0026gt;\u0026gt; ts (ts-adjust \u0026#39;day (- (ts-dow (ts-now)))) (ts-apply :hour 0 :minute 0 :second 0))) (end-of-week (-\u0026gt;\u0026gt; ts (ts-adjust \u0026#39;day (- 6 (ts-dow (ts-now)))) (ts-apply :hour 23 :minute 59 :second 59))) (plist (list :buffers-files (org-agenda-files) :query `(and (ts-active :from ,beg-of-week :to ,end-of-week) (parent \u0026#39;(and (tags \u0026#34;project\u0026#34;) (not (parent)))) (children (todo \u0026#34;TODO\u0026#34;)) ) :title \u0026#34;周计划\u0026#34; :sort \u0026#39;(todo priority date) :super-groups \u0026#39;((:auto-parent t))))) plist))) 三象限搜索条件和分组规则 猴子法则：灵感和待处理的任务\n收集箱灵感收集的条目，待处理状态。搜索条件，inbox 标签，todo 关键字。 分组规则：按优先级和时间消耗排序。 1 2 3 4 5 6 7 8 9 10 (org-ql-search (current-buffer) \u0026#39;(and (todo \u0026#34;TODO\u0026#34;) (tags \u0026#34;inbox\u0026#34;) (not (children)) ) :sort \u0026#39;(todo priority date) :super-groups \u0026#39;((:name \u0026#34;Inbox\u0026#34; :tag \u0026#34;inbox\u0026#34;)) ) 1 1 四象限搜索条件和分组规则 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 (org-ql-search (org-agenda-files) \u0026#39;(and (not (done)) (not (tags \u0026#34;project\u0026#34;)) (or (deadline auto) ;; (habit) (scheduled :to today) (ts-active :on today) ) ) :sort \u0026#39;(todo priority date) :super-groups \u0026#39;((:name \u0026#34;充电模式\u0026#34; :habit t) (:name \u0026#34;阅读\u0026#34; :tag \u0026#34;reader\u0026#34;) (:name \u0026#34;运动\u0026#34; :tag \u0026#34;sport\u0026#34;) (:name \u0026#34;写作\u0026#34; :tag \u0026#34;writer\u0026#34;)) ) 1 1 专注模式，阅读，运动，写作\n1 1 在 emacs 中显示总览效果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (org-ql-search (org-agenda-files) \u0026#39;(or (todo) (habit) (tags \u0026#34;inbox\u0026#34;)) :sort \u0026#39;(todo priority date) :super-groups \u0026#39;((:name \u0026#34;dairy\u0026#34; :scheduled today :and (:tag \u0026#34;project\u0026#34; :children nil) ) (:name \u0026#34;week\u0026#34; :and (:tag \u0026#34;project\u0026#34; :children t) ) (:name \u0026#34;index\u0026#34; :tag \u0026#34;inbox\u0026#34;) (:name \u0026#34;habit\u0026#34; :habit t :tag \u0026#34;writer\u0026#34;))) 1 1 模拟数据：如何培养好习惯 project TODO 尝试新的思维方式 inbox TODO 阅读七个习惯的书籍 整理书记 TODO 撰写自己的使命宣言 TODO 熟悉撰写步骤 TODO 使用30 分钟完成撰写 TODO 和人交流分享经验 TODO 线上论坛讨论 TODO 线下聚会交流 TODO 周日跑步运动 TODO 下周举行聚餐活动 一周阅读一本小说 TODO 十万个为什么 reader TODO 钢铁是怎么炼成的 writer ","date":"2023-05-31T20:45:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8org-ql%E5%90%8C%E6%AD%A5orgagenda%E5%88%B0readme/","section":"post","tags":null,"title":"动态生成 README.md 四象限数据： org-ql 查询语法和分组规则"},{"categories":["解决方案"],"contents":"需求：在 github 的 README 中显示日常项目状态，显示本周主要的任务，列出项目清单和任务安排。设计：使用 org-ql 查询任务状态，列出项目和代办实现，导出 json 格式。\n基于 org-ql-search 实现获取查询，使用 org-ql-view 模板格式化结果数据 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 (defun build-readme-view (name) \u0026#34;Choose and display the `org-ql-views\u0026#39; view NAME. Interactively, prompt for NAME.\u0026#34; (let* ((result) (view (alist-get name org-ql-views nil nil #\u0026#39;string=)) ) (-let* (((\u0026amp;plist :buffers-files :query :sort :narrow :super-groups :title) view) (super-groups (cl-typecase super-groups (symbol (symbol-value super-groups)) (list super-groups)))) (message \u0026#34;step 1:+++++++ %s\u0026#34; query) (build-readme-search buffers-files query :super-groups super-groups :narrow narrow :sort sort :title title :buffer org-ql-view-buffer) )) ) (cl-defun build-readme-search (buffers-files query \u0026amp;key narrow super-groups sort title (buffer org-ql-view-buffer)) (declare (indent defun)) (interactive (list (org-ql-view--complete-buffers-files) (read-string \u0026#34;Query: \u0026#34; (when org-ql-view-query (format \u0026#34;%S\u0026#34; org-ql-view-query))) :narrow (or org-ql-view-narrow (eq current-prefix-arg \u0026#39;(4))) :super-groups (org-ql-view--complete-super-groups) :sort (org-ql-view--complete-sort))) ;; NOTE: Using `with-temp-buffer\u0026#39; is a hack to work around the fact that `make-local-variable\u0026#39; ;; does not work reliably from inside a `let\u0026#39; form when the target buffer is current on entry ;; to or exit from the `let\u0026#39;, even though `make-local-variable\u0026#39; is actually done in ;; `org-ql-view--display\u0026#39;. So we do all this within a temp buffer, which works around it. (with-temp-buffer (let* ((query (cl-etypecase query (string (if (or (string-prefix-p \u0026#34;(\u0026#34; query) (string-prefix-p \u0026#34;\\\u0026#34;\u0026#34; query)) ;; Read sexp query. (read query) ;; Parse non-sexp query into sexp query. (org-ql--query-string-to-sexp query))) (list query))) (results (org-ql-select buffers-files query :action \u0026#39;element-with-markers :narrow narrow :sort sort)) (strings (-map #\u0026#39;org-ql-view--format-element results)) (buffer (or buffer (format \u0026#34;%s %s*\u0026#34; org-ql-view-buffer-name-prefix (or title query)))) (header (org-ql-view--header-line-format :buffers-files buffers-files :query query :title title)) ;; Bind variables for `org-ql-view--display\u0026#39; to set. (org-ql-view-buffers-files buffers-files) (org-ql-view-query query) (org-ql-view-sort sort) (org-ql-view-narrow narrow) (org-ql-view-super-groups super-groups) (org-ql-view-title title)) (when super-groups (let ((org-super-agenda-groups (cl-etypecase super-groups (symbol (symbol-value super-groups)) (list super-groups)))) (setf strings (org-super-agenda--group-items strings)))) ;;TODO no show view ;; insert buffer to coverto build readme (message \u0026#34;build readme file:\\n %s \u0026#34; (s-join \u0026#34;\\n\u0026#34; strings)) ;; (org-ql-view--display :buffer buffer :header header :string (s-join \u0026#34;\\n\u0026#34; strings)) ))) (build-readme-view \u0026#34;readme\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 build readme file: 原则 TODO 诚信原则 TODO 成长原则 TODO 自我管理原则 基于 org-super-agenda 定义 agenda 模板 TODO 快速导出 agenda 清单模板 9d ago :@学习笔记: TODO 每日安排 :@学习笔记: TODO 每周安排 :@学习笔记: 基于 org-ql-select 获取查询结果，自定义 list-to-org 格式化结果内容 借助 org-ql-search 和 org-ql-view 能够实现\n自定义保存 org-ql-views 模板 保存不同查询的模板，保存之后，可以通过 org-ql-view 命令，快速查看模板列表。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 (defun org-build-readme-save () \u0026#34;create new view\u0026#34; (interactive) (let* ((name (read-string \u0026#34;Save view as: \u0026#34; org-ql-view-title)) ;; Bind `org-ql-view-title\u0026#39; to the name that was read, in case ;; it\u0026#39;s different, which `org-ql-view--plist\u0026#39; will pick up. (org-ql-view-title name) (plist (list :buffers-files (org-agenda-files) :query \u0026#39;(todo \u0026#34;TODO\u0026#34;) :sort \u0026#39;(date priority) :title \u0026#34;This week\u0026#34; :super-groups \u0026#39;((:auto-parent t)) ))) (when (or (not (map-elt org-ql-views name nil)) (yes-or-no-p (format \u0026#34;Overwrite view \\\u0026#34;%s\\\u0026#34;?\u0026#34; name))) (setf (map-elt org-ql-views name nil #\u0026#39;equal) plist) (customize-set-variable \u0026#39;org-ql-views org-ql-views) (customize-mark-to-save \u0026#39;org-ql-views)))) (org-build-readme-save) 实现 org-ql-select 支持 org-ql-views 模板中的 query 查询 org-readme-search 参考 org-ql-view 和 org-ql-search 简化搜索逻辑，实现基于 org-ql-select 方法实现自定义查询的效果。通过传入 org-ql-views 模板的名称，利用模板的 query 属性的查询条件。结果还是 list 格式。想要输出格式的内容，需要自定义方法 list-to-org 打印。 list-to-org 将 org-ql-select 查询到的 elisp list 列表格式，转为 org 格式。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 (defun list-to-org (list) \u0026#34;Convert LIST to org-mode string.\u0026#34; (mapconcat (lambda (elem) (cond ((stringp elem) elem) ((keywordp elem) (concat \u0026#34;:\u0026#34; (symbol-name elem))) ((listp elem) (list-to-org elem)) (t (format \u0026#34;%S\u0026#34; elem)))) list \u0026#34;\\n\u0026#34;)) (defun org-readme-search (name) \u0026#34;Choose and display the `org-ql-views\u0026#39; view NAME. Interactively, prompt for NAME.\u0026#34; (let* ((result) (view (alist-get name org-ql-views nil nil #\u0026#39;string=)) ) (-let* (((\u0026amp;plist :buffers-files :query :sort :narrow :super-groups :title) view) (super-groups (cl-typecase super-groups (symbol (symbol-value super-groups)) (list super-groups)))) (message \u0026#34;step 1:+++++++ %s\u0026#34; query) (let* ((query (cl-etypecase query (string (if (or (string-prefix-p \u0026#34;(\u0026#34; query) (string-prefix-p \u0026#34;\\\u0026#34;\u0026#34; query)) ;; Read sexp query. (read query) ;; Parse non-sexp query into sexp query. (org-ql--query-string-to-sexp query))) (list query))) ) (message \u0026#34;step 2:_++++++_ %s\u0026#34; query) (setq result (org-ql-select buffers-files query :action \u0026#39;(list ;; (org-get-heading) (buffer-substring-no-properties (point-at-bol) (point-at-eol)) ) :narrow narrow :sort sort)) )) (message \u0026#34;reuslts : %s\u0026#34; (list-to-org result)) )) (org-readme-search \u0026#34;readme\u0026#34;) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 reuslts : **** TODO 诚信原则 **** TODO 成长原则 **** TODO 自我管理原则 *** TODO [#A] 二象限模式[0/3] :habit: *** TODO 健身模式 :habit: *** TODO [#B] 工作模式 :habit: *** TODO [#B] 阅读模式 :habit: *** TODO [#B] 饭桌礼仪 :habit: *** TODO [#B] 社交模式 :habit: * TODO 思考最重要的事情撰写使命宣言 :blue: * TODO [#B] 拓宽思路的过程 :anki: ** TODO 开发 auto-gpt emacs 插件 ** TODO 捷径通过 emacsclient 命令，或 ifff 集成 Auto-GPT **** TODO 待完善的模板 *** TODO ob-babel 导入第三库遇到的问题 **** TODO Macro: =org-ql-defpred= **** TODO 每日安排 **** TODO 每周安排 **** TODO 快速导出 agenda 清单模板 **** TODO cowuoshi **** TODO 开始计划 **** TODO 明天到家 替换 REAME.md 模块数据 在 README.md 中有固定模式，使用 elisp 处理围绕文本的内容替换为自己的内容。\n1 2 3 \u0026lt;!-- dairy starts --\u0026gt; \u0026lt;!-- dairy ends --\u0026gt; python 使用正则实现的替换方式 replace_chunk:\n1 2 3 4 5 6 7 8 9 def replace_chunk(content, marker, chunk, inline=False): r = re.compile( r\u0026#34;\u0026lt;!\\-\\- {} starts \\-\\-\u0026gt;.*\u0026lt;!\\-\\- {} ends \\-\\-\u0026gt;\u0026#34;.format(marker, marker), re.DOTALL, ) if not inline: chunk = \u0026#34;\\n{}\\n\u0026#34;.format(chunk) chunk = \u0026#34;\u0026lt;!-- {} starts --\u0026gt;{}\u0026lt;!-- {} ends --\u0026gt;\u0026#34;.format(marker, chunk, marker) return r.sub(chunk, content) 将上述方法翻译成 elisp 语法实现 使用 temp-buffer 实现文本替换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 (defun build-readme-replace-chunk (content marker chunk \u0026amp;optional inline) \u0026#34;Replace the chunk between \u0026lt;--- MARKER starts --\u0026gt; and \u0026lt;!--- MARKER ends --\u0026gt; in CONTENT with CHUNK. If INLINE is non-nil, do not add newlines around CHUNK.\u0026#34; (let* ((start (concat \u0026#34;\u0026lt;!-- \u0026#34; marker \u0026#34; starts --\u0026gt;\u0026#34;)) (end (concat \u0026#34;\u0026lt;!-- \u0026#34; marker \u0026#34; ends --\u0026gt;\u0026#34;)) (pattern (concat start \u0026#34;[^^]*?\u0026#34; end))) (with-temp-buffer (insert content) (goto-char (point-min)) (if (re-search-forward pattern nil t) (progn (setq chunk (format \u0026#34;%s\\n%s\\n%s\u0026#34; start chunk end)) (replace-match chunk t t) (buffer-string)) content)) )) (setq readme-content \u0026#34; Hello \u0026lt;!-- chunk starts --\u0026gt; world \u0026lt;!-- chunk ends --\u0026gt; !\u0026#34;) (build-readme-replace-chunk readme-content \u0026#34;chunk\u0026#34; \u0026#34;there\u0026#34;) 1 2 3 4 5 6 Hello \u0026lt;!-- chunk starts --\u0026gt; there \u0026lt;!-- chunk ends --\u0026gt; ! 它的工作原理如下:\n它定义了 start 和 end 字符串,即起始和结束标记。 它定义了一个正则表达式模式,能匹配从起始标记到结束标记的内容。 它创建一个临时缓冲区并插入 content 内容。 它向前搜索第一个模式匹配。 如果找到匹配,它用 chunk 替换匹配内容,并可选地添加换行符。 然后它返回临时缓冲区的内容,替换了匹配内容。 否则它只返回原始的 content 不变。 使用 repace-regexp-in-string 方法替换 这是将 Python 方法 replace_chunk 翻译成 Emacs Lisp 语法的示例：\n1 2 3 4 5 6 7 8 9 (defun replace-chunk-regex (content marker chunk \u0026amp;optional inline) \u0026#34;Replace content between markers denoted by MARKER with CHUNK. If INLINE is non-nil, do not add extra newline characters around CHUNK.\u0026#34; (let ((regex (concat \u0026#34;\u0026lt;!-- \u0026#34; marker \u0026#34; starts --\u0026gt;[^^]*\u0026lt;!-- \u0026#34; marker \u0026#34; ends --\u0026gt;\u0026#34;))) (setq chunk (if inline chunk (concat \u0026#34;\\n\u0026#34; chunk \u0026#34;\\n\u0026#34;))) (setq chunk (concat \u0026#34;\u0026lt;!-- \u0026#34; marker \u0026#34; starts --\u0026gt;\u0026#34; chunk \u0026#34;\u0026lt;!-- \u0026#34; marker \u0026#34; ends --\u0026gt;\u0026#34;)) (replace-regexp-in-string regex chunk content t t))) (replace-chunk-regex readme-content \u0026#34;chunk\u0026#34; \u0026#34;there\u0026#34;) 1 2 3 4 5 6 Hello \u0026lt;!-- chunk starts --\u0026gt; there \u0026lt;!-- chunk ends --\u0026gt; ! 这个函数首先定义了一个正则表达式来匹配和找到要替换的文本。然后，根据 inline 参数，添加或去掉块的前后额外换行符。最后，使用 Emacs Lisp 内置函数 =replace-regexp-in-string=，将找到的文本块替换为新的文本块。\n替换文本之后保存到 README.md 文件中 使用 elisp 脚本替换 README.md 文件中{{内容}} 格式的内容为变量A的值，然后保存文件。\n定义一个入参 readmeFile 在 temp-buffer 中操作该文件。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 (defun build-readme-replace (readmeFile marker chunk \u0026amp;optional inline) \u0026#34;Replace the chunk between \u0026lt;--- MARKER starts --\u0026gt; and \u0026lt;!--- MARKER ends --\u0026gt; in CONTENT with CHUNK. If INLINE is non-nil, do not add newlines around CHUNK.\u0026#34; (let* ((start (concat \u0026#34;\u0026lt;!-- \u0026#34; marker \u0026#34; starts --\u0026gt;\u0026#34;)) (end (concat \u0026#34;\u0026lt;!-- \u0026#34; marker \u0026#34; ends --\u0026gt;\u0026#34;)) (pattern (concat start \u0026#34;[^^]*?\u0026#34; end))) (with-temp-file readmeFile (insert-file-contents readmeFile) ;;(insert-buffer-substring (current-buffer)) (goto-char (point-min)) (if (re-search-forward pattern nil t) (progn (setq chunk (format \u0026#34;%s\\n%s\\n%s\u0026#34; start chunk end)) (replace-match chunk t t) (write-file readmeFile)) )) )) (build-readme-replace \u0026#34;~/hsg/iNotes/README.md\u0026#34; \u0026#34;dairy\u0026#34; \u0026#34; test text\u0026#34;) 1 t 这个函数的工作方式如下:\n它提示用户输入要保存的文件名,并将其存储在 readmeFile 变量中 它获取当前缓冲区,并将其存储在 buffer 变量中 它使用 with-temp-buffer 宏创建一个新的临时缓冲区 它使用 insert-file-contents 将 readmeFile 的内容插入临时缓冲区 它使用 write-file 将临时缓冲区内容写入 readmeFile 文件 这里希望直接保存内容到文件中，不需要提示，在使用 save-buffer 方式保存时，会显示一条确认消息,确认已将缓冲区保存到指定的文件名\n","date":"2023-05-31T01:07:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/orq-ql-search%E4%B8%BAREAMME%E5%8A%A8%E6%80%81%E6%8F%90%E4%BE%9B%E6%95%B0%E6%8D%AE/","section":"post","tags":["reader"],"title":"借助 org-ql 工具自动导出 agenda 待办任务"},{"categories":["学习笔记"],"contents":"使用 create Template 命令创建模板 使用此命令,您可以从活动文档创建模板。 默认热键 : Alt + C 。\n默认情况下,模板将在 local 文件夹中创建 Templates Folder (模板)(您可以随时更改路径)。 模板必须在 Templates Folder 中。 从零开始创建模板 在 Templates Folder 中创建文件。 添加模板文件元数据。 模板元数据 1 2 3 4 5 6 7 8 9 10 11 12 --- PromptInfo: promptId: getParagraph name: ✍️ Write paragraphs description: select a content contiens items, a paragraph for each item will be generated. required_values: title, outline author: Noureddine tags: writing version: 0.0.1 commands: - generate --- PromptInfo 包含有关提示的信息,必须在每个模板的头部。它包含以下字段:\npromptId:标识提示的唯一字符串。它用于UI中每个提示的ID。 name:识别提示的名称。它应该简短和精确。 description:解释此提示的作用和使用方法的描述,您可以在此处放任何内容,但简单和简洁更好。 author:要归功于编写此提示的作者姓名或用户名。 required_values:模板所需的值。 tags:描述此提示的一些标签。此信息用于过滤提示。 version:此提示的版本,遵循语义版本控制。 commands:用于将模板转换为命令,以便为每个命令分配热键(您需要重新加载插件以查看更改) generate:编译模板并通过 gpt-3 生成内容,将结果插入 活动笔记 中。 generate\u0026amp;create:编译模板并通过 gpt-3 生成内容,将结果插入 新建笔记 中。 insert:编译模板并将结果插入活动笔记中,而无需 gpt-3 将结果插入 活动笔记 中。 insert\u0026amp;create:编译模板并将结果插入活动笔记中,而无需 gpt-3 将结果插入 新建笔记 中。 model:将模板显示为输入形式,并将结果插入 活动笔记 中。 clipboard:编译模板并通过 gpt-3 生成内容,将结果写入剪贴板。 构建模板 使用模板可用上下文准备模板。有关模板引擎的更多信息,请参见handlebarsjs。 模板可以通过模板命令访问。 可用于模板的上下文 可用于模板的上下文 模板引擎 有关模板引擎的更多信息,请参见handlebarsjs 模板引擎 包含的信息在插件设置中是可选的。请参阅考虑的上下文。\ntitle: 是文档的标题 。 selection: 是根据考虑的上下文中解释的方法选择的文本。 selection:选择(新的v0.2.17),它是一个数组,包含所有选择。您可以通过 selections 访问它。 context:上下文 包括YAML变量,Title,StaredHeadings,Selection frontmatter:frontmatter 变量可以直接使用或在 frontmatter 变量(对象)中使用。 headings: 它是一个对象,包含所有headings及其内容。 children: 它是一个数组,包含引用的笔记。您可以通过=children=访问它。 mentions: mention 是一个对象,包含两个数组:/linked/和/unlinked/。每个数组包含文档提到的段落。 highlights:突出显示,它是一个数组,包含 obsidian 突出显示。您可以通过 highlights 访问它。 extractions:提取(v0.3.1) extractions 是一个对象,包含三个数组: PDFExtractor 是一个数组,包含笔记中嵌入的PDF文档的文本格式。 WebPageExtractor 是一个数组,包含笔记中的所有外部链接的内容。 YoutubeExtractor 是一个数组,包含所有 YouTube 视频转录的内容。 AudioExtractor 是一个数组,包含通过 Whisper OpenAI 处理的所有音频笔记的转录(文件大小限制:25MB)。 Considered Context 考虑的上下文 Transformer 需要 context 来生成准确的文本。所以我们将与 prompt 一起发送的所有数据,我们称之为 Considered Context 。\n使用基本命令 请参阅 https://text-gen.com/commands.html 中的基本命令。\n使用 selection 它可以是:\n所选文本。 如果光标所在的行/不为空/时,为当前行的文本。 如果/行为空/,为文档的全部内容。 添加文档标题 您可以通过启用插件设置来为 Considered Context 添加 title 。\n添加星号块 如果您想在长篇文章中包含特定部分,可以通过在标题结尾添加星号 * 来添加标题内容。\n您需要在设置中启用该选项。 例如 1 2 3 4 # Title* This is a title # Introduction write introduction 添加元数据变量 您可以在元数据或 frontmatter 变量中添加任何您想要的信息(这将在 生成文本(带元数据) 中考虑。您必须避免插件使用的 YAML关键词 。例如:\n1 2 3 4 5 --- title: Considered Context tags: doc layout: note --- 使用模板命令 从版本0.1.0开始,/文本生成器插件/支持模板。确保模板上提供的信息可供您在插件设置中使用\n","date":"2023-05-28T23:57:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/obsidianAI%E6%8F%92%E4%BB%B6/","section":"post","tags":["Obsidian","翻译"],"title":"制作 Text Generator Plugin 的模板"},{"categories":["解决方案"],"contents":"再使用 org-ql select 查询语句时，经常遇到通过变量来确定查询条件的情况，当直接将使用 format 等方法，将变量格式化为语句时，真正的查询条件并不执行， org-ql 会先通过 org-ql--normalize-query 方法处理：\n下面通过两种方式，验证在org-ql解析查询语句，最终得到的搜索语句\n转义字面量查询条件\n1 2 3 4 5 (setq query (org-ql--normalize-query \u0026#39;(and (heading \u0026#34;system\u0026#34;) (ancestors (heading \u0026#34;你好\u0026#34;)) ))) (message \u0026#34;语句：%s \u0026#34; query) 1 语句：(and (ancestors #[nil \\300\\301!\\207 [heading 你好] 2]) (heading system)) 转义变量查询条件\n1 2 3 4 5 6 (setq test \u0026#34;你好\u0026#34;) (setq query (org-ql--normalize-query \u0026#39;(and (heading \u0026#34;system\u0026#34;) (ancestors (heading test)) ))) (message \u0026#34;语句：%s \u0026#34; query) 1 语句：(and (ancestors #[nil \\301\b!\\207 [test heading] 2]) (heading system)) 通过上面两种语法的打印结果，第一种字面值的方式可以正确转换，第二种使用变量的方式时，该方法会将 test 的变量名，作为查询条件。\n第二种变量方式,做如下修改,实现正确解析变量值:\n1 2 3 4 5 6 (setq test \u0026#34;你好\u0026#34;) (setq query (org-ql--normalize-query `(and (heading \u0026#34;system\u0026#34;) (ancestors (heading, test)) ))) (message \u0026#34;语句：%s \u0026#34; query) 1 语句：(and (ancestors #[nil \\300\\301!\\207 [heading 你好] 2]) (heading system)) 修改之后，打印结果和字面值一样，这表明已正常解析了变量，在查询后，能够得到想到内容。\n两种语法的主要差异在于:\n语句1使用 ` 进行 quasiquote, 所以 (heading, test) 会作为一个 \u0026ldquo;heading 你好\u0026rdquo; 字面量进行查询。 语句2使用 ' 进行 quote, 所以 (heading test) 会作为一个字面量查询进行查询,等同于 (test heading)。 记录在单元测试用的案例 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ;; 使用互转方法 将普通语句转为字符串 (let ((query (org-ql--query-string-to-sexp (format \u0026#34;heading:%s\u0026#34; gts-claude-session))) (test) (buffers-files \u0026#34;prompt/prompt.org\u0026#34;)) ;; 使用 select 语句验证，查询语句内部使用字面值和变量的问题 (setq tess(org-ql-select buffers-files \u0026#39;(and (heading \u0026#34;system\u0026#34;)(ancestors (heading \u0026#34;担任产品经理\u0026#34;))) :action `(org-get-entry))) (message \u0026#34;测试222: %s\u0026#34; (car tess)) ;; 使用 query 语句验证 (setq test (org-ql-query :select \u0026#39;(org-get-entry) :from buffers-files :where `(and (ancestors (heading, gts-claude-session)) (heading \u0026#34;system\u0026#34;) ) )) (message \u0026#34;%s \\n %s\u0026#34;gts-claude-session (car test)) ) 1 2 担任产品经理 请确认我的以下请求。请您作为产品经理回复我。我将会提供一个主题，您将帮助我编写一份包括以下章节标题的PRD文档：主题、简介、问题陈述、目标与目的、用户故事、技术要求、收益、KPI指标、开发风险以及结论。在我要求具体主题、功能或开发的PRD之前，请不要先写任何一份PRD文档。 org-ql 转换问题：不支持 children parent ancestors 相关属性的嵌套 1 2 3 4 5 6 7 8 9 10 11 12 (let ((result)) (setq result (org-ql--query-sexp-to-string \u0026#39;(heading \u0026#34;quoted phrase\u0026#34; \u0026#34;word\u0026#34;))) (message \u0026#34;打印:%s\u0026#34; result) ;;(and ;(heading gts-claude-session) ;; (children (heading \u0026#34;system\u0026#34;)) ;) (setq result2 (org-ql--query-sexp-to-string \u0026#39;(ancestors (heading \u0026#34;universe\u0026#34;)))) (message \u0026#34;打印--:%s\u0026#34; result2) ) 1 打印--:nil ","date":"2023-05-28T23:42:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/org-ql-query%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5%E5%8F%98%E9%87%8F%E9%97%AE%E9%A2%98/","section":"post","tags":null,"title":"org-ql 查询语句如何解析变量值"},{"categories":["学习笔记"],"contents":"org-ql 查询是一个 lisp 表达式，它可以包含任意表达式，也可以调用某些内置谓词 predicates 。 org-ql 被编译成一个谓词函数，该函数在 org 缓冲区中的每个标题上进行点测试;当 non-nil 时，返回匹配到的标题。在可能的情况下，某些内置谓词被优化为全缓冲区正则表达式搜索，这比在每个标题上测试谓词要快得多。\nNotes:\n像 \u0026quot;string\u0026quot; 这样的空字符串会自动转换为 (regexp \u0026quot;string\u0026quot;) 谓词。 标准数值比较函数符号(\u0026lt;~、~\u0026lt;=~、~\u0026gt;~、~\u0026gt;=~、~=)作为参数传递给接受它们的谓词时不需要加引号。与中缀表示法的相似是巧合。 Non-sexp query syntax org-ql-search 命令也接受另一种 non-sexp 查询语法，而 helm-org-ql 命令只接受这种语法。语法很简单，两种语法中的几个查询示例就足够了。默认情况下，当使用多个谓词时，它们与布尔值 and 组合在一起。\nSexp syntax Non-sexp syntax (todo) todo: (todo \u0026quot;SOMEDAY\u0026quot;) todo:SOMEDAY (todo \u0026quot;SOMEDAY\u0026quot; \u0026quot;WAITING\u0026quot;) todo:SOMEDAY,WAITING (ts :on today) ts:on=today (ts-active :from \u0026quot;2017-01-01\u0026quot; :to \u0026quot;2018-01-01\u0026quot;) ts-active:from=2017-01-01,to=2018-01-01 (clocked :on -1) clocked:on=-1 (heading \u0026quot;quoted phrase\u0026quot; \u0026quot;word\u0026quot;) heading:\u0026quot;quoted phrase\u0026quot;,word (and (tags \u0026quot;book\u0026quot; \u0026quot;books\u0026quot;) (priority \u0026quot;A\u0026quot;)) tags:book,books priority:A (src :lang \u0026quot;elisp\u0026quot; :regexps (\u0026quot;defun\u0026quot;)) src:defun,lang=elisp or src:lang=elisp,defun (and (tags \u0026quot;space\u0026quot;) (not (regexp \u0026quot;moon\u0026quot;))) tags:space !moon (priority \u0026gt;= B) priority:A,B 请注意: effort 、 level 和 priority 谓词在 non-sexp 语法中不支持比较器，因此应该传递多个参数，如最后一个示例所示。\nGeneral predicates 在适用的情况下， 参数列 在 谓词名称 旁边。\nblocked 如果当前标题被阻塞，返回 non-nil。调用 org-entry-blocked-p ，见。 category (\u0026amp;optional categories) 如果当前标题在一个或多个 CATEGORIES 字符串列表中，则返回 non-nil。 done 如果条目的 TODO 关键字在 org-done-keywords 中，则返回 non-nil。 effort (\u0026amp;optional effort-or-comparator effort) 如果当前标题的 effort 属性与参数匹配，则返回非nil。可以接受以下形式: (effort DURATION) :如果effort为 DURATION ，则匹配。 (effort DURATION DURATION):如果 effort 在是在DURATIONs之间，那就匹配，包括。 (effort COMPARATOR DURATION):如果将 DURATION 与 COMPARATOR 进行比较，则匹配。COMPARATOR may be \u0026lt;, \u0026lt;=, \u0026gt;, or \u0026gt;=. DURATION 是一个 org effort 字符串, like 5 or 0:05. habit 如果条目是 habit，则返 non-nil。 heading (\u0026amp;rest strings) 如果当前条目的标题全部匹配 STRINGS ，返回 non-nil。匹配不区分大小写。 别名: h. heading-regexp (\u0026amp;rest regexps) 如果当前条目的标题匹配所有 REGEXPS (正则表达式字符串)，则返回 non-nil。匹配不区分大小写。 别名: h*. level (level-or-comparator \u0026amp;optional level) 如果当前标题的大纲级别与参数匹配，则返回 non-nil 。可以接受以下形式: (level NUMBER) :如果标题级别为 NUMBER 则匹配。 (level NUMBER NUMBER):如果标题级别等于或在 NUMBER 之间，则匹配。 (level COMPARATOR NUMBER):如果标题级别与 NUMBER 和 COMPARATOR 比较，则匹配。 COMPARATOR 可以为 \u0026lt;, \u0026lt;=, \u0026gt;, or \u0026gt;= 。 link (\u0026amp;optional description-or-target \u0026amp;key description target regexp-p) Return non-nil if current heading contains a link matching arguments. DESCRIPTION-OR-TARGET is matched against the link\u0026rsquo;s description and target. Alternatively, one or both of DESCRIPTION and TARGET may be matched separately. Without arguments, return non-nil if any link is found. outline-path (\u0026amp;rest strings) 如果当前节点的大纲路径匹配所有的 STRINGS ，则返回 non-nil。每个字符串都可以作为子字符串出现在节点大纲路径的任何部分。例如: Food/Fruits/Grapes 将匹配 (olp \u0026quot;Fruit\u0026quot; \u0026quot;Grape\u0026quot;) 。 别名: olp. outline-path-segment (\u0026amp;rest strings) Return non-nil if current node\u0026rsquo;s outline path matches STRINGS. Matches STRINGS as a contiguous segment of the outline path. Each string is compared as a substring. For example the path Food/Fruits/Grapes would match (olps \u0026quot;Fruit\u0026quot; \u0026quot;Grape\u0026quot;) but not (olps \u0026quot;Food\u0026quot; \u0026quot;Grape\u0026quot;). Aliases: olps. path (\u0026amp;rest regexps) Return non-nil if current heading\u0026rsquo;s buffer\u0026rsquo;s filename path matches any of REGEXPS (regexp strings). Without arguments, return non-nil if buffer is file-backed. priority (\u0026amp;rest args) Return non-nil if current heading has a certain priority. ARGS may be either a list of one or more priority letters as strings, or a comparator function symbol followed by a priority letter string. For example: (priority \u0026quot;A\u0026quot;) (priority \u0026quot;A\u0026quot; \u0026quot;B\u0026quot;) (priority '\u0026gt;= \u0026quot;B\u0026quot;) Note that items without a priority cookie never match this predicate (while Org itself considers items without a cookie to have the default priority, which, by default, is equal to priority B). property (property \u0026amp;optional value \u0026amp;key inherit) Return non-nil if current entry has PROPERTY (a string), and optionally VALUE (a string). If INHERIT is nil, only match entries with PROPERTY set on the entry; if t, also match entries with inheritance. If INHERIT is not specified, use the Boolean value of org-use-property-inheritance, which see (i.e. it is only interpreted as nil or non-nil). regexp (\u0026amp;rest regexps) Return non-nil if current entry matches all of REGEXPS (regexp strings). Matches against entire entry, from beginning of its heading to the next heading. Aliases: r. rifle (\u0026amp;rest strings) Return non-nil if each string is found in either the entry or its outline path. Works like org-rifle. This is probably the most useful, intuitive, general-purpose predicate. Aliases: smart. Note: By default, this is the default predicate used for plain-string query tokens (i.e. given without a specified predicate). This can be customized with the option org-ql-default-predicate. src (\u0026amp;key lang regexps) Return non-nil if current entry contains an Org Babel source block. If LANG is non-nil, match blocks of that language. If REGEXPS is non-nil, require that block\u0026rsquo;s contents match all regexps. Matching is done case-insensitively. tags (\u0026amp;optional tags) 如果当前标题包含一个或多个 TAGS (字符串列表)，则返回非 nil 。测试继承标记和本地标记。 tags-inherited (\u0026amp;optional tags) 如果当前标题的继承标签包含一个或多个 TAGS (字符串列表)，则返回非 nil。如果 TAGS 为 nil，如果 heading 有任何继承的标签，则返回非 nil。 别名: inherited-tags, tags-i, itags. tags-local (\u0026amp;optional tags) 如果当前标题的 local 标签包含一个或多个 TAGS (字符串列表)，则返回非 nil。如果 TAGS 为 nil，如果标题有任何 local 局部标记，则返回非 nil。 别名: local-tags, tags-l, ltags. tags-all (tags) Return non-nil if current heading includes all of TAGS. Tests both inherited and local tags. Aliases: tags\u0026amp;. tags-regexp (\u0026amp;rest regexps) 如果当前标题包含匹配一个或多个正则 REGEXPS 标签，则返回非 nil。测试继承标记和本地标记。 别名: tags*. todo (\u0026amp;optional keywords) 如果当前标题是一个 TODO 项，则返回非 nil。对于 KEYWORDS ，如果关键字是 KEYWORDS (字符串列表)之一，则返回非 nil。当不带参数调用时，只匹配未完成的任务(即不匹配 org-done-keywords 中的关键字)。 Ancestor/descendant predicates ancestors (\u0026amp;optional query) 如果当前标题有父标题，则返回 non-nil。如果 QUERY ，如果父标题匹配，则返回 non-nil。此选择器支持嵌套。 children (\u0026amp;optional query) 如果当前标题有直接子标题，则返回 non-nil。如果 QUERY ，如果子标题匹配，则返回 non-nil。这个选择器可以是嵌套的，例如匹配孙子标题。 descendants (\u0026amp;optional query) 如果当前标题有后代标题，则返回 non-nil。 If QUERY, 如果子标题匹配，则返回 non-nil。 这个选择器支持嵌套(如果你能找到嵌套!) parent (\u0026amp;optional query) 如果当前标题有直接父标题，则返回 non-nil。如果 QUERY ，如果父标题匹配，则返回 non-nil。这个选择器可以是嵌套的，比如匹配父标题。 Date/time predicates 这些谓词接受可选的关键字参数:\n:from: 在时间戳 :from 上或之后匹配的条目 :to: 在时间戳 :to 上或之前匹配的条目. :on: 在此日期时间戳 :on 匹配的条目 :with-time: 如果未指定，匹配带或不带时间的时间戳(例如 hh:mm )。如果为 nil，匹配不带时间的时间戳。如果是，将时间戳与时间匹配。 时间戳/日期参数应该是天数(向前看是正数，向后看是负数)，可以通过 parse-time-string 解析的字符串(字符串可以省略时间值)，符号 today 或 ts 结构体。\nPredicates ts: 如果当前条目具有给定时间段内的时间戳，则返回 non-nil。不带参数,如果条目有时间戳，则返回非空值。\nts-active, ts-a: Like ts, 但只匹配活动时间戳。\nts-inactive, ts-i: Like ts,但只匹配非活动时间戳。\n除了关键字参数之外，下面的谓词也可以接受单个参数，即一个数字，它向后或向前看几天。这个数可以是负数来反转方向。\n这两个谓词解释单个数字参数，就好像它被传递给了 :from 关键字参数，这简化了搜索过去几天内计时或关闭的项目的常见情况:\nBackward-looking clocked: Return non-nil if current entry was clocked in given period. Without arguments, return non-nil if entry was ever clocked. Note: Clock entries are expected to be clocked out. Currently clocked entries (i.e. with unclosed timestamp ranges) are ignored. closed: Return non-nil if current entry was closed in given period. Without arguments, return non-nil if entry is closed. These predicates interpret a single number argument as if it were passed to the :to keyword argument, which eases the common case of searching for items planned in the next few days:\nForward-looking deadline: Return non-nil if current entry has deadline in given period. If argument is auto, return non-nil if entry has deadline within org-deadline-warning-days. Without arguments, return non-nil if entry has any deadline. planning: Return non-nil if current entry has planning timestamp (i.e. its deadline, scheduled, or closed timestamp) in given period. Without arguments, return non-nil if entry has any planning timestamp. scheduled: Return non-nil if current entry is scheduled in given period. Without arguments, return non-nil if entry is scheduled. ","date":"2023-05-28T18:43:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E4%BB%8B%E7%BB%8Dorg-ql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E6%B3%95/","section":"post","tags":null,"title":"介绍 org-ql Queries 语法"},{"categories":["学习笔记"],"contents":"借助 org-super-agenda 加深理解 org-agenda 的功能和用法，通过分组模板养成 review 任务习惯,激发执行力!\n学习 org-super-agenda 加强管理，修炼二项限时间管理的工具\n可以结合 org-ql 增强语法的可读性，结合 org-super-agenda 增加定义选择器的效果.\n要把习惯三要事第一融入到 aganda 中。有几个特点要呈现出来:优先级 ：时间矩阵\n使用 snippet 的方式执行 agenda 的导出操作，能够快速插入到当前 buffer ，实现在 capture 模板执行脚本的问题。\n解决 capture 中获取 tag 的问题在 capture 模板中使用 ％^g 启动 tag 选择功能，然后在 gptel 就可以拿到 aitag,实通过 tag 动态设置 prompt 的功能。\n理解 org-super-agenda 概念 org-super-agenda 是基于 org-ql 针对 agenda 分组功能的增强工具，兼容内置的 org-agenda ，很大简化了配置 org agenda 的语法。主要用于 agenda 视图展示。\n在定义模板之前，先区分 org-ql ， org-super-agenda 和 org-agenda 的概念，至关重要。\n在学习 org-ql 插件之后，对 org-mode 有和更深的理解，它是强大的 org 解析工具，通过 org-ql 可以像查询数据库一样查询 org 文件，能够根据 todo 状态，优先级，标签等，快速获取条目内容，例如：条目的 heading ，entry。\norg-ql 有丰富的工具，都支持 query 语法\norg-ql-query/org-ql-select 可以通过 query 语法，获取 org 元数据列表，在需要获取 org 信息作为参数，为其他方法提供数据。\n例如： 为 capture 模板自动设置 role 角色。在 claude 翻译工具中，设定角色。在 snippet 中添加快捷键，快速获取 org 元数据，为自定义工具提供数据源的支持。\norg-ql-views 是 org-ql 内置 org-agenda 的分组视图，提供了今日，本周，下周，阻塞任务等视图入口。\norg-ql-block 可以配合 org-agenda 自定义命令，添加视图分组，简化 agenda 配置语法。\nhelm-org-ql 基于 org-ql 的 helm 查询视图，支持 org-ql 语法搜索。\n主要的学习方式，翻译文档，从文档中找灵感思路。后续可以在实践中，不断优化选择器的语法，现在不要纠结太多的用法，够用够入门就行。\n基于 org-super-agenda 定义 agenda 模板 想要通过 org-super-agenda 优化的工作流\n7 天周期的方式，主要任务和目标。排序优先级，分类，标签等功能的使用。 怎么结合 tj3 项目理念整合，出以 tj3 为模块的分组 怎么结合阅读状态，看到现在的阅读量和安排的分组 怎么看到习惯的进行状态，是否已经脱离的正常生活 怎么把训练 prompt 作为项目，进行管理，呈现在 agenda 中，现在进行到什么进度等状态跟踪。 怎么把七个习惯的状态找回来，能够执行自我意识的思考，呈现出自我领导的意识，第一次创造的快感。 使用 auto-gpt 的在制定角色的时候，有使命，有目标，有原则，有计划的。第一次创造，第二次创造的流程的演示等。 要做的事情：\n新建 +super-agenda.el 专属的配置文件 演示 readme 初步配置，在 agenda 中看到效果 结合七个习惯，梳理自己的愿景，计划，整理在 org 中管理 基本语法展示\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 (let ((org-super-agenda-groups \u0026#39;(;;每个组的选择器之间都有一个隐式布尔或运算符。 (:name \u0026#34;Today\u0026#34; ; name 可选，指定section名 :time-grid t ; 以时间表格样式显示项目 :todo \u0026#34;TODAY\u0026#34;) ; 具有此todo关键字的项 (:name \u0026#34;Important\u0026#34; ;; Single arguments given alone :tag \u0026#34;bills\u0026#34; :priority \u0026#34;A\u0026#34;) ;;一次设置多个分组的顺序 (:order-multi (2 (:name \u0026#34;Shopping in town\u0026#34; ;; 同时符合两个 tag 条件的分组。 :and (:tag \u0026#34;shopping\u0026#34; :tag \u0026#34;@town\u0026#34;)) (:name \u0026#34;Food-related\u0026#34; ;; 在列表中给出多个参数，隐式为0 :tag (\u0026#34;food\u0026#34; \u0026#34;dinner\u0026#34;)) (:name \u0026#34;Personal\u0026#34; :habit t :tag \u0026#34;personal\u0026#34;) (:name \u0026#34;Space-related (non-moon-or-planet-related)\u0026#34; ;; regexp 在整个条目上不区分大小写地匹配 :and (:regexp (\u0026#34;space\u0026#34; \u0026#34;NASA\u0026#34;) ;; Boolean NOT also has implicit OR between selectors :not (:regexp \u0026#34;moon\u0026#34; :tag \u0026#34;planet\u0026#34;))))) ;;当没有给出节名时，组提供自己的节名 Groups supply their own section names when none are given (:todo \u0026#34;WAITING\u0026#34; :order 8) ; Set order of this section (:todo (\u0026#34;SOMEDAY\u0026#34; \u0026#34;TO-READ\u0026#34; \u0026#34;CHECK\u0026#34; \u0026#34;TO-WATCH\u0026#34; \u0026#34;WATCHING\u0026#34;) ;; Show this group at the end of the agenda (since it has the ;; highest number). If you specified this group last, items ;; with these todo keywords that e.g. have priority A would be ;; displayed in that group instead, because items are grouped ;; out in the order the groups are listed. :order 9) (:priority\u0026lt;= \u0026#34;B\u0026#34; ;; Show this section after \u0026#34;Today\u0026#34; and \u0026#34;Important\u0026#34;, because ;; their order is unspecified, defaulting to 0. Sections ;; are displayed lowest-number-first. :order 1) ;; After the last group, the agenda will display items that didn\u0026#39;t ;; match any of these groups, with the default order position of 99 ))) (org-agenda nil \u0026#34;a\u0026#34;)) TODO 每日安排 在日常工作安排中，出现最多的视图，通过这个配置，养成跟踪任务状态习惯。\n它能一目了然的将正在进行的，即将开始的，快到期，已到期，阻塞等任务状体啊的统计视图，能够帮助检查时间安排，排查执行中遇到存在的问题等。\n要想摆脱时间黑洞，就要充分利用这个配置，时刻知道自己的状态和重要的事情是什么，要做的事情等。\n使用 org-super-agenda-daily 快速 review 日常任务状态：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 (setq org-super-agenda-daily \u0026#39;((:name \u0026#34;日程安排\\n\u0026#34; :time-grid t) (:name \u0026#34;今日要事\\n\u0026#34; :scheduled today) (:name \u0026#34;今日期限\\n\u0026#34; :deadline today) (:name \u0026#34;超期事务\\n\u0026#34; :deadline past) (:name \u0026#34;即将截止\\n\u0026#34; :deadline future) (:name \u0026#34;待处理\\n\u0026#34; :todo \u0026#34;WAIT\u0026#34; :order 98) (:name \u0026#34;Scheduled earlier\\n\u0026#34; :scheduled past))) (let ((org-super-agenda-group org-super-agenda-daily)) (org-agenda-list)) TODO 每周安排 每周安排，以七个习惯的中的设定来配置，回顾的思路来配置这项视图。\n先定角色，在看角色下的任务，再看重要的事情，紧迫的事情，使用二象限思维，分析观察工作的进度和时间管理。\n1 2 3 4 5 6 7 8 9 10 11 (setq org-super-agenda-habit \u0026#39;( (:name \u0026#34;我的\u0026#34; :tag \u0026#34;@我的\u0026#34; :scheduled (get-last-day-of-week-string)) (:name \u0026#34;阅读\u0026#34; :tag \u0026#34;阅读者\u0026#34;) (:name \u0026#34;理财\u0026#34; :tag \u0026#34;投资者\u0026#34;) (:name \u0026#34;开发\u0026#34; :tag \u0026#34;开发者\u0026#34;) (:name \u0026#34;管理者\u0026#34; :tag \u0026#34;管理者\u0026#34;) (:name \u0026#34;兄弟\u0026#34; :tag \u0026#34;兄弟\u0026#34;) )) (let ((org-super-agenda-group org-super-agenda-habit)) (org-agenda-list)) TODO 快速导出 agenda 清单模板 1 2 3 4 5 6 (setq org-super-agenda-snippet \u0026#39;( (:name \u0026#34;我的\u0026#34; :tag \u0026#34;@我的\u0026#34; :scheduled (get-last-day-of-week-string)) )) (let ((org-super-agenda-group org-super-agenda-snippet)) (org-agenda-list)) tj3 在 agenda 的分组 1 2 3 4 5 6 (setq org-super-agenda-tj3 \u0026#39;( (:name \u0026#34;我的\u0026#34; :tag \u0026#34;@我的\u0026#34; :scheduled (get-last-day-of-week-string)) )) (let ((org-super-agenda-group org-super-agenda-tj3)) (org-agenda-list)) 日志模式 1 2 3 4 5 6 7 (let ((org-super-agenda-groups \u0026#39;((:order-multi (1 (:name \u0026#34;Done today\u0026#34; :and (:regexp \u0026#34;State \\\u0026#34;DONE\\\u0026#34;\u0026#34; :log t)) (:name \u0026#34;Clocked today\u0026#34; :log t)))))) (org-agenda-list)) 辅助测试的方法和模拟数据 获取本周的最后一天的日期字符串 以下是一个可以获取本周最后一天日期字符串的Elisp函数：\n1 2 3 4 5 6 7 (defun get-last-day-of-week-string () (let* ((curr-time (current-time)) (day-of-week (string-to-number (format-time-string \u0026#34;%w\u0026#34; curr-time))) (days-to-sunday (- 7 day-of-week)) (last-day-of-week (time-add curr-time (days-to-time days-to-sunday)))) (format-time-string \u0026#34;%Y-%m-%d\u0026#34; last-day-of-week))) (message \u0026#34;This week\u0026#39;s last day is: %s\u0026#34; (get-last-day-of-week-string)) 该函数使用了Emacs Lisp的时间函数，计算出本周最后一天的日期，再用 format-time-string 函数将其转换成指定格式的字符串。最后返回日期字符串。\n测试数据 testA-RRRRRRRRRRRREEEEEEEEEEEE GPT testB-RRRRRRRRRRRREEEEEEEEEEEE TET testC-RRRRRRRRRRRREEEEEEEEEEEE KEY testD-RRRRRRRRRRRREEEEEEEEEEEE IT TODAY testE-RRRRRRRRRRRREEEEEEEEEEEE IT \u0026lt;2023-05-21 周日\u0026gt;\n","date":"2023-05-27T20:35:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/org-super-agenda%E4%BD%9C%E4%B8%BA%E6%97%A5%E5%B8%B8%E5%B7%A5%E4%BD%9C%E8%B0%83%E5%BA%A6%E5%8F%B0/","section":"post","tags":null,"title":"定制 org-super-agenda 视图作为任务调度台"},{"categories":["学习笔记"],"contents":"借助 AI 帮助分析日程安排的也将是非常有力的工具。\n如何获取 agenda 的内容,直接返回构建的视图内容字符串,而不跳转到 agenda 缓冲区 通过 org-agenda 内置命令导出文本格式使用自带命令，会跳转到 org-agenda-view 中无法在 elisp 中拿到列表数据 通过 org-ql 查询命令获取 agenda 列表 将内容投喂给 gptel 获取分析报告和建议借助 org-roam-capture 通过 tag 设定 prompt 角色，在完成 capture 时，自动对话AI。 优化 prompt 对话模板: 基于 capture 模板: 内容总结 ， 写作助理 基于 snippet 模板： agd 调用自定义方法，实现查询 org 内容，插入到当前 buffer 使用 org-ql 获取TODO数据实现 AI 对话 获取 org-agenda 的清单数据。在获取到数据之后，就可以为其他自定义方法提供数据支持。\n例如，想要将查询到的数据，插入当前 buffer，先将列表数据以换行的方式格式化为字符串,然后插入当前位置 buffer。\n还可以结合 gptel 接口，将查询的内容投喂给 AI ，实现和 AI 的对话，例如帮助分析 agenda 任务安排的合理性，获取 AI 专业的建议。\n1 2 3 4 5 6 7 8 9 10 11 12 (defun org-ql-week-todo () (let ((result \u0026#34;\u0026#34;)) (setq result (org-ql-query :select \u0026#39;(org-get-heading) ;; :from (org-agenda-files) :where \u0026#39;(todo))) (setq content (s-join \u0026#34;\\n\u0026#34; (mapcar #\u0026#39;(lambda (x) (format \u0026#34;%s\u0026#34; x)) result))) (message \u0026#34;搜索结果：\\n%s\u0026#34; content) ) ) (insert-org-ql-todo) 1 2 3 4 5 6 7 8 9 10 11 搜索结果： TODO 思考最重要的事情撰写使命宣言 :blue: TODO [#B] 拓宽思路的过程 :anki: TODO 开发 auto-gpt emacs 插件 TODO 捷径通过 emacsclient 命令，或 ifff 集成 Auto-GPT TODO 使用 gptel 分析 agenda 优化日程安排 TODO org-batch-store-agenda-views TODO org-agenda-list-stuck-projects TODO 每日安排 TODO 每周安排 TODO 快速导出 agenda 清单模板 介绍 org-agenda 内置导出工具 org-agenda 提供三个宏函数：\norg-batch-agenda : 为命令行设计，能够执行 org-agenda 模板命令 , org-batch-agenda-csv 支持导出 csv 格式 org-batch-store-agenda-views : 基于 org-agenda 模板中设置的导出文件格式，批量导出并生成相关文件。 org-agenda-list-stuck-projects : 导出阻塞的任务清单。 elisp 不执行宏调用的参数;所以不支持函数类型的入参。\n用户如果 emacsclient 从命令中获取 agenda 的日程清单。例如，导出7天的议程:\n1 emacs -batch -l ~/.emacs -eval \u0026#39;(org-batch-agenda \u0026#34;a\u0026#34; org-agenda-span 7)\u0026#39; 如果想把 org-batch-agenda 作为常规函数调用，则必须使用单引号 ' 包括。\n此外:使用符号作为参数值，则必须对该符号加双引号。\nExtracting Agenda Information (The Org Manual)\norg-batch-agenda 的用法 1 (org-batch-agenda \u0026#34;a\u0026#34; org-agenda-span 7) 1 2 3 4 2:00 S-42 TODO 思考最重要的事情撰写使命宣言 :@Inbox::blue: 2:00 S-42 TODO [#B] 拓宽思路的过程 :@Inbox::anki: 2:00 D-42 TODO 思考最重要的事情撰写使命宣言 :@Inbox::blue: 2:00 D-42 TODO [#B] 拓宽思路的过程 :@Inbox::anki: 1 2 3 ;; (org-batch-agenda \u0026#34;E\u0026#34; org-agenda-span 7) (setq agenda-result (org-batch-agenda \u0026#34;E\u0026#34; org-agenda-span 7)) (message \u0026#34;每日安排： %s\u0026#34; agenda-result) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 每日安排： --------重要紧急---------- habit: TODO [#A] 二象限模式[0/3] :habit: project: TODO [#A] hackingWithSwift --------重要不紧急--------- inbox: TODO [#B] 拓宽思路的过程 :@Inbox::anki: inbox: TODO 开发 auto-gpt emacs 插件 :@Inbox:灵感:: inbox: TODO 捷径结合 emacsclient 命令，或使用 ifff 集成 Auto-GPT :@Inbox:灵感:: inbox: TODO 使用 gptel 分析 agenda 优化日程安排 :@Inbox:: inbox: TODO org-agenda-list-stuck-projects :@Inbox:: inbox: TODO org-batch-store-agenda-views :@Inbox:: -------紧急不重要----------- org-batch-store-agenda-views 基于 org-agenda 模板中设置的导出文件格式，批量导出并生成相关文件。\n定时导出agenda view\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 ;; https://mudan.wiki/Emacs/The_Org_Manual/The_Org_Manual.html (after! org-agenda (setq org-agenda-exporter-settings \u0026#39;((ps-number-of-columns 2) (ps-landscape-mode t) (org-agenda-add-entry-text-maxlines 0) ;;设置导出时，显示任务的内容最大行数 (org-agenda-prefix-format \u0026#34; [ ] \u0026#34;) ;; 设置任务title的前缀 ;;(org-agenda-with-colors nil) ; 默认值t:显示颜色 (org-agenda-remove-tags t) ;;(org-agenda-tag-filter-preset (list \u0026#34;+personal\u0026#34;)) (htmlize-output-type \u0026#39;css))) ;; 定时导出agenda view. ;; (file-expand-wildcards \u0026#34;~/org/*.org\u0026#34;) ;; (setq org-agenda-files (file-expand-wildcards \u0026#34;~/org/*.org\u0026#34;)) (defun progo-run-agenda-store () \u0026#34;定时导出agenda\u0026#34; (message \u0026#34;Agenda to be exported... \u0026#34;) (org-batch-store-agenda-views org-agenda-span (quote month) ;;org-agenda-start-day \u0026#34;2007-11-01\u0026#34; ;;org-agenda-include-diary nil org-agenda-files (file-expand-wildcards \u0026#34;~/hsg/iNotes/content-org/Orgzly/*.org\u0026#34;)) (message \u0026#34;Agenda exported!\u0026#34;)) ;; 从现在开始，每5分钟：5*60s 执行一次。 ;;(run-at-time nil 300 \u0026#39;progo-run-agenda-store) ) org-agenda-list-stuck-projects 导出阻塞的任务清单\n1 2 3 4 5 6 7 8 (org-agenda-list-stuck-projects 7 ; Next 7 days nil ; No specific files nil ; No custom command \u0026#34;Tasks\u0026#34; ; Heading for first view \u0026#39;(\u0026#34;PROJECT\u0026#34;) ; Only PROJECT todos nil nil ; Default time range \u0026#34;Projects\u0026#34;) ; Heading for second view ","date":"2023-05-27T20:08:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9E%E7%8E%B0agenda%E5%92%8Cai%E5%AF%B9%E8%AF%9D%E5%88%86%E6%9E%90%E5%B7%A5%E4%BD%9C%E5%AE%89%E6%8E%92/","section":"post","tags":null,"title":"使用 ChatGPT 分析优化 agenda 日程安排"},{"categories":["学习笔记"],"contents":"每个组选择器在 agenda 中创建一个包含它匹配的项的组，并使用这些项;任何与它不匹配的项都被传递给下一个组选择器。选择器 :discard 是一个例外:它在不创建 agenda 组的情况下持有它匹配的所有项，并将其余项传递给下一个选择器。\n每个组选择器都有一个参数，参数可以是单个原子也可以是一个列表，例如 :tag 接受一个字符串或字符串列表。有些选择器是谓词，如 :deadline 或 :habit ;为了一致性，他们也接受一个参数，但它被忽略了。\n注意: 由于使用哈希表实现，分组后可能不会保留项的顺序。未来的版本可能会解决这个缺点。\nKeywords :name 可选地，设置组名头。可以是字符串;或者符号 none ，在这种情况下，不会插入头文件。如果没有设置 :name ，则自动命名组。 :face A face 应用于组中的项目。如果 face 是一个包含 :append t 的列表，它将被追加。参见 function add-face-text-property 。 :transformer 用于在显示前,转换项字符串。用一个参数、项字符串或一个 sexp 调用的函数，在这种情况下，项字符串绑定到 it 。 Special selectors 每个选择器都需要一个参数，即使它只是 t ，例如 :anything 、 :auto-category 、 :auto-group 和 :discard 。\n:and 将匹配所有选择器的项分组到一个或多个选项中。 :anything 选择每一个项目，无论什么。这可能是最有用的 :discard ，因为它实际上不测试任何东西，所以它比，例如 :regexp \u0026quot;.\u0026quot; ，它必须获取每个项目的条目文本。 :auto-category 这将自动按类别对项目进行分组(通常是其所在的文件名，没有 .org 后缀)。 :auto-dir-name 这将根据源缓冲区的目录名自动对项进行分组。 :auto-group 这将选择具有 agenda-group org 属性集的项。通过为子树设置此属性，其中的每个项目都将按照该名称分类到议程组中，并放置到选择器为 :auto-group agenda 中)。 :auto-map 当将每个项作为来自 agenda 缓冲区的字符串应用到给定函数时，它会根据返回的值自动对项进行分组)。该函数应该返回一个字符串，用作分组键和其组的头。 :auto-outline-path 这将根据项目的大纲路径层次结构自动分组，如 计划/接管宇宙/接管月球 。 :auto-parent 这将自动按父标题对项目进行分组。这非常方便，特别是如果您按项目分层地对任务进行分组，并使用议程限制将议程限制在一个子树中。 :auto-planning 这将自动按照项目最早的计划日期或截止日期对项目进行分组，并根据变量 org-super-agenda-date-format 进行格式化。 :auto-priority 这将自动按优先级对项目进行分组。 :auto-property 这将根据给定属性的值自动对项进行分组 :auto-tags 这将自动根据所有标签对项目进行分组(即，具有完全相同标签的项目，无论以何种顺序，都将被分组在一起)。 :auto-todo 这将自动根据待办事项关键字对项目进行分组。 :auto-ts 这将自动按条目中任何位置的最新时间戳的日期对条目进行分组，并根据变量 org-super-agenda-date-format 进行格式化。对于参数 reverse ，组按最新优先排序。 :discard 丢弃匹配选择器的项。在此之后处理的任何组都不会看到丢弃的项。您可以在组列表的开头或结尾使用它，以便缩小项目列表(与 :not 结合使用)，或者排除您不感兴趣的项目。 :not 将不匹配任何选择器的项分组到任意组中。 注意， :not group 选择器 创建 一个与它不匹配的项的组; 它可以和 :discard 连用来丢弃不匹配的项。例如， (:discard (:not (:priority \u0026quot;A\u0026quot;)))) 作为第一个选择器意味着只有优先级为 A 的项目会出现在议程中，而 (:discard (:priority \u0026quot;C\u0026quot;)) 意味着任何优先级为 C 的项目都不会出现在议程中。 :order 设置顺序部分的数字将显示在 agenda 中，最低的数字首先。默认为 0 。 :order-multi 一次设置多个组的顺序，如 (:order-multi (2 (groupA) (groupB) ...)) ，将这些组的顺序设置为 2。 :take 取组中的前n个事项。如果n是负的，取最后n项。例如， (:take (-3 group)) 将从组中取出最后3个项目。剩余的项被丢弃。注意:不能保证保留来自group的条目的顺序，因此 :take 可能并不总是显示期望的条目。 Normal selectors 这些选择器单独接受一个参数，或者接受列表中的多个参数。\n:category 将匹配任何给定类别的项目分组。参数可以是字符串或字符串列表。 :children 选择任何有子条目的项。参数可以是 t 来匹配，如果它有任何子参数，可以是 nil 来匹配，如果它有任何带有 to-do 关键字的子参数，可以是 todo 来匹配，如果它有带有某些 to-do 关键字的子参数，可以是一个字符串来匹配。您可以使用它来选择作为项目顶级标题的项。请注意，在非每日/每周视图中，由于其递归性质，这可能非常慢。 :date 对具有关联日期的项进行分组。参数可以是 t 匹配具有任何日期的项， nil 匹配没有日期的项，或 today 匹配具有今天日期的项。与 ts-date 日期文本属性进行匹配。 :deadline 对有截止日期的项目进行分组。参数可以是 t (匹配任意截止日期的项)、 nil (匹配没有截止日期的项)、 past (匹配过去截止日期的项)、 today (匹配截止日期为今天的项)或 future (匹配未来截止日期的项)。也可以给出参数，比如 before DATE 或 after DATE , 其中 DATE 是 org-time-string-to-absolute 可以处理一个日期字符串 。 :effort\u0026lt; 将小于(或等于)给定工作量的项目分组。参数是一个时间-持续时间字符串，例如 5 或 0:05 表示5分钟。 :effort\u0026gt; 将高于(或等于)给定工作量的项目分组。参数是一个时间-持续时间字符串，例如 5 或 0:05 表示5分钟。 :file-path 将缓冲区的文件名路径匹配任何给定正则表达式的项分组。 :habit 将习惯项分组(属性为 STYLE: habit 的项)。 :heading-regexp 将标题匹配任何给定正则表达式的项分组。 :log Group Agenda Log Mode 模式项目。参数可以是 close 或 closed 来选择今天关闭的项目; clock 或 clocked 选择今天已打卡的项目; changed 或 state 选择今天待办事项状态发生变化的项目; t 选择任何已记录的项，或 nil 选择任何未记录 non-logged 的项。 (请注意，这些项目也可以由 :time-grid 选择器匹配，所以如果您希望这些项目在它们自己的组中显示，您可能需要在包含 :time-grid 选择器的组之前选择它们。\n:pred 如果任何给定的谓词函数在调用时返回 non-nil，并且每个项目都是来 agenda 缓冲区字符串，则将项目分组的。 :priority 将匹配任何给定优先级的项目分组。参数可以是一个字符串或字符串列表，它应该是优先级字母，例如 A 。 :priority\u0026gt; 将高于给定优先级的项目分组，例如 C 。 :priority\u0026gt;= 将高于或等于给定优先级的项分组，例如 B 。 :priority\u0026lt; 将低于给定优先级的项目分组，例如 A 。 :priority\u0026lt;= 将低于或等于给定优先级的项目分组，例如 B 。 :property 使用属性对项进行分组，值可选。参数可以是属性名字符串，也可以是属性名字符串和用于测试值的值字符串或谓词的列表。 :regexp 将匹配任何给定正则表达式的项分组。 :scheduled 对计划的项目进行分组。参数可以是 t (匹配任何日期计划的项目) nil (匹配没有计划的项目) past (匹配过去计划的项目) today (匹配今天计划的项目) future (匹配未来计划的项目) 也可以给出参数，比如 before DATE 或 after DATE ，其中 DATA 是一个 org-time-string-to-absolute 可以处理日期字符串。\n:tag 将匹配任何给定标记的项目分组。参数可以是字符串或字符串列表。 :time-grid 对出现在时间网格上的项目进行分组。 :todo 将匹配给定的任意一个关键字的项分组。参数可以是字符串或字符串列表，也可以是 t 来匹配任何关键字，或者 nil 来只匹配非待办项。 ","date":"2023-05-27T19:32:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/org-super-agenda%E6%96%87%E6%A1%A3%E7%BF%BB%E8%AF%91/","section":"post","tags":["翻译"],"title":"org-super-agenda 语法说明"},{"categories":["学习笔记"],"contents":"模拟curl 方式请求slack Api,需要参考的逻辑有\n先定位入口，跟踪代码 定位到 gptel-curl 实现类主要功能都在这里，需要在这里找到解决方案先分析该类的主要功能 参数内容的收集 gptel-curl--get-args 以进程的方式开始 curl 请求数据开启进程 gptel-curl-get-response 处理数据：以流的方式插入到当前 buffer 需要流式响应功能支持，socket模式 Socket Mode implementation | Slack gptel 入口 gptel-request 方法介绍 理解源码，分析入口参数和环境变量初始状态，以及后续功能方法的处理逻辑\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 (cl-defun gptel-request (\u0026amp;optional prompt \u0026amp;key callback (buffer (current-buffer)) position context (stream nil) (in-place nil) (system gptel--system-message)) (let* ((gptel-stream stream) (start-marker (cond ((null position) (if (use-region-p) (set-marker (make-marker) (region-end)) (point-marker))) ((markerp position) position) ((integerp position) (set-marker (make-marker) position buffer)))) (full-prompt (cond ((null prompt) (gptel--create-prompt start-marker)) ((stringp prompt) `((:role \u0026#34;system\u0026#34; :content ,system) (:role \u0026#34;user\u0026#34; :content ,prompt))) ((consp prompt) prompt))) (info (list :prompt full-prompt :buffer buffer :position start-marker))) (when context (plist-put info :context context)) (when in-place (plist-put info :in-place in-place)) (funcall (if gptel-use-curl #\u0026#39;gptel-curl-get-response #\u0026#39;gptel--url-get-response) info callback))) 这是 gptel-request 函数的定义,它向 ChatGPT 发出请求并获取响应。让我们详细分析它:\n它接受可选的 prompt 、 callback 和许多关键字参数。\nprompt 可以是字符串(用于构造完整提示)、 nil (使用当前区域或缓冲区内容)或 plist 的列表(原样使用)。\ncallback 是两个参数的函数,用于响应(字符串)和 info plist 调用:\n1 (callback RESPONSE INFO) 如果没有响应或错误, RESPONSE 为 nil。\ninfo plist 至少包含:\n:prompt - 发送的完整提示 :position - 发送请求的 marker :buffer - 发送请求时的当前缓冲区 :status - 请求结果的简短字符串 如果省略 callback ,响应将插入发送请求的点。\nBUFFER 是请求属于的缓冲区。如果省略,则记录当前缓冲区。\nPOSITION 是缓冲区位置(整数或标记)。如果省略,则记录(point)或(region-end),具体取决于是否激活了区域。\nCONTEXT 是回调运行所需的任何其他数据。它包含在回调的INFO参数中。\nSYSTEM 是发送给 ChatGPT 的系统消息(聊天指令)。如果省略,则使用当前缓冲区的 gptel--system-message 的值。\n以下关键字主要用于内部使用:\nIN-PLACE :是一个布尔值,用于默认回调在插入响应时确定是否需要在提示和响应之间插入分隔符。 STREAM : 是一个布尔值,用于确定是否应流式传输响应,就像在`gptel-stream’中一样。如果指定自定义CALLBACK,请勿设置此项! 该函数调用周围可以 let 绑定模型参数。\n所以总而言之,这个函数向 ChatGPT 发出请求并获取响应,要么使用提供的回调进行处理,要么直接将其插入到缓冲区中。它接受许多参数以控制和定制该请求。\n使用 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 (defun gptel-tmp-request (prompt) (when (string= prompt \u0026#34;\u0026#34;) (user-error \u0026#34;A prompt is required.\u0026#34;)) (gptel-request prompt :callback (lambda (response info) (if (not response) (message \u0026#34;gptel-capture 错误: %s\u0026#34; (plist-get info :status)) ;; (with-current-buffer (goto-char (point-max)) (unless (bolp) (insert \u0026#34;\\n\u0026#34;)) (insert \u0026#34;** 测试 \\n\u0026#34; response \u0026#34;\\n\u0026#34;) ;; ) )) )) ;;测试 gptel-tmp-request (let ((prompt \u0026#34;测试\u0026#34;)) (gptel-tmp-request prompt) ) 1 gptel-curl--sentinel gptel-curl 中的方法介绍 参数部分 要先理解 gptel 参数格式，按照格式整理出 slack 接口的入参变量\ngptel 参数格式 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 (defun gptel-curl--get-args (prompts token) \u0026#34;Produce list of arguments for calling Curl. PROMPTS is the data to send, TOKEN is a unique identifier.\u0026#34; (let* ((args (list \u0026#34;--location\u0026#34; \u0026#34;--silent\u0026#34; \u0026#34;--compressed\u0026#34; \u0026#34;--disable\u0026#34;)) (url \u0026#34;https://api.openai.com/v1/chat/completions\u0026#34;) (data (encode-coding-string (json-encode (gptel--request-data prompts)) \u0026#39;utf-8)) (headers `((\u0026#34;Content-Type\u0026#34; . \u0026#34;application/json\u0026#34;) (\u0026#34;Authorization\u0026#34; . ,(concat \u0026#34;Bearer \u0026#34; (gptel--api-key)))))) (push (format \u0026#34;-X%s\u0026#34; \u0026#34;POST\u0026#34;) args) (push (format \u0026#34;-w(%s . %%{size_header})\u0026#34; token) args) ;; (push (format \u0026#34;--keepalive-time %s\u0026#34; 240) args) (push (format \u0026#34;-m%s\u0026#34; 60) args) (push \u0026#34;-D-\u0026#34; args) (pcase-dolist (`(,key . ,val) headers) (push (format \u0026#34;-H%s: %s\u0026#34; key val) args)) (push (format \u0026#34;-d%s\u0026#34; data) args) (nreverse (cons url args)))) 这是 gptel-curl--get-args 函数的定义,它为调用 curl 生成参数列表。让我们详细分析它:\n它接受 prompts (要发送的数据)和 token (唯一标识符)作为参数。 它首先定义一些默认 curl args ,如 --location 、 --silent 、 --compressed 等。 它定义 ChatGPT API端点的URL。 它使用 json-encode 将 prompts 编码为 JSON,并使用 encode-coding-string 将其编码为 UTF-8。 它定义包含认证令牌的标题。 它使用 push 将更多 args 添加到列表,如-X POST(用于POST请求)、-w 来关联响应大小与 token、-m 60(超时)等。 它使用 pcase-dolist 迭代标题,并使用 push 将格式化的 -H args 添加到列表中。 它使用 push 将 -d arg (包含编码的JSON数据)添加到列表中。 它使用 nreverse 反转 args 列表,并使用 cons 将 URL 添加到开头,形成完整的 curl 调用参数。 它返回生成的 args 列表。 所以总而言之,这个函数构造用于将 prompts 发送到 ChatGPT API的curl命令行参数。它添加所有必需的参数,如方法、数据、标头、超时等,并返回完整的参数列表以供调用 curl 使用。\n它显示了构建命令行工具包装器/接口所需的各种知识,如:\ncurl 的参数理解 编码(这里为JSON和UTF-8) plist 和 alist 的使用 反转列表以获得正确的参数顺序 1 (gptel-curl--get-args \u0026#34;xx\u0026#34; \u0026#34;xxx3\u0026#34;) \u0026ndash;disable \u0026ndash;compressed \u0026ndash;silent \u0026ndash;location -XPOST -w(xxx3 . %{size_header}) -m60 -D- -HContent-Type: application/json -HAuthorization: Bearer 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 -d{\u0026ldquo;model\u0026rdquo;:\u0026ldquo;gpt-3.5-turbo\u0026rdquo;,\u0026ldquo;messages\u0026rdquo;:[120,120],\u0026ldquo;stream\u0026rdquo;:true,\u0026ldquo;temperature\u0026rdquo;:1.0} https://api.openai.com/v1/chat/completions slack 相关参数 整理 slack 参数，打印测试\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 (defun slack-curl--get-args (prompts token) \u0026#34;Produce list of arguments for calling Curl. PROMPTS is the data to send, TOKEN is a unique identifier.\u0026#34; (let* ((args (list \u0026#34;--location\u0026#34; \u0026#34;--silent\u0026#34; \u0026#34;--compressed\u0026#34; \u0026#34;--disable\u0026#34;)) (url \u0026#34;https://slack.com/api/chat.postMessage\u0026#34;) (data (encode-coding-string (json-encode (gptel--request-data prompts)) \u0026#39;utf-8)) (headers `((\u0026#34;Content-Type\u0026#34; . \u0026#34;application/json\u0026#34;) (\u0026#34;Authorization\u0026#34; . ,(concat \u0026#34;Bearer \u0026#34; (gptel--api-key)))))) ;;向 crul参数：args 中添加字段 (push (format \u0026#34;-X%s\u0026#34; \u0026#34;POST\u0026#34;) args) (push (format \u0026#34;-w(%s . %%{size_header})\u0026#34; token) args) ;; (push (format \u0026#34;--keepalive-time %s\u0026#34; 240) args) (push (format \u0026#34;-m%s\u0026#34; 60) args) (push \u0026#34;-D-\u0026#34; args) ;; pcase-dolist essentially循环一个alist或plist,为每个元素执行一些操作 (pcase-dolist (`(,key . ,val) headers) (push (format \u0026#34;-H%s: %s\u0026#34; key val) args)) ;;添加 prompt data (push (format \u0026#34;-d%s\u0026#34; data) args) (nreverse (cons url args)))) gptel-curl 进程部分 先理解源码，看看如何新建 slack API 的进程，实现异步请求接口，同时和 emacs 交互。\n这个函数启动一个后台 curl 进程来获取响应,并设置回调以在获得完整响应时进行处理。它还包括将响应从 markdown 转换为 org mode 的选项。\n它显示了 Emacs 中的强大进程和异步编程功能。这使您可以启动长时间运行的后台进程,同时仍然保持 Emacs 响应,因为处理是异步完成的。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 ;;TODO: The :transformer argument here is an alternate implementation of ;;`gptel-response-filter-functions\u0026#39;. The two need to be unified. ;;;###autoload (defun gptel-curl-get-response (info \u0026amp;optional callback) ;; 1 \u0026#34;Retrieve response to prompt in INFO. INFO is a plist with the following keys: - :prompt (the prompt being sent) - :buffer (the gptel buffer) - :position (marker at which to insert the response). Call CALLBACK with the response and INFO afterwards. If omitted the response is inserted into the current buffer after point.\u0026#34; (let* ((token (md5 (format \u0026#34;%s%s%s%s\u0026#34; (random) (emacs-pid) (user-full-name) (recent-keys)))) ;; 3 (args (gptel-curl--get-args (plist-get info :prompt) token)) ;; (process (apply #\u0026#39;start-process \u0026#34;gptel-curl\u0026#34; (generate-new-buffer \u0026#34;*gptel-curl*\u0026#34;) \u0026#34;curl\u0026#34; args))) ;;4 (with-current-buffer (process-buffer process) (set-process-query-on-exit-flag process nil) ;;6 (setf (alist-get process gptel-curl--process-alist) (nconc (list :token token :callback (or callback (if gptel-stream #\u0026#39;gptel-curl--stream-insert-response #\u0026#39;gptel--insert-response)) :transformer (when (or (eq gptel-default-mode \u0026#39;org-mode) (eq (buffer-local-value \u0026#39;major-mode (plist-get info :buffer)) \u0026#39;org-mode)) (gptel--stream-convert-markdown-\u0026gt;org))) info)) (if gptel-stream (progn (set-process-sentinel process #\u0026#39;gptel-curl--stream-cleanup) (set-process-filter process #\u0026#39;gptel-curl--stream-filter)) ;;8 (set-process-sentinel process #\u0026#39;gptel-curl--sentinel))))) ;;9 它定义了一个名为 gptel-curl-get-response 的函数,该函数接受 info plist 和可选的回调 callback 作为参数。 info plist 包含诸如提示、缓冲区、插入响应位置的标记等信息。 callback 将在获得响应后以 response 和 info 为参数进行调用。如果省略,响应将插入当前缓冲区的 point 之后。 它生成一个随机 token,并使用该 token 和 prompt 构建 curl 命令行参数。 它使用 apply 启动名为 gptel-curl 的新进程来运行 curl 和构建的参数。输出发送到一个专用缓冲区 *gptel-curl* 。 它在 gptel-curl 进程的缓冲区中设置一些进程标志: 查询退出标志设置为 nil 它在 gptel-curl--process-alist 中存储进程、 token 、回调和转换器(如果需要,用于将 markdown 转换为 org-mode) 如果 gptel-stream 为真,它设置 sentinel 和 filter 函数来处理流输出。否则它设置 sentinel 函数。 sentinel 和 filter 函数(定义在其他地方)将处理完成响应的接收和调用回调。 设置回调方法：gptel-curl\u0026ndash;stream-insert-response 这行代码是对函数 gptel-curl--stream-insert-response 的引用。 #’ 是读取函数名称的语法。\n所以这一行实际上表示要调用名为 gptel-curl--stream-insert-response 的函数。\n该函数很可能与此前显示的 gptel-curl-get-response 函数一起工作,因为:\n它也与 gptel-curl 进程相关,用于从 curl 获取响应。 gptel-curl-get-response 指定如果 gptel-stream 为真,则使用 gptel-curl--stream-insert-response 作为回调。 所以我们可以推断, gptel-curl--stream-insert-response 函数很可能执行以下操作:\n它是 gptel-curl-get-response 指定的回调函数,以在接收到完整响应时进行调用。 鉴于其名称,它可能将响应插入 calling 函数(gptel-curl-get-response)指定的缓冲区。 因为它是 stream 版本,它可能逐渐添加响应,而不是等待完整响应。这可能意味着它被设置为 gptel-curl 进程的 filter 函数,每当有输出可用时就被调用。 它可能还执行 markdown 到 org mode 的转换(如果需要),因为 gptel-curl-get-response 指定了该选项。 所以总而言之,这行代码表明在处理流 curl 响应并将其插入指定缓冲区时要调用名为 gptel-curl--stream-insert-response 的函数。该函数很可能通过 filter 函数挂钩到相关进程,并在处理响应时执行任何必要的格式转换。\n在 gptel-curl--process-alist 中存储进程 这段代码将一些值与 gptel-curl 进程相关联,并将其存储在 gptel-curl--process-alist 中。让我们详细分析它:\n它使用 alist-get 查找与进程相关联的值。如果尚不存在,它将返回 nil 。 它使用 nconc 将多个列表合并为一个列表。它构建要与进程相关联的列表,包含: :token - 之前生成的随机 token :callback - 要使用的回调。它首先检查是否指定了 callback ,如果没有则使用 gptel-stream 的值来确定是使用 gptel-curl--stream-insert-response 还是 gptel--insert-response 。 :transformer - 仅当 gptel-default-mode 或 info 指定的缓冲区主要模式为 org-mode 时,才使用 gptel--stream-convert-markdown-\u0026amp;gt-\u0026gt;org 进行 markdown 到 org 模式的转换。 它将 info plist 附加到列表的末尾。 它使用 setf 将该组合列表存储在 gptel-curl--process-alist 中,与进程相关联。 所以总而言之,这段代码为进程设置一个回调函数和转换器(如果需要),并将所有这些信息与一个随机 token 相关联,以防止跨站点请求伪造。它存储所有这些信息,以便以后可以基于进程查找其回调/转换器等。\n这显示了 Lisp 的许多功能,如:\nplist 的使用 nconc 用于列表连接 setf 用于存储值 以 alist 形式存储关联数据 有条件的逻辑来设置可选值 这些构建块允许您构建复杂的数据结构和关联,这是编写实际应用程序所必需的。\n定义自己的函数 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 ;;;###autoload (defun slack-curl-get-response (info \u0026amp;optional callback) ;; 1 \u0026#34;Retrieve response to prompt in INFO. INFO is a plist with the following keys: - :prompt (the prompt being sent) - :buffer (the gptel buffer) - :position (marker at which to insert the response). Call CALLBACK with the response and INFO afterwards. If omitted the response is inserted into the current buffer after point.\u0026#34; (let* ((token (md5 (format \u0026#34;%s%s%s%s\u0026#34; (random) (emacs-pid) (user-full-name) (recent-keys)))) ;; 3 (args (gptel-curl--get-args (plist-get info :prompt) token)) ;; (process (apply #\u0026#39;start-process \u0026#34;gptel-curl\u0026#34; (generate-new-buffer \u0026#34;*gptel-curl*\u0026#34;) \u0026#34;curl\u0026#34; args))) ;;4 (with-current-buffer (process-buffer process) (set-process-query-on-exit-flag process nil) ;;6 (setf (alist-get process gptel-curl--process-alist) (nconc (list :token token :callback (or callback (if gptel-stream #\u0026#39;gptel-curl--stream-insert-response #\u0026#39;gptel--insert-response)) :transformer (when (or (eq gptel-default-mode \u0026#39;org-mode) (eq (buffer-local-value \u0026#39;major-mode (plist-get info :buffer)) \u0026#39;org-mode)) (gptel--stream-convert-markdown-\u0026gt;org))) info)) (if gptel-stream (progn (set-process-sentinel process #\u0026#39;gptel-curl--stream-cleanup) (set-process-filter process #\u0026#39;gptel-curl--stream-filter)) ;;8 (set-process-sentinel process #\u0026#39;gptel-curl--sentinel))))) 以流的方式插入 buffer 先理解源码，如何把 curl 进程的响应数据以流的方式插入到 buffer 中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ;;;###autoload (defun gptel-curl--stream-insert-response (response info) \u0026#34;Insert streaming RESPONSE from ChatGPT into the gptel buffer. INFO is a mutable plist containing information relevant to this buffer. See `gptel--url-get-response\u0026#39; for details.\u0026#34; (let ((status-str (plist-get response :status)) (start-marker (plist-get info :position)) (tracking-marker (plist-get info :tracking-marker)) (transformer (plist-get info :transformer))) (when response (with-current-buffer (marker-buffer start-marker) (save-excursion (message \u0026#34;插入结果222：-----%s \\n 状态：%s\u0026#34; response status-str) (unless tracking-marker (gptel--update-header-line \u0026#34; Typing...\u0026#34; \u0026#39;success) (goto-char start-marker) (unless (or (bobp) (plist-get info :in-place)) (insert \u0026#34;\\n\\n\u0026#34;)) (setq tracking-marker (set-marker (make-marker) (point))) (set-marker-insertion-type tracking-marker t) (plist-put info :tracking-marker tracking-marker)) (when transformer (setq response (funcall transformer response))) (put-text-property 0 (length response) \u0026#39;gptel \u0026#39;response response) (goto-char tracking-marker) (insert response)))))) 这是gptel-curl\u0026ndash;stream-insert-response函数的定义,如我们预期的那样,它将流响应插入指定的缓冲区。让我们详细分析它:\n它接受响应response和info plist作为参数。info plist包含与该缓冲区相关的信息,如gptel\u0026ndash;url-get-response中详述。\n它从响应中获取状态字符串,从info中获取起始标记、跟踪标记和转换器(如果有)。\n如果有响应,它将在包含起始标记的当前缓冲区中进行操作。\n它首先检查是否已设置跟踪标记。如果没有,它会更新标题行,转到起始标记,插入两个换行符(除非在原地编辑),并设置一个跟踪标记以跟踪响应的插入位置。它还将跟踪标记添加到info plist中。\n如果指定了转换器,它将对响应进行转换。\n它将gptel属性与整个响应文本关联。\n它转到跟踪标记并插入响应。\n然后它返回,直到有更多响应要添加,在那时它将再次调用。\n所以总而言之,这个函数将流式响应添加到缓冲区,进行任何必要的转换,并跟踪每个响应的插入位置以供将来添加使用。\n它显示了Emacs Lisp的许多强大功能,如:\n标记和缓冲区操作 属性和文本属性 plist的使用 save-excursion用于临时保存位置 这是一个非常典型的Emacs Lisp函数,展示了构建复杂功能所需的各种工具。\n使用 slack curl 参数定义模块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (defun slack-curl--get-args (prompts) \u0026#34;Produce list of arguments for calling Curl. PROMPTS is the data to send, TOKEN is a unique identifier.\u0026#34; (let* ((args (list \u0026#34;--location\u0026#34; \u0026#34;--silent\u0026#34; \u0026#34;--compressed\u0026#34; \u0026#34;--disable\u0026#34;)) (data (encode-coding-string (url-hexify-string \u0026#34;你好\u0026#34;) \u0026#39;utf-8)) ;; (url (format \u0026#34;https://slack.com/api/chat.postMessage?channel=D052Y13FSRY\u0026amp;as_user=true\u0026amp;text=%s\u0026#34; data)) (url \u0026#34;https://slack.com/api/conversations.history?channel=D052Y13FSRY\u0026amp;limit=2\u0026#34;) (headers `((\u0026#34;Authorization\u0026#34; . ,(concat \u0026#34;Bearer \u0026#34; slack-claude-bot-token))))) ;;向 crul参数：args 中添加字段 (push (format \u0026#34;-X%s\u0026#34; \u0026#34;POST\u0026#34;) args) ;; (push (format \u0026#34;-w(%s . %%{size_header})\u0026#34; token) args) ;; (push (format \u0026#34;--keepalive-time %s\u0026#34; 240) args) (push (format \u0026#34;-m%s\u0026#34; 60) args) (push \u0026#34;-D-\u0026#34; args) ;; pcase-dolist essentially循环一个alist或plist,为每个元素执行一些操作 (pcase-dolist (`(,key . ,val) headers) (push (format \u0026#34;-H%s: %s\u0026#34; key val) args)) ;;添加 prompt data ;; (push (format \u0026#34;-d%s\u0026#34; data) args) (nreverse (cons url args)))) 数据解析模块 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 (defun slack-curl--stream-filter (process output) (message \u0026#34;进程过滤----\u0026#34;) (let* ((content-strs) (proc-info (alist-get process slack-curl--process-alist))) (with-current-buffer (process-buffer process) ;; Insert output (save-excursion (goto-char (process-mark process)) (insert output) (set-marker (process-mark process) (point))) ;; Find HTTP status (unless (plist-get proc-info :http-status) (save-excursion (goto-char (point-min)) (when-let* (((not (= (line-end-position) (point-max)))) (http-msg (buffer-substring (line-beginning-position) (line-end-position))) (http-status (save-match-data (and (string-match \u0026#34;HTTP/[.0-9]+ +\\\\([0-9]+\\\\)\u0026#34; http-msg) (match-string 1 http-msg))))) (plist-put proc-info :http-status http-status) (plist-put proc-info :status (string-trim http-msg)))) ;; Handle read-only gptel buffer (when (with-current-buffer (plist-get proc-info :buffer) (or buffer-read-only (get-char-property (plist-get proc-info :position) \u0026#39;read-only))) (message \u0026#34;Buffer is read only, displaying reply in buffer \\\u0026#34;*ChatGPT response*\\\u0026#34;\u0026#34;) (display-buffer (with-current-buffer (get-buffer-create \u0026#34;*ChatGPT response*\u0026#34;) (goto-char (point-max)) (move-marker (plist-get proc-info :position) (point) (current-buffer)) (current-buffer)) \u0026#39;((display-buffer-reuse-window display-buffer-pop-up-window) (reusable-frames . visible))))) (when-let ((http-msg (plist-get proc-info :status)) (http-status (plist-get proc-info :http-status))) ;; Find data chunk(s) and run callback (when (equal http-status \u0026#34;200\u0026#34;) (funcall #\u0026#39;slack-curl--stream-insert-response (let* ((json-object-type \u0026#39;plist) (status (string-match \u0026#34;}}$\u0026#34; (buffer-string))) (response) (content-str)) (message \u0026#34;匹配结果：%s\u0026#34; status) (when (string-match \u0026#34;}}\u0026#34; (buffer-string)) (setq response (replace-regexp-in-string \u0026#34;[^\\\\{]*?\\{\\\u0026#34;ok\u0026#34; \u0026#34;{\\\u0026#34;ok\u0026#34;(buffer-string))) (with-temp-buffer (insert response) (goto-char (point-min)) (let* ((json-object-type \u0026#39;plist) (json-array-type \u0026#39;list) (json (json-read)) (messages (plist-get json :messages)) ) ;; 解析 messages 消息数据 (dolist (msg messages) ;; 仅解析Claude的信息 (if-let* ((bot (plist-get msg :bot_profile)) (botname (plist-get bot :name)) (claude (string= botname \u0026#34;Claude\u0026#34;)) (text (plist-get msg :text))) (push text content-strs) )) ) ) ) (apply #\u0026#39;concat (nreverse content-strs))) proc-info)))))) ;; (condition-case nil ;; (while (re-search-forward \u0026#34;\\{\\\u0026#34;ok\u0026#34; nil t) ;; (save-match-data ;; (unless (looking-at \u0026#34;\\}{3}$\u0026#34;) ;; (when-let* ((response (json-read)) ;; (delta (map-nested-elt ;; response \u0026#39;(:choices 0 :delta))) ;; (content (plist-get delta :content))) ;; (message \u0026#34;响应plist：-----%s\u0026#34; (buffer-string)) ;; (message \u0026#34;delta：-----%s\u0026#34; delta) ;; (message \u0026#34;解析content：-----%s\u0026#34; content) ;; (push content content-strs) ;; (message \u0026#34;组合结果：%s\u0026#34; content-strs) ;; )))) ;; (error ;; (goto-char (match-beginning 0)))) ","date":"2023-05-27T03:12:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%AE%9A%E5%88%B6gptel%E4%BA%86%E8%A7%A3%E6%B5%81%E5%BC%8F%E5%93%8D%E5%BA%94%E5%BC%80%E5%8F%91/","section":"post","tags":null,"title":"gptel 的 api 是如何插入到当前 buffer"},{"categories":["学习笔记"],"contents":"AI需求 描述需求，投喂给 AI 给出建议，获取灵感，例如：\n1 2 3 4 5 你是精通elisp语法，了解emacs的常规用法和习惯，请帮我实现下面的功能： 这是数组A：(list \u0026#34;你好，Typing\u0026#34; \u0026#34;你好，世界！Typing\u0026#34; \u0026#34;你好，世界！生活很美好，Typing\u0026#34; \u0026#34;你好，世界！生活很美好，要面对现实Typing\u0026#34;) 写一个elisp函数：在当前buffer的光标位置，依次将数组A中的内容全部插入到光标的位置，要求每次插入的内容不能和已插入个的内容内容重复，次序要保持连贯。 插入的预期效果：\u0026#34;你好，世界！世界!生活很美好，要面对现实\u0026#34;。 Claude 灵感 这个函数会在当前光标的位置插入所有内容，不会出现重复。同时，如果已经插入了部分内容，新的内容会接在已有内容的后面。这里是实现该功能的Emacs Lisp代码:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 (defun insert-without-duplicate-at-point (lst) \u0026#34;Insert elements of LIST into current buffer at point without duplicates.\u0026#34; (message \u0026#34;开始-----\u0026#34;) (let ((existing-content \u0026#34;\u0026#34;) (point (point))) (message \u0026#34;插入开始,位置ddd: %s\u0026#34; point) (dolist (elem lst) (message \u0026#34;正在插入：%s\u0026#34; elem) (unless (string-match (regexp-quote elem) existing-content) (goto-char point) (insert elem) (setq point (point)) (message \u0026#34;插入完成的位置: %s\u0026#34; point) (setq existing-content (buffer-substring point (point-max))) ) ) )) (setq list \u0026#39;(\u0026#34;你好,Typing\u0026#34; \u0026#34;你好,世界!Typing\u0026#34; \u0026#34;你好,世界!生活很美好,Typing\u0026#34; \u0026#34;你好,世界!生活很美好,要面对现实Typing\u0026#34;)) (insert-without-duplicate-at-point list) 你好,Typing你好,世界!Typing你好,世界!生活很美好,Typing你好,世界!生活很美好,要面对现实Typing\n这个函数 insert-without-duplicate 接受一个列表和缓冲区作为参数。它首先获取缓冲区的现有内容,然后迭代列表中的每个元素。对于每个元素,它使用 string-match 检查该元素是否已经存在于缓冲区中。如果不存在,则使用 insert 将元素插入缓冲区,并更新现有内容。\n我们将示例列表 list 传递给这个函数,将元素插入当前缓冲区。结果缓冲区的内容将是:\n你好,世界!世界!生活很美好,要面对现实\n这个函数确保列表的元素被连续插入缓冲区,同时不包含任何重复项,与要求一致。\n编写伪代码 在获取到最新内容时，使用正则匹配已经显示过内容，截取出新正的内容。然后插入到 buffer 的最后正则的规划， ^.*关键字.\\s* 关键字存在两种状态：\n必须是全局变量 第一次本地没有内容，不需要截取，需要将 Type 字段清理掉，然后复制给关键字，用于下一次正则匹配。 每次在截取完之后，将新增的内容复制给关键字。 依次类推。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 (setq gts-render-regkey \u0026#34;\u0026#34;) (setq gts-render-lastpoint (point)) ;; 正在输入中时，继续下一次请求，在请求过程中，可以先解析一步内容展示 (if-let* ((typing (string-suffix-p \u0026#34;_Typing…_\u0026#34; parsed)) ;; 每次先处理掉 Typing 后缀 (let ((point (point)) (regkey gts-render-regkey) (content (replace-regexp-in-string \u0026#34;\\n\\n_Typing…_\u0026#34; \u0026#34;\u0026#34; parsed))) ;; 第一次先记录 (if (= regkey \u0026#34;\u0026#34;) (setq regkey content) (progn (setq regkey (content (replace-regexp-in-string (format \u0026#34;^.*%s\u0026#34; regkey) \u0026#34;\u0026#34; content))) ) ) ;;将内容插入当前位置 (goto-char gts-render-lastpoint) (insert regkey) ;;更新到全局中存储: 新位置和正则关键字 (setq gts-render-lastpoint (point)) (setq gts-render-regkey regkey) ) ) (progn (message \u0026#34;Claude正在输入...\u0026#34;) ) ;; 否则，即为输入完成：展示 (insert \u0026#34;\\n\u0026#34; parsed \u0026#34;\\n\u0026#34;)) 在 go-translate 实现 render 渲染器 集成到项目正则实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 (setq gts-render-regkey \u0026#34;\u0026#34;) (setq gts-render-lastpoint (point)) (cl-defmethod gts-out ((_ gts-current-buffer-render) task) (deactivate-mark) (with-slots (err parsed) task (if err (user-error \u0026#34;%s\u0026#34; err) ;; 根据解析结果，判断状态： ;; 正在输入中时，继续下一次请求，在请求过程中，可以先解析一步内容展示 (if-let* ((typing (string-suffix-p \u0026#34;_Typing…_\u0026#34; parsed)) ;; (result (replace-regexp-in-string \u0026#34;\\n*\\s*_Typing…_.*\u0026#34; \u0026#34;\u0026#34; parsed)) ;; ) (progn (message \u0026#34;Claude正在输入...\u0026#34;) ;; 每次先处理掉 Typing 后缀 (let ((point (point)) (regkey gts-render-regkey) (content (replace-regexp-in-string \u0026#34;\\n\\\\{0,\\\\}_Typing…_\u0026#34; \u0026#34;\u0026#34; parsed))) ;; 第一次先记录 (if (string= regkey \u0026#34;\u0026#34;) (setq regkey content) (progn (message \u0026#34;正则匹配：%s\u0026#34; regkey) (setq regkey (replace-regexp-in-string (format \u0026#34;^.*%s\u0026#34; regkey) \u0026#34;\u0026#34; content)) (message \u0026#34;匹配匹配后的内容：%s\u0026#34; regkey) ) ) ;;将内容插入当前位置 (goto-char (point)) (insert regkey) ;;更新到全局中存储: 新位置和正则关键字 ;; (setq gts-render-lastpoint (point)) (setq gts-render-regkey regkey) )) ;; 否则，即为输入完成：展示 ;; (insert \u0026#34;\\n\u0026#34; parsed \u0026#34;\\n\u0026#34;) ) ))) 在项目中使用 substring 截取方式实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 (setq gts-render-stored \u0026#34;\u0026#34;) (cl-defmethod gts-out ((_ gts-current-buffer-render) task) (deactivate-mark) (with-slots (err parsed) task (if err (user-error \u0026#34;%s\u0026#34; err) ;; 根据解析结果，判断状态： ;; 正在输入中时，继续下一次请求，在请求过程中，可以先解析一步内容展示 (if-let* ((point (point)) (inserted gts-render-stored) (typing (string-suffix-p \u0026#34;_Typing…_\u0026#34; parsed)) ;; (result (replace-regexp-in-string \u0026#34;\\n*\\s*_Typing…_.*\u0026#34; \u0026#34;\u0026#34; parsed)) ;; ) (progn (message \u0026#34;Claude正在输入...\u0026#34;) ;; 每次先处理掉 Typing 后缀 (let ((content (replace-regexp-in-string \u0026#34;\\n\\\\{0,\\\\}_Typing…_\u0026#34; \u0026#34;\u0026#34; parsed))) ;;将内容插入当前位置 (goto-char (point)) (setq inserting (substring content (length inserted) (length content))) (insert inserting) ;;更新到全局中存储: 新位置和正则关键字 (setq gts-render-stored content) )) ;; 否则，即为输入完成：展示 (goto-char (point)) (setq inserting (substring parsed (length gts-render-stored) (length parsed))) (insert inserting \u0026#34;\\n\u0026#34;) ) ))) 通过模拟数据梳理处理规范 使用正则匹配 1 2 3 4 5 6 7 8 9 10 11 (let ((result \u0026#34;\u0026#34;) (new \u0026#34;\u0026#34;) (content \u0026#34;\u0026#34;)) (setq new \u0026#34;在Emacs Lisp中,循环允许你重复执行一系列表达式。主要有以下两种类型:\\n\\n1. while -\\n\\n_Typing…_\u0026#34;) (setq content \u0026#34;在Emacs Lisp中,循环允许你重复执行一系列表达式。主要有以下两种类型:\\n\\n1. while - 通过一个condition循环:\\n\\n```elisp\\n(while condition \\n (expression1)\\n (expression2) \\n ...) \\n```\\n\\n这会在condition\\n\\n_Typing…_\u0026#34;) ;; (setq new \u0026#34;_Typing…_\u0026#34;) (setq regkey (replace-regexp-in-string \u0026#34;\\n\\\\{0,2\\\\}_Typing…_\u0026#34; \u0026#34;\u0026#34; new)) (message \u0026#34;内容：%s\u0026#34; content) (setq result (replace-regexp-in-string (format \u0026#34;^.*%s\u0026#34; regkey) \u0026#34;\u0026#34; content)) (message \u0026#34;结果数据内容：%s\u0026#34; content) ) 使用 replace-string 方式处理字符串 1 2 3 4 5 6 ;; 直接替换的方式 (setq new \u0026#34;你好\u0026#34;) (setq content \u0026#34;你好,世界！\u0026#34;) (replace-string (format \u0026#34;%s\u0026#34; new) \u0026#34;\u0026#34; content) (message \u0026#34;内容：%s\u0026#34; new) (message \u0026#34;截取之后内容：%s\u0026#34; content) 1 截取之后内容：,世界！ substring 截取字符串 (substring string start \u0026amp;optional end)\n其中， string 是你要截取的字符串， start 是截取的起始位置， end 是截取的结束位置。如果省略 end 参数，那么将截取从 start 位置开始到字符串结尾的所有字符。\n以下是一个例子：\n1 2 (setq str \u0026#34;Hello, world!\u0026#34;) (setq sub-str (substring str 0 5)) ; 截取 \u0026#34;Hello\u0026#34; 以上代码中，我先定义了一个字符串 str=。然后，我使用 =substring 函数截取 str 的前五个字符，并将其赋值给 sub-str 变量。注意，字符串的索引是从 0 开始的。\n1 2 3 4 5 6 7 8 9 10 11 (let ((result \u0026#34;\u0026#34;) (new \u0026#34;\u0026#34;) (content \u0026#34;\u0026#34;)) (setq new \u0026#34;在Emacs Lisp中,循环允许你重复执行一系列表达式。主要有以下两种类型:\\n\\n1. while -\\n\\n_Typing…_\u0026#34;) (setq content \u0026#34;在Emacs Lisp中,循环允许你重复执行一系列表达式。主要有以下两种类型:\\n\\n1. while - 通过一个condition循环:\\n\\n```elisp\\n(while condition \\n (expression1)\\n (expression2) \\n ...) \\n```\\n\\n这会在condition\\n\\n_Typing…_\u0026#34;) ;; (setq new \u0026#34;_Typing…_\u0026#34;) (setq regkey (replace-regexp-in-string \u0026#34;\\n\\\\{0,2\\\\}_Typing…_\u0026#34; \u0026#34;\u0026#34; new)) (message \u0026#34;regkey长度：%s\u0026#34; (length regkey)) (setq result (substring content (length regkey) (length content))) (message \u0026#34;截取之后的：%s\u0026#34; result) ) 1 2 3 4 5 6 7 8 9 10 11 12 截取之后的： 通过一个condition循环: ```elisp (while condition (expression1) (expression2) ...) ``` 这会在condition _Typing…_ ","date":"2023-05-25T22:17:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/Claude%E8%BE%93%E5%87%BA%E7%8A%B6%E6%80%81%E5%9C%A8buffer%E4%B8%AD%E5%AE%9E%E7%8E%B0%E5%90%8C%E6%AD%A5/","section":"post","tags":null,"title":"扩展 go-translate 渲染器支持 Claude Typing 输入状态"},{"categories":["学习笔记"],"contents":"helm 功能 Helm是一个Emacs的框架,用于创建符合人体工程学的交互式工具。它有以下主要优点:\n简单且一致的交互方式\n使用相同的界面和按键绑定为许多功能提供接口,这样用户只需要学习一次就可以应用到所有 Helm 工具上。这大大降低了学习成本,让 Emacs 的各种功能更易于掌握。\n强大的过滤机制使用实时过滤,可以根据输入的字串快速过滤出相关选项,这使其非常适合处理长列表或大量数据。过滤器可以针对候选项的任何部分(标题,路径,标签等)进行操作。\n支持模糊匹配\n过滤不但支持精确匹配,还支持模糊匹配。这在处理长列表时提供了很大便利,只需要输入部分字母就可以过滤出相关选项。\n快速选择\n通过字母导航, Helm 允许使用户快速选择列表中的选项。无需从列表顶部逐一翻阅,用户可以直接输入选项的首字母快速定位。\n支持补全\n输入支持 Emacs 自带的补全功能。当用户输入部分字母时,Helm 会显示相关选项的补全提示,方便用户快速选择需要的项。\n可定制\n具有高度的可定制性,用户可以轻松定义新的 Helm 工具以满足特定需要。许多其他 Emacs 包都提供了 Helm 接口,这使得 Helm 的实用范围更加广泛。\n基于源\n工具基于多个命名源(source)运行,每个源返回一个候选项列表。这使得 Helm 可以同时搜索和过滤来自多个源的选项,比如查找文件时同时搜索多个目录。\n学习路径 在日常使用中，helm 是接触最多的，能够很方便提供，现在通过插件的自定义，扩展 prompt 查询和获取 prompt 的功能。\n现在根据比较常用的 helm 工具，可以基于现有的插件做集成，或学习自定义 prompt helm 插件。\n直接调用 helm 传入参数 基于 helm-org-ql 扩展支持 prompt 查询。 参考 helm-org-ql-views 的用法，学习 helm 数据源等，高级用法 参考 helm-org-capture-templates , 扩展 capture 模板的 helm ，学习相关用法 helm 数据源初始化方法 helm-make-source 参考 helm-org-ql-views-source 1 2 3 4 5 6 7 8 9 10 ;;;###autoload 通过 org-ql 获取数据源 ;; 通过 alist 列表中获取数据源 (defvar helm-org-ql-views-source (helm-make-source \u0026#34;Org QL Views\u0026#34; \u0026#39;helm-source-sync :candidates (lambda () (-\u0026gt;\u0026gt; org-ql-views (-map #\u0026#39;car) (-sort #\u0026#39;string\u0026lt;))) :action (list (cons \u0026#34;Show view\u0026#34; #\u0026#39;org-ql-view))) \u0026#34;Helm source for `org-ql-views\u0026#39;.\u0026#34;) helm-build-in-buffer-source 参考获取浏览器书签的方法 1 2 3 4 5 6 7 8 (defvar helm-chrome-history-source (helm-build-in-buffer-source \u0026#34;Edge History\u0026#34; :init #\u0026#39;helm-chrome-history-init :action (helm-make-actions \u0026#34;Browse URL\u0026#34; (lambda (x) (browse-url (car (split-string x \u0026#34;|\u0026#34;)))) \u0026#34;W3m URL\u0026#34; (lambda (x) (w3m (car (split-string x \u0026#34;|\u0026#34;))))))) 两个几个属性 :candidates 候选列表: helm 展示的文本和选择传递的内容，基于该项的格式定义。\n简单的候选项列表: :candidates '(\u0026quot;Item 1\u0026quot; \u0026quot;Item 2\u0026quot; \u0026quot;Item 3\u0026quot;) 候选项的assoc list: 1 2 3 :candidates \u0026#39;((\u0026#34;Item 1\u0026#34; . 1) (\u0026#34;Item 2\u0026#34; . 2) (\u0026#34;Item 3\u0026#34; . 3)) 在这种情况下,每个候选项都是一个 cons cell ,car 部位显示在 helm buffer 中,cdr部位是该候选项的值。\n:action 选中执行的事件: 支持 闭包的等实现。\n自定义 helm 数据源主要基于 org 文件文件中，需要了解 org-ql 的语法，知道如何将会 org-ql 结果数据，转换为 helm 的数据源等。\n1 2 3 4 5 6 7 (setq contents (org-ql-query :select \u0026#39;(org-get-entry) :from \u0026#34;~/hsg/iNotes/content-org/prompt/prompt.org\u0026#34; :where \u0026#39;(and (ancestors (heading gts-claude-session)) (heading \u0026#34;system\u0026#34;) ))) 基于 helm-org-ql 设置 AI prompt 声明处理 AI prompt 函数 helm-org-ql-AI-show-marker 添加到 helm-org-ql-actions 中。 调用 helm-org-ql 时，在选中条目时，Tab 键，跳转到actions 操作列表。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 ;; AI 选择Prompt 获取 system 的内容 (add-to-list \u0026#39;helm-org-ql-actions (cons \u0026#34;设置为 Claude 角色\u0026#34; \u0026#39;helm-AI-prompt-marker)) ;; 为helm-org-ql 添加自定义 action ;; 在 helm view 选择条目之后，处理条目下的内容获取。 (defun helm-AI-prompt-marker (marker) \u0026#34;Show heading at MARKER.\u0026#34; (interactive) (let ((role \u0026#34;\u0026#34;) (prompt \u0026#34;\u0026#34;) (start (marker-position marker)) ;;标记起始位置 ) (message \u0026#34;开始位置-----：%s\u0026#34; start) (with-current-buffer (marker-buffer marker) ;; (message \u0026#34;获取entry: %s\u0026#34; (org-get-entry)) ;; (setq prompt (org-get-entry)) (save-excursion (org-back-to-heading t) (goto-char marker) ;; 获取 helm 选择的条目的 title ，不包含 todo 优先级 标签等信息 (setq role (org-get-heading t t t)) (setq helm-calude-current-role role) ;; 获取 helm 选择条目的内容 ;; 例如：当选择的 prompt.org 中的 system 条目，就可以获取到 prompt 内容。 (setq prompt (buffer-substring-no-properties ;; start ;; 包含heading (line-beginning-position 2) ;; 不包含heading (org-end-of-subtree t))) (message \u0026#34;获取prompt: %s\u0026#34; prompt) ) ))) helm-AI-prompt 基于 helm-rog-ql 限制搜索的范围，仅展示 prompt.org 文件中的 heading 1 2 3 4 5 (defun helm-AI-prompt() (interactive) (helm-org-ql \u0026#34;~/hsg/iNotes/content-org/prompt/prompt.org\u0026#34; :name \u0026#34;AI prompt\u0026#34;) ) 1 helm-org-ql-AI-show-marker 基于 org-ql 定制 helm 查询 prompt helm-claude-role：基于 helm + org-ql-query 实现. 通过 query 语法定制 helm 数据源。\n显示 prompt.org 的一级heading\n声明交互函数，直接调用 helm 接口展示搜索页面\n1 2 3 4 5 6 7 8 9 10 ;; 基于 helm 直接封装 (defun helm-claude-role () (interactive) (helm :prompt (format \u0026#34; %s 切换角色为：\u0026#34; helm-calude-current-role) :sources helm-AI-prompt-source :buffer \u0026#34;*Helm AI prompt*\u0026#34; :full-frame nil ) ) 使用 org-ql-query 读取 prompt 库文件，初始化数据源\n通过 org-ql-query 屏蔽 system user 等级，限制 helm 显示的文本内容\n弊端：不支持 tags todo 等高级搜索\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ;; 为helm提供数据元数据 ;; 通过 org-ql-query 屏蔽 system user 等级，限制 helm 显示的文本内容 ;; 弊端：不支持 tags todo 等高级搜索 (defvar helm-AI-prompt-source (helm-make-source \u0026#34;Org QL Views\u0026#34; \u0026#39;helm-source-sync :candidates (lambda () ;; TODO 查询之后整理出列表格式，提供显示和action传值。 ;; 获取数据helm的数据源，通过不同方式整理成 helm支持的格式 list (org-ql-query :select \u0026#39;(list (org-get-heading) (org-get-heading t t t)) :from \u0026#34;~/hsg/iNotes/content-org/prompt/prompt.org\u0026#34; :where \u0026#39;(children))) :action (list ;; TODO 以这种格式添加选择之后的操作 ;; 1. 声明一个变量，传递给 go-translate 引擎 (cons \u0026#34;设置 prompt 名称\u0026#34; (lambda (x) (message \u0026#34;选择的heading:%s\u0026#34; (car x)) (setq helm-calude-current-role (car x)) )) )) ) 使用场景: 在 go-translate 中使用 AI prompt helm-claude-tranlate 使用方式\n需要先设置 helm-claude-current-role 角色，默认：英翻中 可以通过 helm 选择切换新角色，支持helm 的工具有： helm-org-ql : 新增了选择事件，在使用时，要确保条目来自prompt.org中，这样才能得到正确的 prompt，具体看 prompt.org 的结构 helm-AI-prompt：基于 helm-org-ql ,仅限制了在 prompt.org 文件中搜索,其他功能一样 helm-claude-role：基于 helm + org-ql-query 实现，通过query 语法 helm 数据源，显示 prompt.org 的一级heading 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 (setq helm-calude-current-role \u0026#34;英翻中\u0026#34;) (defvar helm-claude-translater (gts-translator :picker (lambda () (cond ((equal helm-calude-current-role \u0026#34;英翻中\u0026#34;) (gts-noprompt-picker :texter (gts-current-or-selection-texter))) ((equal helm-calude-current-role \u0026#34;内容总结\u0026#34;) (gts-paragraph-picker)) (t (gts-prompt-picker)))) :engines (lambda () (gts-claude-engine :auth-key slack-claude-bot-token :channel \u0026#34;D052Y13FSRY\u0026#34; :system helm-calude-current-role) ) :render (lambda () (cond ((equal helm-calude-current-role \u0026#34;英翻中\u0026#34;) (gts-posframe-pop-render) (t (gts-buffer-render)))) ))) (defun helm-claude-tranlate () (interactive) (gts-translate helm-claude-translater)) 参考代码片段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 (cl-defun helm-org-ql-source (buffers-files \u0026amp;key (name \u0026#34;helm-org-ql\u0026#34;)) \u0026#34;Return Helm source named NAME that searches BUFFERS-FILES with `helm-org-ql\u0026#39;.\u0026#34; ;; Expansion of `helm-build-sync-source\u0026#39; macro. (helm-make-source name \u0026#39;helm-source-sync :candidates (lambda () (let* ((query (org-ql--query-string-to-sexp helm-pattern)) (window-width (window-width (helm-window)))) (when query (with-current-buffer (helm-buffer-get) (setq helm-org-ql-buffers-files buffers-files)) (ignore-errors ;; Ignore errors that might be caused by partially typed queries. (org-ql-select buffers-files query :action `(helm-org-ql--heading ,window-width)))))) :match #\u0026#39;identity :fuzzy-match nil :multimatch nil :nohighlight t :volatile t :keymap helm-org-ql-map :action helm-org-ql-actions)) ;;; Org capture templates ;; ;; (defvar org-capture-templates) (defun helm-source-org-capture-templates () \u0026#34;Build source for org capture templates.\u0026#34; (helm-build-sync-source \u0026#34;Org Capture Templates:\u0026#34; :candidates (cl-loop for template in org-capture-templates collect (cons (nth 1 template) (nth 0 template))) :action \u0026#39;((\u0026#34;Do capture\u0026#34; . (lambda (template-shortcut) (org-capture nil template-shortcut)))))) (defun helm-org-capture-templates () \u0026#34;Preconfigured helm for org templates.\u0026#34; (interactive) (helm :sources (helm-source-org-capture-templates) :truncate-lines helm-org-truncate-lines :buffer \u0026#34;*helm org capture templates*\u0026#34;)) ","date":"2023-05-25T03:59:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%87%AA%E5%AE%9A%E4%B9%89helm%E6%94%AF%E6%8C%81%E6%9F%A5%E8%AF%A2prompt%E5%BA%93/","section":"post","tags":null,"title":"基于 helm-org-ql 自定义 helm 检索 prompt.org 库"},{"categories":["学习笔记"],"contents":"Budget your time with org-mode!\nUsage Adding budgets 您可以通过自定义 org-clock-budget-intervals 来指定要使用的间隔。\n目前四个间隔是内置的，week，month，季度(3个月从1月1日开始的时间段)和年份。要在任务上添加预算，请添加一个属性( C-c C-x p ): BUDGET_WEEK, BUDGET_MONTH ， BUDGET_QUARTER, BUDGET_YEAR\n此外,用户也可以通过为 org-clock-budget-intervals 提供名称和计算 (FROM . TO) 区间的函数来定义自己的区间。\n属性可以容纳两种类型的值,要么是一个数,然后被解释为分钟数,要么是一个 HH:MM 字符串,以明显的方式解析。\n预算是重复的,这意味着每个后续区间将获得与上一个区间相同的预算。您可以移除属性以删除预算。\n您可以指定一天中要为预算(即 可预算的 )保留的小时数。这是通过 org-clock-budget-daily-budgetable-hours 配置的。默认值为12小时,假设8小时工作日和4小时的休闲活动。每个预算区间的小时数是根据该区间的天数计算得出的,即一周7天,一个月28-31天,等等。\nRunning reports 运行 org-clock-budget-report 命令会生成 org mode 中的时间分配报告,报告中:\n您可以点击名称跳转到相应任务 各列可以通过按 s 键进行排序,再按一次 s 键反向排序 g 键重新加载报告,更新报告内容 org mode通过 ~org-clock-budget-report 为我们生成的不仅是一个静态报告,更是一个富有交互性的时间管理工具。这些交互功能可以极大地增强报告的可用性,让我们可以不仅停留在查看报告,更可以对数据进行操作与分析。\n时间管理的关键在于理解细节和掌握最新动态。 org-clock-budget-report 通过这组交互功能达成了这个目标,成为 org mode 时间追踪体系中一个核心与关键的报告工具。\nThis is how the report looks:\n对于每个启用的时间区间,您将得到三列:\n首先是预算,然后是实际点击时间,最后是使用预算的百分比。\n当超过100%时,意味着超支。\n各组的排序方式(水平)与 org-clock-budget-intervals 相同。所以,这个报告告诉我们:\norg-clock-budget-report 会生成一定时间区间(interval)的报告,需要先通过 org-clock-budget-intervals 启用这些间隔 每个间隔会有三列数据: 预算:我们为该间隔设置的预算时间 实际点击时间:在该间隔内实际花费的时间 百分比:实际点击时间占预算时间的百分比 当百分比超过100%时,表示我们超出了该间隔的预算,超支了 各间隔在报告中的显示顺序与我们在 org-clock-budget-intervals 中设置的相同 所以,从这个报告中,我们可以清晰地看到:\n每个时间间隔的预算时间和实际花费时间之间的对比关系 是否有某些间隔超支,超出了预算 整体来说,我们的时间分配是否过于集中在某一个时间区间 org-clock-budget-report 通过这种简洁的三列报告格式,让我们可以直观清晰地理解时间使用情况与分配是否合理。当我们的时间管理出现问题时,它也可以快速地指出问题所在,让我们有针对性地进行优化与调整。\n该报告还包括一行,描述从该时间区间内已经预算了多少小时,以及还可以分配给某项活动的小时数:\n1 2 3 4 5 6 7 8 9 10 11 | Task | Y budget | Y clocked | Y C/G | M budget | M clocked | M C/G | W budget | W clocked | W C/G | |---------------------+----------+-----------+-------+----------+-----------+-------+----------+-----------+-------| ... ... | Budgeted/Clocked | 3502:00 | 1468:06 | 41.9% | 122:00 | 50:05 | 41.1% | 75:20 | 0:00 | 0.0% | |---------------------+----------+-----------+-------+----------+-----------+-------+----------+-----------+-------| | Budgetable hours | 4392:00 | 890:00 | 79.7% | 372:00 | 250:00 | 32.8% | 84:00 | 8:40 | 89.7% | 最后一行为图例: ^总预算小时数 ^剩余时间预算 ^ 预算工时与总工时的比例 自定义颜色使用 org-clock-budget-ratio-faces 和 org-clock-budgeted-ratio-faces .\nF.A.Q. 这与 effort 工作量估算有何不同? 工作量是对完成一项任务所需时间的估计。您可能会逾期或提前完成，这没关系，因为估算是一种猜测。然而，时间/时钟预算是一个固定的数量，你不能逾期。一个每周工作40小时的人只有大约40小时的空闲时间(5个工作日5小时，周末2 × 10小时)，就是这样。\n为了计划你的任务，你使用工作量估算，为了在几周或几个月内安排它们，你使用 budget 预算(有时称为能力或目标)。在做计划时，您使用 effort 估算任务的工作量：例如几天和几周，月等。现在也可以选择 budget 来做（有时称为 容量 或 目标 ）。例如，你可能有一个任务，估计需要30个小时，你希望用3周的时间来完成它。因此，你应该每周花10个小时来完成这个任务，而不是更多，把剩下的时间分配给其他任务。如果你估计的时间太少，你可以简单地将这段时间再延长10个小时。如果时间太多，你可以把剩余的时间重新分配到其他任务上。\n我为什么要预算我的时间? 资源分配是有效性的基础。 有了一个有目的的商业，您不会因为考虑该怎么做而感到不知所措。 一旦您用完所有的时间，就意味着您需要在其他方面进行工作。这种方式可以在不同的任务上分配工作以避免倦怠。与基本计划相关，这可能会导致令人惊讶的“管理”时间节省。\n我应该什么时候评估时间? “推荐”的工作流量是每周（或每周一次）的重复任务称为“下周计划”（两周/月\u0026hellip;），在那里您可以固定您的任务并完善您的评估，回顾过时的任务等。 根据您的熟练程度，这可能需要10到60分钟。要想达到不浪费不必要的时间，同时在一周内摆脱所有认知负担的最佳状态，可能需要一些练习和纪律。\n","date":"2023-05-25T03:07:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/org-clock-budget%E6%8F%92%E4%BB%B6%E7%BF%BB%E8%AF%91/","section":"post","tags":["翻译"],"title":"翻译 org-clock-budget 时间管理插件的用法"},{"categories":["学习笔记"],"contents":"目标：借助claude 的结构，请求结果，然后插入到当前位置。\n现在已经在 go-translate 找到了最佳的交互方式，只要通过 elisp 调用 slack api 就可以实现翻译工具的扩展。\n现在要做的几件事情\n阅读 org-translate 翻译引擎的扩展方法 使用 elisp 实现 slack api ，获取 claude 的回答。 后续：不仅翻译，还可以通过 prompt 设置不同的角色，和 capture 整合，和 agenda 整合的，都迎刃而解了。 实现 claude 基于 web api 使用轮询的方式获取 claude 的回复内容，然后给 gts render 中。\n过程中需要了解 elisp 语法，了解 go-translate 源码,根据 readme 基本了解设计思路之后，开始开发 claude 引擎。\n先参考已实现的引擎，在作者的实现中找灵感，思路。可以先从 youdao 半成品来了解基本的架构。\n以开发引擎为主，主要包含几个方面\n引擎类属性： 是定义参数，暴漏给用户，设置必要的个人信息和权限的内容。 引擎解析器：需要先声明类，在通过 gts 框架中提供的模型，实行对元数据的分析。 引擎本体：主要和 api 交互，难道数据源，交付给解析器，然后渲染操作。 按照思路简单模式实现接口逻辑 使用 elisp 实现 http API 调用，返回值为实现slack 接口调用\n在写引擎本体的过程中，面对的挑战：\n获取用户的输入,存在task中： 获取方式 (oref task text) ，具体要了解 task 结构，它提供了很多重要的信息。解析完成的内容最终存在这里。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 (defclass gts-task () ((id :initform (gensym)) (text :initarg :text :documentation \u0026#34;Text that sent to engines. It maybe contains delimiters\u0026#34;) (from :initarg :from) (to :initarg :to) (raw :initform nil :documentation \u0026#34;raw result responsed by the http-client\u0026#34;) (parsed :initform nil :initarg :parsed :documentation \u0026#34;result parsed by parser, string or list\u0026#34;) (err :initform nil :initarg :err :documentation \u0026#34;error info\u0026#34;) (meta :initform nil :initarg :meta :documentation \u0026#34;extra info passed from parser to render. tbeg/tend\u0026#34;) (engine :initarg :engine :initform nil) (render :initarg :render :initform nil) (translator :initarg :translator :initform nil))) claude API 集成因为是基于 claude web api 聊天接口，这个过程设计到两个接口，一个是发送用户信息给claude，开启一次聊天。然后，通过一个获取聊天历史记录的接口中获取 claude 的聊天记录。\nclaude 回复是断续的，就像 chatgpt 在聊天过程中，不断输入的状态，所以从聊天记录接口中获取的内容也就是不断更新的。需要用到轮询的方式，等待 claude 输入完成，之后，表示一次聊天成功。\n基于这种状态，就需要用到聊个前嵌套的接口来实现接口调用。\n先说思路：第一先使用发送用户信息的接口，创建会话，等会话回调成功，再调用聊天历史接口，开始定时轮询，等待回复完成。\n封装请求方法, 支持 对话，和 获取回复的两个接口。\n认证方式：Authorization ，需要新建机器人，获取相关权限和 token 新建对话 API 和 入参是 chat.postMessage?channel=SlackChannel\u0026amp;as_user=true\u0026amp;text=Text 通过历史记录获取回复的借口： ?channel=SlackChannel\u0026amp;limit=limit\u0026amp;pretty=1\u0026amp;oldest=oldest 借助 babel 实现简单的逻辑 在 elisp 中声明一个请求 http API的接口，该接口返回一个字符串，前三次返回的内容以“__typeing…“结尾，第四次返回不含“__typeing…“。请一个实现http请求，递归发出请求，直到接口返回的内容不含“__typeing…“字符时，停止，然后返回最后一次响应的结果。\n函数1 作为 API 入口，函数2 作为第一次请求的数据 函数3 作为第二次请求的数据 让后调用API 处理结果返回。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 ;; 函数1 实现作为API 入口 (cl-defmethod translate1 (text task) ;;拿到初始数据，返回翻译结果 (message \u0026#34;启动翻译引擎\u0026#34;) (talkaction text (lambda () ;;talk完成回调 (message \u0026#34;talk 完成回调--\u0026#34;) (message \u0026#34;开始下一个任务%s\u0026#34; task) )) ) (defun talkaction(text block) (message \u0026#34;创建对话\u0026#34;) ;;开始请求服务器，处理业务 (requestServer text (lambda (result) (message \u0026#34;原始数据：%s \\n 处理数据%s\u0026#34; text result) (funcall block) ;; (funcall translateblock) )) ) (defun requestServer (text blocke) (message \u0026#34;服务器---\u0026#34;) (let ((result (format \u0026#34;%s成功\u0026#34; text))) ;;在执行回调闭包 (funcall blocke result) ) ) (translate1 \u0026#34;你好\u0026#34; \u0026#34;订阅监听\u0026#34;) 1 开始下一个任务订阅监听 在使用 elisp 闭包嵌套出现的问题 在两个定义两个函数相互调用，通过闭包的方式传递上下文环境过程中，出现在网络回调的闭包中无法访问入参闭包的情况。\n代码如下：\n新建对话的函数，入参包含从引擎中传递的 done 闭包，在回调中 (funcall done) ,就会出现上述的问题，出现对话失败的提示。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (defun new-claude-talk (engine done) (with-slots (talkurl auth-key channel user talk-time) engine (setq turl (format talkurl channel (url-hexify-string user))) (setf talk-time (float-time (car (current-time)))) (gts-do-request turl :headers `((\u0026#34;Authorization\u0026#34; . ,(format \u0026#34;Bearer %s\u0026#34; auth-key))) :done (lambda () (funcall done) ) :fail (lambda (err) (message \u0026#34;对话失败:%s\u0026#34; err) )) ) ) 引擎中的代码实现这是引擎的实现入口，调用上一步的网络请求，发起会话。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 (cl-defmethod gts-translate-old ((engine gts-claude-engine) task rendercb) (with-slots (user talk-time) engine (setf user (oref task text)) (message \u0026#34;用户正式输入：%s\u0026#34; (oref engine user)) (gts-with-token engine (lambda () (message \u0026#34;user对话内容\u0026#34;) (with-slots (text) task ;; 获取时间戳 (message \u0026#34;对话时间：%s\u0026#34; (oref engine talk-time)) (message \u0026#34;对话内容：%s\u0026#34; text) ) (subscribe-claude-request engine talk-time (lambda () (message \u0026#34;完成开始绘制 -- \u0026#34;) (gts-update-raw task (buffer-string)) (gts-parse (oref engine parser) task) (funcall rendercb) ) ) ) (lambda (err) (gts-render-fail task (format \u0026#34;获取令牌密钥时出错，请检查您的网络和代理，或稍后重试\\n\\n%s\u0026#34; err)))) ) ) 轮询接口的实现，在第一步新建会话完成时，会触发方法的调用。主要依赖第一个接口回调回来的时间戳，其实在分析之口，为了避免传参问题，时间戳完全可以获取当前时间。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 (defun subscribe-claude-request (engine time done fail) \u0026#34;Request an HTTP API and return response when it does not end with \u0026#39;__typing...\u0026#39;.\u0026#34; (with-slots (subscribeurl auth-key channel) engine (message \u0026#34;获取时间戳：%s\u0026#34; time) (let ((json) (subscribe (format subscribeurl channel time))) (gts-do-request subscribe :headers `((\u0026#34;Authorization\u0026#34; . ,(format \u0026#34;Bearer %s\u0026#34; auth-key))) :done (lambda () (let (beg end json) (re-search-forward \u0026#34;^[0-9]+$\u0026#34;) (setq beg (point)) (re-search-forward \u0026#34;^\\\\([0-9]+\\\\)$\u0026#34;) (setq end (- (point) (length (match-string 1)))) (setq json (json-read-from-string (string-trim (buffer-substring-no-properties beg end)))) json)) :fail fail) (dolist (object (plist-get json :messages)) (setq oldest (plist-get object :ts)) (setq result (plist-get object :text))) (if (or (= (length result) 0) (string-match \u0026#34;_Typing\\\\.\\\\.\\\\._\u0026#34; result)) ;; 如果响应以 _typing..._ 结尾,递归调用 (subscribe-claude-request engine time done fail) ;; 否则直接返回响应 ) (funcall done) ))) 获取当前时间戳的脚本\n1 (time-to-seconds (current-time)) 1 1684952067.575853 该代码将返回从Unix纪元（1970年1月1日UTC）开始到当前时间的秒数。\n","date":"2023-05-25T02:29:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/claude%E6%8F%92%E4%BB%B6%E9%9B%86%E6%88%90%E5%88%B0go-translate/","section":"post","tags":null,"title":"写一个 claude emacs 翻译工具客户端"},{"categories":["学习笔记"],"contents":"Agenda-like views Function: org-ql-block 要用作自定义 agenda 议程块，请键入 org-agenda-custom-commands 。例如，您可以像这样定义一个自定义系列命令，它将在单个缓冲区中列出 Tag 为 emacs ,所有优先级 A 项，其中 todo 状态为 SOMEDAY ，后面跟着标准 agenda 议程视图:\n1 2 3 4 5 6 7 (setq org-agenda-custom-commands \u0026#39;((\u0026#34;ces\u0026#34; \u0026#34;Custom: Agenda and Emacs SOMEDAY [#A] items\u0026#34; ((org-ql-block \u0026#39;(and (todo \u0026#34;SOMEDAY\u0026#34;) (tags \u0026#34;Emacs\u0026#34;) (priority \u0026#34;A\u0026#34;)) ((org-ql-block-header \u0026#34;SOMEDAY :Emacs: High-priority\u0026#34;))) (agenda))))) 这相当于像这样的 tags-todo 搜索:\n1 2 3 4 (setq org-agenda-custom-commands \u0026#39;((\u0026#34;ces\u0026#34; \u0026#34;Custom: Agenda and Emacs SOMEDAY [#A] items\u0026#34; ((tags-todo \u0026#34;PRIORITY=\\\u0026#34;A\\\u0026#34;+Emacs/!SOMEDAY\u0026#34;) (agenda))))) 但是， org-ql-block 版本的运行时间大约是原来的1/5。\n变量 org-ql-block-header 可以绑定到一个字符串作为 header，否则会自动生成 header。\nListing / acting-on results Caching Org 使用逐缓冲区缓存来加速后续搜索。\n它以查询表达式和匹配操作为关键字，这意味着，对于相同缓冲区中的相同查询和相同匹配操作，如果自上次运行查询以来缓冲区未被修改，则将返回缓存的匹配操作结果，并且不会在该缓冲区中再次求值查询。\n因此，由于在调用以下函数时，查询表达式和匹配操作都不能保证被求值，因此它们应该没有副作用。或者，如果需要副作用，则缓存应该无效(例如，通过增加缓冲区的修改标记，或通过使用尚未缓存的查询表达式或匹配操作)。\n注:未来的改进将允许更容易地禁用或清除缓存.\nFunction: org-ql-select 参数: (buffers-or-files query \u0026amp;key action narrow sort) 返回值： QUERY 查询条件 在 BUFFERS-OR-FILES buffer 或文件中匹配到的条目.\nBUFFERS-OR-FILES 是一个或多个文件或缓冲区。\nQUERY 是一个 org-ql 查询语句 sexp (引号，因为这是一个函数)。\nACTION 是一个函数，它在每个匹配的目标题开头的位置上调用。可能是:\nelement or nil: 相当于 org-element-headline-parser.\nelement-with-markers: 相当于调用 org-element-headline-parser,用加 org-ql--add-markers 上标记. 适合使用 org-ql-agenda--format-element 进行格式化, 允许插入到 Org Agenda-like buffer 中.\nA sexp, 它将被字节编译为lambda函数。\nA function symbol.\n如果 NARROW 为非空值，则不会对缓冲区进行展开(默认是展开并搜索整个缓冲区)。 SORT 为 nil，在这种情况下，条目不作排序;或者一个或一组定义的 org-ql 排序方法(date, deadline, scheduled, closed, todo, priority, or random); 或者一个用户定义的比较器函数，它接受两个项作为参数并返回 nil 或 non-nil。\nExamples:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 ;; Return list of to-do headings in inbox file with tags and to-do keywords: (org-ql-select \u0026#34;~/org/inbox.org\u0026#34; \u0026#39;(todo) :action #\u0026#39;org-get-heading) ;; =\u0026gt; (\u0026#34;TODO Practice leaping tall buildings in a single bound :personal:\u0026#34; ...) ;; Without tags and to-do keywords: (org-ql-select \u0026#34;~/org/inbox.org\u0026#34; \u0026#39;(todo) :action \u0026#39;(org-get-heading t t)) ;; =\u0026gt; (\u0026#34;Practice leaping tall buildings in a single bound\u0026#34; ...) ;; Return WAITING heading elements in agenda files: (org-ql-select (org-agenda-files) \u0026#39;(todo \u0026#34;WAITING\u0026#34;) :action \u0026#39;element) ;; =\u0026gt; ((headline (:raw-value \u0026#34;Visit the moon\u0026#34; ...) ...) ...) ;; Since `element\u0026#39; is the default for ACTION, it may be omitted: (org-ql-select (org-agenda-files) \u0026#39;(todo \u0026#34;WAITING\u0026#34;)) ;; =\u0026gt; ((headline (:raw-value \u0026#34;Visit the moon\u0026#34; ...) ...) ...) Function: org-ql-query 参数: (\u0026amp;key (select 'element-with-markers) from where order-by narrow)\nLike org-ql-select, 但是参数的命名更像 SQL 查询.\nSELECT 作用等价于 org-ql-select 的 ACTION 功能. FROM 作用等价于 org-ql-select 的 BUFFERS-OR-FILES 的功能. WHERE 作用等价于 org-ql-select 的 QUERY 功能. ORDER-BY 作用等价于 org-ql-select 执行 SORT 功能. NARROW 作用等价于 org-ql-select 执行 NARROW 功能. Examples:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 ;; Return list of to-do headings in inbox file with tags and to-do keywords: (org-ql-query :select #\u0026#39;org-get-heading :from \u0026#34;~/org/inbox.org\u0026#34; :where \u0026#39;(todo)) ;; =\u0026gt; (\u0026#34;TODO Practice leaping tall buildings in a single bound :personal:\u0026#34; ...) ;; Without tags and to-do keywords: (org-ql-query :select \u0026#39;(org-get-heading t t) :from \u0026#34;~/org/inbox.org\u0026#34; :where \u0026#39;(todo)) ;; =\u0026gt; (\u0026#34;Practice leaping tall buildings in a single bound\u0026#34; ...) ;; Return WAITING heading elements in agenda files: (org-ql-query :select \u0026#39;element :from (org-agenda-files) :where \u0026#39;(todo \u0026#34;WAITING\u0026#34;)) ;; =\u0026gt; ((headline (:raw-value \u0026#34;Visit the moon\u0026#34; ...) ...) ...) ;; Since `element\u0026#39; is the default for SELECT, it may be omitted: (org-ql-query :from (org-agenda-files) :where \u0026#39;(todo \u0026#34;WAITING\u0026#34;)) ;; =\u0026gt; ((headline (:raw-value \u0026#34;Visit the moon\u0026#34; ...) ...) ...) Macro: org-ql (deprecated) 参数: (buffers-or-files query \u0026amp;key sort narrow markers action) org-ql 扩展为对 org-ql-select 的调用，带有相同的参数。为方便起见，参数应该不加引号。\nNote: 此宏已弃用，并将在 v0.7 移除.\nCustom predicates TODO Macro: org-ql-defpred 参数: (name args docstring \u0026amp;key body preambles normalizers)\n定义一个 org-ql 选择器谓词，命名为 org-ql——predicate-NAME 。\nNAME 可以是一个符号或一个符号列表:如果是一个列表，第一个被用作 NAME ，其余的是别名。 A 函数仅为 NAME 创建，而不是为别名创建，因此应该使用规范化器在查询中用 NAME 替换别名(继续阅读)。\nARGS 是一个 cl-defun 风格的参数列表。 DOCSTRING 是函数的注释内容。\nBODY 是谓词的主体。\n它将在一个 org 标题的开头进行匹配，如果标题的条目是匹配的，它应该返回 non-nil。\nPREAMBLES 和 NORMALIZERS 是与 org-ql 查询示例匹配的 pcase 表单列表。\n它们在函数 org-ql——query-preamble 和 org-ql——normalize-query 的定义中拼接成 pcase 形式，见。这些函数在展开宏时被重新定义，除非变量 org-ql-defpred-defer 为 non-nil，在这种情况下，应该在调用 org-ql--define-query-preamble-fn 和 org-ql--define-normalize-query-fn 定义谓词后手动重新定义这些函数.\nNORMALIZERS 用于将查询表达式规范化为标准形式。\n例如，当谓词有别名时，应该使用 normalizer 规范化器将别名替换为谓词名称。此外，谓词参数可以采用更优化的形式，以便谓词在查询时要做的工作更少。注意:在查询完全规范化之前，normalizer 规范化器会反复应用于查询，因此应该仔细编写规范化器以避免无限循环。\nPREAMBLES 引用正则表达式，可用于直接在缓冲区中搜索潜在的匹配项，而不是在每个标题上测试谓词体。(命名是困难的) 在 PREAMBLES 中的每个 pcase 形式里， pcase 表达式(不是模式)应该是一个具有以下键的列表，每个键的值应该是一个表达式，可以引用模式中绑定的变量:\n:regexp 直接搜索到潜在匹配项的正则表达式。\n:case-fold 绑定 case-fold-search 的正则表达式搜索\n:query 应该替换查询表达式的表达式，或者不应该更改的 query (例如，如果 regexp 不足以确定标题是否匹配，在这种情况下，需要在标题上测试谓词的主体)。如果 regexp 保证匹配，这可能只是 t ，使查询表达式无需做任何工作，从而提高了性能。\n为方便起见，在 pcase 模式中，符号 predicate-names 是一种特殊的形式，它被替换为匹配谓词的任何名称和别名的模式。\n例如，如果 NAME 是: (heading h)\n然后,如果 NORMALIZERS 是: ((`(,predicate-names . ,args) `(heading ,@args)))\n(heading h) 将解释为: ((`(,(or 'heading 'h) . ,args) `(heading ,@args)))\n","date":"2023-05-20T10:59:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/org-ql%E5%87%BD%E6%95%B0%E5%92%8C%E5%AE%8F%E5%86%85%E5%AE%B9%E7%BF%BB%E8%AF%91/","section":"post","tags":null,"title":"介绍org-ql函数和宏的用法"},{"categories":["学习笔记"],"contents":"org-ql-find 使用 emacs 的内置补全工具和一个 org-ql 查询选择的标题实现跳转:\norg-ql-find 在当前缓冲区中搜索。 org-ql-find-in-agenda searches in (org-agenda-files). org-ql-find-in-org-directory searches in org-directory. org-ql-refile 此命令将当前的 org 条目重新归档到通过使用 org-ql 补全进行搜索所选择的条目中。它搜索 org-refile-targets 中列出的文件以及当前缓冲区。\norg-ql-search 读 QUERY 和用 org-ql 搜索 。以交互方式提示输入这些变量:\nBUFFERS-FILES: A 搜索 一个 buffer 列表/文件列表。互动，也支持是:\nbuffer: 搜索当前缓冲区 all: 搜索所有组织缓冲区 agenda: 搜索函数 org-agenda-files 返回的缓冲区列表 是一个用空格分隔的文件或缓冲区名称的列表. GROUPS: 设置一个 org-super-agenda 分组 . 参见 org-super-agenda-groups.\nNARROW: 当非nil时，在搜索之前不要展开缓冲区。交互式的，带前缀，留窄。\nSORT:一个或一组 org-ql 排序函数，如 date 或 priority 。\n快捷键: 键绑定在结果缓冲区中\nr: 刷新结果。带前缀，提示调整搜索参数。 v: 展示 transient view dispatcher(像 magit 的弹出窗口)。 C-x C-s: 将查询保存到变量 org-ql-views (可通过命令 org-ql-view 访问)。 Note: 视图缓冲区当前处于 org-agenda-mode ，这意味着 some Org Agenda 命令可以工作，例如跳转到 entry 和更改 item 优先级(不必更新视图)。此功能是实验性的，不能保证对所有命令都能正确工作。(它之所以有效，是因为在每个项目上放置了适当的文本属性，模仿议程缓冲区。)\nhelm-org-ql 该命令显示与helm的匹配。\n在helm会话中按 C-x C-s 将结果保存到 org-ql-search 缓冲区中。 org-ql-view 选择并显示存储在 org-ql-views 中的视图。\nBindings: buffer 已绑定的快捷键说明\ng, r: Refresh results. With prefix, prompt to adjust search parameters. v: Show transient view dispatcher (like Magit\u0026rsquo;s popups). C-x C-s: 将查询保存到变量 org-ql-views (可通过命令 org-ql-view 访问)。 org-ql-view-sidebar 显示一个侧边栏窗口，列出存储在 org-ql-views 中的视图，以便于访问。在侧边栏中，按 RET 或 mouse-1 显示该点的视图，并按 c 自定义该点的视图。\norg-ql-view-recent-items 显示 FILES 中最近 DAYS 天的项目，时间戳为 TYPE 。\nTYPE 支持这些类型： ts, ts-active, ts-inactive, clocked, closed, deadline, planning, or scheduled.\nFILES 默认为函数 org-agenda-files 返回的文件。\norg-ql-sparse-tree 参数: (query \u0026amp;key keep-previous (buffer (current-buffer)))\n在 BUFFER 中显示 QUERY 的稀疏树，并返回结果的个数。该树将显示查询匹配的行，以及在 org-show-context-detail 中定义的任何其他上下文，如所示。\nQUERY 是一个 org-ql 查询 sexp(引号，因为这是一个函数)。 BUFFER 默认为当前缓冲区。当 KEEP-PREVIOUS 为 non-nil 时(在查找匹配项之前)，大纲不会重置为概述状态，这允许对该命令进行嵌套调用。在生成稀疏树后运行 org-occur-hook 。\n","date":"2023-05-20T09:54:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/org-ql%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E7%9A%84%E7%BF%BB%E8%AF%91/","section":"post","tags":["翻译"],"title":"介绍 org-ql 常用命令"},{"categories":["日志随笔","学习笔记"],"contents":"在 capture 中支持 tag 的选择，tag 可以分类，扩展AI分类，以 prompt 的 title 作为 tag 值。在调用 gpt 之前，只需要设定 tag 就行了。\n例如：想使用 写作助理的角色，完成一下操作\n现在 tag 分组中添加角色名称 再添加 tag 到 headline 上 在请求之前，使用 tag 值匹配 prompt 模块的名称，然后就可以为 gptel 设置 system 了。 难点： 如何通过 tag 获取 prompt，有几种方案\n依赖 json 文件，通过解析 json 文件，匹配到 prompt 直接从 prompt.org 文件中获取 手动解析 org-element 数据，在进行匹配操作 借助第三方库 org-ql 实现快速检索 org 文件的内容，获取到 prompt 在支持 tag 功能之后，将很大的改进 gptel 使用场景：\n在 capture 中，就可以通过 tag 方式,设置 prompt 。 在 org 文件时，当前光标的位置调用 gptel ，只要设置 tag , gptel 就以设置的 prompt 方式回答问题。 需要做那些工作\n使用 org-ql 查询 tag 匹配的 prompt\n使用 org-ql 获取 prompt 库中内容\n替换 gptel 自定义方法中，调试功能\n在继承过程中发现遗留问题：\norg-ql query 的 where 语法中, 例如：提示type格式问题。 1 2 3 (setq type \u0026#34;hello world\u0026#34;) (org-ql-query :from \u0026#34;file\u0026#34; :where \u0026#39;（heading type)) 使用 org-get-entry 获取条目内容职能得到第一行的内容 从 capture 中无法拿到 tags ,目前通过添加 org-capture 属性的传递模板类型。意味着无法在 capture 过程中，使用 tag 设置的机制，设置 prompt。 使用 org-ql 解析 prompt.org 数据 以下面格言书 prompt 格式为例子，获取 prompt 子目录 system 条目中的内容\n1 2 3 4 5 6 7 8 9 * 格言书 :文本:AI: :PROPERTIES: :remark: 根据问题输出鼓舞人心的名言和有意义的格言。 :END: ** system 我希望你能充当一本箴言书。对于我的问题，你会提供明智的建议、鼓舞人心的名言和有意义的谚语，以帮助指导我的日常决策。此外，如果有必要，你可以提出将这些建议付诸行动的实际方法或其他相关主题。 ** user 我的问题是: org-ql/READ-zh.org\norg-ql/examples.org\n在学习 org-ql 的基本用法，需要使用 org-ql 的 ancestors 特性：\n子节点条件语法： (ancestors (heading \u0026ldquo;tag名称\u0026rdquo;)),该表达式是要求匹配的条目必须有父级条目，使用嵌套语法要求父条目名称为 tag 的名称。\n这样 select 返回的是 system 条目的 org-element 元数据。\n再通过 select 语句明确要返回条目的内容类型,例如获取 system 条目下的文本类型: :select '(org-get-entry)\n1 2 3 4 5 6 7 (org-ql-query :select \u0026#39;(org-get-entry) :from \u0026#34;~/hsg/iNotes/content-org/prompt/prompt.org\u0026#34; :where \u0026#39;(and (tags \u0026#34;AI\u0026#34;) (ancestors (heading \u0026#34;内容总结\u0026#34;)) (heading \u0026#34;system\u0026#34;) )) 请将我提供的每篇文字都概括为 100 个字，使其易于阅读和理解。避免使用复杂的句子结构或技术术语。 下面根据具体场景,将上面的查询方法，封装一下获取 prompt 目录下 system 和 user 的内容.\n获取字符串一级条目的 AI 标签 在实际需求中，需要先从 capture 的字符串的内容中获取用户设置的 AI 标签，然后提供给处理 prompt.org 使用。\n这个方法主要两个参数：\norg-str 是 capture 过程中的 org 字符串。 tagregex 是 org-ql 查询用户设置的 tag 正则，匹配到 AI 标签，并返回。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 (defun get-element-tag-by-ql (org-str tagregex) (let (result) (with-current-buffer (get-buffer-create \u0026#34;*gpteltagtemp*\u0026#34;) (erase-buffer) (insert org-str) (org-mode) (message \u0026#34;buffer内容： %s \\n buffer 名称： %s\u0026#34; (buffer-string) (current-buffer)) (setq tags (org-ql-query :select \u0026#39;(org-entry-get (point) \u0026#34;TAGS\u0026#34;) :from (current-buffer) :where \u0026#39;(and (tags* (format \u0026#34;^%s.*$\u0026#34; tagregex)) (not (parent)) ) )) (message \u0026#34;数组1111：%s\u0026#34; tags) (setq result (catch \u0026#39;tag-found (dolist (tag tags) (setq tag (substring tag 1 -1)) ; 去除首尾: (setq tagarr (split-string tag \u0026#34;:\u0026#34;)) (dolist (item tagarr) (message \u0026#34;匹配中：%s\u0026#34; item) (setq reg (format \u0026#34;^%s.*$\u0026#34; tagregex)) (message \u0026#34;正则：%s\u0026#34; reg) (when (string-match reg item) (setq item (substring item 2)) ;;去除AI前缀 (throw \u0026#39;tag-found item))) ))) (message \u0026#34;结果：%s\u0026#34; result) ))) (setq org-string \u0026#34;* Hello world :AI内容总结: \\nThis is the body of first-level headline.\\n\\n** Subheadline \\nTest text.Test text.\u0026#34;) (get-element-tag-by-ql org-string \u0026#34;AI\u0026#34;) 1 结果：内容总结 通过 AI 标签从 prompt.org 文件中获取 prompt 使用 org-ql 从 prompt.org 文件中获取 prompt，封装了如下方法，为了便于测试，使用 with-temp-buffer\n方法的作用和参数\n第一参数，为 prompt.org 文件路径 第二参数，来自 capture 中用户设置的 AI 标签，对应 prompt.org 条目中一级条目的标题。 第三参数，设置 prompt 的类型，支持 system 和 user 类型，对应 prompt.org 中的子条目的title。定义 ptype 过程中，遇到 (heading ptype) 报错的问题，没有排查到原因，展示使用 1 和 其他标识来区分要获取的类型。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 (defun get-element-prompt-by-ql (org-str title ptype) (let (prompt) (with-current-buffer (get-buffer-create \u0026#34;*gpteltemp*\u0026#34;) (erase-buffer) (insert org-str) (org-mode) (if (= ptype 1) (setq prompt (org-ql-query :select \u0026#39;(org-get-entry) :from (current-buffer) :where \u0026#39;(and (ancestors (heading title)) (heading \u0026#34;system\u0026#34;) ))) (setq prompt (org-ql-select (current-buffer) \u0026#39;(and (ancestors (heading title)) (heading \u0026#34;user\u0026#34;) ) :action \u0026#39;(org-get-entry) )) ; ) (message \u0026#34;当前获取的类型：%s\u0026#34; (car prompt)) ))) (setq org-string \u0026#34;* Hello world :AI:\\nThis is the body of first-level headline.\\n** user\\n\\nTest text.Test text.\u0026#34;) ;; (setq file \u0026#34;~/hsg/iNotes/content-org/prompt/prompt.org\u0026#34;) (setq file \u0026#34;~/hsg/iNotes/content-org/test.org\u0026#34;) (get-element-prompt-by-ql org-string \u0026#34;Hello world\u0026#34; 0) 1 2 当前获取的类型： Test text.Test text. ","date":"2023-05-20T09:47:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%A9%E5%B1%95capture%E4%B8%ADtag%E8%AE%BE%E7%BD%AE%E6%94%AF%E6%8C%81prompt/","section":"post","tags":["灵感"],"title":"扩展 org-capture 基于 TAGS 功能动态设置 prompt"},{"categories":["学习笔记"],"contents":"主要目的是使用 API 解析字符串中的 org-mode 数据。获取对应的节点内容等。\n测试方法：使用 ob-babel 功能，支持共享数据和环境变量，可以传值等特点。\n初始化数据源 1 2 3 4 (setq org-string \u0026#34;* Hello world\\n:PROPERTIES:\\n:OWNER: Dav\\n:ID: 123\\n:END:\\n\\nThis is the body of first-level headline.\\n\\n** Subheadline\\n\\nTest text.\u0026#34;) (with-current-buffer (get-buffer-create \u0026#34;*org-string*\u0026#34;) (insert org-string) ) APi 测试用例 获取所有属性名 1 2 3 4 5 6 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (let ((x (org-buffer-property-keys))) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (print x))) ) ID OWNER 获取当前 headline 1 2 3 4 5 6 7 8 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) ;; 提取当前标题的组成部分。 (let ((x (org-heading-components))) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (print x))) ) 2 2 nil nil Subheadline nil 获取所有 headline 1 2 3 4 5 6 7 8 9 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (let (($headings nil)) (org-map-entries (lambda () (push (org-heading-components) $headings))) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (print $headings))) ) 2 2 nil nil Subheadline nil 1 1 nil nil Hello world nil org-element.el 库测试用例 org-data 的数据结构 (org-data nil \u0026lt;e1\u0026gt; \u0026lt;e2\u0026gt; \u0026lt;e3\u0026gt; … )\n每个 \u0026lt;e1\u0026gt; 都有 \u0026lt;elm_form\u0026gt;:\n(\u0026lt;elm_type_name\u0026gt; \u0026lt;plist\u0026gt; \u0026lt;x\u0026gt;)\n其中 \u0026lt;x\u0026gt; 代表 0 或 1 个 \u0026lt;elm_form\u0026gt; 。(可能更多，但到目前为止我只看到0或1个。)\n\u0026lt;elm_type_name\u0026gt; 有两中类型 org-element-all-elements ， org-element-all-objects 。例如: org-element-all-elements 包含。 section keyword headline property-drawer paragraph clock comment comment-block diary-sexp item node-property src-block table table-row verse-block\n参考：Emacs Lisp: Parse Org Mode\n获取 buffer 的 org-data 1 2 3 4 5 6 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (let ((x (org-element-parse-buffer))) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (print x))) ) org-data (:begin 1 :contents-begin 1 :contents-end 125 :end 125 :robust-begin 3 :robust-end 123 :post-blank 0 :post-affiliated 1 :path nil :mode org-data :CATEGORY nil :granularity headline) (headline (:raw-value Hello world :begin 1 :end 125 :pre-blank 0 :contents-begin 15 :contents-end 125 :robust-begin 54 :robust-end 123 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 1 :OWNER Dav :ID 123 :title Hello world :mode first-section :granularity headline :cached t :parent (org-data (:begin 1 :contents-begin 1 :contents-end 125 :end 125 :robust-begin 3 :robust-end 123 :post-blank 0 :post-affiliated 1 :path nil :mode org-data :CATEGORY nil :granularity headline) #0)) (headline (:raw-value Subheadline :begin 99 :end 125 :pre-blank 1 :contents-begin 115 :contents-end 125 :robust-begin 117 :robust-end 123 :level 2 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 99 :title Subheadline :mode section :granularity headline :parent #0))) 获取 org-element-at-point 返回有关光标位置的元素的列表数据\n1 2 3 4 5 6 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (let ((x (org-element-at-point))) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (print x))) ) node-property (:key OWNER :value Dav :begin 28 :end 40 :post-blank 0 :post-affiliated 28 :mode node-property :granularity element :cached t :parent (property-drawer (:begin 15 :end 56 :contents-begin 28 :contents-end 49 :post-blank 1 :post-affiliated 15 :mode planning :granularity element :cached t :parent (section (:begin 15 :end 99 :contents-begin 15 :contents-end 98 :robust-begin 15 :robust-end 96 :post-blank 1 :post-affiliated 15 :mode section :granularity element :cached t :parent (headline (:raw-value Hello world :begin 1 :end 125 :pre-blank 0 :contents-begin 15 :contents-end 125 :robust-begin 54 :robust-end 123 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 1 :OWNER Dav :ID 123 :title Hello world :mode first-section :granularity element :cached t :parent (org-data (:begin 1 :contents-begin 1 :contents-end 125 :end 125 :robust-begin 3 :robust-end 123 :post-blank 0 :post-affiliated 1 :path nil :mode org-data :CATEGORY nil :cached t))))))))) 获取 org-element-context 返回点周围最小的元素或对象。返回值是一个类似于(TYPE PROPS)的列表，其中\nTYPE 是元素或对象的 org-element-type 类型 PROPS 是与其关联的属性 org-element-property 列表。 1 2 3 4 5 6 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (let ((x (org-element-context))) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (print x))) ) headline (:raw-value Subheadline :begin 106 :end 132 :pre-blank 1 :contents-begin 122 :contents-end 132 :robust-begin 124 :robust-end 130 :level 2 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 106 :title Subheadline :mode nil :granularity element :cached t :parent (headline (:raw-value Hello world :begin 1 :end 132 :pre-blank 0 :contents-begin 15 :contents-end 132 :robust-begin 61 :robust-end 130 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 1 :OWNER Dav :ID 123 :title Hello world :mode first-section :granularity element :cached t :parent (org-data (:begin 1 :contents-begin 1 :contents-end 132 :end 132 :robust-begin 3 :robust-end 130 :post-blank 0 :post-affiliated 1 :path nil :mode org-data :CATEGORY nil :cached t))))) 获取当前位置的元素类型 1 2 3 4 5 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (print (org-element-type (org-element-context)) ) 获取当前位置的元素属性 1 2 3 4 5 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (print (org-element-property :ID (org-element-at-point)) ) 解析 org-element-contents 返回给定元素或对象中所有元素或对象的有序列表(按缓冲区位置)。\n获取headline 的值\n1 2 3 4 5 6 7 8 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (org-element-map (org-element-parse-buffer) \u0026#39;headline (lambda (x) (princ (org-element-property :raw-value x)) (terpri)))) ) t t 获取 headline ID 1 2 3 4 5 6 7 8 9 10 11 12 13 14 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (org-element-map (org-element-parse-buffer) \u0026#39;headline (lambda (x) (princ x) (let ((myid (org-element-property :ID x))) (when myid (princ \u0026#34;heading: \u0026#34; ) (princ (org-element-property :raw-value x)) (terpri ) (princ \u0026#34;ID value is: \u0026#34; ) (princ myid )))))) ) 123 获取 section is the body of\n1 2 3 4 5 6 7 8 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (org-element-map (org-element-parse-buffer) \u0026#39;section (lambda (x) (princ (org-element-contents x)) ))) ) (property-drawer (:begin 15 :end 63 :contents-begin 28 :contents-end 56 :post-blank 1 :post-affiliated 15 :mode planning :granularity nil :parent (section (:begin 15 :end 133 :contents-begin 15 :contents-end 131 :robust-begin 15 :robust-end 129 :post-blank 2 :post-affiliated 15 :mode section :granularity nil :parent (headline (:raw-value Hello world :begin 1 :end 163 :pre-blank 0 :contents-begin 15 :contents-end 163 :robust-begin 61 :robust-end 161 :level 1 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 1 :OWNER Dav :ID 123 :title (Hello world) :mode first-section :granularity nil :parent (org-data (:begin 1 :contents-begin 1 :contents-end 163 :end 163 :robust-begin 3 :robust-end 161 :post-blank 0 :post-affiliated 1 :path nil :mode org-data :CATEGORY nil :granularity nil) #4)) #2 (headline (:raw-value Subheadline :begin 133 :end 163 :pre-blank 1 :contents-begin 149 :contents-end 163 :robust-begin 151 :robust-end 161 :level 2 :priority nil :tags nil :todo-keyword nil :todo-type nil :post-blank 0 :footnote-section-p nil :archivedp nil :commentedp nil :post-affiliated 133 :title (Subheadline) :mode nil :granularity nil :parent #4) (section (:begin 149 :end 163 :contents-begin 149 :contents-end 163 :robust-begin 149 :robust-end 161 :post-blank 0 :post-affiliated 149 :mode section :granularity nil :parent #5) (paragraph (:begin 149 :end 163 :contents-begin 149 :contents-end 163 :post-blank 0 :post-affiliated 149 :mode planning :granularity nil :parent #6) Test text . 获取 paragraph 和转文本的方法测试 1 2 3 4 5 6 7 8 9 10 11 12 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (org-element-map (org-element-parse-buffer) \u0026#39;paragraph (lambda (x) (princ (org-element-contents x)) (let ((content (org-element-contents x))) ;; (princ content) (princ (org-element-interpret-data x)) ) ))) ) This is the body of first-level headline. Test text. 应用场景和测试数组处理 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 (with-current-buffer \u0026#34;*org-string*\u0026#34; (org-mode) (with-output-to-temp-buffer \u0026#34;*xah temp out*\u0026#34; (setq itemstr \u0026#34;\u0026#34;) (setq items \u0026#39;()) (org-element-map (org-element-parse-buffer) \u0026#39;paragraph (lambda (x) (setq item1 (org-element-interpret-data x)) (setq item2 (org-element-contents x)) (princ \u0026#34;原始数据：\u0026#34;) (princ item1) (princ \u0026#34;\\n\u0026#34;) ;; (set itemstr (concat itemstr \u0026#34;\\n\u0026#34; item1)) (setq itemstr (format \u0026#34;%s\\n%s\u0026#34; itemstr item1)) (princ \u0026#34;结果数据：\u0026#34;) (princ itemstr) (princ \u0026#34;\\n\u0026#34;) (add-to-list \u0026#39;items item) )) (setq items (reverse items)) (princ \u0026#34;最终：\u0026#34;) (princ itemstr) ) ) 1 2 3 4 5 6 7 8 9 10 This is the body of first-level headline. tetanic test2 tewet Test text . ","date":"2023-05-19T00:21:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/org-element/","section":"post","tags":null,"title":"org-element.el API 联调文档"},{"categories":["学习笔记"],"contents":"通过扩展org-roam-capture 模板完善 emacs 工作流:\n收集灵感 \u0026ndash;\u0026gt; 配置 chatGPT prompt \u0026ndash;\u0026gt; 发送到 ChatGPT \u0026ndash;\u0026gt; 获得建议和处理内容 \u0026ndash;\u0026gt; 根据反馈，分析灵感内容，是否进行下一步安排。\n本文主要包括以下功能：\n定制 AI capture 模板，支持角色属性和 AI 模板标签，添加 AI 分组。 利用 org-capture-template 的特性动态加载预设的 ChatGPT prompt 模板。 添加 hook 函数，在保存 capture 之后，和 ChatGPT 交互，并将处理的内容追加到结果中。 先定义一个 capture 模板 1 2 3 4 5 6 7 8 9 10 (add-to-list \u0026#39;org-roam-capture-templates \u0026#39;(\u0026#34;al\u0026#34; \u0026#34;inbox:捕获灵感\u0026#34; entry \u0026#34;* ${title}\\t:灵感:\\n prompt:\\n %(add-prompt-from-json)\\n\u0026#34; :if-new (file \u0026#34;Orgzly/inbox.org\u0026#34;) :empty-lines 1 :jump-to-captured 1 :role \u0026#34;写作\u0026#34; :ai t )) 动态添加 role prompt : 使用 %(方法) 从 json 中获取 prompt 添加到 entry 中。 :ai t : 设定为 ai 模板，主要在 hook 方法中使用，可以针对这类模板，做特殊处理。 :role \u0026quot;写作\u0026quot; : 添加 prompt 角色属性，主要在动态添加 prompt 时，用来匹配 json 数据。以下是一个示例 elisp 函数，可以使用它向 org-capture-templates 列表中添加多个模板： 开启 AI 的模板分组，在使用 capture 便于管理\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ;; 使用 =append= 函数将新模板组添加到 =org-capture-templates= 列表中。 (defun add-org-capture-templates (new-templates) \u0026#34;Add NEW-TEMPLATES to the `org-capture-templates\u0026#39; list.\u0026#34; (setq org-capture-templates (append org-capture-templates new-templates))) ;; 向 org-capture-templates 列表中添加多个模板 (add-org-capture-templates \u0026#39;org-roam-capture-templates \u0026#39;((\u0026#34;a\u0026#34; \u0026#34;AI cupture\u0026#34;) (\u0026#34;al\u0026#34; \u0026#34;inbox:捕获灵感\u0026#34; entry \u0026#34;* ${title}\\t:灵感:\\n prompt:\\n %(add-prompt-from-json)%?\u0026#34; ;; (file \u0026#34;~/.doom.d/templates/org-mode/AI/写作助手.org\u0026#34;) :if-new (file \u0026#34;Orgzly/inbox.org\u0026#34;) :empty-lines 1 :jump-to-captured 1 :role \u0026#34;写作\u0026#34; :ai t) )) 从加载 json 中预设的 prompt 1 2 3 4 5 6 7 8 9 10 11 12 13 (defun add-system-prompt-from-json () (let* ((prompt) (role (plist-get org-capture-plist :role)) (desc (plist-get org-capture-plist :description)) (json-object-type \u0026#39;plist) (json-array-type \u0026#39;list) (json (json-read-file \u0026#34;~/hsg/iNotes/content/prompt/roles.json\u0026#34;))) (message \u0026#34;获取角色：%s 描述：%s\u0026#34; role desc) (dolist (object (plist-get json :roles)) (when (string= (plist-get object :title) \u0026#34;佛祖\u0026#34;) (setq prompt (plist-get object :descn)) )) prompt)) 解析 json 文件中的对象列表 匹配 :role 指定的角色，返回 角色的 prompt 。 问题：这种方式无法在 capture 过程中使用 ^%{主题} 占位符模板，职能使用确定的 prompt 模板内容。\n解决办法文件模板设置 capture 模板，这样需要为每个 AI 模板编写文件模板。\n下面举例说明：\n先设置 AI capture 模板，这样就不需要 :role \u0026quot;写作\u0026quot; 属性\n1 2 3 4 5 6 7 8 (add-to-list \u0026#39;org-roam-capture-templates \u0026#39;(\u0026#34;at\u0026#34; \u0026#34;测试文件模板\u0026#34; entry (file \u0026#34;~/.doom.d/templates/org-mode/AI/写作助手.org\u0026#34;) :if-new (file \u0026#34;Orgzly/inbox.org\u0026#34;) ;; :role \u0026#34;写作\u0026#34; :ai t )) 写作助手.org 文件模板样例：\n1 2 3 4 5 6 7 8 9 * TODO ${title} 我写关于%^{主题}。 请给我一些开始的要点: - 相似的主题是什么? - 主题的基础是什么? - 为什么创建“%^{主题}”主题? - 它解决了什么问题? 借助 gptel 和 openAI 通信 在 capture 完成时，执行 AI 方法\n自定义 hook 方法：获取 capture 相关属性 hook 方法对所有 capture 模板都生效，即当 caputre 完成时，都会执行该方法，需要在 hook 方法中添加过滤条件，实现自定义需求。之前已经在 capture 模板自定义属性： :ai t , 当 ai 属性为 t 时，执行下面的操作。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 (defun gptel-capture-hook () (if org-note-abort (message \u0026#34;带有键 %s 和描述 %s 的模板终止\u0026#34; key desc) ;;调用 gptel 发送给 AI (if (org-capture-get :ai) (let ((key (plist-get org-capture-plist :key)) (desc (plist-get org-capture-plist :description)) (org-str (plist-get org-capture-plist :template)) (role (plist-get org-capture-plist :role)) ) ;; 通过解析字符串获取用户模板内容 ;; (setq content (content-from-org-element org-str)) ;; 从json文件中获取system prompt ;; (setq system (add-system-prompt-from-json)) ;; 第一步获取 capture 字符串中的AI tag ;; (setq aitag (get-element-tag-by-ql org-str \u0026#34;AI\u0026#34;)) ;; 在capture 时，竟然拿不到 tag 值 (setq aitag role) ;; 第二步获取 使用org-ql 从 org 文件中获取system ;; aitag 作为 title 获取 prompt (setq promptfile \u0026#34;~/hsg/iNotes/content-org/prompt/prompt.org\u0026#34;) (setq system (get-element-prompt-by-ql promptfile aitag 1)) (setq user (get-element-prompt-by-ql promptfile aitag 0)) (message \u0026#34;结果=-%s \\n -%s\u0026#34; system user) (gptel-capture-request system org-str) ) ))) (defun get-element-tag-by-ql (org-str tagregex) (let (result) (with-current-buffer (get-buffer-create \u0026#34;*gpteltagtemp*\u0026#34;) (erase-buffer) (insert org-str) (org-mode) (setq tags (org-ql-query :select \u0026#39;(org-entry-get (point) \u0026#34;TAGS\u0026#34;) :from (current-buffer) :where \u0026#39;(and (tags* (format \u0026#34;^%s.*$\u0026#34; tagregex)) (not (parent)) ) )) (message \u0026#34;数组：%s\u0026#34; tags) (setq result (catch \u0026#39;tag-found (dolist (tag tags) (setq tag (substring tag 1 -1)) ; 去除首尾: (setq tagarr (split-string tag \u0026#34;:\u0026#34;)) (dolist (item tagarr) (message \u0026#34;匹配中：%s\u0026#34; item) (setq reg (format \u0026#34;^%s.*$\u0026#34; tagregex)) (message \u0026#34;正则：%s\u0026#34; reg) (when (string-match reg item) (setq item (substring item 2)) ;;去除AI前缀 (throw \u0026#39;tag-found item))) ))) (message \u0026#34;结果：%s\u0026#34; result) ))) ;; ptype 1 :system 其他：user (defun get-element-prompt-by-ql (file title ptype) (let (prompt) (if (= ptype 1) (setq prompt (org-ql-query :select \u0026#39;(org-get-entry) :from file :where \u0026#39;(and (ancestors (heading title)) (heading \u0026#34;system\u0026#34;) ))) (setq prompt (org-ql-select file \u0026#39;(and (ancestors (heading title)) (heading \u0026#34;user\u0026#34;) ) :action \u0026#39;(org-get-entry) )) ) )) ;; 解析org-str，获取指定部分内容 (defun content-from-org-element (org-str \u0026amp;optional headline) (with-temp-buffer (erase-buffer) (insert org-str) (org-mode) (setq content \u0026#34;\u0026#34;) (org-element-map (org-element-parse-buffer) \u0026#39;paragraph (lambda (x) ;;把获取到的段落，格式为text (setq item (org-element-interpret-data x)) ;;拼接循环到的每个段落，用\\n分割 (setq content (format \u0026#34;%s\\n%s\u0026#34; content item)) )) content)) 监听 hook 方法： org-capture-after-finalize-hook\n1 (add-hook \u0026#39;org-capture-after-finalize-hook \u0026#39;gptel-capture-hook) 在包 AI cupture 事项保存到文件中之后，将自动调用 gptel-capture-hook 函数。\n参考：\nTemplate elements (The Org Manual)\norg mode - creating an org-capture template - Emacs Stack Exchange\n通过 gptel 和 openAI 交互 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 (defun gptel-capture-request (sytem prompt) (when (string= prompt \u0026#34;\u0026#34;) (user-error \u0026#34;A prompt is required.\u0026#34;)) (message \u0026#34;开始网络 %s \\n %s\u0026#34; system prompt) (setq gptel--system-message sytem) (gptel-request prompt :callback (lambda (response info) (if (not response) (message \u0026#34;gptel-capture 错误: %s\u0026#34; (plist-get info :status)) (with-current-buffer (plist-get org-capture-plist :buffer) (goto-char (point-max)) (unless (bolp) (insert \u0026#34;\\n\u0026#34;)) (insert \u0026#34;** 测试 \\n\u0026#34; response \u0026#34;\\n\u0026#34;) ) )))) 参考：GitHub - karthink/gptel: A no-frills ChatGPT client for Emacs ","date":"2023-05-17T11:52:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%89%A9%E5%B1%95org-roam-capture%E6%94%AF%E6%8C%81ChatGPT/","section":"post","tags":null,"title":"扩展 org-roam-capture 模板支持ChatGPT"},{"categories":["Inbox"],"contents":"在体验 AI 对工作和生活越来越大，疯狂的探索更多的技巧和使用场景，改善生活习惯。很自然，就瞄上了 Siri 本该强大的小助手，是时候通过 AI 来提升对话体验了。\n这段时间，在网上出现很多解决方案和工具，把 chatgpt 集成到 siri ，都离不开 Shortcuts 工具。\n在 shortcut 中可以使用手机系统的朗读功能，把 AI 的回答，用系统自带的人声朗读。在体验上不太好，尝试借助第三方语音合成服务 API 把 AI 文本转为更多人声，然后回传给手机播放，达到定制的效果。\n在短视频中很多使用 Azure 语音配音的，效果很好，在国内想使用它，很难获取体验资格，拿不到 API 密钥。在申请 visa 卡，注册帐号，消耗了太多精力，尝试了翻墙注册新帐号，用信用卡生成器，美国地址生成器，仍无法认证，最后只能放弃。\n其实，在朗读文本时，不满意 Shortcut 的朗读效果的话，还可以尝试在用 Siri 激活捷径的时候，使用 Siri 来识别文本，可以很流畅朗诵，体验还是蛮不错。\n现在回到正题，在网上有很多现成的 shortcut 快捷指令，已经实现了 Siri + chatgpt 的效果。但在适用过程中，chatgpt API 延迟是硬伤，频繁被 Siri 误判为链接异常，稍候再试，中断了对话。\n这段时间一直在用 slack 中的 Claude 解决很多技术问题，能够提供很多高质量的回答，好感度满分。\n在 Slack 有一些使用经验，了解过它强大扩展特性，提供 Webhook ， Web Api ，Socket mode 等，帮助第三方平台能够很好的接入它功能。基于扩展的特性，现在很多开源的 chatgpt 插件会接入 Slack 对接，作为机器人，提升 AI 聊天的体验。\n在体验过 mygptReader ， be-on-anything 一些很好的把 chatgpt 集成到了 Slack 中，体验效果非常好，但是 mygptreader 限制太多， be-on-anything 终究要依赖本地服务。\n在使用使用了这么多好用的工具插件之后，该怎么使用 Shortcut 实现 Siri AI 的想法，就有了一个能解决网络延迟，免费和 AI 聊天的方案。反其道而行之：在 Shortcut 使用获取网址操作命令，借助 Slack 的开放性，实现 Siri 调用 API 和 Claude 对话。\n思路：将 Slack 作为平台，Claude APP 聊天作为 AI 服务。通过Income webhook, Slack Web API ，Slack App 等功能，定义一个轮询指令，用来监听 Claude 的最后一条消息。这样拿到聊天历史的 JSON ，解析出 Claude 的回答的内容，就能让 Siri 帮你朗读出来，实现 Siri + AI 低延迟的体验效果。\n在shortcut 实现 Siri 和 Claude 聊天，主要用到这个APi\n向Claude AI 机器人发送消息的接口：chat.postMessage method | Slack\n轮询指令监听 AI 获取最新一条聊天记录：conversations.history method | Slack\n文档中提供了接口验证工具，很大的便利开发效率。\n","date":"2023-04-22T23:26:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/siriAIClaude%E7%9A%84%E4%BD%8E%E5%BB%B6%E8%BF%9F%E5%AF%B9%E8%AF%9D/","section":"post","tags":null,"title":"siri 对话 Claude AI，低延迟畅聊"},{"categories":["Inbox"],"contents":"第一步搞定 slack webhooks 配置 Slack 中 Incoming Webhooks 是输入消息的功能，可以作为订阅工具介绍用户的消息吗？\nSlack 的 Incoming Webhooks 功能允许外部应用程序通过 HTTP 请求向 Slack 发送消息。它不能直接用于订阅用户消息。但通过 webhook 消息中的用户信息,我们可以实现某个用户消息的过滤与订阅。具体步骤如下:\n在 Slack 中,选择要接收消息的频道,点击“应用与集成”。选择“传入 Webhook”,点击“添加配置”。 这会生成一个 webhook URL。外部应用可以通过向此 URL 发送 HTTP POST 请求来向该频道发送消息。 收到的 webhook 请求中的 body Data 包含了构建 Slack 消息所需的所有信息,包括: text:消息文本内容 username:发送者用户名 channel:消息所在频道 ID user:发送用户的 ID 等等 外部应用接收到该 webhook 请求后,可以解析请求信息,提取 用户 ID 与用户名等信息。 通过用户 ID 对消息进行过滤,只处理目标用户发送的消息。然后提取 text 字段的文本内容,并在应用界面进行显示,实现该用户消息的订阅与接收。 Slack 应用配置 webhook 成功后,外部应用需要定期轮询 webhook URL,等待接收 Slack 发送过来的 webhook 请求,然后进行解析与处理。 这样,通过解析webhook 请求与过滤用户信息,外部应用就可以实现订阅 Slack 中某个用户的消息。 Incoming Webhooks 本身是让外部应用可以推送消息到 Slack 的功能,但借助于 webhook 请求中的用户信息,我们可以 newspaper subscription slack 的用户消息。它需要外部应用保存用户信息与定期检索 webhook URL,属于一种比较hack 的方式。\nSlack 目前官方提供的订阅消息接口有两个: 1.rtm.connect - 该接口建立一个 WebSocket 链接,通过该链接实时接收频道消息。这是目前 Slack 推荐的消息订阅方式。使用方式:\n调用 rtm.connect 获取 WebSocket URL 启用 WebSocket 客户端与该 URL 建立链接 通过 WebSocket 接收实时消息数据 2.channels.history - 该接口用于获取频道历史消息。通过定期调用,可以实现消息订阅。使用方式:\n调用 channels.history 获取频道最近 N 条消息 设置定期定时器,每 T 秒调用一次 channels.history 比较历史消息与新获取的消息,提取新增消息 处理新增消息并作出响应 相比 chat.postMessage 的轮询方式,rtm.connect 的 WebSocket 订阅和 channels.history 的定期拉取都是更优雅高效的消息订阅方案。我强烈建议采用其中一种方式实现 Slack 消息订阅。\n第一步在 shortcuts 中订阅 webhook URL iOS Shortcuts 应用中没有直接的“接收 Webhook”操作。但我们可以通过其他操作与功能实现 webhook 消息的接收与处理。\n以下是具体实现步骤与截图:\n添加“获取网址”操作,输入之前在 Slack 中获取的 webhook URL。这将返回该 URL 的内容,也就是发送过来的 webhook 消息。 添加一个 IF 条件判断,判断“获取网址”操作的输出是否包含“webhook 消息”字段。如果包含,则表示接收到新的 webhook 消息。 如果接收到新消息,我们提取消息中的“text”字段作为 Claude 应用回复的内容。 最后,添加一个“显示通知”操作,在标题中选择“Claude 回复”,内容选择前面提取的文本内容变量。这将在 iOS 中显示回复通知。 保存快捷方式后,它就会定期轮询 webhook URL,等待接收到新回复消息并显示通知。 第三步实现 shortcuts 轮询订阅 在 iOS Shortcuts 中,可以通过添加定时器与循环操作实现对 webhook URL 的轮询订阅。具体步骤如下:\n添加“获取网址”操作,输入 Slack 中生成的 webhook URL。这将返回 URL 内容,也就是 Claude 应用发送过来的 webhook 消息。 添加一个“重复”循环操作。在“重复次数”字段输入一个较大的值,例如 100 次。这将创建一个循环,重复 100 次获取 webhook 消息。 在循环中继续添加“如果”条件判断。判断“获取网址”操作的输出是否包含“webhook 消息”字段。如果包含,表示接收到 Claude 应用的新回复,跳出循环。 如果接收到新回复,提取消息中的文本内容并显示通知。之后添加一个“停止运行”操作,跳出整个快捷方式流程。 如果 100 次循环后仍未接收到新回复,快捷方式将自动停止运行。此时,我们需要添加一个“延迟”操作,例如 2 分钟。然后使用“继续运行”操作重新启动该快捷方式,再进入循环监听 webhook URL。 这样,快捷方式就实现了定期轮询订阅 webhook URL,等待接收 Claude 应用的新回复。一旦收到新回复,显示通知并停止运行。如果超时未收到回复,就延迟指定时间后重新启动监听。 具体流程如下: 获取网址(Webhook URL)→ 重复(100)→ 如果(包含“webhook 消息”字段)→提取文本内容→ 显示通知→ 停止运行→ 延迟(2 分钟)→ 继续运行→ 获取网址(Webhook URL)→ 重复(100)\u0026hellip;\n","date":"2023-04-22T22:28:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/shortcut+slack%E5%AE%9E%E7%8E%B0AI%E9%80%9A%E8%AF%9D/","section":"post","tags":null,"title":"使用 shortcuts 订阅 Claude AI对话"},{"categories":["Inbox"],"contents":"在苹果手机上，通过 shortcut 集成 AI 和 Siri 实现语音对话，进一步提升了 AI 对话的体验。\n具体过程是，通过 Siri 唤醒 Shortcut 通过语音方式开启和 AI 对话，Shortcut 在接收到 AI 以文本形式反馈后，使用语音工具朗读文本。\n在朗读环节，体验有点差强人意，怎么优化 shortcut 语音为主题展开。\n在 Shortcuts 中,可以通过以下方式使用第三方的语音合成服务:\nIFTTT - IFTTT 是一个流行的自动化平台,它提供了对各种 web 服务的连接,包括语音合成服务。你可以创建一个 IFTTT 应用连接一个语音服务,然后在 Shortcut 中使用\u0026quot;Run Web Request\u0026quot;操作调用该 IFTTT 应用来合成语音。 API 直接调用 - 许多语音服务如 AWS Polly、Google Text to Speech、Baidu Text to Speech 都提供 API 可以直接调用。你可以在 Shortcut 中使用\u0026quot;Get Contents of URL\u0026quot;操作调用这些 API 来合成语音。 HomeBridge 插件 - 如果你使用 HomeBridge,它有一些语音合成的插件,如 homebridge-polly-tts。你可以配置这些插件,然后在 Shortcut 中使用 HomeKit 操作来调用它们合成语音。 推荐的 Shortcut 和语音服务:\nAWS Polly - 亚马逊的云端语音服务,它提供真人发音的神经语音,音质很高,通过 API 可以轻松调用。 Google Text to Speech - 谷歌的免费语音合成服务,提供支持多种语言和发音人选择的高质量语音,也可以通过 API 或 IFTTT 轻松调用。 百度语音合成 - 百度的语音服务,支持中文和英文,音质也不错,提供开放 API 可以在 Shortcut 中调用。 IFTTT + Voicerss - Voicerss 是一款免费的 API 语音服务,IFTTT 应用可以连接它并在 Shortcut 中使用。 homebridge-polly-tts - 如果你使用 HomeBridge,这个插件可以连接 AWS Polly 服务并通过 HomeKit 在 Shortcut 中调用。 这些都是比较流行可靠的语音服务与 Shortcut 集成方案,你可以按需选择并体验不同的语音效果。如果在使用过程中遇到任何问题,欢迎说明,我可以提供进一步的帮助。\n借助 HomeKit 优势 homebridge-ifttt 是一个将 IFTTT 服务接入 HomeBridge 的插件。使用它,你可以在 IFTTT 创建连接各种语音服务的应用,然后在 HomeBridge 和 Shortcuts 中调用这些应用来进行语音合成。要安装并使用 homebridge-ifttt,可以按以下步骤操作:\n安装 HomeBridge - 在一台安装有 Node.js 的设备上安装 HomeBridge。 注册 IFTTT 帐户 - 前往 ifttt.com 并注册一个免费 IFTTT 帐户。 安装 homebridge-ifttt - 运行命令: npm install -g homebridge-ifttt\n在 HomeBridge 中配置 IFTTT 配件: 1 2 3 4 5 6 7 \u0026#34;platforms\u0026#34;: [{ \u0026#34;platform\u0026#34;: \u0026#34;IFTTT\u0026#34;, \u0026#34;makerkey\u0026#34;: \u0026#34;your_maker_key\u0026#34;, \u0026#34;device\u0026#34;: { \u0026#34;name\u0026#34;: \u0026#34;IFTTT\u0026#34; } }] 将 your_maker_key 替换为你的 IFTTT Maker Key。\n在 IFTTT 中创建连接语音服务的应用: 选择\u0026quot;IFTTT 访问授权\u0026quot;服务作为触发器 选择需要的语音服务如\u0026quot;Voicerss - 文本转语音\u0026quot;作为操作 当 IFTTT 接收到来自 IFTTT Maker Channel 的触发时,Voicerss 将合成并播放语音 重启 HomeBridge,IFTTT 应用和语音服务会出现在 Home 应用中。 在 Shortcuts 中,使用 HomeKit 操作\u0026quot;播放语音(使用 IFTTT)\u0026ldquo;来调用 IFTTT 应用,语音服务将进行语音合成。 可选的语音服务:\nVoicerss: 免费语音 API 服务,IFTTT 应用提供,中文和英文 Anthropic:免费语音 API 服务,IFTTT 应用提供,多语言 Other TTS Services:基于软件的 TTS 服务,IFTTT 应用提供,英文等 这种方案可以连接你选择的多种语音服务。如果在配置或使用过程中有任何问题,欢迎说明,我将提供详细的帮助。也欢迎分享使用 HomeBridge 和 IFTTT 进行语音集成的体验与建议。将有助于帮助更多 Shortcut 用户发掘并享受它强大的语音化功能!\n1 2 3 curl https://maker.ifttt.com/trigger/totts/with/key/dq0HRmkxprvckuzMcgVFgu?value1=你好 curl -X POST -H \u0026#34;Content-Type: application/json\u0026#34; -d \u0026#39;{\u0026#34;value1\u0026#34;:\u0026#34;你好\u0026#34;}\u0026#39; https://maker.ifttt.com/trigger/{totts}/json/with/key/dq0HRmkxprvckuzMcgVFgu ","date":"2023-04-22T22:17:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%BF%AB%E6%8D%B7%E6%8C%87%E4%BB%A4%E5%92%8Cifttt%E6%B7%BB%E5%8A%A0%E5%BC%80%E5%85%B3%E6%9C%BA%E5%88%B6/","section":"post","tags":null,"title":"通过 shortcut 集成 AI 和 Siri 实现语音对话"},{"categories":["学习笔记"],"contents":"和 AI 对话一段时间，受到很大的启发。\n在 AI 辅助下，日常开发，时间和项目管理，效率都有了明显的提升。相信 AI 将在生活中扮演更多角色，影响自己的行为习惯。\n网上看到已经有大牛，用 AI 实现了无代码开发，从项目框架设计，功能开发和测试发布，都由 AI 一步步回答实现，例如 mygptreader 。\n受此启发，在尝试开发过程中，尽量使用 AI 来完成，功能的设计和开发。\n例如，使用 swift 开发一个 snippet 转换插件过程中，只需负责提需求，验收 AI 代码可用性，然后集成到脚本运行就好。\n这样以来，任务重心偏向了需求挖掘，功能设计，代码验收上。做这些工作，更多体现在领导和管理上，如何扮演好新的角色至关重要。\nemacs 拥有丰富的插件，在 org-AI 的加持下， tj3 项目管理，博客写作 ox-hugo 插件， plantuml 插件， 代码块 插件等，都能有效的提升生产力。经过这次 AI 浪潮洗礼，将 emacs 训练成高效能七个习惯的执行者的愿望，也许指日可待了。\n使用 AI 制作 prompt snippets 提升 chatgpt 沟通 使用脚本收集流行的 prompt 库，批量转换 snippet， 例如：alfred snippet ， emacs snippet 等。\n通过这个简单脚本的开发，借助 AI 尝试无代码编程。在需求，设计，编码，调试实战中，工作中心偏设计管理，尽量在 emacs 中探索可提升产出的技术栈，学习积累新的开发习惯。\n技术设计：采用 swift 语言， JSON 库解析 propmt 源数据转为目标 snippt 格式。\n开发工具：借助 emacs 插件提升产出效率。例如：利用 org-swift plantuml 快速设计，测试等。\n分析数据模型 prompt 数据源样例\n这段 json 片段来自微信机器人 chat-on-wechat 中的角色插件，插件中整理很多关于角色 prompt。\n主要功能：例如在片段的角色的描述，在微信中和 AI 聊天时，只要输入 佛祖 即可。\n制作 snippet 会用到 title ， descan remark 字段。\n1 2 3 4 5 6 7 8 9 10 { \u0026#34;title\u0026#34;: \u0026#34;佛祖\u0026#34;, \u0026#34;description\u0026#34;: \u0026#34;从现在开始你是佛祖，你会像佛祖一样说话。你精通佛法，熟练使用佛教用语，你擅长利用佛学和心理学的知识解决人们的困扰。你在每次对话结尾都会加上佛教的祝福。\u0026#34;, \u0026#34;descn\u0026#34;: \u0026#34;从现在开始你是佛祖，你会像佛祖一样说话。你精通佛法，熟练使用佛教用语，你擅长利用佛学和心理学的知识解决人们的困扰。你在每次对话结尾都会加上佛教的祝福。\u0026#34;, \u0026#34;wrapper\u0026#34;: \u0026#34;您好佛祖，我：\\\u0026#34;%s\\\u0026#34;\u0026#34;, \u0026#34;remark\u0026#34;: \u0026#34;扮演佛祖排忧解惑\u0026#34;, \u0026#34;tags\u0026#34;: [ \u0026#34;interesting\u0026#34; ] }, snippet 目标结构样例： emacs snippet 格式\n这段显示的 or-ai 的 snippet 结构展示，作为脚本的输出格式。\nsnippet 的 key 使用 prompt 名称的中文全拼缩写。\n例如：将 佛祖 prompt 转为 snippet 效果：\n1 2 3 4 5 6 7 8 9 10 # -*- mode: snippet -*- # name: 佛祖 # key: fz # -- #+begin_ai markdown :max-tokens 250 ${1:[SYS]: ${2:从现在开始你是佛祖，你会像佛祖一样说话。你精通佛法，熟练使用佛教用语，你擅长利用佛学和心理学的知识解决人们的困扰。你在每次对话结尾都会加上佛教的祝福。} }[ME]: 您好佛祖，我： $0 #+end_ai emacs + AI 开发模式 在 org 中进行 swift 语言开发，主要用到一下插件：\norg-ai 在 org 中 AI 实时对话\norg-swift ，支持 swift 脚本 org-babel ，在 org 中轻松运行脚本，便于测试验收代码，类似 swift playgroud 。\n采用字符串的形式，处理格式转换，然后写入目标文件保存到文件\n用变量模拟 json 数据 采用多行字符串组装要转换的格式 使用 print 验证字符串结果 1 2 3 4 5 6 7 8 9 10 11 12 13 14 var name = \u0026#34;miao\u0026#34; var key = \u0026#34;mn\u0026#34; var prompt = \u0026#34;猫娘\u0026#34; let snippet = \u0026#34;\u0026#34;\u0026#34; # -*- mode: snippet -*- # name: \\(name) # key: \\(key) # -- #+begin_ai markdown :max-tokens 250 ${1:[SYS]: ${2:\\(prompt)} }[ME]: $0 \u0026#34;\u0026#34;\u0026#34; print(snippet) 打印结果：\n1 2 3 4 5 6 7 8 # -*- mode: snippet -*- # name: miao # key: mn # -- #+begin_ai markdown :max-tokens 250 ${1:[SYS]: ${2:猫娘} }[ME]: $0 获取中文全拼缩 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 import Foundation func PYFirst(string:String?, _ allFirst:Bool=false)-\u0026gt;String{ var py=\u0026#34;#\u0026#34; if let s = string { if s == \u0026#34;\u0026#34; { return py } let str = CFStringCreateMutableCopy(nil, 0, s as CFString) CFStringTransform(str, nil, kCFStringTransformToLatin, false) CFStringTransform(str, nil, kCFStringTransformStripCombiningMarks, false) py = \u0026#34;\u0026#34; if allFirst { for x in (str! as String).components(separatedBy:\u0026#34; \u0026#34;) { py += PYFirst(string:x) } } else { py = (str! as NSString).substring(to: 1).uppercased() } } return py } //调用示例，返回# var s :String? //PYFirst(string:s) s = \u0026#34;中华人民共和国@hi wor\\r\\nld.\u0026#34; //调用示例，返回ZHRMGHGW let result = PYFirst(string:s,true) //调用示例，返回Z let result2 = PYFirst(string:s) print(\u0026#34;结果1: \\(result) \\n 结果2: \\(result2)\u0026#34;) 1 2 结果1: ZHRMGHGW result2: Z 脚本的核心功能和运用 使用 JSONEncoder 解析本地的 json 文件，转为 model 对象。\n目前支持三个工具的 snippet\nalfred snippet\n转为 json 文件集合，需要手动压缩成 .zip ，然后命名为 .alfredsnippets\n如果安装无效，尝试以下方式安装\n在alfred snippet 新建一个snippet 集合，然后导出为 alfredsnippets 包 再使用 zip 工具不解压缩的情况下，将生成的 json 导入到 包中。 双击包，成功导入到 alred snippet 中。 emacs-snippet\nauto-gpt yaml模板\n使用方法：python -m auto-gpt \u0026ndash;settings-file role.yaml\n生成chatfred 的aliases\n安装方法：把chatfred的内容拷贝到chatfred 配置项中\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 public static func toSnippets(json:String) -\u0026gt; String? { // 使用 JSONEncoder 解析本地的json 文件，转为model 对象。 let url = URL(fileURLWithPath: json) let data = try! Data(contentsOf: url) let prompt = try! JSONDecoder().decode(Prompt.self, from: data) prompt.roles.map { role in // 保存为json 文件 var wrapper = role.wrapper wrapper.replaceAll(matching: \u0026#34;\\n.*$\u0026#34;, with: \u0026#34;\u0026#34;) do { // alfred ----- let jsonEncoder = JSONEncoder() let alfred = SnippetModel(uid: UUID().uuidString, name: role.title, keyword: role.title.pinyin.lowercased(), snippet: role.descn) let alfredM = AlfredModel(alfredsnippet: alfred) jsonEncoder.outputFormatting = .prettyPrinted let resultData = try jsonEncoder.encode(alfredM) let filename = alfred.name + \u0026#34; [\\(alfred.uid)]\u0026#34; let newfile = \u0026#34;/Users/boyer/Desktop/propmt/\\(filename).json\u0026#34; let url = URL(fileURLWithPath: newfile) try resultData.write(to: url, options: .atomic) // emacs-snippet ---把字符串保存为文件 --- let snippet = \u0026#34;\u0026#34;\u0026#34; # -*- mode: snippet -*- # name: \\(role.title) # key: \\(alfred.keyword) # group: \\(role.tags.first ?? \u0026#34;\u0026#34;) # -- #+begin_ai markdown :max-tokens 250 [SYS]: \\(role.descn) [ME]: \\(wrapper) $0 #+end_ai \u0026#34;\u0026#34;\u0026#34; let snippetfile = \u0026#34;.doom.d/snippets/org-mode/ai/\\(alfred.name)\u0026#34; let emacsnippet = Path.home+snippetfile try! emacsnippet.write(snippet) //auto-gpt ----- //使用方法：python -m auto-gpt --settings-file role.yaml let auto_gpt = \u0026#34;\u0026#34;\u0026#34; ai_goals: - \\(role.remark) ai_name: \\(role.title) ai_role: \\(role.descn) \u0026#34;\u0026#34;\u0026#34; let autofile = \u0026#34;.dotfiles/auto-gpt/roles/\\(role.title).yaml\u0026#34; let autogpt = Path.home+autofile try! autogpt.write(auto_gpt) //生成chatfred 的aliases //使用方法：把chatfred的内容拷贝到chatfred 配置项中。 let alfred_aliases = role.title.pinyin.lowercased() + \u0026#34;=\u0026#34; + role.descn + \u0026#34;;\\n\u0026#34; let fred = \u0026#34;Desktop/chatfred.txt\u0026#34; let chatfred = Path.home+fred // try! chatfred.append(alfred_aliases) let fileHandle = try FileHandle(forWritingTo: chatfred.url) fileHandle.seekToEndOfFile() if let data = alfred_aliases.data(using: .utf8) { fileHandle.write(data) } fileHandle.closeFile() } catch { print(\u0026#34;生成失败\u0026#34;) } } return \u0026#34;生成成功\u0026#34; } TODO ob-babel 导入第三库遇到的问题 问题1. org-mode 9.6.1 在使用 var 传递变量失败\n在导入第三方库时，通过 ai 提供了几种方法，验证都无效\n使用：var myLibrary=\u0026ldquo;Regex\u0026rdquo; 在swift 块中，import $myLibrary 使用：var loadpath =\u0026quot;\u0026quot; 源码路径，在 emacs-elisp 块中夹带 load-path 方式 在 swift 块中使用 load-file 的方式加载 swift 文件，然后使用库方法 三种方法在验证之后都是无效的。\n1 2 (setq load-path (cons includepath load-path)) (load-file (concat includepath \u0026#34;Regex.swift\u0026#34;)) 1 2 3 4 5 6 7 8 9 let myString = $myString // 将Org-mode代码块中的myString变量赋值给Swift变量 print(\u0026#34;声明的变量：\\(myString)\u0026#34;) let pattern = \u0026#34;T.*T\u0026#34; let regex = try! Regex(pattern) if regex.matches(myString) { print(\u0026#34;Regex matched!\u0026#34;) } else { print(\u0026#34;Regex didn\u0026#39;t match.\u0026#34;) } 1 2 3 4 5 \u0026lt;stdin\u0026gt;:1:16: error: cannot find \u0026#39;$myString\u0026#39; in scope let myString = $myString // 将Org-mode代码块中的myString变量赋值给Swift变量 \u0026lt;stdin\u0026gt;:5:10: error: value of type \u0026#39;Regex\u0026lt;AnyRegexOutput\u0026gt;\u0026#39; has no member \u0026#39;matches\u0026#39; if regex.matches(myString) { ~~~~~ ^~~~~~~ 1 2 3 4 5 6 import Foundation var text = \u0026#34;test\\n \\\u0026#34;%s\\\u0026#34;\u0026#34; print(\u0026#34;kkkk==\\(text)\u0026#34;) //text.removeLast(4)//replacingOccurrences(of: \u0026#34;\\\u0026#34;%s\\\u0026#34;\u0026#34;, with: \u0026#34;\u0026#34;) text.replaceAll(matching: \u0026#34;%.*$\u0026#34;, with: \u0026#34;\u0026#34;) print(\u0026#34;jjjj==\\(text)\u0026#34;) 1 2 3 \u0026lt;stdin\u0026gt;:5:6: error: value of type \u0026#39;String\u0026#39; has no member \u0026#39;replaceAll\u0026#39; text.replaceAll(matching: \u0026#34;%.*$\u0026#34;, with: \u0026#34;\u0026#34;) ~~~~ ^~~~~~~~~~ ","date":"2023-04-19T21:05:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/org-babel%E5%BC%80%E5%8F%91swift/","section":"post","tags":null,"title":"AI 解放 IDE ，专注 emacs 提升生产力"},{"categories":["Inbox"],"contents":"auto-gpt 是一款提前设定目标，然后交给 chatgpt 自问自答的一些的操作，人类仅做好每一步的选择就好，大大简化了对话过程。\n相比普通的聊天模式，缺乏和用户的交互的灵活性。\nauto-gpt 对于在工作生活中积累一些工作流程模板和习惯的人比较友好， 现在只需要把目标写入 yaml 模板文件，然后通过 \u0026ndash;ai-setting 启动 auto-gpt 。就能解放双手，作选择就行了。 auto-gpt 在每完成一步计划，会询问是否执行，也可以将个人看法反馈给 auto-gpt 。\n提醒自己在日常工作生活中，要养成 以终为始 的习惯，有目的的做事，才能遇强则强。\n想有快速掌握各种思维模式，可以参考 clickprompt 项目，上面收集了针对不同业务的行为规范模板。分析自己的需求，找到相应的模板，例如：对话，写作，开发等，都有相应的模板。借助模板能够提升看待问题解决问题的方式。auto-gpt 就是通过提供 yaml 模板，大大提升了 chatgpt 沟通效率。\nauto-gpt 自带一套模式：角色，职责和 5 个目标。auto-gpt 在接收到给定的模板后，会自动分析需求，优化目标，拆分任务，产出高质量的行动方案。在 clickprompt 上提供了更多好用的业务模板，经过简单处理成 yaml 模板，就可以激发 auto-gpt 更多的业务能力，善用这些模板，就能在不同领域和角色上，激发出惊人的潜力，例如：写作，开发，演讲。\n现在有很多现成的 prompt 项目，提供针对不同需求的角色的提示语，配合 clickprmpt 能让 chatgpt 更专业，更加精准的回答你的问题。\n辅助工具推荐 在面对众多 prompt 提示语的轰炸，如何高效管理这些碎片话的语句，就迫在眉睫。\n建议找一款适合自己的 snippet 工具，把常用的 prompt 整理成快捷输入的命令，帮助记忆和输入。\n在 mac 用户，推荐 alfred snippet 的功能，优化网上有很多介绍。\nalfred 推出了 chatfred 最为 chatgpt 前端，彻底把 chatgpt 融入到了生活的方方面面。\n作为 emacs 用户用脚本生成了 snippet 快，结合 org-ai 让写作，知识管理更加智能有趣。\n之前积累了很多提上来个写作，项目管理，知识管理，很多提升效率的模板，类似 clickprompt 工作流模板。\n准备在现有的模板上，添加 chatgpt prompt 扩展，让 AI 随叫随到。\n举例：输入 ai 自动展开和 AI snippet 对话。\n1 2 3 4 5 #+begin_ai [SYS]: You are a helpful assistant. [ME]: #+end_ai TODO 待完善的模板 ox 博客模板：在写作的过程中，就可以借助模板的方式，编写博客 tj3 项目管理模板： 创建项目任务计划等 ","date":"2023-04-19T17:03:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/autogpt%E6%95%88%E7%8E%87%E5%B7%A5%E5%85%B7/","section":"post","tags":null,"title":"auto-gpt：将思维框架赋予chatgpt"},{"categories":["Inbox"],"contents":"在使用org-sync 过程中，对中文解析问题，导致无法正常同步。\n现在尝试通过让AI 阅读elisp 源码，给出解决办法，和编写可用的脚本。\nAI对话需要解决的两个问题：先问为什么会同步失败。\nemacs org-sync 同步github issue 中文乱码。 分析org-sync插件源码，确认导致中文乱码的片段，并给出修复方法 下面是同步github-issue 核心代码，可以交给AI 帮你分析问题：\n通过分析这个 org-sync-github.el 的源码,我发现以下几个地方可能导致中文乱码:\n在发送 HTTP 请求时,Accept-Encoding 没有设置为 utf-8,这会导致 GitHub 返回的 JSON 数据的编码不是 utf-8,从而解析后出现乱码: 1 2 3 4 5 6 7 (defun org-sync-github-request (method url \u0026amp;optional data) \u0026#34;Send HTTP request at URL using METHOD with DATA. Return the server decoded JSON response.\u0026#34; (message \u0026#34;%s %s %s\u0026#34; method url (prin1-to-string data)) (let* ((url-request-method method) (url-request-data data) (buf (org-sync-github-url-retrieve-synchronously url))) (url-request-extra-headers \u0026lsquo;((\u0026ldquo;Accept-Encoding\u0026rdquo; . \u0026ldquo;utf-8\u0026rdquo;))) 修复方法是在请求头中添加:\n1 2 (setq url-request-extra-headers \u0026#39;((\u0026#34;Accept-Encoding\u0026#34; . \u0026#34;utf-8\u0026#34;))) 获取响应内容后,没有对 JSON 数据做解码,直接解析了原始的字符数据: 1 2 3 (with-current-buffer buf (goto-char url-http-end-of-headers) (prog1 (json-read) (kill-buffer))))) 修复方法是先对响应做解码,再解析 JSON:\n1 2 3 4 5 (with-current-buffer buf (let ((content (decode-coding-string (buffer-string) \u0026#39;utf-8)))) (goto-char url-http-end-of-headers) (prog1 (json-read content) (kill-buffer))))) 解析 JSON 时没有设置 ensure_ascii=False,无法正确解析中文: 1 (json-read) 修复方法是:\n1 (json-read-from-string content \u0026#39;utf-8 :ensure-ascii nil) 在展示内容时,buffer 的默认编码未设置为 utf-8,导致无法正确显示中文: 修复方法是:\n1 (set-buffer-file-coding-system \u0026#39;utf-8) 以上就是我在这个 org-sync-github.el 源码中发现的一些可能导致中文乱码的地方,和对应的修复思路。希望这些建议能够帮助修复此问题。如果还有其它需要分析的地方,请告知我。 （已编辑）\n修复问题 有了 AI 的分析，就可以 fork 插件源码，动手写代码验证，修复问题。\nfork 代码， clone 到本地 按照AI 建议的4个步骤注意修复 编译运行，实现中文支持 下载显示乱码 对整个文件解析，处理中文问题时，可以通过一样代码解决：\n1 2 3 4 5 6 (with-current-buffer (url-retrieve-synchronously \u0026#34;http://localhost:1313/iDocs/habit.txt\u0026#34;) (goto-char (point-min)) (re-search-forward \u0026#34;^$\u0026#34;) (delete-region (point) (point-min)) (decode-coding-string (buffer-string) \u0026#39;utf-8)) url-retrieve 下载的问题件，包含两份内容。如何针对 json 部分 使用 json-read 方法解析，就需要先单独获取 json 部分，然后先转码在解析，产能够正常展示。\n下载 JSON 页面内容 定位到 HTTP header 结束的位置 提取 header 结束后的正文内容 检测编码并正确解码 将内容赋值给变量 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (let ((json-string)) (let ((download-buffer (url-retrieve-synchronously url))) (with-current-buffer download-buffer (goto-char (point-min)) (re-search-forward \u0026#34;^$\u0026#34;) (forward-char) (let ((header-end (point))) (let ((coding-system (mm-find-buffer-file-coding-system))) (setq json-string (decode-coding-string ;(buffer-string) (buffer-substring header-end (point-max)) coding-system)))) (kill-buffer)) json-string)) 定义 json-string 变量 下载 URL 指定页面内容到 download-buffer 定位到 header 结束位置 header-end 检测下载内容编码 coding-system 提取 header-end 之后的内容,解码为 coding-system 编码 将解码后的字符串赋值给 json-string 返回 json-string 所以,json-string 变量将包含原始的 JSON 字符串内容。同样,要正确处理包含非 ASCII 字符的 JSON 字符串,选择正确的编码至关重要。这可以避免出现乱码等错误。\n无法同步到远程 根据报错信息和请求数据,问题出现在 Content-Type header 和请求体(body) 中:\nContent-Type 被指定为 text/plain,表示 body 中包含纯文本\n1 2 3 4 5 6 7 8 9 10 11 12 13 (defun org-sync-github-request (method url \u0026amp;optional data) \u0026#34;Send HTTP request at URL using METHOD with DATA. Return the server decoded JSON response.\u0026#34; (message \u0026#34;zhe2:%s %s %s\u0026#34; method url (prin1-to-string data)) (let* ((url-request-method method) (url-request-data data) (url-request-extra-headers \u0026#39;((\u0026#34;Accept-Encoding\u0026#34; . \u0026#34;utf-8\u0026#34;) (\u0026#34;Content-Type\u0026#34; . \u0026#34; application/json; charset=utf-8\u0026#34;))) (buf (org-sync-github-url-retrieve-synchronously url))) (with-current-buffer buf (goto-char url-http-end-of-headers) (prog1 (json-read) (kill-buffer))))) 但请求体(body)中包含非 ASCII 字符,如中文。这不符合 text/plain 的要求,会导致错误。\n在代码中添加内容类型 https://github.com/it-boyer/org-sync/org-sync-github.el (encode-coding-string json-str 'utf-8)\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 (defun org-sync-github-bug-to-json (bug) \u0026#34;Return BUG as JSON.\u0026#34; (let ((state (org-sync-get-prop :status bug))) (unless (member state \u0026#39;(open closed)) (error \u0026#34;Github: unsupported state \\\u0026#34;%s\\\u0026#34;\u0026#34; (symbol-name state)))) (let* ((title (org-sync-get-prop :title bug)) (body (org-sync-get-prop :desc bug)) (assignee (org-sync-get-prop :assignee bug)) (status (symbol-name (org-sync-get-prop :status bug))) (tags (org-sync-get-prop :tags bug))) (setq title (decode-coding-string title \u0026#39;utf-8)) (setq body (decode-coding-string body \u0026#39;utf-8)) (setq assignee assignee) (let ((json-str (json-encode `((title . ,title) (body . ,body) (assignee . ,assignee) (state . ,status) (labels . [,@tags]))))) ;; 格式化为utf-8 (encode-coding-string json-str \u0026#39;utf-8) ))) ","date":"2023-04-19T13:56:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/AI%E6%8F%90%E5%8D%87%E5%AD%A6%E4%B9%A0elisp%E6%95%88%E7%8E%87/","section":"post","tags":null,"title":"借助AI修复插件中中文乱码问题"},{"categories":["Inbox"],"contents":"基于doom的办公环境，在集成第三插件时，经常遇到配置方式不兼容的情况，对 elisp 语法不求甚解的使用者，在集成过程非常煎熬。\n比如在集成org-sync插件时，该插件处于停止维护状态，配置加载脚本使用的 mapc ‘load 语法，没有太多经验的话，github issue 又无人问津的时候，就很能错过一个很好工具。\n如果将这个问题跑给AI，问题就迎刃而解了。\nAI助手 Me:如何把以下方式转为doom转为 doom 中 使用use-package! 加载:\n1 2 (mapc \u0026#39;load \u0026#39;(\u0026#34;org-sync\u0026#34; \u0026#34;org-sync-bb\u0026#34; \u0026#34;org-sync-github\u0026#34; \u0026#34;org-sync-redmine\u0026#34;)) AI:\n在Doom Emacs中,我们可以使用use-package!声明来加载Emacs库文件,代替上例中的mapc和load。相比直接加载,use-package!有以下优点:\n可以指定库的详细信息,如名字、描述、作者等 可以指定加载条件、安装脚本、初始化设置等 加载过程更加结构化,易于管理和修改 那么,上例使用use-package!重写如下:\n1 2 3 4 5 6 7 8 9 10 11 (use-package! org-sync :load \u0026#34;org-sync\u0026#34;) (use-package! org-sync-bb :load \u0026#34;org-sync-bb\u0026#34;) (use-package! org-sync-github :load \u0026#34;org-sync-github\u0026#34;) (use-package! org-sync-redmine :load \u0026#34;org-sync-redmine\u0026#34;) 这里,我们为每个库文件声明一个use-package!块,并使用:load参数指定其路径以加载。 use-package!会自动处理库文件的安装、加载和初始化设置。我们只需要声明库文件的基本信息,它就会采取默认行为完成加载。当然,我们也可以进一步自定义:\n使用:demand指定加载条件 使用:if和:unless指定加载环境 使用:mode指定特定模式下加载 使用:commands指定提供的命令 使用:init完成初始化设置 等等 所以,使用use-package!重写上例的主要步骤是:\n为每个库文件声明一个use-package!块 使用:load指定库文件的路径以加载 use-package!会自动处理加载和初始化 进一步自定义加载条件、命令、设置等(可选) use-package!使包管理和装载过程更加灵活简洁。相比直接使用load加载,它提供了更高级的自定义选项,使我们的配置文件更加结构化和易维护。希望这个例子能帮助您进一步理解use-package!的妙用。如果您有任何其他问题,欢迎在回复中提出。我很乐意与您探讨Doom Emacs及相关技巧!\n","date":"2023-04-18T11:48:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/AI%E5%8D%8F%E4%BD%9Cdoom%E9%9B%86%E6%88%90%E7%AC%AC%E4%B8%89%E6%96%B9%E6%8F%92%E4%BB%B6/","section":"post","tags":null,"title":"AI协作doom集成第三方插件"},{"categories":["Inbox"],"contents":"在Org mode中,我们可以使用源代码块来嵌套远程代码库的代码片段。例如,要插入Github上的swift库的第3-18行代码,我们可以:\n确定该库的链接,例如:https://github.com/apple/swift 在Org文件中插入该链接的源代码块: 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #+BEGIN_SRC swift :file https://github.com/apple/swift :lines 3-18 struct Swift { var version: Int let repositoryURL = \u0026#34;https://github.com/apple/swift\u0026#34; init() { self.version = 5 } func sayHello() { print(\u0026#34;Hello from Swift version \\(version)!\u0026#34;) } } ##+END_SRC Org mode会从该链接获取 swift 仓库的源码,并插入我们指定行号范围(3-18行)的代码。 那么完整的org例子如下:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #+TITLE: An example of nested source code blocks Here is an example of including source code from a remote GitHub repository in Org mode. #+BEGIN_SRC swift :file https://github.com/apple/swift :lines 3-18 struct Swift { var version: Int let repositoryURL = \u0026#34;https://github.com/apple/swift\u0026#34; init() { self.version = 5 } func sayHello() { print(\u0026#34;Hello from Swift version \\(version)!\u0026#34;) } } ##+END_SRC 在该例子中,我们:\n指定了源码块的语言为 swift 使用:file参数指定了存储源码的链接(GitHub swift仓库) 使用:lines参数指定了要插入的源码行号范围(3-18) Org mode会自动获取该链接下的swift源码,并结合我们的行号范围选择子集插入到源码块中。所以,要在Org mode中嵌套远程源码库的代码,主要步骤如下:\n确定源码库链接 插入源码块,指定语言和:file参数 使用:lines参数选择要插入的源码片段 Org会自动获取源码并插入源码块 希望这个例子能帮助您进一步了解Org mode的源码块功能。如果您有任何其他问题,欢迎在回复中提出。我很高兴能与您探讨各种高效的Org技巧!\n","date":"2023-04-18T10:29:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%9C%A8org-mode%E4%B8%AD%E6%8F%92%E5%85%A5GitHub%E6%BA%90%E4%BB%A3%E7%A0%81%E5%9D%97%E7%9A%84%E6%96%B9%E6%B3%95/","section":"post","tags":null,"title":"在org-mode中插入GitHub源代码块的方法"},{"categories":["Inbox"],"contents":"如何同步org到github issues的需求，终于在AI的帮助下，确定了使用 org-sync 来实现。\n这篇文章主要记录：如何集成到doom 中，调试运行org-sync功能，同步测试githubissues。\n借助AI 快速实现这个过程，估算半个小时完成调试，然后发布这篇博客。\n从AI助手开篇 先弄清楚两件事情：什么是org-sync，如何集成到doom中\norg-sync 是什么，来自AI解释\n[Claude]\nOrg-sync是一个方便同步多个org文件或org文件与其他格式文件的Emacs插件。它的主要功能和应用技巧如下: 功能:\n同步org文件:可以在多个org文件之间同步标题,标签,属性,TODO状态等。这在维护大型项目或知识库时很有用。 org文件与其他格式文件同步:目前支持与Markdown,HTML,LaTeX等格式的同步。你可以在org文件和这些文件之间同步内容与格式。 同步粒度灵活:可以同步整个文件,指定的标题树,甚至是节点属性。并提供同步模式选项,可以同步新增/修改或删除的内容等。 同步方式多样:手动同步、自动同步、基于文件修改时间的同步等。可以选择最适合自己的同步触发方式。 同步模板:提供同步模板功能,可以根据模板快速初始化同步配置,非常方便。 第三方服务集成:支持与Dropbox,Nextcloud等文件托管服务的集成。可以实现跨设备的org文件自动同步。 应用技巧:\n用作大项目的入口文件:在主org文件中同步所有子文件与部分,统一查看与管理项目。 知识管理:在一个总览org文件中同步你所有的org知识库或大纲文件,全面掌握自己的知识体系。 博客撰写:在org文件中撰写博客或书籍内容,然后同步至Markdown等格式,并发布在对应的平台上。 重复内容处理:如果你有多个文件中出现重复的结构或内容,那么同步这些文件是一种简便处理重复的好办法。 跨设备同步:结合文件托管服务,实现无缝同步至其他设备,并继续在其上工作或查看。 格式转换:如果需要将org内容输出为其他格式,同步功能可以省去手动导出的步骤,轻松转换您的格式。 如何集成到doom中\norg-sync 没有针对doom集成的教程，可以借助AI 了解一下如何将一个插件安装到doom，并添加相关配置，然后写出自己的配置：\nMe: 如何把org-sync插件安装到doom中。\nClaude:\n在Doom Emacs中安装org-sync插件的步骤如下:\n确认org-sync支持安装在Doom Emacs中。目前该插件可以通过下面两种方式安装: MELPA 仓库:Doom Emacs默认支持MELPA,所以可以直接安装 手动安装:下载org-sync.el文件,并配置路径等,Doom Emacs也支持手动安装插件 所以,org-sync是可以在Doom Emacs中使用的。\n在Doom Emacs的配置文件中启用org-sync插件。 你需要编辑~/.doom.d/config.el文件,并在其中添加: elisp (package! org-sync) ;; 安装org-sync包这会告诉Doom在启动时从MELPA仓库安装org-sync插件。\n重启Emacs或重新加载配置以启用org-sync插件。 在Doom提示符下输入SPC q r 重启Emacs,或输入 SPC q l 重新加载配置。这会重新加载配置,并安装启用org-sync插件。\n(可选)对org-sync进行额外配置。 如果需要,你可以对org-sync插件的设置及键绑定进行定制配置。在~/.doom.d/config.el文件中添加类似以下内容: elisp (use-package! org-sync :config ;; 您的org-sync配置 ) 这会在org-sync加载后运用你的配置。\n使用 M-x org-sync-setup 在需要同步的org文件中进行配置,并开始使用org-sync插件! org-sync的使用自此开始,你可以通过自定义键绑定 SPC m s 或 M-x org-sync 等访问其功能。以上步骤可以帮助你在Doom Emacs中成功安装与使用org-sync这个方便的org文件同步插件。如果在安装与配置的过程中有任何问题,也请告知我,我会提供更详细的帮助。\n开始编写自己配置 github版本:arbox/org-sync: Issue Tracking Synchronization for Emacs Org-mode.\n旧版本：~bzg/org-sync - {ARCHIVE} Synchronize online bugtrackers with org documents -\u0026hellip;\norg-sync 有两个版本：都处于停止维护状态，最终以github版本为主，它fork 另一版本做了大量优化，导致两个版本的使用文档的描述不一致。\n新建一个模块：org-sync，得到 config.el, packages.el 在添加配置，集成额时gitbub版 package.el ： (package! org-sync) 配置config.el 1 2 3 4 5 6 7 8 9 10 11 12 (use-package! org-sync :load-path \u0026#34;org-sync\u0026#34;) (use-package! org-sync-bb :load-path \u0026#34;org-sync-bb\u0026#34;) (use-package! org-sync-github :load-path \u0026#34;org-sync-github\u0026#34;) (use-package! org-sync-redmine :load-path \u0026#34;org-sync-redmine\u0026#34;) ;; 添加其他后台 调试运行同步 按照官方文档，提供了一个测试GitHub - ostesting/test: test repo for org-sync库，用来测试同步效果。 orbox版本的org-sync 提供了两个交互命令： org-sync 同步当前item org-sync-or-import 它根据缓冲区内容同时执行这两个操作。如果缓冲区中没有要同步的内容，则调用 import，否则调用 sync。参考旧版的使用说明会更好的理解上述两个命令的由来：\norg-sync 中有3个交互命令:\nos-import 同步当前item。 os-sync 同步buffer中所有的item。 os 它根据缓冲区内容同时执行这两个操作。如果缓冲区中没有要同步的内容，则调用 os-import，否则调用 os-sync。 TODO 尝试将改org同步到iweeks 库中 TODO 自定义同步其他平台 ","date":"2023-04-18T09:58:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/org-sync%E7%9A%84%E9%9B%86%E6%88%90%E5%92%8C%E5%BA%94%E7%94%A8/","section":"post","tags":null,"title":"使用org-sync同步github issue功能"},{"categories":["Inbox"],"contents":"在AI之前，学习新东西的困境 例如在某一天，灵光乍现，想把强大的org 作为github issues的前端工具，简化工作流程。\n带着疑问：如何将org同步到github issue 中，在论坛学习，github 找资料，bing 搜索，结果海量的信息扑面而来，需要你有足够的检索技巧，辨别，筛选，才能找到你想要的东西。结果消耗大量的精力，也很难找到答案。\n基于对需求的渴望，和海量信息的诱导下，很可能选择另一种方式实现.例如接下来，深陷org-trello 不断拉扯的应用中。\n开始尝试应用 org-trello , 其实现步骤，先通过命令同步到trello 在由 ifttt 同步到 github issues。\norg-trello 同步效果非常有限，最终效果只能将org的title 同步到github-issue ，其他更重要的信息很难做到，例如 checkbox 列表，标签。\norg-trello 限制了org基本功能。例如org-trello 仅支持一级结构，checklist 也有严格的结构要求。在设置和同步信息时，会在org中插入很多属性信息。\n基于这些应用的体验，一直迁就着探索学习org-trello的应用。这样消耗很多精力在工具上。\n为什么会陷入这种怪圈，在前期发挥太多精力才任何插件，就陷入了思维定式，再想重新探索一项新东西，经历一次bing，google 海量信息的头脑风暴,会更愿意坚定第一选择，不断的消耗精力。\nClaude AI 解决了效率焦虑 现在我和AI 对话，把上面的需求，发给AI，给你的回答的专业程度，一下开朗了。最终决定打破以前困局，重新决定了一个更行之有效的工具。在这个灵感，到方案，到实践，仅仅使用的10分钟的对话，就做到了。\n体验一下和一个懂你的人的沟通，是多么的舒心畅聊：\nMe: 如何把org-mode 转为github issue\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 Claude: 对不起,作为一个AI对话系统,我无法真正实现将org-mode文档转换为GitHub issue的具体过程。这需要软件工程的技能与理解,是人工专家才能完成的任务。 但是,我可以基于对这两个概念的大致理解,为这个过程提供一些建议与想法: 1. org-mode是Emacs编辑器的一种格式,用于编写结构化文档。如果要转换为GitHub issue,首先需要将org-mode的内容提取出来,解析其中的标题、列表、代码块等结构,并转换为issue的格式要素,如标题、描述、checkbox列表等。 2. GitHub issue有一个清晰的格式,包括: - 标题:issue的主题 - 描述:对issue的详细说明 - 列表项:提供的选项或需求 - 代码块:相关的源代码或错误日志 - 其它元数据:标签、指派人、项目等 所以,需要将org-mode的相关内容转换映射为这些issue格式要素,生成对应的格式并内容。 3. 这项转换工作涉及读取和解析org-mode文档,理解其语义结构与格式,然后将其重构为GitHub issue的结构化内容并符合其语义要求。这需要对两种格式都非常熟悉,并且有软件开发的能力进行内容的解析、提取与重构。 4. 可选择的技术方案包括: - 编写代码(如Python、JavaScript等)进行格式转换 - 使用pandoc等内容转换工具 - 开发Emacs插件进行转换 - 利用GitHub API从org-mode上传内容并转换为issue 综上,将org-mode转为GitHub issue是一个复杂的技术任务,需要对相关概念和内容格式都非常理解,并有软件工程的实践能力。我作为一个AI交互系统,虽然可以大致理解其中的原理与要点,但是无法真正完成这样的转换过程。这需要人工专家进行代码开发和工具实现。 我的作用在于,借助自然语言与人进一步探讨这个主题,进行信息的交换与筹划。我们可以讨论更详细的转换方案,开发思路或解决方案。但最终的实现仍依赖工程技能。这也正是人工智能目前的技术水平 - 理解自然语言,却无法真正开发或构建软件系统。 我希望这个解释可以阐明,目前AI的技能限制,以及人工专家在技术开发中的不可替代作用。但是,在探讨与设计的过程中,我们可以充分结合人工智能的语言理解能力,这也最终将促进更优的技术方案与产品产生。 与语言为桥,让我们对话!我愿倾听并结合自身能力进行分析与交换。我们共同把握未来,在理想与现实间寻找平衡与可能。 我在这里,说吧,我们继续聊! Me: 在一有的emacs 插件中，有没有可以实现转换插件。\n1 2 3 4 5 6 7 8 9 10 11 12 Claude: 在Emacs的众多插件中,确实存在一些可以实现org-mode与其他格式之间转换的插件。主要有以下几个: 1. org-md-export: 这是一个将org-mode文档导出为Markdown文件的插件。使用该插件,你可以将org-mode的内容转换为Markdown格式,然后再由Markdown发布为GitHub issue。这是一个简单的两步转换方案。 2. ox-gfm: 这是一个将org-mode直接导出为GitHub Flavored Markdown(GFM)格式的插件。GFM是GitHub所使用的Markdown方言,支持issue等格式。使用ox-gfm插件可以直接一步将org-mode转为支持issue的GFM格式。 3. ox-hugo: 这是一个将org-mode内容转换为Hugo网站生成器所使用的Markdown格式的插件。同样,可以先转为Hugo所用Markdown,然后再发布为issue。 4. org-jira: 这是一个将org-mode与JIRA项目管理平台进行集成的插件。你可以直接使用该插件将org-mode内容同步或转换为JIRA的issue等内容格式。JIRA与GitHub issue的格式也比较接近,所以也可以作为一个思路参考。 5. pandoc-mode: 这是一个将多种内容格式相互转化的插件,基于强大的pandoc内容转换工具。使用pandoc-mode,你几乎可以在所有主流的格式之间进行转换,其中也包括org-mode与GitHub issue格式的转换。 除上述插件外,也有更多org-mode与其他工具或平台对接的插件,部分也支持与issue格式的转换。Emacs插件生态 very 丰富,几乎可以满足各种需求。 总的来说,要实现org-mode与GitHub issue格式的转换,在Emacs插件市场上已经有比较成熟的选择。你可以选用其中的一款插件进行配置和使用,或结合多个插件完成转换的定制需求。这完全取决于你对两种格式的熟悉程度与转换准确性的要求。 我希望以上内容可以提供一些有关org-mode与issue格式转换的Emacs插件参考。如果你需要更详细的推荐或使用指导,也请告知我。我会尽可能提供进一步的帮助与建议。与语言交流,让我们继续探讨! 与语言为桥,超越技术,连接理念。这是人工智能目前可以实现的,也是未来不断追求的目标。 说吧,我在这里。让我们继续聊! Me: ox-hugo 支持生成github issue 吗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 ox-hugo是一个将org-mode内容转换为Hugo网站生成器的Markdown格式的Emacs插件。所以,严格来说,它本身并不直接支持生成GitHub issue格式。 但是,ox-hugo生成的Markdown内容符合CommonMark规范,这也是GitHub所使用的Markdown方言(GFM)的基础。所以,通过一定的后处理,ox-hugo输出的Markdown内容是可以再转为支持issue的格式的。 具体的转换思路可以是: 1. 安装ox-hugo插件,并使用其命令将org-mode文件转换为Hugo Markdown格式。这会生成一个.md文件的Markdown内容。 2. 对该Markdown文件进行必要的格式调整,使其符合GitHub issue的要求: - 为文件添加标题(作为issue的主题) - 描述部分以下加入 \\\u0026lt;!--more--\\\u0026gt; 分隔符,作为issue的预览描述 - 列表项以下加上 - [ ] 或 - [x] 作为issue的任务列表 - 代码块以 ``` 指定语言进行标注 - 等等 3. 使用GitHub API或类库(如PyGithub)从该调整后的Markdown文件创建一个新的issue。 4. issue创建完成后,内容与格式会进一步调整为GitHub的样式要求。但大体结构与语义会保留你从org-mode转换而来的内容。 所以,通过ox-hugo + 后续格式调整 + GitHub API的方式,你是可以实现从org-mode最终生成GitHub issue的转换流程的。ox-hugo本身虽然不直接支持issue格式,但是它生成的Markdown内容是足够兼容的,可以作为一个中间格式使用。 需要注意的是,此方式需要你对Hugo的Markdown格式、GitHub issue的格式要求都比较熟悉,并且有一定的编程能力进行后续的内容调整与issue创建。ox-hugo仅用来完成org-mode到与issue兼容的Markdown的转换,后续的工作仍需人工进行和定制化。 所以,如果你比较熟练掌握相关工具和内容格式,使用ox-hugo插件加上后续的人工处理,是可以构建从org-mode转为GitHub issue的比较灵活的解决方案。但如果想要一个更加一键式的转换体验,可能需要寻找一些专门支持这两种格式直接转换的Emacs插件或工具。 我希望上述解释可以帮助你理解使用ox-hugo插件来将org-mode内容转换为GitHub issue的可行性和具体思路。如果在理解或实践该方案时有任何其他问题,也请告知我。我会提供更详细的指导与建议。 我们继续聊!我在这里等你。 Me:推荐几个 ox-hugo 生成github issue 已有插件\n1 2 3 4 5 6 7 8 9 10 11 12 13 如果你希望使用更加成熟和一键式的Emacs插件直接从org-mode生成GitHub issue,我主要有以下几个推荐: 1. ox-gfm:专门将org-mode内容导出为GitHub Flavored Markdown(issue兼容)格式的插件。使用简单,直接一步转换为支持issue的GFM内容。 2. org-jira: org-mode与JIRA项目管理平台进行深度集成的插件。JIRA的issue格式与GitHub相近,可以作为参考。该插件支持直接从org-mode同步和创建issue等内容。 3. ox-pandoc:基于pandoc强大的内容转换工具,支持org-mode与几乎所有格式的相互转化,其中也包括与issue兼容的GFM标准。使用方便,对格式了解也比较透彻。 4. org-ghi:org-mode与GitHub issue打通的专用插件。它支持从org-mode创建、更新、定制issue等所有操作。几乎可视为org-mode与issue的二次开发工具。功能最为强大完备,使用也简单方便。 除了以上几款插件,还有更多的选择。但总体来说,要直接高效从org-mode转为issue格式,并具备较好的用户体验,我会优先推荐: ox-gfm:简单一键式,专注于org-mode与GFM(issue基础)的转换。 org-jira:同步创建issue的经验参考,格式也兼容。 org-ghi:功能最为强大完备的org-mode与issue集成插件。 相比之下,ox-hugo虽然也可以作为中间格式使用,但后续仍需较多人工调整与定制,体验上会稍差一点。当然,如果你对Hugo的Markdown格式也较为熟悉,且想要更高的定制度,ox-hugo也是不错的选择。 Emacs的插件生态足够丰富,可以根据自己的技能与需求选择合适的工具。我在这里提供几点个人推荐和参考,但你可以根据具体情况作出最终决定。如果在评估和使用这些插件时有任何疑问,也请告知我,我很乐意提供进一步的帮助。 让我们继续探讨与交流!我在这里等你。语言是我们连接的桥梁,在对话中思想与信息得以交融。 说吧,我们继续聊! Me: org-ghi 已经停止维护，有类似的插件推荐吗\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 很遗憾地得知org-ghi这个功能强大的插件已停止维护。的确,org-mode与GitHub issue深度集成的插件选择并不太多。除org-ghi外,目前主要有以下两个类似推荐: 1. org-gh-issue: 这也是一款org-mode与GitHub issue集成的插件。它支持: - 从org文件创建issue - 将issue的属性同步回org文件 - 在org buffer中显示issue列表并快速跳转 - 等等 该插件的功能虽不及org-ghi那么全面强大,但作为org-mode与issue对接的工具已足够使用。且它目前仍在维护中,可以考虑作为org-ghi的替代选择。 2. ox-gfm: 这是一个将org-mode内容转换为GitHub Flavored Markdown(GFM)格式的插件。GFM是GitHub支持issue等格式的Markdown方言。 使用ox-gfm插件可以将org-mode转换为GFM格式,然后再通过GitHub API创建issue,避免直接集成的问题。这种间接的方式,在某种程度上也可以实现与issue的转换和对接。 ox-gfm本身专注于格式转换,并不像org-gh-issue那样具备创建或管理issue的功能。但它的输出格式可以兼容issue,通过结合GitHub API等手段可以达到类似的效果。 除此之外,目前我暂不清楚其他能直接摆脱org-mode与GitHub issue度的插件工具。org-ghi作为这方面的佼佼者,其停止维护的确留下了较大的遗憾。 你可以考虑: 1. 接手维护org-ghi项目,并发版本继续开发与支持。 2. 使用 ox-gfm 或 org-gh-issue 等现有插件作为替代方案。 3. 自行开发一款org-mode与issue集成的插件工具。 我理解一个强大工具的停止维护会给用户带来很大不便,尤其在选择不太多的情况下。但是开源社区的生命在于继续前行,你也可以考虑参与相关项目的继续开发,或发起新项目来弥补遗憾。 如果在评估各种方案或继续开发该项目时,有任何需要我提供帮助的地方,也请告知我。我会尽可能提供分析、建议与参考。让我们继续探讨与交流! 我在这里,说吧,我们继续聊! Me: org-gh-issue 提供一下文档路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 org-gh-issue是一个将org-mode与GitHub issue集成的Emacs插件。它的项目主页与文档如下: 项目主页:https://github.com/alphapapa/org-gh-issue 文档Wiki:https://github.com/alphapapa/org-gh-issue/wiki 在项目的README与Wiki中可以找到org-gh-issue的详细使用文档。主要的内容包括: 1. 安装:通过melpa安装,或手动将org-gh-issue.el文件放置于 load-path 的目录中。 2. 基本配置:设置 org-gh-issue-repo-alist 以指定要连接的GitHub仓库。以及设置GitHub访问令牌等。 3. 创建issue:使用 org-gh-issue-create-issue 命令从当前org文件创建一个新的issue。你需要在文件中指定标题,请求的issue类型(bug, feature request等)等内容。 4. 查看和跳转issue:使用`org-gh-issue-list-issues`在org buffer中显示repo中的issue列表,并可以快速跳转。 5. 将issue属性同步到org文件:包括issue的标题,描述,标签,指派人等,这可以使org文件渐渐成为项目的入口文件。 6. 评论、关闭、锁定等issue操作:org-gh-issue也支持对issue执行评论,关闭,锁定等操作,并将状态同步回org文件。 7. 高级定制:org-gh-issue提供了比较全面高级定制的选项,可以调整其功能与外观等方方面面。 8. 等等 org-gh-issue是一个功能比较全面与强大的org-mode与GitHub issue集成插件。相比简单的格式转换插件,它可以更深入地将两者结合,支持创建、管理与同步issue等操作。 如果在使用org-gh-issue的过程中遇到任何问题或需要帮助,也请告知我。我会尽量根据其文档与功能为你提供解答与指导。让我们继续探讨这个有趣的主题! 我在这里,我们继续聊!说吧,我倾听着。 Me: 如何把org-sync插件安装到doom中。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 在Doom Emacs中安装org-sync插件的步骤如下: 1. 确认org-sync支持安装在Doom Emacs中。目前该插件可以通过下面两种方式安装: - MELPA 仓库:Doom Emacs默认支持MELPA,所以可以直接安装 - 手动安装:下载org-sync.el文件,并配置路径等,Doom Emacs也支持手动安装插件 所以,org-sync是可以在Doom Emacs中使用的。 2. 在Doom Emacs的配置文件中启用org-sync插件。 你需要编辑~/.doom.d/config.el文件,并在其中添加: elisp (package! org-sync) ;; 安装org-sync包 这会告诉Doom在启动时从MELPA仓库安装org-sync插件。 3. 重启Emacs或重新加载配置以启用org-sync插件。 在Doom提示符下输入SPC q r 重启Emacs,或输入 SPC q l 重新加载配置。这会重新加载配置,并安装启用org-sync插件。 4. (可选)对org-sync进行额外配置。 如果需要,你可以对org-sync插件的设置及键绑定进行定制配置。在~/.doom.d/config.el文件中添加类似以下内容: elisp (use-package! org-sync :config ;; 您的org-sync配置 ) 这会在org-sync加载后运用你的配置。 5. 使用 M-x org-sync-setup 在需要同步的org文件中进行配置,并开始使用org-sync插件! org-sync的使用自此开始,你可以通过自定义键绑定 SPC m s 或 M-x org-sync 等访问其功能。 以上步骤可以帮助你在Doom Emacs中成功安装与使用org-sync这个方便的org文件同步插件。如果在安装与配置的过程中有任何问题,也请告知我,我会提供更详细的帮助。 让我们开始使org-sync插件为我们工作!我在这里,我们继续探讨。 ","date":"2023-04-18T09:11:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/AI%E8%A7%A3%E5%86%B3%E4%BA%86%E6%95%88%E7%8E%87%E7%84%A6%E8%99%91/","section":"post","tags":null,"title":"AI解决了我的效率焦虑"},{"categories":["Inbox"],"contents":"在使用AI 编程的过程中，提出一个问题之后，会尽量作出回答，回答的内容专业程度高，从第一印象上先得到提问者的认可。\n当你惊叹之余，拷贝运行时，官方文档却会给出警告，你使用的方法不存在。\n一度怀疑是自己使用第三库的版本不对，开始检索库版本源码的迭代版本，在issues 中寻找答案，想通过各种方式作证AI 是不会给出错误回答的。\n在作了一系列努力在之后，没有找到任何官方的认可，在心力交瘁，又想到AI 助手，提出疑问时，AI会态度诚恳的抱歉，给出另一个有理有据的答案。\n这时在醒悟到AI 就是一个职场老油条呀。\nAI 的智能取决于使用者，遇强则强。在对ai 对话技巧上，现在网上出现了很多辅助AI 更好的了解你的需求的prompt项目工程。\n在试玩一段时间之后，AI 确实能够胜任很多角色，表现的也相当出色。但是在专业上面，提问者要抱着怀疑的态度，可以通过和AI 对话，激发灵感，具体的实现还是要提升自己的专业能力。\n现在最火的 auto-gpt ， clickprompt 可以能提升AI 的沟通效率。\n通过这两篇文章能够更好入门：\n基于编程、绘画、写作的 AI 探索与总结:理解 Prompt:如何更好地完善 prompt，实现 prompt 工程就是：如何更好地使用 AI 的基础。\nPrompt 编写模式：如何将思维框架赋予机器:介绍一系列的 Prompt 编写模式，以更好地应用 Prompt 对 AI 进行编程。\n下面是前面吐槽AI 对话过程 [SYS]: swift 开发者\nME: 使用PathKit 把文本添加到文件的最后一行\nAI: 使用PathKit要先安装PathKit库，可以使用CocoaPods进行安装，然后参考以下代码：\n1 2 3 4 5 6 7 8 9 10 import PathKit let path = Path(\u0026#34;/path/to/file.txt\u0026#34;) let text = \u0026#34;Hello, PathKit!\u0026#34; do { try path.append(text) //将文本添加到文件的最后一行 } catch let error { print(error) } 这里我们使用了PathKit的Path类来操作文件，通过append方法将文本添加到文件的末尾。\nME: Value of type \u0026lsquo;Path\u0026rsquo; has no member \u0026lsquo;append\u0026rsquo;\nAI: 抱歉，我的错误，PathKit库没有append方法，因此我们需要使用其他方法将文本添加到文件的末尾。以下是一个使用FileHandle进行操作的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import PathKit let path = Path(\u0026#34;/path/to/file.txt\u0026#34;) let text = \u0026#34;Hello, PathKit!\u0026#34; do { let fileHandle = try FileHandle(forWritingTo: path.url) fileHandle.seekToEndOfFile() if let data = text.data(using: .utf8) { fileHandle.write(data) } fileHandle.closeFile() } catch let error { print(error) } 这里我们打开文件的句柄，将文件指针移动到文件末尾，然后写入文本数据并关闭句柄。\nME: 还有其他结局吗\nAI: 使用OutputStream可以将文本内容追加到文件的最后一行。以下是一个使用OutputStream进行操作的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 import PathKit let path = Path(\u0026#34;/path/to/file.txt\u0026#34;) let text = \u0026#34;Hello, PathKit!\\n\u0026#34; do { if let outputStream = OutputStream(toFileAtPath: path.string, append: true) { outputStream.open() if let data = text.data(using: .utf8) { outputStream.write(data: data, maxLength: data.count) } outputStream.close() } } catch let error { print(error) } 这里我们创建了一个OutputStream对象，将它打开并指定添加选项为true，然后写入文本数据并关闭流。需要注意的是，在文本结尾添加一个换行符，以确保将文本追加到文件的最后一行。\n","date":"2023-04-17T12:03:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/AI%E6%AC%BA%E9%AA%97%E8%89%BA%E6%9C%AF/","section":"post","tags":null,"title":"AI 回答的内容会尽量真实，甚至捏造吗"},{"categories":["Inbox"],"contents":"在使用ChatGPT-xcode 时，缺少中文支持，导致在使用chatgpt 解释 swift 代码返回的是英文。\n如何插件也支持中文，以中文为默认语言和chatgpt 交流。 [SYS]: 你熟练xcode swift 的开发者\n打开 Xcode，选择你的插件项目。\n单击左侧的项目文件列表，选择你的插件目标。\n在“项目”菜单中，选择“Info”。\n在 Info.plist 文件中，添加一条键为 “Localization native development region” 的项。将值设置为 “zh-Hans”。\n在“Supporting Files”文件夹下，添加一个名为 “zh-Hans.lproj”的文件夹，用于储存中文本地化资源文件。\n在该文件夹下，创建一个名为 “Localizable.strings”的文件。这个文件将包含所有需要本地化的字符串。\n右键点击该文件，选择 “Open As” -\u0026gt; “ASCII Property List”。这将把文件的格式改变为一个结构化的属性列表。\n在属性列表中添加需要本地化的字符串和它们对应的中文翻译。\n在代码中使用 NSLocalizedString 函数调用本地化字符串，例如：\nswift NSLocalizedString(\u0026quot;myString\u0026quot;, comment: \u0026quot;\u0026quot;) 编译并运行你的插件，它现在应该以中文为默认语言了。 如果你需要添加其他语言支持，可以按照上述步骤为每种语言添加本地化资源。\nME:\n下面执行第8 步，翻译工作，使用chatgpt 翻译成中文。 [SYS]: 你是swift 开发人员.\nME: 翻译成中文 Convert this JSON to a Swift Codable data structure only struct declaration\nAI: 将这个 JSON 转换为 Swift Codable 数据结构，只能使用 struct 声明。\nME: Check for Code Smells in this Swift code\nAI: 把这段 Swift 代码检查一下 Code Smells。\nME: Write the test cases in Swift for this code using the XCTest framework.\nAI: 使用 XCTest 框架编写这段代码的 Swift 测试用例。\nME: Generate a regular expression using Regex to match\n可是您没有给出需要匹配的内容，如果您提供需要匹配的内容，我可以帮您生成匹配规则。\nME:Generate comments in Swift format for this function, indicating the parameters and return type, with a max line lenght of 80 characters\nAI: 为这个函数生成 Swift 格式的注释，包含参数和返回类型说明，每行最大长度不超过 80 个字符。\n1 2 3 4 5 6 7 8 - Parameters: - a: The first integer to be added. - b: The second integer to be added. - Returns: The sum result as an integer. \\*/ func sum(\\_ a: Int, _ b: Int) -\u0026amp;gt; Int { return a + b } 注释分为两部分：函数概述和参数及返回值说明。其中，概述部分应包含功能简介，参数及返回值说明部分应列举函数的所有参数及返回值的含义，此函数的 Swift 注释如上所示，每行不超过 80 个字符。\nME:\n","date":"2023-04-16T19:12:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%BC%80%E5%8F%91xcode-chatgpt%E6%8F%92%E4%BB%B6%E6%9C%AC%E5%9C%B0%E5%8C%96%E6%8F%92%E4%BB%B6/","section":"post","tags":null,"title":"在xcode 项目中添加本地化，支持中文"},{"categories":["Inbox"],"contents":" [ME]: 在emacs 中新建一个snippet 之后，如何激活？\n[AI]: 在 Emacs 中激活一个 snippet 可以按照以下步骤：\n打开一个模式对应的 buffer，例如 Python 模式下的一个 Python 文件。\n输入 snippet 的关键字，然后按下 `\u0026lt;TAB\u0026gt;` 键。\n如果有多个匹配的 snippet，则在它们之间切换，直到找到期望的 snippet。\n如果 snippet 中有需要填写的字段，那么 Emacs 会提示你输入每个字段的值。依次输入完所有的字段值后，按下 `\u0026lt;TAB\u0026gt;` 键即可跳转到下一个字段。\n填写完所有字段值后，按下 `\u0026lt;TAB\u0026gt;` 键或 `\u0026lt;RET\u0026gt;` 键即可应用 snippet。\n需要注意的是，有些模式可能不支持 snippet，或者需要安装额外的插件才能使用 snippet。如果在某个模式下无法应用 snippet，请查看该模式的文档，或者尝试安装相关插件。\n[ME]: 在这个操作中，刚刚不提示新建的snippet, 该怎么解决，有重新加载snippet 的命令吗\n[AI]: 如果在使用 snippet 时没有发现新建的 snippet，可能是因为 Emacs 还没有加载该 snippet 文件。可以尝试在 Emacs 配置文件中添加如下内容以加载 snippet：\n``` elisp (require \u0026lsquo;yasnippet) (yas-load-directory \u0026ldquo;/path/to/directory/containing/snippets\u0026rdquo;) ```\n其中，`\u0026quot;/path/to/directory/containing/snippets\u0026quot;` 是存放 snippet 文件的目录的路径，需要替换成实际的路径。\n如果已经加载了 snippet 文件，但是仍然无法使用新创建的 snippet，可以尝试使用 `yas-reload-all` 命令重新加载 snippet。具体操作为：\n打开一个模式对应的 buffer。\n进入该模式的 snippet 目录。\n使用 `M-x yas-reload-all` 命令重新加载 snippet。\n重新打开 snippet 即可。\n需要注意的是，在重新加载 snippet 后可能需要重启 Emacs 才能生效。\n[ME]:\n","date":"2023-04-16T02:08:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%97%AE%E7%AD%94AI-snippet/","section":"post","tags":null,"title":"问答AI emacs snippet 用法"},{"categories":["Inbox"],"contents":"TODO 需要验证的问题 解决的问题 swift-mode build spm 项目，在repl 中debug spm 代码 ob-swift 默认使用 swift repl buffer ，达到共用 session 的效果 ob-swift 执行命令设置为 swift repl 需要验证的问题：ob-swift 是否和 swift-mode repl 共用 session\n先编译 UnitDemo 项目 ，新建对话 进入 repl session 在 ob-swift 中使用默认的 session ，尝试 import UnitDemo 相关库。 整理 include 方法实现跨块的代码共享参数环境 Emacs: chaining org babel blocks Reddit - Dive into anything 整理 noweb 的用法，共享变量 Noweb Reference Syntax (The Org Manual) 整理 ob-babel 官方文档中的 header 参数的应用 Using Header Arguments (The Org Manual) swift-mode 使用自己的库 使用 :session 引入块环境 :PROPERTIES: nil:END:\n1 2 3 4 let x = 1 let y = 2 let z = x + y print(z) 1 let a = 1 1 2 3 print(\u0026#34;test1----\\(a)\u0026#34;) print(\u0026#34;test2----\\(a)\u0026#34;) print(\u0026#34;test3----\\(a)\u0026#34;) 优化 ob-swift session 对话脚本问题 熟悉几个命令 start-process call-interactively\n源库中使用使用 process 1 2 3 4 5 6 7 (let ((obname \u0026#34;*ob-swift-xx*\u0026#34;)) (start-process obname obname \u0026#34;sudo swift repl\u0026#34;) ) (let ((obname \u0026#34;*ob-swift-xx*\u0026#34;)) (process-send-string obname (format \u0026#34;%s\\n\\\u0026#34;%s\\\u0026#34;\\n\u0026#34; \u0026#34;print(\\\u0026#34;hello\\\u0026#34;)\u0026#34; ob-swift-eoe)) (accept-process-output (get-process obname) nil nil 1) ) fork库中 使用 swift-mode 方法 run-swift 1 2 3 4 5 6 7 (save-window-excursion (let ((obname \u0026#34;*swift-repl*\u0026#34;)) (setq swift-mode:repl-buffer obname) (call-interactively \u0026#39;run-swift) (get-buffer obname) ) ) (call-interactively \u0026lsquo;run-swift) 方法执行之后，仍提示 no process 是什么原因\n这可能是因为 run-swift 方法未能正确启动 Swift 进程。你可以尝试重新启动 Emacs 或检查你是否正确配置了 Swift 环境。你也可以尝试手动启动 Swift 进程以确保它能正常工作。\n如何解决这个问题：ob-swift\u0026ndash;eval-in-repl: Buffer ob-swift-my-session has no process\n设置 ob-swift 默认 session 名称:session \u0026ldquo;Swift REPL [swift repl]\u0026rdquo; 1 print(a) 使用 ob-swift 引入第三方库:借助swift-mode:debug-swift-module方法实现 借助 swift-mode:debug-swift-module 方法实现,该方法会新建进程和 swift-repl buffer 它名通过 swift repl 执行的命令命名，例如：`swift repl -i \u0026hellip;` 查看进程列表： list-process 查看buffer： spc b B 通过这两个方法可以找到 repl buffer 的名称。\n然后，设置 ob-swift 的 `：session` 的名称 *Swift REPL [swift repl -i ...]* ,这样，在运行代码块的时候，就可以和 swift-mode 共用环境。\n1 import UnitLib 这样就可以在代码块中调用第三方库了。\n处理 outdata 字符串，截取 //\u0026mdash;- 之后的字符串，使用elisp 实现上述功能，举例说明 可以使用 split-string 函数将 outdata 字符串分割成多个行，并使用 nthcdr 和 member 函数来找到 //---- 之后的所有行。以下是一个示例实现：\n在elisp 中通过在指定的字符串分割原始字符串，并得到最后部分，举例说明\n可以使用=split-string=函数来分割字符串。例如，要在字符串\u0026quot;/usr/local/bin\u0026quot;中分割出最后一个部分\u0026quot;bin\u0026quot;，可以使用如下代码：\n1 2 (setq outdata \u0026#34;test2----\\(a)\\nprint(\\\u0026#34;test3----\\\u0026#34;)\\n//----\\ntest1----1\\n326\u0026gt; test2----1\\n327\u0026gt; test3----1\u0026#34;) (car (last (split-string outdata \u0026#34;//----\\n\u0026#34;))) 1 2 3 test1----1 326\u0026gt; test2----1 327\u0026gt; test3----1 其中， (split-string \u0026quot;/usr/local/bin\u0026quot; \u0026quot;/\u0026quot;) 将字符串 \u0026ldquo;usr/local/bin\u0026rdquo; 以 \u0026ldquo;\u0026rdquo; 为分隔符分割成一个字符串列表， last 函数返回列表中的最后一个元素，然后用 car 函数取出这个元素的值。\n通过 :noweb 传值 1 const char * message1 = \u0026#34;hello from block 1\u0026#34;; 1 const char * message2 = \u0026#34;hi from block 2\u0026#34;; 1 2 3 4 5 6 7 8 9 10 #include \u0026lt;stdio.h\u0026gt; \u0026lt;\u0026lt;c1\u0026gt;\u0026gt; \u0026lt;\u0026lt;c2\u0026gt;\u0026gt; int main(void) { printf(\u0026#34;%s\\n\u0026#34;, message1); printf(\u0026#34;%s\\n\u0026#34;, message2); return 0; } 1 2 hello from block 1 hi from block 2 通过 :var 跨源块传递值 第一步 声明块变量: ,#+name: c_hello 第二步 在块中引用： :var data=块变量 1 2 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;hello C\u0026#34;); return 0; } 1 echo hello from sh $data 1 hello from sh hello C 通过 :include 引用块环境 第一步 重写 adviced:org-babel-execute-src-block 第二步 声明块变量名： ,#+name: b1 第三步 引入块环境： :include 块变量名 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 (defun adviced:org-babel-execute-src-block (\u0026amp;optional orig-fun arg info params) (let ((body (nth 1 info)) (include (assoc :include (nth 2 info))) (named-blocks (org-element-map (org-element-parse-buffer) \u0026#39;src-block (lambda (item) (when (org-element-property :name item) (cons (org-element-property :name item) item)))))) (while include (unless (cdr include) (user-error \u0026#34;:include without value\u0026#34; (cdr include))) (unless (assoc (cdr include) named-blocks) (user-error \u0026#34;source block \\\u0026#34;%s\\\u0026#34; not found\u0026#34; (cdr include))) (setq body (concat (org-element-property :value (cdr (assoc (cdr include) named-blocks))) body)) (setf (nth 1 info) body) (setq include (assoc :include (org-babel-parse-header-arguments (org-element-property :parameters (cdr (assoc (cdr include) named-blocks))))))) (funcall orig-fun arg info params))) ;; 这段代码使用 =advice-add= 函数，在 =org-babel-execute-src-block= 周围添加了一个名为 =adviced:org-babel-execute-src-block= 的 advice。这意味着在执行 =org-babel-execute-src-block= 时，将首先执行此 advice 中定义的代码，然后再执行原始函数中的代码。 (advice-add \u0026#39;org-babel-execute-src-block :around \u0026#39;adviced:org-babel-execute-src-block) 解释一下这段代码 1 const char * message1 = \u0026#34;hello from block 1\u0026#34;; 1 const char * message2 = \u0026#34;hello from block 2\u0026#34;; 1 2 3 4 5 6 #include \u0026lt;stdio.h\u0026gt; int main(void) { printf(\u0026#34;%s\\n\u0026#34;, message1); printf(\u0026#34;%s\\n\u0026#34;, message2); return 0; } 1 2 hello from block 1 hello from block 2 在运行代码时提示错误：use of undeclared identifier \u0026lsquo;message1\u0026rsquo; printf(\u0026quot;%s\\n\u0026quot;, message1);\n这是因为 message1 的作用域仅限于 b1 块中，无法在 main 函数内部访问。可以将 message1 定义成全局变量或使用 #include 指令将 b1 块中的代码直接包含到 main 函数中。例如，将 b1 的代码直接放到 main 函数上方，或者在 main 函数中使用 #include \u0026quot;file.org::b1\u0026quot; 来包含 b1 块中的代码。\n自定义 ob-babel TODO 自定义 ob-swift dotfiles/configuration.org at 71adbedf80d4985a14c674f14c386dc8232da824 · Nich\u0026hellip;\n1 2 3 4 5 6 7 8 9 10 11 12 (defun org-babel-execute:swift (body params) \u0026#34;Execute a block of Swift code with org-babel.\u0026#34; (message \u0026#34;executing Swift source code block\u0026#34;) (ob-swift--eval body)) (defun ob-swift--eval (body) (with-temp-buffer (insert body) (shell-command-on-region (point-min) (point-max) \u0026#34;swift -\u0026#34; nil \u0026#39;t) (buffer-string))) (provide \u0026#39;ob-swift) 这是一个定义了 `org-babel-execute:swift` 函数的 Emacs Lisp 代码段，用于执行 Swift 代码块。下面是代码的注释说明：\n1 2 3 4 5 6 7 8 9 10 11 12 ;; 定义一个名为 `org-babel-execute:swift` 的函数 ;; 该函数接受两个参数，`body` 表示代码块中的代码字符串， ;; `params` 包含了代码块的参数列表和其他信息 (defun org-babel-execute:swift (body params) ;; 获取参数列表中 `:session` 参数的值，即 REPL 会话名称 (let ((session (cdr (assoc :session params)))) ;; 如果 `:session` 参数的值为 \u0026#34;none\u0026#34;，表示不使用 REPL， ;; 直接调用 `ob-swift--eval` 函数执行代码 (if (string= \u0026#34;none\u0026#34; session) (ob-swift--eval body) ;; 否则使用 `ob-swift--eval-in-repl` 函数在 REPL 中执行代码 (ob-swift--eval-in-repl session body))))) TODO 自定义AI ob-slack 对话模块 新建模块在 emacs-slack 基础上，新增 ob-babel 功能，例如在org-mode 中和指定的人聊天\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 (defun org-babel-execute:slack (body params) \u0026#34;Execute Slack message BODY with PARAMS.\u0026#34; (let* ((user (cdr (assoc :user params))) (buffer-name (format \u0026#34;*Slack - %s*\u0026#34; user))) (if user (slack-user-buffer user) ; Enter private buffer with user (slack-buffer)) ; Enter default Slack buffer (insert body) (slack-send-message-or-comment) (slack-read-mode))) (defvar org-babel-default-header-args:slack \u0026#39;((:user . \u0026#34;创客屋 : Claude\u0026#34;) ; Default Slack user (:session . \u0026#34;none\u0026#34;) (:results . \u0026#34;none\u0026#34;)) \u0026#34;Default header arguments for slack blocks.\u0026#34;) (add-to-list \u0026#39;org-babel-exec-map \u0026#39;(\u0026#34;slack\u0026#34; . org-babel-execute:slack)) (add-to-list \u0026#39;org-babel-prep-session-alist \u0026#39;(slack . org-babel-prep-session:slack)) 1 Hi there! How\u0026#39;s it going? ","date":"2023-04-16T02:02:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%97%AE%E7%AD%94AIob-swift-%E5%AF%BC%E5%85%A5%E7%AC%AC%E4%B8%89%E6%96%B9%E5%BA%93/","section":"post","tags":null,"title":"问答AI: ob-swift 导入第三方库"},{"categories":["Inbox"],"contents":" [SYS]: You are a helpful assistant.\nME: swift 中 String 字符串如何删除最后几个字符。\n[AI]: 可以使用 String 的 `removeLast(_:)` 方法来删除最后几个字符，方法参数指定要删除的字符数量。例如，要删除最后两个字符，可以这样写：\n```swift var str = \u0026ldquo;Hello, World!\u0026rdquo; str.removeLast(2) print(str) // 输出 \u0026ldquo;Hello, World\u0026rdquo; ```\n注意，如果要删除的字符数量大于字符串的长度，会导致运行时错误。\nME: swift 中，字符串替换，支持正则的方法\n[AI]: 在 Swift 中，`NSRegularExpression` 类支持正则表达式的处理。你可以使用它进行字符串的替换操作。下面是示例代码：\n```swift let originalStr = \u0026ldquo;hello,Swift world\u0026rdquo; let pattern = \u0026ldquo;\\\\bhello\\\\b\u0026rdquo; let replacement = \u0026ldquo;Hi\u0026rdquo;\ndo { let regex = try NSRegularExpression(pattern: pattern) let range = NSRange(originalStr.startIndex..\u0026lt;originalStr.endIndex, in: originalStr) let result = regex.stringByReplacingMatches(in: originalStr, range: range, withTemplate: replacement) print(result) // \u0026ldquo;Hi,Swift world\\n\u0026rdquo; } catch let error { print(\u0026ldquo;invalid regex: \\(error.localizedDescription)\u0026rdquo;) } ```\n以上代码中， `pattern` 定义了匹配的模式，这里使用了 `\\b` 表示单词的边界，从而只匹配到 \u0026ldquo;hello\u0026rdquo; 而不是 \u0026ldquo;helloSwift\u0026rdquo; 等类似情况。`replacement` 指定替换成的字符串。\n在实现代码之前，需要先用正则表达式 `pattern` 初始化一个 `NSRegularExpression` 实例。然后，设置要匹配的字符串的 `range`，最后非常方便地调用 `stringByReplacingMatches` 方法替换字符串中的匹配项。\n需要注意的是，正则表达式中的特殊字符需要进行转义处理，比如 `\\` 需要写成 `\\\\`。同时，对于分组、量词等较为复杂的正则表达式，需要进一步熟悉正则表达式语法后才可以使用。\n[AI]: Swift 标准库中本身不支持使用正则表达式进行字符串替换，但可以使用第三方库 `Regex` 来实现。\n`Regex` 是使用 Swift 语言编写的正则表达式引擎，它支持完整的 Perl 正则表达式语法，并且简单易用。通过在项目中引入 `Regex` 模块，就可以方便地使用它进行字符串匹配和替换。\n下面是使用 `Regex` 进行字符串替换的示例代码：\n```swift import Regex\nlet originalStr = \u0026ldquo;hello,Swift world\u0026rdquo; let pattern = \u0026ldquo;\\\\bhello\\\\b\u0026rdquo; let replacement = \u0026ldquo;Hi\u0026rdquo;\ndo { let regex = try Regex(string: pattern) let replacedStr = try regex.replaceAll(in: originalStr, with: replacement) print(replacedStr) // \u0026ldquo;Hi,Swift world\\n\u0026rdquo; } catch let error { print(\u0026ldquo;invalid regex: \\(error.localizedDescription)\u0026rdquo;) } ```\n以上代码中，首先使用\n","date":"2023-04-16T02:01:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%97%AE%E7%AD%94AIswift-%E4%B8%AD-String-%E5%AD%97%E7%AC%A6%E4%B8%B2%E5%A6%82%E4%BD%95%E5%88%A0%E9%99%A4%E6%9C%80%E5%90%8E%E5%87%A0%E4%B8%AA%E5%AD%97%E7%AC%A6/","section":"post","tags":null,"title":"问答AI:swift 中 String 字符串如何删除最后几个字符"},{"categories":null,"contents":"在日常生活中，因为经验或能力有限，导致经常遇到无法解决的问题，想通过阅读学习找打找解决的办法，但是书本知识有一定的门槛，在阅读之后，有很难在实际生活中应用。这就非常会导致积极性受阻，丧失信心。\n在阅读过程中，我们到底该怎么对学到的不仅仅停留在记忆上，让知识真正的为我所用呢。这些该怎么做到，我们应该培养哪些能力，提升对知识的应用效果呢。\n案例：我在学习七个习惯，已经很长时间了，经历很多痛苦的历程，到现在还是无法把浅显易懂的道理应用到生活中，还是在低效能的生活中挣扎。\n现在采用了阅读 + 笔记的模式，重新整理学习，希望能更加深层次的掌握七个习惯的知识体系。把做磨练成一个提升生活的框架，把生活作息和行为态度，都以它为行动手册纲领。\n打造一个整理知识的书架，能在生活中快速检索出原则和人生目标。打造这个框架需要付出哪些努力？\n从calibredb + org-noter 阅读七个习惯，采用空雨伞 + roam 两种工具提供的技巧和方法，希望在这次阅读之后，能够通过整理思路的书架的思维，把七个习惯的知识放到它应该在地位置，形成一套可以快速检索的知识体系。\n在学习七习知识点，采用方格笔记的学习笔记本的技巧，记录总结加深理解，实现知识再现，快速检索的知识宝库。\n学习笔记的技巧有哪些：\n要养成写标题的习惯，能够激发意识到笔记 空白的一秒钟，板书技巧，把印在脑海里的内容，记录在知识点中。 发现区域，充分利用链接词，逻辑故事化知识点，提升再现的效果 在发现区域，通过连接词有效的培养培养 概括能力 在学习七个习惯中，针对每个知识点，能够做到学习笔记的要求，学习过程同时锻炼提升空雨伞理解记忆的技巧，能够产出更扎实好用的知识宝库。\n","date":"2023-02-23T20:20:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%A6%82%E4%BD%95%E6%88%90%E4%B8%BA%E5%96%84%E4%BA%8E%E5%BA%94%E7%94%A8%E7%9F%A5%E8%AF%86%E7%9A%84%E4%BA%BA/","section":"post","tags":null,"title":"如何成为善于应用知识的人"},{"categories":["学习笔记"],"contents":"这几天的知识体系是什么 hugo和ob集成开发inotes快速实现博客编写\ngithubaction的玩法编译swift代码，为开发swift做准备\nob写博客的习惯画图工具和图片存储机制发布到Hugo展示\nelisp基础语法的学习和封装shell插件quickrun ios证书管理match cert的的使用，确定不支持个人开发账号\n捷径、alfred、键盘快捷键的应用代替鼠标的习惯\nemacs工具知识体系搭建的机制，记录日常工作习惯，要在二象限思维看待时间和生活方式\n现在明显没有做到，做的事情的优先级完全不符合预期，接下来要做什么？\n接下来就是习惯工具再次精炼的过程，在学习githubaction的过程，就是在学习一种习惯，它把事情流程化，把事情更加智能化，让生产力解放的思维，借用这种思维，丰富现在七个习惯的短板，提升学习的效率有很大的帮助，如何把action接入到生活习惯中，先看看有哪些工具可以辅助，捷径已经打通，能够激活workflow这样就可以将可以远程处理的任务，使用swift脚本在github上执行之后，回传到本地，就像一台远程主机一样方便，唯一不足是没有emacs环境的加持，但在远程办公这件事情上可以转换思维了，action是一台电脑能解决很多问题，如果有远程需要，可以先考虑action的饮用。 code space也有终端功能，能否安装eMacs实现远程编写org呢。这个可以考虑一下\n","date":"2022-10-24T07:47:10Z","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%9C%89%E4%B8%80%E4%B8%AA%E5%A5%BD%E7%9A%84%E6%96%87%E6%A1%A3%E6%98%AF%E6%8F%90%E9%AB%98%E6%8A%80%E8%83%BD%E7%9A%84%E6%9C%80%E4%BD%B3%E6%8D%B7%E5%BE%84/","section":"post","tags":null,"title":"有一个好的文档是提高技能的最佳捷径"},{"categories":["解决方案"],"contents":"问题1 在配置远程路径时，使用ob-git命令面板编辑remote路径，无法生效。 解决办法：在pc端设置.git/config，指定远程路径位https协议，设置默认推送的origin，然后手动同步到手机端的obisian项目中，这时通过edit remote 命令查看远程列表，是https协议，就成功了。\n问题2 卡顿问题优化，因为ob-git插件使用的js版本git命令，是轻量级的git版本，支持简单的push fetch一些简单命令，对文件数目的检索也有一定限制，导致在大项目中，运行消耗时间较长。\n清理子模块 这次优化主要从清理项目中多余的分支和子模块例如之间hugo主题，因为发布放在了github workflow完成，手机端不需要主题查看，于是清理了部分类似的子模块。\n按道理来说子模块对ob-git不过敏有影响，为了瘦身做了相关操作。\nclone最后一次提交版本 另一个瘦身方式，通过\u0026ndash;depth=1，重新clone一份博客库，也可以起到瘦身作用。\n","date":"2022-10-20T19:27:19Z","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/obsidian-git%E6%80%A7%E8%83%BD%E9%97%AE%E9%A2%98%E4%BC%98%E5%8C%96/","section":"post","tags":null,"title":"obsidian-git性能问题优化"},{"categories":["解决方案"],"contents":"在这个过程主要针对ob插件的应用的学习，学会了template的语法，创建Hugo模版，配合quickadd实现一键创建博客，并支持添加分类和时间管理能功能，这样，主要基于博客思维，把平时的思考更加规范，有输入也有输出的知识体系的成长。\n学到了 templete语法 quickadd模版用法 git忽略文件的规则，了解排除忽略文件的语法\n先忽略全部，在!感叹号排除掉需要管理的文件\n知识是这样，但是在操作的时候，没有生效 发布hugo之后,博客不显示问题。 是因为publishDate字段格式只能是日期，不能带时间戳 ","date":"2022-10-20T15:41:10Z","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8obsidian%E7%BC%96%E5%86%99%E5%8D%9A%E5%AE%A2%E6%8F%90%E5%8D%87%E6%80%9D%E7%BB%B4/","section":"post","tags":null,"title":"使用obsidian编写博客提升思维"},{"categories":["习惯"],"contents":"拆为己用是学习工具，有效的应用能提升学习力。突破初级学习者的认知习惯，锻炼成为高级学习者和学习促进者，才是王道。 学习高境界传达思想，需要将知识记忆，理解，吸收，激发活经验，反思，提问，内化为自己的知识，通过，分析处理，总结整理，输出自己观点，丰富知识体系，提升思想水平。 \u0026gt; 一个习惯的养成，要有新的思想水平：必需由内而外，以原则为中的思维方式。 按照RIA工具分析CMMI培训 RIA是现场学习工具，跟着拆书家的 RIA 现场学习的指令，把原书的节选章节拆为己用，也能够解决自己的问题，提升相应的能力。 反思 CMMI 现场培训的效果，因为作为 ATM 角色参加，对 CMMI 一无所知，带着学习的渴望和压力，参加了 CMMI 现场培训。 案例分析 从培训师的角度看，是对基础知识的普及，照读 PPT，其中分了三天来培训，涉及到了概述、能力域的分类梳理学习，也穿插了一些案例的描述实践。 从学习者的角度看，对 CMMI 认证的过程和 ATM 职责不明确。在学习时没有重点，只是在课上奋笔疾书，到头来学习的效果很差。 结果在考试之前，花费了三天时间恶补，一章一节的记笔记，才看到 CMMI 的整理轮廓。认识了实践域，能力域之间的区别，认识了不同部门和不同职责的划分原则，理解了 CMMI 重在提供一套切实可行的实践标准，协助在困境中的企业指明一套方案，从而完善体制规范，提高人员协作的能力，最大限度提高效能。 反思 现场学习的情况：在这个经历中，现场学习效果很不好，听听激动，想想有用，笔记无用的情况。 自学的情况：花费了三天的时间重新学习，结果只是记忆性的。应试考试。在工作上没有任何应用。 这种情况，是我急切希望改变的，想提高自学的效率，把知识真正的内化为自己的，能在工作中真正的付诸实践。 使用拆为己用提升学习效率 在阅读了拆为己用的学习方法，认识到了自身学习境界，还处于初级学习者阶段，还是凭记忆学习，为书本负责，不能联想到自己的经验，仅为学习而学习，没有内化知识的能力，没有应用知识的能力。 想要通过学习拆为己用的理论来改变当前的现状，掌握拆为己用的能力 在学习过程中，付出了哪些努力，结果是否达到了目标状态，还有哪些疑惑没有得到解决？ 对于阅读传统观念：读书是要系统化，才能吸收并应用知识，提高自身的能力，拆为己用提出了成人学习的概念，成人教育的五大公理，几乎颠覆了传统观念。 拆为己用在读书难的老问题中的反思和追问下，开始了超越式的解决读书难的问题，即拆为己用的理论的提出依据。 拆为己用的适用边界：成人教育，致用类书籍！原则是：反求诸己，对学习者负责。 拆为己用VS方格笔记 拆书工具和麦肯锡高效阅读法和聪明都在用的方格笔记本的理念不谋而合（三分法：板书-发现-行动/I-A1-A2），方格笔记本从“记思传”（学习笔记本/工作笔记本/提案笔记本）三个方面来打破对笔记本的认知，提供了方格笔记本的方法培养人的逻辑思维能力。 在拆为己用的概念中加入了成人教育的角度来说读书的方法的问题，这也迎合了方格笔记本中的工作笔记本法的观念。 方格笔记本三分法重在由事实问题，到发现问题，再到方案的策划。 提案笔记本：是解决问题为目的，对应拆为己用的 A1IA2 以经验为基础反思整理再到策划付诸行动， 学习笔记本：板书到发现到行动是内化知识，应用知识的过程和拆为己用的 IA1A2 便签概念保持一致。 可知在笔记本的方法论的基础基础上，三分法是笔记的根本，思想上基于事实，激活个人经验叙述为故事来内化知识，在制定行动中应用知识。在拆为己用提供一套三步法的完整的标准。 所以现在的情况是，标签法已经基本掌握，如何吸收知识还没有真正的应用到实践中。如何把拆为己用的理论方法，内化为自己的知识，在阅读中应用起来。需要培养拆为己用的习惯。 开发拆为己用思维习惯 对比了方格笔记本的深刻了解了方法论的重要性，怎样付诸行动，可以对比下高效能人士的七个习惯的技巧。即如何把拆为己用内化为习惯。 高效能人士的七个习惯中心在于从转换思维的层面来彻底改变人的行为和态度，即要想改变行为和态度必需现在思维方式进行转换。 要找习惯所遵循的原则，明确以什么原则为中心的思维方式，然后确定产出和产能的角色是谁，遵循产出和产能平衡原则才能实现高效能。 七个习惯的首要习惯积极主动，刺激和回应之间的选择自由原则，赋予了作出承诺，信守承诺的责任。 在开发一个习惯时，要发挥人的四大天赋，自我意识，独立意志，良知和想象力。基于这些，才能有效的确认和开发习惯。 在学习拆为己用的过程中，前几章中讲述了习惯的养成过程，学习观念的转换相当重要，只有先从思维方式上的转换，才能在学习力上的改进。 拆为己用是一种框架工具，在提高知识转化效能时，需要了解以下概念 拆为己用符合习惯的标准吗？ 知识：理论范畴,思维方式转换，你是哪个哪个境界的阅读者。 技巧：适用 IA1A2 便签法 意愿：内化知识，应用知识，激活经验（鲜活，故事，关联，反思），付诸行动（目标，行动，关联，可控） 拆为已用要革新什么思维方式？如何转换，转换后会带来什么变化？ 拆为己用属于知识积累，内化知识和应用。革新学习力的旧思维，改变学习方式。 拆为己用的产出是什么，产能是什么，如何保证效能平衡？ 效能基于产能和产出平衡原则： 产能：拆为己用的理念和拆的便签法 产出：提高学习新知识/掌握新能力的质量和速度 在阅读中，保证两者的平衡，才能充分发挥拆为己用的最大效能，达到快速阅读，内化知识应用知识的效果。 如果重技巧工具轻内化知识和应用知识的能力，就无法提高吸收应用新知识的本领。 ","date":"2022-08-17T15:14:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/%E6%A1%86%E6%9E%B6%E5%B7%A5%E5%85%B7%E5%86%85%E5%8C%96%E4%B8%BA%E4%B9%A0%E6%83%AF%E6%A1%88%E4%BE%8B/","section":"post","tags":null,"title":"如何把框架工具内化为习惯"},{"categories":["习惯"],"contents":"A1:追问和反思经验 在以前项目中，仅注重代码实现，对效率和回报没有概念，后来加入了项目愿景和项目宣言，来弥补管理上的缺陷，先明确目标，演练整个过程可能遇到的问题，估算时间，约定工作方式和协作安排等。 这样的设想很重要，但是在实际项目中，添加项目愿景和项目宣言，只体现在了概念层，很难在建项目的同时考虑到愿景的演练过程。 I: 分析和整理信息知识点 在实际操作中，tj3的模式确实在自我管理上，有了很不错的成效。但是在愿景和宣言上，还是一大短板，在项目中很难短时间设想构思演练整个过程。 这次主要对以终为始的模块，整了为愿景：心灵演练，主题更明确，知道要做什么，能够很快知道下一步该怎么进行。 A2:内化应用知识，谱写愿景 在上面的经历中，要明确下一次创建项目时，应该做什么。 在模版中优化了愿景和宣言模块，整合为愿景：心灵演练，更大突出主题，能快速唤醒以终为始的思维方式。 愿景步骤： 掌握在心灵演练过程，五个确认要领，越生动越好。 确定角色，设定角色的目标和责任，撰写使命宣言。 制定下一步行动 优化roam模版，在新建项目时，有模版可用，现在新增的几个模版，能够满足阅读，信息，经验，开发和项目几个方面的模版。 模版分为两种：博客和项目，项目支持导出tj3甘特图。 博客支持拆为己用的三个模版：RIA，AIA，iAA。 强化思维的框架工具体系图 ","date":"2022-08-17T12:06:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/%E6%95%B4%E5%90%88%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E5%92%8Ctaskjuggler%E5%B7%A5%E5%85%B7/","section":"post","tags":null,"title":"七个习惯和taskjuggler整合"},{"categories":["习惯"],"contents":"模板即框架，框架强化思维，思维改变行为，养成高效能习惯意识。 在emacs中我使用tj3模板积累一些框架工具，可以说模板改变了日常生活，从知识点的整理，内化应用；需求问题分析整理，输出博客；在项目管理过程中，通过模板确定原则，目标和执行方案，协助把控进度，让庞杂的工作井然有序。 在不同场景下，通过模板强化思维，规范了行为，帮助培养高效能的习惯。 思维转换是艰难过程，需要一定的知识储备，甚至一个知识体系，改变原有的思维方式。 这里主要针对tj3模板兼容的思维框架做统计，理解框架思维的使用场景和作用。 知识体系框架工具 提高理解记忆和知识体系管理的思维方式 知识体系积累最常见的几个途径：阅读，经验，信息。 方格笔记思维，主要在记忆，思考，传达时使用。 阅读档案思维，在读书之前，先读目录和序言，确定论点和章节，在制定阅读计划的过程。 在阅读、信息中，使用拆为己用：AIA 思维模式，在emacs 中的org snippet 使用a2 锻炼思维。 效能体系框架工具 提升执行力的思维工具 二项限思维：是确保要事第一的工具思维，通过四步，角色在原则和良知引导下，有效管理生活。 在开发demo中，使用hack 模板，快速确定项目开发的主要细节和成果。 在项目管理中，使用new-project 模板，能够帮助快速进入项目管理的状态，分解任务，演练整个过程。 体系图 模板预览 ","date":"2022-08-16T20:11:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/tj3%E6%A8%A1%E6%9D%BF%E4%BD%93%E7%B3%BB%E5%9B%BE/","section":"post","tags":null,"title":"强化思维的框架工具体系图"},{"categories":["习惯"],"contents":"很多人自制力差，导致学习环境限制了学习效率。如何才能不受环境制约，时刻保持高效能的学习状态呢。 图书馆营造的明净舒适宽敞，书籍庄严的氛围，以及和一群不约而同来到图书馆的书虫群体的共情，在心灵上形成了一种朝圣的仪式感。读者内心会充满虔诚，由此激发专注和责任感。图书馆的价值就在仪式感，专注力，责任感。 如何让专注力摆脱环境的束缚，就需要探索提升专注力和责任感的有效方法了。 抵挡外界干扰和诱惑，提升专注力的有效方法。 设定明确的愿景和目标，撰写使命宣言，培养自我朝圣的意识，安排下一步行动清单。 学习场景 泰康图书馆 平时去泰康图书馆，那里有茶水，工作餐，早上8点开馆，晚上22点闭馆，非常适合平时学习。但是周日闭馆，距离3公里有点远，如果遇到下雨天等天气，非常不便。 回龙观图书馆第一分馆 早上六点半到十点，睡懒觉，听B站视频虚度了到十点。然后洗漱整理心情，打卡来到回龙观第一分图书馆，需要在公众号预约，上下两次预约，早上9-12:30,下午13:00-20:00,需要带身份证，核酸证明和测体温，因为是在社区，入馆需要等门禁卡开门才能进小区，下次可以从北门进来。 ","date":"2022-08-15T11:09:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/%E5%AD%A6%E4%B9%A0%E5%9C%BA%E6%99%AF%E7%9A%84%E4%BB%B7%E5%80%BC%E6%84%8F%E4%B9%89/","section":"post","tags":null,"title":"学习场景的价值意义"},{"categories":["习惯"],"contents":"习惯的养成需要意愿，知识和技巧来实现，我的意愿就是高效能的阅读，在繁忙，在紧迫，在走投无路，在堕落绝望的时候，要保证一片阅读的净土。我在现实中还在借助图书馆的环境和气氛激发阅读思考。这几天沉浸在图书馆中，加急学习的习惯有自我领导，以终为始的分析力，自我管理，要事第一的执行力的磨练，从升职记到方格笔记，然后聚合力到习惯，生活中心扩展影响圈的几个要素：智慧，力量，方向，安全感。一步步激活生活七个习惯的经验的基础，产能和产出平衡的原则的认识。将这些思想转化为方法工具，让思维养成框架意识。 通过方法论培养框架的思维的习惯 执行力的框架：衣柜整理法，二项限工具 分析力的框架：方格笔记三分法，空雨伞。 在日常事务中开发了哪些框架，哪些框架还停留在理解知道的层面，哪些框架养成了习惯，成为行为意识？哪些最具影响力，有助于改变现状的框架值得付出努力的习惯？ 习惯要有成熟度评估体系，每日对框架成熟度反思，有助于调整状态，合理分配时间精力，提升综合习惯。 成熟度1:理解记忆，列为培养的思维框架 成熟度2:融会贯通，应用框架解决实际问题 成熟度3:框架整合，理解框架职能和产出，和其他框架联合应用，有机组合 成熟度4:框架意识，养成习惯，在面对各种问题，有框架思维意识。 成熟度5:能在生活不同场景下，熟练应用框架，整合框架，融会贯通。 学习CMMI成熟度等级标准及作用和评估价值 所有的框架和知识都在向tj3融合。如何把这个框架应用起来，做到高效率，不受环境束缚的执行力和专注力的平台，使命宣言和愿景的设定的过程如此的重要。在当下最重要的是提升阅读的效率，逐步提升阅读效率，养成高效阅读的习惯。 以养成高效阅读的习惯为例，tj3系统在这个过程发挥框架的作用，提升学习的效率。 高效阅读的知识积累 先回顾高效阅读法的重要章节和知识点：阅读的优点，阅读的习惯,高效记忆的阅读规范，书中介绍了高效阅读习惯需要积累的知识（是什么，为什么），激发读者意愿：开阔视野培养思维方式和挖掘潜能，学习同情力提升领导力，激发干劲；要有要事第一的二项限分析行为优先级意识，合理分配时间和精力的作息时间，提高阅读的价值观觉悟，要有阅读的时间意识责任，专注力，如何记忆书中的知识，学什么，为什么，目标意识问题意识，专注一本书，立即读，不要重复，不要作笔记，要立刻回顾，写档案总结评价，让书本成为数据库。要输出，写博客，聊天，组织讨论组和演讲等。 以上就是高效阅读的知识，意愿是高效快速吸收书本的知识，内化为自己的技能，要有技能成熟度的标准，我现在阅读的成熟度有没有提高。 成熟度的反思 我现在读魔力创业和麦肯锡意识，这两本书，有意识的阅读书本目录何序言，先弄懂为什么读，学到什么在践行译本主的阿专注和不重读的原则，及时回顾输出的内化。 现在仅仅做到了为什么，学什么，不重读的习惯，但是理解记忆的方格笔记的思考意识培养不足。回顾总结很少。 方格笔记成熟度反思 方格笔记的成熟度如何呢。我现在空雨伞的思维方式，让我更积极的思考，遇到问题能够从事实出发，罗列问题，跟着大脑的想法整理思考，然后总结分析解决问题的下一步任务或论点意识等。意识不够强烈，需要分析过程中，框架更加清晰，逻辑更加明确，分析力更上一层楼。 麦肯锡意识的比较 现在由各更厉害的书本，麦肯锡意识和方格笔记作为分析工具的方法框架来说，他们的联系是什么。方格笔记的事实，对应意识的逻辑书＋议题树为了界定问题提出论点。这更象是工作笔记的思考笔记的实战分析。比工作笔记更具指导价值。 工作笔记的作用是思考问题，勇于舍弃的整理术，新陈代谢良好，将不重要的信息处理掉，建议是询问确定愿景和论点，如何确认这个方面可以和麦肯锡意识对比阅读，加深理解记忆 . 知识积累状况 最近在锻炼以终为始和要事第一的两个习惯，重新阅读升职记加深理解目标管理的六个高度，时间管理的3+1清单，收集箱，目标清单，任务清单，下一步行动清单，以及二项限法则，只装一件事，衣柜整理法习惯意识。 在目标到任务的过程中学习掌握分析力的本领，培养要事第一原则的思维方式，采用二项限法则，配合方格笔记框架思维，锻炼勇于舍弃的分析方法，定位问题本质，故事化逻辑过程，得出一个论点和下一步任务和行动。 掌握了分析力和执行力两大工具，在生活实践中要经常应用磨练的自觉意识，要时刻提醒，保持锋芒，陈旧自己高效能的习惯，成为想要的样子。 最近在学习高效阅读，提升内化知识的效率，培养高效阅读的习惯。\n","date":"2022-08-15T09:30:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/%E6%A1%86%E6%9E%B6%E6%80%9D%E7%BB%B4%E6%88%90%E7%86%9F%E5%BA%A6%E8%AF%84%E4%BC%B0%E6%84%8F%E8%AF%86/","section":"post","tags":null,"title":"框架思维成熟度评估意识"},{"categories":["项目总结"],"contents":"阅读诉求，势在必行 了解阅读的优点，展望了知识体系的无限想象，下一步该如何付诸行动，构建自己的知识体系呢？例如每天读两个小时，每周读两本书。阅读管理类，理财类，开发类，工具类等，从这书籍中吸收知识，完善构建自己的知识体系，形势所逼，已经到了势在必行的地步了。 面对日常最直观的阅读诉求，该怎么处理？ 阅读困境，痛定思痛 以前读书习惯，大多是一时兴决定阅读，在网上根据有限的词汇量（管理，开发，工具）搜索索电子书资源,再参考豆瓣排名评价，确定是否阅读。书籍主要通过calibre管理，在emacs上阅读。阅读时凭直觉挑选章节，记忆方法是反复阅读，输出方式是在朋友圈发表一下感想，经过一番自我感动，然后宣告结束。 从以前阅读习惯可知，对阅读愿景，没有目标，阅读动机也是一时兴起，急于救火等原因，理解jyiii全靠暴力式反复阅读强记硬背。这样虽然耗费大量宝贵的精力和时间，却无法从知识体系的角度将知识拆为己用，激活经验，内花技能。最终耗费了精力，荒废了光阴，只留下短暂的自我感动。 高效阅读习惯的养成 有这么痛苦的经历，作为教训，该怎么突破阅读困境，获得阅读自由呢？ 回到前文在现实的压力下，呐喊出一针见血的诉求，面对这种近乎情感输出的表达，该如何从中辨别筛选出背后逻辑和真实目的，然后再转化为可执行的具体任务。 这个过程可以通过衣柜整理法，工作笔记法，分析整理得出真实愿景。使用tj3系统管理目标和任务。 对于高效的阅读习惯：先明确习惯的三个元素，知识，意愿，技巧。 我的意愿就是能够快速的将书中的知识内化为自己能力，并输出完善自己的知识体系。 技巧就是两个分析工具和一个tj3系统，在阅读中认真执行系统工具的要领，就能提高阅读效能。 针对这些需求，可以进一步明确目标和愿景，情感确认是否可执行。再进行详细的计划安排和任务分解。 执行力和分析工具内功大法 阅读过程会遇到哪些现实问题？ 选书问题， 读书需要先定方向，比如管理类书籍，还有怎么选书，哪本书能解决当下困境？ 目标愿景 如何制定愿景，读到什么程度，愿意付出多少精力，能下定多打的决心区执行。 回顾监督 如何能保证阅读完成？执行中遇到问题怎么调整，有缓冲机制吗，信心会受挫吗。会导致半途而废吗。 总结内化 如何保证能如期完工，内化为自身能力，甚至做到演讲的高度。 对工具的考验：衣柜整理法，方格笔记，二项限法则，自我领导，要事第一，使命宣言 这些工具面对是日常计划回顾，派上用场。现在面对的是读书，如何应对。 对系统考验：这些问题再tj3模板中已经解决，再制定一套针对阅读的行为规范，应该不成问题。 ","date":"2022-08-12T18:24:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BB%E7%9A%84%E4%B9%A0%E6%83%AF%E5%85%BB%E6%88%90/","section":"post","tags":null,"title":"高效阅读的习惯养成"},{"categories":["项目总结"],"contents":"书是通往另一个世界的大门，可以穿越时空，和不同时代的人作朋友，了解他们的价值观和性格，和雷厉风行的办事风格，这些熠熠生辉的宝贵人品，都可以在书本中学到，要找到影响你一生的东西，必须高效阅读，把知识内化为能力。 阅读是一次神游拜访，心灵伴侣，生活导师，效能达人，不同领域的成功人士，都会十分热情，知无不言，言无不尽的教导你，引领你，给你人生最宝贵的经验。 在阅读中认识自己，吸取前辈的智慧，内化自身能力，完善自己，积极在生活中行动，用成绩来致敬书中的英雄们。 书本强属性：知识体系 一个人要有知识储备意识，尽早构建能支撑起自身价值观的知识体系，它是生长智慧的土壤，是主导人的性格，行为，素养的潜意识价值观，一个人的思维定式。完善构建自己的知识体系，应该做为一生的追求。 如何完善构建自己的知识体系呢？ 书本就是知识精华的载体，是作者在一个领域深耕积累构建的一套完整的知识体系。 我们从目录序言等架构上开始着手，先纵览全局，认识知识框架，再重点学习。对知识逐渐养成整理组织，内化吸收的习惯，将更多的书本的知识源源不断的输送到自己的知识框架中，完善自己价值观。 如何通过读书完善自己的不足，先要之道读书能带给你什么？ 知识体系成长智慧火种 读书可以开阔视野，积累知识储备，构建属于自己的知识体系，掌握了知识，塑造独立的思维方式和价值观。 在坚固的知识储备下，激发你的想象力，创造出更多独到的见解，成长出更敏锐的洞察力，能准确察觉事情的发展规律和方向，在实践中反复推演执行过程，预判结果，提高效率，减少目标误差，在回顾中，反思总结，积累智慧和经验，完善知识体系，形成闭环。 以此既往，智慧，方向，力量，安全感，四个相辅相成的中心力量，拉动你的生活中心，扩大影响圈，自然而然成就了高效的生活状态。 前辈经验指引正确方向 书中有很多生动的实践经验，通过阅读掌握这些宝贵经验，能少拼搏十年，达到人生巅峰。 把这些经验融会贯通，化为己用，在实践中，能提前预判事态发展，确定方向，作出正确决策；在设计过程能统筹全局，作出切合实际的愿景，设定可行的目标，制定使命宣言，树立坚定不移的决心。 慧眼如炬学习人情世故 书中除了自我修养和效能提升之外，还有人情世故，处世之道。 如何作一个有原则又不失风度的人？从书中能找到我辈榜样。 受七个习惯影响深刻，一直在修炼七个习惯，以原则为中心的生活方式，先定位自己的生活中心，制定角色在生活中的使命宣言，以宣言为行动准则，对生活负责的态度，积极参与社交活动，身体力行的扩大影响圈，以原则为中心的生活，是我所期望的。 书中更多的是不同领域，不同地位，不同人生阶段的生活阅历和故事。应该多体验别人的人生，了解不同阶段的人生感悟和办事原则。培养自己的同理心，这其实是就是交朋友，包容理解是必修课。阅读不同的人生，体验人生百态。才能提高慧眼是识英雄的能力，提升领导力，知人善任的能力。 下一步行动 以后在读书时，要有意识培养这几个优点，同样也可以作为选书的重要指标，描述愿景的考量元素。 五个方面 提升业务能力，能够在业务之外找到更多机会 培养价值观和思维方式，能够影响自己的行为，俗话说的开阔眼界 挖掘自身潜力，读书能让人看到不足，和改进的方向。 培养同理心，人物传记。 主要关注角色时代等带入感很强的书籍，能够接触更多的人和事，理解他人的价值观 做提案和博弈的知识库，在接触很多实战案例时，在事件工作中得以应用在好不过。 独立思考的能力：和培养价值观和思维模式相同，有自己的坚持的知识体系基础。 激发干劲，这个第一次听说，事实。感动和知识欲可以调动积极主动的意识，让人干劲十足。 ","date":"2022-08-12T08:35:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BB%E7%9A%84%E4%BC%98%E7%82%B9%E6%BF%80%E5%8F%91%E6%B1%82%E7%9F%A5%E6%AC%B2/","section":"post","tags":null,"title":"认知高效阅读的优点丰富阅读目标愿景"},{"categories":["项目总结"],"contents":"分析目找目标 目录设计的很好，在目录结构上以问答的方式，很快激发了读者共鸣和求知欲，从为什么读书很难，是什么导致读书阻力重重。带着问题开始思考读书的优点是什么，如何解决没有时间的问题，以及如何能高效的记住书本的内容，再内化为自己的能力，输出成果与人分享的喜悦。仅从目录页已经带着读者走完了阅读习惯养成的整个过程，体验了阅读的力量和魅力。 如何从目录中确定哪个章节属于重点阅读的，哪个章节优先级高。可以借助二项限法则，思考当前的生活中心，哪个章节有助于扩大你的影响圈，衡量其的重要性。 这本书的目录是逐渐成长的方式展开的，跳过任意章节都可能导致知识点不连贯，对作者论点理解出现偏差。但是如果按顺序来读，一旦有苦涩乏味的地方，必定会消耗精力，丧失读下去的兴趣。 阅读兴趣是第一位的，以兴趣为突破口先入为主，在兴趣的疑问的驱动下，摸索到读者的表达逻辑，激发求知欲，自然产生了解其他章节的诉求，来辅助理解重要章节的内容，主要精力用在对主要论点的加深理解和内化上，其他章节都为此服务。 阅读的优点章节解析 以本书为例，我在每次立项时，因为缺少成功经验，很难写出触动人心的愿景，这本书阅读的优点章节奉送了一波真实经验，可以借鉴其中的成果和胜利，丰富自己的愿景目标，树立奋斗的榜样，激发阅读的动力。 通过学习这个章节，作者用真实案例，罗列了有效阅读的各项优点，例如开阔视野，塑造思维方式，提高沟通能力，领导力等。这些都是我梦寐以求的能力，无不促使我必须培养良好的阅读习惯，让阅读更具有目标意识。 培养目标意识，就要利用tj3自我领导，在心灵演练愿景的过程，描述结果越真实，生动，可实现，越自信勇敢，就能激发更多的动力执行力和决心。保持住，希望在阅读任何一本书时，都要有目标意识，提升阅读专注力。 专注阅读理解记忆章节分析 前几天读完升职记，一天之后不知道讲的是什么，虽然我记笔记，写感想，但是没有激活经验和总结积累，导致理解不够，再次阅读的时候还有很多新内容发人深省。甚至读了三遍才知道书本的结构和中心要领：时间管理，目标管理和习惯的养成等。 以前这样的无效阅读比比皆是，曾经反思过这个问题，尝试通过时间管理，卡片笔记和脑图拆解等手段解决，也坚持写过博客，但是执行效果布显著，兴趣很快被消耗殆尽，导致半途而废。 我该怎么记住书中的内容呢，书本章节篇幅长篇大论，读完之后很难记住到底讲的是什么，这如何解决。 读书要学会选书，带着兴趣读书，找到自己想了解知识点，想玩游戏解密一样阅读。就是在阅读时要带着目的思考文中论点，猜想作者的安排和思路，推演分析在生活的经历，加深理解，这样读完之后，会有收获。 以上是为什么记不住书中的内容，作者给了几条建议，符合方格笔记的学习笔记本的框架和RIA激活生活经验等策。这些斗士框架是的思维，就看高效的实战技巧是什么了。 如何拆为己用，转化为自己的能力，这个本领强大，一直追求的境界。那该如何实现，输出，读完之后赶紧写博客输出。分享，讨论，模拟场景等方式。 读书档案，写出目标和付出行动。 目标章节 分析这么多章节的内容，最感兴趣的是那篇呢。 读书的优点，我要重新认识阅读的动力，让愿景更加丰富。 读书时间管理，我使用tj3项目管理的方式阅读，利用有效地时间阅读。 学以致用，目的性阅读，在于读之前要知道几个问题，可以在模板中列出来，在每次开启新书时，可以按照本章的关注点，审查阅读的重点然后安排计划。 转化为能力，这要知道什么才能体现自己的能力了。文章发表，阐述自己的观点和应用。这就是能力的体现，分享讨论影响他人协助他人也是一种能力。在领域成为专家沟通能力更强，有能力之后领导力影响力都会得到提升。现在重视的是内化的技巧。把能力提升。 优先级是 读书的优点，加深阅读的动力和愿景的向往 学以致用的技巧，如何吸收书中的知识，拆为己用，学习笔记的各自优点比较 输出：转化为自己的能力 ","date":"2022-08-11T21:48:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E4%BB%8E%E7%9B%AE%E5%BD%95%E7%BB%93%E6%9E%84%E4%B8%AD%E8%8E%B7%E5%8F%96%E5%9F%BA%E6%9C%AC%E4%BF%A1%E6%81%AF%E5%AE%9A%E4%BD%8D%E9%87%8D%E8%A6%81%E7%AB%A0%E8%8A%82/","section":"post","tags":null,"title":"从目录结构中获取基本信息找到最想学习的章节"},{"categories":["项目总结"],"contents":"愿景 我想通过阅读这本书，学习如何快速高效阅读一本书，书是一个知识体系的载体，如何快速理解掌握吸收内化一门知识体系，是非常重要的学习能力。希望认真阅读这本书之后，对书本这个载体有更深的理解，一本的类型，架构，知识体系构思过程等。在读书之前能够快速掌握作者的意图，是对书本的最大尊重。 掌握高效内化书中知识技巧的本领，拆为己用，提升学习能力。 目标 tj3是一套遵循七个习惯原则的管理框架系统，包含了任务管理和目标管理，和日常积累的高效能的行为规范：作出承诺，信守承诺，要事第一，以终为始等。目前用来管理工作和个人项目开发，执行一套完整过程，立项，设定目标，任务分解，进度跟踪，目标任务回顾，总结输出。项目在严谨的系统管理下，做到了快速迭代，保质保量的完成。 阅读书籍正像开发项目一样，需要根据个人需求和兴趣，对阅读设定目标，制定计划，针对重点章节开发学习相关知识体系，作学习笔记，分析理解，定期回顾总结加深记忆。让后在工作中实践，分享，讨论。 基于以上两点出发，如何让tj3在阅读中发挥正向作用，想通过学习麦肯锡阅读法，了解其高效阅读的原则规范，内化到tj3系统中，积极实践，帮助自己养成高效的阅读习惯，开启开挂的人生。 现在缺少一个单独对书籍吸收的模式工具。 麦肯锡阅读法是一本阅读规范的书籍，即，告诉你该做什么。抽取三个章节来说明： 高效阅读的优点：开阔视野塑造价值观和思维模式，看是现实挖掘潜力，培养同理心提高领导力，激发干劲（感动和求知欲的神秘力量） 高效阅读的习惯：创造阅读时间：调整作息，利用通勤，制定阅读计划 高效阅读的规范：作阅读档案标记和评价，专注一本书，读后立即笔记，买后立即读，不重读，定目标也计划 高效输出的规范：提高工作的速度和质量，和人分享聊天，写博客和档案总结，演讲。 按照以上的明确了高效阅读的注意事项和行为规范，要牢记这些改善阅读习惯。 要通过这次的阅读得到一些东西： 适合的roam 的高效阅读模板 ebook 结合emacs 快速收集阅读感悟和拆拆笔记。 目前有 a 模版可以快速生成roam 文件，收集书籍的阅读内容，记录阅读感悟。 在calibre阅读中可以通过网上查询功能实现。不在此赘述。 如何选择书籍 如何拆解一本书，找到自己想要的章节 如何总结一本书，成为自己的知识体系 使用roam 种子思维，吸收书本的要领和价值 下一步阅读习惯 高效阅读法主要提供一套高效阅读规范，不能奢望它提升你的阅读效率。这样我们只能考虑如何在阅读中规范自己的行为习惯，有意识培养提高阅读效率。 如何在阅读中规范阅读习惯，可以借助tj3系统的行为规范，针对阅读定几条阅读规范，提高阅读效率是改变人生的重要手段，必须担起责任，严格要求自己，时刻践行自己的使命宣言和承诺。 在立项之初，就应作出使命宣言的承诺，遵守高效阅读的原则。 阅读规范如下： 读目录体系，找目标，使用方格笔记，舍弃章节，设定愿景和目标 提高分析力，不重读，使用方格笔记，必须熟练于心，不择手段，多实践勤学苦练 专注一本书，立即读，兴趣昂然时，抓住冲劲，一鼓作气 读后再收集，敢舍弃，收集信息之后，必须用于舍弃，得出中心论点 比如：拿到一本书之后，先通过书目录了解正本书的知识体系结构，再阅读序言收集书本的主要表的内容，再收集这些信息之后，借助方格笔记的工作笔记法思考书本的专题，进行信息取舍过滤，总结论点i，借助心灵演练整个过程，然后情感确认是否值得阅读。 如果适合阅读，论点可以转化为目标和问题意识，然后，采用二项限法则确定重要章节，组织规划阅读时间，完成第一步种子播种。 开始阅读，严格遵守高效阅读的规范原则： 在兴趣和目标意识的去驱使下提高专注力 在紧锣密鼓的沙知识轰炸下，使用方格笔记的思考框架，紧抓论点，搜集信息，故事化作者思维逻辑图像，打好中间环节的立威之战。 在阅读之后，头脑风暴正劲之际，立即展开博客输出的操作，列出3~6个观点，将脑中的观点的故事化情节，一股脑倾倒在tj3框架中，将这些灵感论点和思路作为信息，进行处理，组织，总结概括，形成一篇逻辑缜密的文章。 ","date":"2022-08-11T18:27:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E9%98%85%E8%AF%BB%E9%BA%A6%E8%82%AF%E9%94%A1%E9%AB%98%E6%95%88%E9%98%85%E8%AF%BB%E6%B3%95%E6%84%BF%E6%99%AF%E5%92%8C%E4%B9%A0%E6%83%AF%E8%AF%89%E6%B1%82/","section":"post","tags":null,"title":"阅读麦肯锡高效阅读法愿景和习惯诉求"},{"categories":["周报"],"contents":"方格笔记的要点就是框架思维，掌握三分法则，培养基于事实思考问题，使用做图和逻辑连接词可视化思考过程，以做到温故知新现场浮现的效果，还要习惯总结概括，发现问题的本质原因。 要知道空雨伞的针对记思传不同用途中发挥的作用。标题是点睛能够引发思考，有一个准确的主题，能引导潜意识针对主题挖掘潜在关联，对激活生活经验同样作用很大，要学会定标题。 标题在工作笔记中，尤其明显，堪称保龄球的中心点，确定论点，舍弃不必要的信息资料，主题表达一针见血，不仅能让大脑更加专注清晰，问题会更加明确。这个阶段主要是对信息的处理能力，加以确认的能力，要通过沟通表达，梳理别人真正的论点需求，明确目标愿景。勇于舍弃的笔记本，能让头脑便聪明。 故事化过程，可以借助生活经验，演练加深记忆和理解，站在自己的角度看问题，把技术点套用到自己的经验上，看自己会怎么做。在看一篇文章时，要通过标题，猜想文章的内容，我从文章中能看到什么，学到什么，是否对我的知识体系有好处。然后就是阅读理解的过程，摘抄一段感兴趣的话，使用RIA拆解的流程，分析发现，尝试通过逻辑连接词故事化知识点，然后培养总结概括，下一步行动。提升自己的本领或搭建知识体系。或放入二项限中，作为孵化项目，等到有时间整理付出行动。 具体愿景： 每天早上阅读一篇文章，采用方格笔记的方法分析文章的核心论点，使用逻辑连接词和（展开，总结，重点，换个角度）箭头为什么等，探索分析文章的，然后做总结，看学到了什么，在什么场景下可以使用，在其他环境是否可以变通，等追问，挖掘培养自己分析总结的能力。 早上一篇：学习笔记法 中午一篇：工作笔记法 晚上一篇：提案笔记法 周末总结：博弈笔记法 文章要提前准备，把这个训练过程制定为一个习惯，定期做这个流程，加深理解应用。 下一步看看如何制定一个习惯吧。看这个习惯如何融入到emacs工具中。\n","date":"2022-08-05T21:35:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%91%A8%E6%8A%A5/%E6%96%B9%E6%A0%BC%E7%AC%94%E8%AE%B0%E6%9C%AC%E7%9A%84%E5%9B%9E%E9%A1%BE%E5%8F%8D%E6%80%9D%E6%80%BB%E7%BB%93/","section":"post","tags":null,"title":"回顾方格笔记和agenda集成情况"},{"categories":["周报"],"contents":"2022-08-04 Thursday 灵感四系向的汇总 今天我应该做什么让生活更加丰富多彩呢。 这是想要的什么的，我已经开始逃避现实了。还能有什么比这些更难过的现实能够打倒一个人呢。 当下我真该塑造一种习惯。 这种习惯是什么，可以总结一下吗？ 第一的重要的就是分析能力的锻炼的习惯，我想实现的愿景是在早上能够放空自己，使用的方法就是方格笔记法的要领。我要掌握方格笔记法，把这个强大的工具应用起来。 几点比较重视的地方： 记思传的工具，从三个思维框架中开始：空雨伞，板书发现总结概括，事实解释观点方案。 我都接触过哪些框架工具，激活以下生活经验，认识自己。 卡片法：标题，定义，案例总结 tj3:项目管理流程框架，需求，分析，拆解，开发，回顾。 拆为己用：RIA，AIA，总结阅读生活经验 anki：记忆法卡片制作 以终为始，要事第一等，都有内在机制，都可以看出框架逻辑的。 培养意识 想在已经确定elfeed和pocket，calibre为主要的信息来源，要练习org－roam的基本功，实践方格笔记的记思传三个本领。不要担心有困难，要大胆的做，才能有成长。 描述以下流程： 阅读要有结果，在收集上阅读了一篇文章之后，要做到以下几点： 确定是否感兴趣，然后保存到pocket中，阅读理解分析，然后借助capture夹工具，分析是那种情况，是记忆，还是思考，或者传达一个观点。要有意识采用方格笔记的空雨伞，发现解释总结，使用文章博客的方式传达，总结自己的思想。 要有结构，有数据有中心思想。 如何应用到具体场景中的 早上：一天之计在于晨，如果抓住这段时间 设想是把这段时间用在读书，思考，计划，时间管理中 中午：午休时间该怎么处理 晚上：如果管理自己的时间 要有框架思维，总结概括的意识，透过现象看本质。 使用方格笔记整理思路，确定面打扰时间等运用场景和目标设想 第一步：确定标题，激活思考的能力 第二步：明确事实，从事实中发现规律和习惯问题 第三步：总结问题，制定下一步行动 第四步：使用衣柜整理法，分析整理规划下一步行动的标准。 执行力：时间管理 梦想的开始的地方 时间管理：价值观－四项限－下一步行动－形成系统：衣柜整理法的妙用 目标管理：树的分解法：SMART树根，树干（愿景），树枝，树杈 衣柜整理法：收集，处理，组织，回顾，行动。 分析方法：首先要立观点，找准方向才能行动。 衣柜整理法：处理过程，就是2分钟法则，确定可行和不可行的事件 可行有：项目任务，下一步行动 不可行：材料，将来某时，需要时机成熟才能做的事情。 所以该从那里动手呢。 如果想知道自己的价值观，就需要借助方格笔记深入分析，找到准确的目标才行。 之前定了几项原则，在重复一下，加深记忆，要付诸行动。 钟点法则：时间日志，目前已经开始使用emacs的倒计时，监督管理和回顾时间了。 免打扰时间：在这个时间段，放空大脑，调整目标愿景，制定计划，管理时间。 收集法则：遇到突发临时事情，要充分利用inbox收集箱，等当前事情处理完成之后，再处理灵感等，容易干扰的事情。 方格笔记和小强升职记的两套方法论 方格笔记，主要说分析问题的逻辑框架，给定一个解决标准，比如经常遇到需要记忆的问题时，如何提高理解力，发现重点和该概括总结的能力，要有培养成习惯的意识。每天做一次阅读理解，训练整个过程。 还有用于思考的思想框架，通过笔记本引导思考，确定问题根本，舍弃干扰判断的信息。例如遇到我到底想干什么？想什么时候实现？然后确定目标观点，至关重要。 回想了这些知识之后，该如何使用收集箱，capture工具模板 方格笔记就是RIA，IAA，AIA模板的capture工具。要按照这种规范，配合方格笔记多练习，罗斯思维能力逐步形成，让大脑便聪明的习惯。 讨论一下，方格笔记和emacs之前的差别是哪些，如何配合使用，提升能力。 方格笔记的优点：手写的优势，做图方便。手写能够带动潜意识，激发潜在的思维，有助于时间关联。做图逻辑连接词的重要性，在发现环节，要多用展开，总结，重点，换个想法等有利于思考的关键词，配合箭头，更直观总结问题，实现笔记的再现的特点，有助于温故而知新。 2022-08-05 Friday TODO 免打扰时间放空大脑 充分利用emacs工具，吸收方格笔记的知识点，让时间管理更大合理，提到执行力和分析能力。 该怎么清空大脑呢 今天早上我在作为上拿出方格笔记之后，并没有在乎是否采用方格笔记的框架进行思考，而是先用笔随意写，脑子中想什么就写什么，慢慢思路逐渐被打开了。这是一次比较成功的经历。 如果在emacs中能复制这次的体验吗？换句话说，我如何使用emacs放空大脑，我想在灵感和任何想法在那里输出，给想法找一个倾诉的地方，是的，就是找一个安置想法的地方，然后在使用衣柜整理法处理优先级，安排一天的工作。 这个放空的过程应该有方格框架思维意识，辨别事实，分析总结能力的提高。 尝试一下放空训练 早上起来主要用在安装VR设备的开发环境，问题停留在了emacs的终端工具上。 大把的经历浪费在了doom搭建的过程，如何解决这个问题，就是网络线路问题，除非花钱购买节点，这样遇到类似的情况就可以剩下很多时间了。 搭建swift开发环境 在termux下可以安装swift开发环境，支持spm工具，支持emacs开发自动补齐功能。按照这两点特征，在andoid端搭建环境还是很有吸引力的，但是最终的产出效果是怎样呢。 目前发现第三包支持问题存疑，如果第三方不支持linux系统，即使现在费好长时间搭建起来，但是无法使用，那这是浪费经历了。 给出一些建议 使用spm工具搭建一个helloworld，验证库依赖机制支持情况，linux兼容过程问题。 如果可行，开发一个简单的alfred插件，输出workflow清单json解析等过程。 如果不行，总结那里存在问题，是否可以突破，确定是否需要继续关注这个话题。 下一步行动清单 搭建swift开发环境，验证是否可行 把任务清单归档到相应的项目中（这个难度很大，先使用jurlo收集，把方格笔记的过程疏通之后，在做emacs系统整理） 使用agenda监督日常工作，在晚上回顾，并总结今天执行情况 DONE 标题：花半个小时测试swift开发环境是否可行，并做简要总结 水很深，swift很多基础库编译失败，APPKit，Cocoa等 如果想深入研究需要看认真阅读下pkg swift到底兼容了哪些库，它的作用是什么，能干什么事情，这都需要明确之后，才能拿来用。 TODO 回顾方格笔记和agenda集成情况 DONE 午饭、午休时间 套餐：两浑一素，15,一碗杂谷粥 核算检测 TODO 按照四项限原则整理agenda列表，让每件事情都存档记录 整理日之信息 整理信息\n","date":"2022-08-04T19:53:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%91%A8%E6%8A%A5/22i31/","section":"post","tags":null,"title":"2022-W31"},{"categories":["学习笔记"],"contents":" VR的复苏 复苏期（2019 至今）：基于第一波产品的失败经 验教训，新技术逐步改进、产业链趋于成熟，产品体验及性价比明显提升。2019 年底随着 全球 5G 正式展开部署，VR/AR 作为 5G 核心的商业场景重新被认识及重视，行业重回升势；\n同年 Qculus Quest 发售，VR 游戏《Beat Saber》全球销量超 100 万份。\n2020 年，VR/AR 行业产业链各环节成熟度提升，叠加疫情推动居家需求上升，以 Facebook 发布的 Qculus Quest 2 为代表的消费级 VR 设备需求增长强劲，爆款 VR 游戏《Half-Life：Alyx》引爆行业。\n2020 年 VR/AR 产业投融资活跃，金额及数量均回到 2016 年的高点水平。\n生产稳定期： VR/AR 新技术的性能/效果最终能满足消费者需求时，将进入实质的普及生产阶段。\nVR/AR 出货量增长显著，已进入产业化放量增长阶段。比之 2018-2020 年相对平缓的终端 出货量，随着 Facebook Quest2、微软 Hololens2 等标杆 VR/AR 终端迭代发售、电信运 营商虚拟现实终端的发展推广，以及平均售价从当前 2500/9700 元进一步下降，2021-2022 年 VR/AR 终端规模上量、显著增长。\n产业链分析框架 硬件 VR 终端的硬件主要由芯片处理器、屏幕及光学器件、声学器件、存储、壳料、辅料等构成。\n其中，芯片处理器、存储、光学显示器件在 VR 终端成本中占比较高，与智能手机重合度较高，许多领域的技术积累可以复用，硬件产业链相对比较成熟。\n成本 VR 目前的主要的使用场景 是游戏及视频，以图像处理与显示为功能重点，因此硬件成本中：\n屏幕占比 36% 光学器件占 比 6% 光学显示器合计占比约 40% 同时 VR 也需要较高的内存，存储成本占比 27% 负责计算、渲染和图像处理的 CPU、GPU 处理器占比 16%左右。 芯片 高通骁龙 XR2 成为 VR 主力芯片。\n最早应用到 VR/AR 设备的芯片是高通针对手机的 SOC 方案 821、835、845，其中 835、845 均针对 VR/AR 设备作相应优化。\n2018 年 5 月，高通 推出 VR 专用芯片骁龙 XR1，其性能与骁龙手机芯片660 相近。\n2019 年 12 月，高通发布基 于骁龙 865 衍生的 XR2，集成了高通的 5G、AI 及 XR 技术。\n2019年高通骁龙发布5G+XR芯片 XR2， 骁龙XR2 是以骁龙865为基础针对 VR/AR 设备进行改造的专用芯片平台，结合了高通 5G、 AI 及 XR 领域的最新技术，相对 XR1 其性能得到显著提升。\n目前新一代 VR 一体机 Oculus Quest 2、VIVE Focus 3、Pico Neo 3 系列等均采用 XR2 平台。\n软件 VR对系统的挑战： 3D化与实时性 ，是虚拟现实优化创新的重要技术方向。\n正如 iOS 基于 UNIX，Android 基于 Linux，虚拟现实 OS 并非独立于现有操作系统发展 而来，在操作系统和底层软件上继承了移动端特性，是基于移动 OS 定制优化的嵌入式实时系统。\nVR 技术特征 近眼显示 特征，虚拟现实 OS 有望成为首个 3D 化操作系统。 感知交互 特征，虚拟现实 OS 凸显稳态、实时、紧耦合的发展特性。\n近眼显示\n当前移动 OS 主要面向传统手机应用设计，用户视野较小，UI 控件和 Layout 布局方式均面向 2D，对多任务系统的执行并不迫切。\n虚拟现实 OS 可能不再有“桌面”概念，用户目之所及即为操作界面，更加强调空间思维，在 3D 图形渲染、3D 内容传输、3D 显示乃至基于 glTF 等新兴 3D 格式等方面变化甚巨。\n感知交互\n虚拟现实 OS 凸显稳态、实时、紧耦合的发展特性。\n移动系统机制\n传统移动 OS 是一个 待命式 系统，系统基于用户有意识主动操作进行响应，且各子系统相对独立。\n传感与渲染子系统相互独立； 图像输入与渲染子系统相互独立； 传感器不参与渲染处理系统； 移动OS系统设计存在诸多缓存逻辑； VR系统特性差异\n虚拟现实 OS 更像稳态系统，不论用户主动操作与否，从姿态到渲染保持实时稳定运行，20ms MTP 时延约束成为其中核心技术挑战，体现在如下方面。\n在图形渲染方面\nVR由于复杂合成系统将带来过高渲染延迟，不同于移动 OS 用户界面 2D 图 层合成的方式，虚拟现实 OS 渲染方式存在显著差异。\n在传感融合方面\n移动 OS 交互方式以触屏为主，基于这一交互技术的事件体系在虚拟现实中无法使用，此外，移动 OS系统架构中缺少高精度高频率的传感融合实现，架构的复杂性导致传感延迟较高。\n在内容应用方面\n移动 OS 图形驱动均为 C++库，上层应用采用 Dalvik 虚拟机作为运行时，与实际 图形驱动较远，效率较低，且移动 OS 的事件回调机制难以满足虚拟现实应用的实时性需求。\nVR主流系统 VR 设备目前主要是基于安卓定制系统。\n早期的 VR 一体机基本沿袭手机端的计算芯片与操作系统，如：\nOculus Go 采用高通骁龙 821 芯片； Vive Focus 采用高通骁龙 835 芯片； 操作系统则是在安卓系统的基础上进行优化及定制。\n类似地，分体式 VR 包括 PC VR、PS VR 以 及华为 VR Glass、创维 V601 等超短焦手机 VR，其运行的操作系统仍以连接的主机为主， 包括微软 WMR、索尼 PS 及安卓系统。\n3D开发工具 3D 开发工具的核心是生产与创作工具，逐步走向简单化、轻量化、可视化。\n目前市场核心的 3D 开发引擎包括 Unity 的 U3D、Epic Games 的 Unreal Engine，以及 Frostbite Engine 寒霜引擎、起源引擎等，主要用于游戏、影视等 PGC 的内容生产。\n由于 Metaverse 需要简单易用的生产工具，3D 开发工具也逐步走向简单化、轻量化、可视化， 如 Roblox 平台的开发工具 Roblox Studio，《我的世界》MC Studio 等。\n目前，VR/AR 均已脱离了基于厂商原始 SDK 的简陋低效开发阶段，而步入了第三方技术支 持的高效开发新纪元。\nVR 大型应用开发已得到各类图形库平台供应商的支持。\nVR 开发不再拘泥于 Oculus SDK、OpenVR 等原始 SDK，而是可以通过 Unity、Unreal 等成熟图形引擎、 游戏引擎实现快速高效开发。\nOpenXR:VR通用的SDK OpenXR 是一个由 Khronos 组织联盟开发的开放式、无版权费用的 XR 行业标准规范，旨在 简化 VR/AR 软件开发，打通游戏引擎及内容底层连接，塑造具备互通性的开放生态。\nOpenXR 最大的意义是，游戏开发者使用一个 API 接口就能让游戏在不同品牌的 VR/AR 中运行；硬件厂商则可利用现有 OpenXR 内容降低市场进入门槛，为消费者提供更丰富的内容体验。\n以下不同硬件平台对OpenXR的支持：\n微软在 HoloLens、WMR 头显均提供 OpenXR 支持； Unity 推出 OpenXR 支持预览版； Epic 宣布虚幻引擎 5 不再支持 SteamVR、Oculus 等平台，转而支持且仅支持 OpenXR 标 准； Oculus 推荐游戏引擎使用 OpenXR； 国内厂商中华为、兆芯、Pico 等也加入 OpenXR 联盟参与标准的讨论与制定工作； 内容/平台 VR 内容题材日益丰富，促进 VR 体验向消费者渗透普及。\n截至 2020 年 12 月，Steam、 Oculus PC、Viveport、SideQuest、Pico、Oculus Quest 平台的 VR 应用总数分别达到 5554、 1755、2513、931、578、235 款。\n截至 2020 年 9 月，Facebook Quest 平台内容收入已达 到 1.5 亿美元，35 款游戏收入达到百万美元，沉浸声、手势识别与虚拟化身等特色内容制作 SDK 陆续发布。\n随着 VR 内容的丰富、设备体验的升级以及售价的不断下探，VR 产品将 进一步向消费者渗透普及。\n应用领域 游戏之外，视频、直播、电竞、社交等商业场景亦多点开花，呈现广阔前景。\n根据 IDC 数据，消费类 VR 主要包括游戏、视频、直播、影院、电竞、社交、音乐等领域.\n商业类 VR 主要是教育、文旅、医疗、家装、房产、零售等。\n其中基础的 VR 娱乐产品如游戏、视频、直播等需要用户具有高沉浸感，从而达到“身临其境”的体验，这对于 VR 内容的品质要求非常高；\n而对于商用场景，用户对产品的关注点更多的在于能否达到相应的效果，因此，商用 VR 的内容门槛相对用户端要低，内容制作成本也相对较低，同时一些商业模式也已经跑通，可预见商业 VR 将迎来高速发展。\n巨头布局：围绕硬件、软件、内容/平台展开竞争 Facebook：以消费级硬件切入，剑指 VR 社交 硬件方面\nFacebook 在收购 Oculus 后相继推出 PC VR Oculus Rift CV，VR 一体机 Oculus Go、VR 一体机 Oculus Quest、PC VR Oculus Rift S、VR 一体机 Oculus Quest 2。\n其中 Oculus Quest 2 上线半年后销量超过此前所有产品总和，预测2021年销量为500-900万台。\n软件方面\n出于商业竞争及战略安全的考虑，Facebook 已经加大投入构建围绕空间计算与 3D 的完整 VR/AR 操作系统，以应对对安卓系统的依赖而受制于谷歌。\n自研操作系统有助于 Facebook 将社交、隐私与硬件深度结合，为其收购的公司以及合作伙伴构建完善生态。\n内容方面\nQuest 平台采用严格的审核机制决定游戏上线，以高品质内容成就高口碑，上线以来收入规模稳步增长，累计收入规模超 1.5 亿美元，超 60 款游戏收入达 100 万美元。\n此外，VR 社交平台《Facebook Horizon》被视作 Facebook 志在社交的桥头堡，仍在测试中，兼容 Rift、Quest。\n微软：专注 AR 眼镜，继续打磨 HoloLens 硬件方面\n微软发布 HoloLens 一代惊艳市场，持续打磨后推出 HoloLens 2，增加了强大的 手势追踪，这种进步是划时代性的，如同智能手机的触屏功能；相对一代 CPU 性能有显著提升，可以流畅运行复杂特效；与微软 Azure、Dynamics 365 等远程方案很好结合使用。\n软件方面\nHoloLens 运行在名为 Windows Holographic 的平台上，如果将 HoloLens 看作 PC 机，那么 Windows Holographic 平台就是操作系统。\n基于 Windows 10 的 Windows Holographic 平台能够提供全息影像框架、交互模型、感知 API 和 XboxLive 服务，目前在 Windows 商店里能够找到数百个全息 UWP 应用，可见其正在规模性地扩展。\n同时，微软联合 Unity 推出 MRTK 开发工具（Microsoft Mixed Reality Toolkit）旨在帮助开发者轻松利用 Unity 开发跨平台 MR 应用。\n它同时允许开发者通过编辑器模拟轻松进行原型设计。\n最新的 MRTK 2.7 现可通过 Mixed Reality Feature Tool 下载，正式支持 OpenXR。\n苹果：低调布局多年，颠覆性产品蓄势待发 硬件方面\n专利技术，截至目前，苹果已有 330 多项公开可查的 VR/AR 关键专利。\n苹果在 AR/VR 领域 的布局最早可以追溯到 2006 年提交的一项头戴式显示器的专利。\n截至目前透露的最新专利 包括“动态环境照明控制”、“全景光场捕捉、处理和显示”，以及一项“基站”专利，为 VR/AR 内容提供处理能力，支持用户与内容进行 6DoF 交互。\n软件方面\n苹果最新的 ARKit 5 帮助开发者构建比以往任何时候都要更好的 AR 体验，主要包括位臵锚定支持更多地区、人脸追踪功能升级、改进运动追踪等。\n内容方面\n苹果收购 VR/AR 直播企业 Next VR、收购虚拟现实初创公司 Spaces、Apple TV+ 流媒体视频服务中增加 VR/AR 内容，基于底层链条逐步完善内容生态。\n谷歌：不再支持 Daydream，重心重回 AR 硬件方面\n2017 年，Google Glass 以企业版本 Glass Enterprise Edition 回归，主要面向企业客户，涉及农业机械、制造业、医疗以及物流等领域。\n2019 年，Google Glass Enterprise Edition 2问世。企业级市场之外，谷歌于2020年收购加拿大眼镜公司North布局消费级AR， North 创立于 2012 年，主要研发支持手势控制操作的臂环设备 Myo； 2018 年改名为 North， 同时推出智能眼镜 Focals，同年 North 收购英特尔 230 多份智能眼镜专利。\n软件方面\n对标苹果 ARKit 推出 ARCore，基于安卓系统搭建增强现实（Augmented Reality, AR）应用的 SDK。\nARCore 使用三项关键技术来整合虚拟内容和现实世界：\n运动跟踪技术 （让手机能够理解并追踪自身在环境中的相对位臵）； 环境理解技术（让手机可以侦测到扁 平的水平面，如地表或咖啡桌）； 光照强度估测技术（可以估量当前环境的光照情况）； VR穿戴分类 VR平台可分成2大类，分别为 有线VR 和 无线VR\n有线VR：是指基于PC/主机类的VR设备，例如：OculusDK1、DK2；CV1；HTC VIVE；Sony PSVR等。\n其特点：基于强大计算能力的极佳的综合体验效果。\n无线VR： 以 Google Cardborad 、 Oculus GearVR 、 Oculus Quest2 为代表的移动端VR，以手机或者穿戴式设备实现无线显示。\n其优点：可以随身携带，缺点是计算能力不如台式机强大。\n未来 无线VR 一定是主流方向，这不单是因为嵌入式CPU、GPU发展越来越强大，体验越来越好，更重要的一点是，无线方式结合VR技术可以实现丰富的商务模式，更容易获得普通消费者青睐。\n下一步：学习VR技术,开发元宇宙 推荐给一些零基础一个完整的学习路线：语言掌握C# \u0026mdash; 工具掌握 Unity \u0026mdash; SDK掌握Vuforia和ARKit \u0026mdash; AR眼镜掌握HoloLens开发 \u0026mdash;- VR眼镜掌握Oculus Quest开发。\n介绍了主流VR硬件平台，但想要真正“携手VR”，还需要了解如何开发VR应用。下面就介绍一下VR开发引擎，其实本质还是传统的3D引擎，尤其是传统的 双U （即Unity3D和Unreal），加入了VR插件（所谓VR插件，基本功能是实现左右分屏渲染，陀螺仪、位置跟踪等API）。\n开发引擎与我们传统的开发语言环境相比，有以下几个不同：\n首先开发者要更熟悉3D 的理念，这是VR的基础 其次VR的3D引擎开发需要各种各样的开发应用资源 Unity（U3D） Unity Technologies 是一个全面整合的专业游戏引擎，同是一款强大的IDE工具，可以制作多平台综合型游戏。诸如三维视频游戏、建筑可视化、实时三维动画等类型互动内容。\nUnity类似于Director,Blender game engine, Virtools 或 TorqueGame Builder等利用交互的图型化开发环境为首要方式的软件，其编辑器运行在Windows 和Mac OS X下，可发布游戏至Windows、Mac、Wii、iPhone和Android平台。也可以利用Unity web player插件发布网页。\n参与者不仅仅是程序员，还有美工等其他人员，所以引擎是一个完整的协作工具，编程尤其是写代码只是开发中的一个环节， 开发 更多是一种综合性工作。\nUnreal Engine（UE） 关于UE和UDK，前者是正式商业版本（建议用此版本），后者是前者的免费版，无源码，商业用途需要授权。 UNREAL ENGINE中文名“虚幻引擎”，是目前世界最知名、授权最广的顶尖游戏引擎，占有全球商用游戏引擎80%的市场份额。中国首家虚幻技术研究中心在上海成立，该中心由GA国际游戏教育与虚幻引擎开发商EPIC的中国子公司EPIC GAMES CHINA联合设立。\n基于它开发的大作无数，除《虚幻竞技场3》外，还包括《战争机器》、《彩虹六号维加斯》、《镜之边缘》等等。在美国和欧洲，虚幻引擎主要用于主机游戏的开发，在亚洲，中韩众多知名游戏开发商购买该引擎主要用于次世代网游的开发，如《剑灵》、《TERA》、《战地之王》等。 iPhone上的游戏有《无尽之剑》（1、2）、《蝙蝠侠》等。\n双U对比 关于以上两种开发引擎哪种更适合VR开发\nUnreal 优势：3D图形画质较好，因为它采用了预烘培等技术，并且更充分地利用了Shader。 劣势： 开发难度较大，早期只能使用C/C++开发，UDK引入了类C/JAVA语言UnrealScript作为开发语言，但业内精通UE的开发者不多，有极端观点认为UE如果不做FPS射击游戏的话，失败概率很大。 Unity 优势 架构设计非常合理；开发者容易上手。 跨平台支持非常好，第三方插件系统非常先进，能第一时间获得最新VR设备的插件支持，堪称宝库的 asset Store 第三方组件、素材商店让你仿佛是在与全世界的开发者联合开发。 Unity开发可以 举一反三 ：一次开发可以迅速应用到多种平台，或者新插件一发布，许多老的项目也能扩展到新的方式当中。比如VR开发，Oculus、HTC、Sony、Cardboard一发布，Unity平台上就有新的插件可以使Unity开发的老项目适用于VR新硬件平台上。所以目前U3D的开发者队伍发展速度非常快。 劣势 出现时间较晚，一般认为缺省画质不如UE。 其他平台 其他还有一些平台如CryEngine、OSVR等，也有一些开发者不用引擎，直接用高级语言驱动VR设备开发，但这种方法要解决的问题太多，比如左右画面自己渲染，陀螺仪驱动数据读取等，有兴趣的开发者可以找一些资料，不过因为VR硬件平台发展太快，选择这种开发方式要慎重。\nOpenXR OpenXR 是VR领域的一个重要里程碑。这个API将允许游戏和其他应用程序在各种硬件平台上轻松运行，而无需专有的SDK。\nOpenXR 的实现是非常底层的，普通的开发者们无需仔细研究底层，只需要拿到工具类进行开发调用即可。 开发者们可以基于OpenXR上层继续进行便捷的应用开发，但这同样需要一个类似VRTK的开发套件来进行。 VR/AR厂商们可以将自己原有的SDK向 OpenXR改造靠拢，以实现一个多平台互通的桥梁。 OpenXR | OpenXR是什么？一文带你全面了解OpenXR的相关知识，上车收藏不迷路 - 云+社区 - 腾讯云\nOpenXR | （二）使用 OpenXR 制作一款简单VR示例场景 的全过程详细教程，包含两个实战案例。 - 云+社区 - 腾讯云\nOpenXR Plugin OpenXR Plugin是 Unity 开发的符合 OpenXR 标准的工具包，旨在让 Unity 开发者尽可能高效地将内容部署到更加广泛的 XR 目标平台上。开发者在 Unity 2020 中通过 Package Manager 搜索\u0026quot;openxr\u0026quot;即可找到该工具包并进行安装。\nOpenXR Plugin | OpenXR Plugin | 1.0.3\nOpenXR 插件 - Unity 手册\n","date":"2022-03-16T11:34:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E5%85%83%E5%AE%87%E5%AE%99%E4%BA%A7%E4%B8%9A%E9%93%BE/","section":"post","tags":null,"title":"元宇宙产业链"},{"categories":["学习笔记"],"contents":"OpenXR 旨在标准化各种 VR / AR 平台上的设备和应用程序之间的规范。\n它由 Khronos Group 制定，Khronos Group 是一个由 VR/AR 相关公司组成的组织，下面会进行详细介绍。 微软、HTC等多家公司都参与了，Valve（SteamVR）也在2021年2月支持。\n以下不同硬件平台对OpenXR的支持：\nVR开发面对的痛点 VR 和 AR 最近经历了热潮，随之而来的是大量硬件和软件公司开始在该领域展开努力。虽然种类繁多，但越来越多的设备（每个设备都有自己不兼容的 API）正在增加 碎片化 。\nSDK碎片化：开发成本得不偿失\n在进行VR开发的时候，开发者们要根据不同的VR设备厂商来使用不同的SDK进行应用开发。如果没有跨平台的标准，VR应用程序，游戏和引擎必须移植到每个供应商的API。\n这意味着每个VR设备只能运行已经移植到其SDK的应用程序，结果是高昂的开发成本和令人困惑的客户限制了市场的增长。\nAPI 碎片化导致应用程序开发人员不得不花费大量时间、金钱和资源与各种硬件集成。即使是大团队也被迫选择他们支持的平台和设备，而对于小团队来说问题更严重。\n除了开发人员之外，API 碎片化给消费者带来了问题，他们需要检查自己喜欢的硬件是否与他们希望使用的应用程序兼容，并且不确定今天的软件是否与明天的硬件兼容。\n因此，目前的情况看起来像这样，应用程序开发人员利用中间件，但仍然需要做大量工作才能将他们的内容带到多个平台。简而言之，碎片化减缓了 VR/AR 设备的采用，给开发人员带来了不必要的工作，并限制了新的和创新设备获得普及的能力。\nOpenXR 是 Khronos公司设定的VR行业标准，希望让所有的VR厂商们可以基于此标准进行应用开发等上层逻辑处理。 VRTK是基于最开始的Oculus、Vive等厂商做的一个开发套件，目的是让开发者们可以更方便快捷的进行应用开发(OpenXR行业标准出现之前)。 Khronos公司现在要做的是建立一个OpenXR行业标准，然后再使用新的套件进行通用的应用开发。\n规范开发的两个标准：OpenXR OpenXR 工作组相信我们可以通过标准化来帮助解决这些问题。标准将允许应用程序开发人员将更多时间花在创造令人惊叹的体验上，而将更少的时间花在让体验在无数硬件组合上发挥作用上。它还将使设备供应商能够在其平台上提供更多内容，并将使其投资面向未来。\nOpenXR 标准分为两部分。\n应用程序接口 openXR 定义了应用程序接口， 应用程序开发人员 和 中间件提供者 写入该接口，用于定义和组合通用的跨平台功能。\n这使应用程序开发人员能够编写一次可在任何地方运行的代码，专注于对其应用程序进行创新，并且不必为各种不同的设备支持多个接口。\n设备层运行时交互 OpenXR 设备层允许 VR/AR 运行时与各种设备进行交互。\n如果硬件制造商想要添加对新设备的支持，他们会实现符合设备层规范的代码，并且他们的硬件将立即与为应用层编写的应用程序兼容。\n这是一个强大的架构，使每个人都能够专注于对他们来说最重要的事情。\nOpenXR 标准旨在实现供应商之间丰富多样的实现差异化。来自不同供应商的运行时可能在性能和功能上有所不同，但是让这些运行时实现支持相同的标准接口会为最终用户带来更多的选择。\n生态图 跨平台的VR标准通过使应用程序能够在任何VR系统上运行一次，以及访问集成在VR系统中供应用程序使用的VR设备，从而消除了行业分割。\n公开支持 OpenXR 的公司 微软在 HoloLens、WMR 头显均提供 OpenXR 支持； Unity 推出 OpenXR 支持预览版； Epic 宣布虚幻引擎 5 不再支持 SteamVR、Oculus 等平台，转而支持且仅支持 OpenXR 标 准； Oculus 推荐游戏引擎使用 OpenXR； 国内厂商中华为、兆芯、Pico 等也加入 OpenXR 联盟参与标准的讨论与制定工作； Khronos 百度百科 Khronos Group 团队成立于 2000 年 1 月 由包括 3Dlabs, ATI, Discreet, Evans \u0026amp; Sutherland, Intel, Nvidia, SGI 和 Sun Microsystems 在内的多家国际知名多媒体行业领导者创立 致力于发展开放标准的应用程序接口 API ，以实现在多种平台和终端设备上的富媒体创作、加速和回放。\nKhronos官网地址\nKhronos相关标准 OpenGL OpenGL 是行业领域中最为广泛接纳的 2D/3D 图形 API, 其自诞生至今已催生了各种计算机平台及设备上的数千优秀应用程序。OpenGL是独立于视窗操作系统或其它操作系统的，亦是网络透明的。在包含CAD、内容创作、能源、娱乐、游戏开发、制造业、制药业及虚拟现实等行业领域中，OpenGL™ 帮助程序员实现在 PC、工作站、超级计算机等硬件设备上的高性能、极具冲击力的高视觉表现力图形处理软件的开发。\nOpenKODE OpenKODE 是免授权费的、跨平台的为加速富媒体和图形应用程序而联合一组本地应用程序接口 APIs 构成的全面媒体堆栈规范标准。 OpenKODE 是媒体应用移植性 API，致力于持续地提供先进的媒体性能，从而提高本机媒体应用源移植性和降低移动平台不相容性。OpenKODE 1.0 通过联合OpenGL ES 和 OpenVG Khronos APIs 以提供艺术级的矢量 2D 和 3D加速，并形成了新的OpenKODE 核心API,提供抽象的操作系统资源，从而最小化在 Linux、Brew、Symbian、Windows Mobile、WIPI 和以实时操作系统(RTOS)为基础游戏和应用程序移植时的资源变更。 OpenKODE 的后续版本将会增加 OpenSL ES 和 OpenMAX 媒体应用程序接口APIs，用以提供完全整合图形算法处理的音频/视频加速。\nOpenGL ES OpenGL ES 是免授权费的，跨平台的，功能完善的2D和3D图形应用程序接口API，它针对多种嵌入式系统专门设计 - 包括控制台、移动电话、手持设备、家电设备和汽车。它由精心定义的桌面OpenGL子集组成，创造了软件与图形加速间灵活强大的底层交互接口。OpenGL ES 包含浮点运算和定点运算系统描述以及 EGL针对便携设备的本地视窗系统规范。OpenGL ES 1.X 面向功能固定的硬件所设计并提供加速支持、图形质量及性能标准。OpenGL ES 2.X 则提供包括遮盖器技术在内的全可编程3D图形算法。OpenGL ES-SC 专为有高安全性需求的特殊市场精心打造。\nOpenML OpenML 是开源的、免授权费的、跨平台的编程环境，其专为捕捉、传输、处理、显示和同步数字媒体所设计 - 包括2D/3D图形和音频/视频流。OpenML 1.0 定义了专业水准取样级别流同步；用于加速视频处理的OpenGL扩展；MLdc专业显示控制应用程序接口API及ML 针对应用程序和处理硬件间非同步媒体流的架构。\nOpenVG OpenVG 是针对诸如Flash和SVG的矢量图形算法库提供底层硬件加速界面的免授权费、跨平台应用程序接口API。OpenVG 现仍处于发展阶段，其初始目标主要面向需要高质量矢量图形算法加速技术的便携手持设备，用以在小屏幕设备上实现动人心弦的用户界面和文本显示效果，并支持硬件加速以在极低的处理器功率级别下实现流畅的交互性能。\nOpenMAX OpenMAX 是无授权费的,跨平台的应用程序接口API，通过使媒体加速组件能够在开发、集成和编程环节中实现跨多操作系统和处理器硬件平台，提供全面的流媒体编解码器和应用程序便携化。OpenMAX API将会与处理器一同提供，以使库和编解码器开发者能够高速有效地利用新器件的完整加速潜能 - 无需担心其底层的硬件结构。\nOpenSL ES OpenSL ES 是无授权费、跨平台、针对嵌入式系统精心优化的硬件音频加速API。它为嵌入式移动多媒体设备上的本地应用程序开发者提供标准化, 高性能,低响应时间的音频功能实现方法，并实现软/硬件音频性能的直接跨平台部署，降低执行难度，促进高级音频市场的发展。\nCOLLADA COLLADA 是面向交互式 3D 应用程序的基于 XML 的数字资产交换方案，使 3D 创作应用程序可以自由地交换数字资产而不损失信息 - 使多种DCC和3D处理软件包可以组合成强大的工具链管道。独特的交互模式提供了广泛全面的视觉编译。COLLADA FX支持使用 OpenGL ES 着色语言创作和封装着色器，以使一流的 3D 创作工具可以有效协作创建 OpenGL / OpenGL ES 应用程序和资产。\nOpenGL SC 开放标准的 OpenGL SC 高度安全 Profile 被定义为满足高安全敏感性的特殊市场，如航空工业，军事，医学和汽车业应用程序，包含D0178-B认证。它简化了高度安全认证，保证可靠性，与实时系统需求相符，并便于高度安全应用程序的继承移植。\nOpenXR概念 OpenXR 是一种免版税的开放标准，可提供对增强现实 (AR) 和虚拟现实 (VR)（统称为 XR）平台和设备的高性能访问。\n“OpenXR 旨在简化 AR/VR 软件开发，使应用程序能够覆盖更广泛的硬件平台，而无需移植或重写其代码，随后允许支持 OpenXR 的平台供应商访问更多应用程序。随着 OpenXR 1.0 规范的发布，AR/VR 开发人员现在可以创建真正的跨平台 XR 体验。” \u0026mdash;\u0026mdash;布伦特·E·因斯科 (英特尔首席 XR 架构师和 OpenXR 工作组主席)\n如果没有跨平台标准，VR 和 AR 应用程序和引擎必须使用每个平台的专有 API。新的输入设备需要定制的驱动程序集成。\nOpenXR 提供跨平台、高性能的直接访问跨多个平台的各种 XR 设备运行时。 OpenXR 使应用程序和引擎（包括 WebXR）能够在任何公开 OpenXR API 的系统上运行。\nOpenXR体系结构\n行业行情 关于OpenXR更多信息的官网介绍： https://www.khronos.org/openxr/\n总结 总而言之， OpenXR 是VR领域的一个重要里程碑。这个API将允许游戏和其他应用程序在各种硬件平台上轻松运行，而无需专有的SDK。 OpenXR 的实现是非常底层的，普通的开发者们无需仔细研究底层，只需要拿到工具类进行开发调用即可。 开发者们可以基于OpenXR上层继续进行便捷的应用开发，但这同样需要一个类似VRTK的开发套件来进行。 VR/AR厂商们可以将自己原有的SDK向 OpenXR改造靠拢，以实现一个多平台互通的桥梁。 关于OpenXR上层的开发套件目前还没找到很合适的，如果有好用的开发套件也欢迎评论区提出呀~ ","date":"2022-03-16T11:19:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/OpenXR%E7%AE%80%E4%BB%8B%E8%AF%B4%E6%98%8E/","section":"post","tags":null,"title":"OpenXR"},{"categories":["项目总结"],"contents":"需求描述 在我的团队中，同一个人总是自愿起立站立或写下会议笔记。理想情况下，每个人都应该分担这个负担，因此我开始在桌上旋转笔以随机选择某人来完成每个任务。这种方法效果很好，但是我们并不总是有钢笔或桌子。 需求 ：借用转动的随机笔，来指定谁来执行的任务。这个场景很常见，在多个事情面前，不知道该如何抉择时，可以使用这种随机方式，天注定的缘分来行使抉择权。\n愿景：希望能够激发之前的开发经验，能在这个基础上学好新知识，也能温习之前的旧知识。最终实现在开发思维的转变，以 swiftUI 的开发模式来思考需求的实现。\n了解swiftUI 开发模式，积累swift知识体系\n掌握SwiftUI 原生 API UIKit 混编 SwiftUI状态属性实现数据通信 Combine 使用，推荐：swiftui-notes 记录在项目中会遇到哪些问题 用例描述 转笔选择：当点击转笔时，开始旋转，会在随机方向停下来。 团队人数：通过滑块控制笔下静止位置的数量。 开发设计 产出时序图，类图，活动图，甘特图\n难点调研 列出项目中，可能用到的技术点，做好调研工作。\n转笔动画 随机人数设置和停止 网络请求获取笔的样式 扩展支持加载远程图片的方法先通过本地配置文件，提供图片的名称、地址等信息，代替服务器端。知识点：文件解析方式，swiftUI 数据层交互方式，网络访问方式，响应式开发。 SPM 学习 Slider 控件支持绑定State 属性 Image 图片自适应大小的方法和frame 属性的使用 bundle 加载main 和 module 中的资源方法 String 格式化小数点的方法 VStack 布局封装和间距和外边距的设置 开发：要事第一 源码库：Landmarks/Sources/Pen\n转笔页面 设置页面 转笔样式 封装自己的网络库 回顾总结 访问taskjuggler版本 转笔游戏 原文：随机转笔:这是一个解决常见问题的傻瓜应用程序：随机选择一个人来完成任务。 Swift Package Manager for iOS | raywenderlich.com\n项目地址：GitHub - iT-Boyer/PenOfDestiny\n2021-04-07\n2021-04-10\nox a2\n","date":"2022-02-09T14:05:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/swift%E9%9A%8F%E6%9C%BA%E7%AC%94%E7%BB%83%E4%B9%A0%E9%A2%98/","section":"post","tags":null,"title":"转笔游戏"},{"categories":["学习笔记"],"contents":"资料： 原文：随机转笔:这是一个解决常见问题的傻瓜应用程序：随机选择一个人来完成任务。 Swift Package Manager for iOS | raywenderlich.com\n2021-04-07\n2021-04-10\n场景描述 在我的团队中，同一个人总是自愿起立站立或写下会议笔记。\n理想情况下，每个人都应该分担这个负担，因此我开始在桌上旋转笔以随机选择某人来完成每个任务。这种方法效果很好，但是我们并不总是有钢笔或桌子。\n需求：借用转动的随机笔，来指定谁来执行的任务。\n需求点：点击笔。它会在向随机方向安定下来之前旋转。滑块控制笔下静止位置的数量。这些代表您团队中的人数。\n这个场景很常见，在多个事情面前，不知道该如何抉择时，可以使用这种随机方式，天注定的缘分来行使抉择权。\n目标 想通过这个有趣的小应用，来转换开发思维，把老 oc 过度为 swiftUI。\n目前这个项目是有两个版本，一个初始版本，一个完成版本，我将跟着作者的方法，来设计开发一套好玩的抉择工具。希望能够激发之前的开发经验，能在这个基础上学好新知识，也能温习之前的旧知识。\n最终实现在开发思维的转变，以 swiftUI 的开发模式来思考需求的实现。知识，技巧，意愿\n开始跟着大牛学习之旅吧。\n计划 学习这个项目掌握，SwiftUI 原生 API 的使用，添加依赖学习两个好用的控件库\n目标是，快速掌握最新的 swiftUI 开发模式\n注册 raywenderlish 账户，下载初始项目\n快速启动初始项目，设定学习目标，预估花费的时间\n掌握 swiftUI 基本语法，梳理对知识体系的认知\nswiftUI 控件 API，UIKit 之间的调用，两者之间的交互方式，有哪些可以使用的想有的封装库，帮助开发。\nswiftUI 和数据层的通信方式的原理，需要进步一步了解哪些知识，是否有已有库可以借鉴使用。\n确定自己是否使用 swiftUI 开发模式\n确定运用到在实际项目中会遇到哪些问题，即相关具体步骤\n随机笔，学习 SPM 工具私库管理 扩展支持加载远程图片的方法 先通过本地配置文件，提供图片的名称、地址等信息，代替服务器端。\n新建一个文件：\n新增网络依赖库：\n知识点：文件解析方式，swiftUI 数据层交互方式，网络访问方式，响应式开发。\n最佳的版本控制方案：创建 SPM 私库并维护版本管理 创建 SPM 私库，分装远程加载图片为工具库通过 xcode \u0026ndash; new 菜单 \u0026ndash; SPM 库\n主要了解 Package.swift 文件中的属性配置，通过 spm 来管理 iOS 私库。让后共享给项目中使用。\n猜想：肯定支持创建 iOS 项目，既然支持针对库的 target，通过 SPM 是否可以创建或维护 iOS 项目。\n发布私库\n主要是 xcode 中版本管理，\n更新图片加载工具，更新发布新版本 版本号约定：major.minor.patch\nmajor:重大变更，例如修改旧接口，影响老功能的改版\nminor:小型变更，例如，新增功能接口\npatch：修改 bug 变更\n添加依赖库：xcode \u0026ndash; file 菜单 \u0026ndash; SPM \u0026ndash; add SPM 库\n更新依赖库：xcode \u0026ndash; file 菜单 \u0026ndash; SPM \u0026ndash; 更新到最新版本\n","date":"2021-11-26T12:02:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/swift%E9%9A%8F%E6%9C%BA%E7%AC%94%E7%BB%83%E4%B9%A0%E9%A2%98/","section":"post","tags":null,"title":"Swift随机笔项目练习"},{"categories":["解决方案"],"contents":"A1:追问和反思经验 小米路由器R1D一代，已经吃灰了很久，之前使用过MixBox工具箱，实现zerotier跨局域网访问，ssr工具订阅功能，随着mixbox不再更新，很多功能已经无法使用。\n在后来，路由器死机频率增大，需要经常刷机重置系统，获取ssh权限。还有网线接口不稳定，几次催促房东大叔帮忙维修，都不了了之。\n之后上网只能通过房东wifi上网，可怕时，在房东wifi局域网里，几台设备竟然无法通过ssh相互链接。\n以上算是对之前的吐槽吧。\n前几周元宇宙特别感兴趣，逐渐被各种博主种草了 oculus quest2 ，在查看了各种攻略从亚马逊海外购入手了一款128G VR 头显，注定要重新器在第一次海外购的焦急等待中，开始怀疑是好奇驱使剁手的冲动。\n在亚马逊海外购购买oculus quest2 是怎么一个历程，在双十一预售开始前两天，就已经抑制不住剁手了，网上说入手oc没必要等双十一，海外购不会参与双十一优惠折扣。\n这个想法助长了剁手的疯狂，紧接着，第二天就开始了双十一预售活动，浮动在10~40元不等，最高一浮动是日区，直接降价40元，加上海关运费比美区少了小100元，这个折扣也是妥妥的诱人。\n随着第一波打击，不仅懊悔，太年轻，怎没再忍两天，哪怕一天呢。一时想不开，大清早，定八点一刻闹钟，向客服沟通退货的事，她们者客客气气的说，等收到货之后，才能发起退货，无理由退货需要承担两百多元的海关税。\n想想高额的关税，忍气吞声了。这还没有体验VR 的神奇，就已经开始受气的心态，会导致第一次体验大打折扣。\n该怎么提高兴致，让自己真正的享受VR 生活。\n开发：\n因为是程序员，起初的意愿是使用现有的技术学习VR 开发，经过一番百度，了解到VR 虚拟现实，依赖的开发环境，对于iOS 开发者完全不匹配。\nVR 系统是android, 开发依赖3U IDE ，不同设备商家有自己的SDK，对一串的新知识，新技能的有了比较全面的认知之后，结合iOS 主推的开发方向是增强现实、机器学习、人工智能等技术的方向。\nVR 开发领域，除了游戏，开发价值并不大。\n游戏：本来购买的意愿\n再进一步挖掘VR 的作用，只能作为游戏主机，让生活增添一些光彩。\n是什么念头改变了我对VR 的看法，应该是九月份对三体图书的迷恋，通过VR 模拟三体世界的体验，通过设备真切的感受，潜意识对虚拟世界的渴望，虚拟世界可以更加直接呈现精神世界，能够从真切体验不同场景，世界，扩展自己的眼界，增长见闻，丰富精神生活。\n在十月之前，脑子中只有对生活的恐惧，到处是计划，效率，高效能等内卷的生活包围着，人就像机器，想象力都是那么晦涩，思考方式都是整齐画一，内心压抑着各种情绪，无从倾诉发泄。\n在十一游玩之后，没有再循规蹈矩的计划生活，而是行动起来了，走出来了。虽然猝不及防，虽然阴雨连连，还是那么不善交际，但是生活好像重新有了色彩，苛求变得温柔，焦虑也有了动力，重新有了随心轻松的感觉，看到了长假应该有的样子。\n在想象力再次回归时，便有了三体潜意识的种子，有了元宇宙和VR 的联系。我是想记住这种假期体验，体验长城，老胡同，展厅，展馆，有烟火气，能激发想象力的东西。疫情原因导致很多线下实体已经很难搜寻。转念为何不去三体世界，将想象力放大到科技领域呢。\n在高效能的道路上积压的目标和任务，愿景和原则，一下子都真实起来。看到了\n视频\n电影院 VR\nI: 分析和整理信息知识点 激活VR 头显的方法，facebook steam 升级 shellclash\nA2:内化应用知识，谱写愿景 要事第一，制定下一步行动 ","date":"2021-11-23T15:22:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/shellclash%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","section":"post","tags":null,"title":"期待VR改变枯燥的生活"},{"categories":["解决方案"],"contents":"A1:追问和反思经验 在梳理项目中老模块时，发现代码维护经手人不同的编码风格，出现功能和代码目录结构无法匹配，在缺少文档情况下，想着手整理项目结构，需要做哪些努力？目前方案是按MVC基础模型来整理目录结构，将控制器，视图，模型，整合在一起，让功能和代码更加清晰可见。如何做到代码整合，需要知道代码之间的依赖关系，即类之间通过import相互引用的关系，通过这套关系整理类结构的以来。想到的是获取类之间的以来关系，\nI: 分析和整理信息知识点 通过objc工具生成类似管理卡片的工具\nA2:内化应用知识，谱写愿景 在实际开发项目中，通过objc工具统计代码设计的合理性，有助于复盘开发设计。\n要事第一，制定下一步行动 objc-dependency-visualizer\nDrafter\n样例：Objc-dependency-visualizer\nobjc生成类依赖关系图的操作步骤：\n是否支持workspace 管理下的项目。\n如何对一个目录下的类生成类依赖图谱\n帮助命令 通过帮助命令，理解支持的功能和生成依赖所需的资源。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 $ ./generate-objc-dependencies-to-json.rb -h Usage: objc_dependency_tree_generator [options] General options: -p, --path PATH Path to directory where are your .o files were placed by the compiler -D DERIVED_DATA Path to directory where DerivedData is -s PROJECT_NAME Search project .o files by specified project name -t, --target TARGET_NAME Target of project -e PREFIXES Prefixes of classes those will be exсluded from visualization. NS|UI UI|CA|MF -d, --use-dwarf-info Use DWARF Information also -w, --swift-dependencies Generate swift project dependencies -k FILENAME Generate dependencies from source kitten output (json) --ast-file FILENAME Generate dependencies from the swift ast dump output (ast) --ast-show-parsed-tree Show ast parsing info (for swift ast parser only) --inheritance-only Show only inheritance dependencies -f FORMAT Output format. json by default. Possible values are [dot|json-pretty|json|json-var|yaml] -o, --output OUTPUT_FILE target of output Common options: -h Prints this help 脚本依赖 .o 文件，在生成类图依赖时，需要先编译源码，生成 .o 文件。\n脚本默认先从 -D 指向的Xcode编译的DeriveData 目录中，查找build 的项目的 .o 文件。\n在特殊的情况下，可以通过 -p 指向特殊的 .o 目录位置，然后生成依赖。\n即生成类图依赖图主要依赖 .o 文件，知道这个原理之后，才能正确的理解命令的使用方法。\n命令支持更多的方式：使用手册 project 名称：（\u0026quot;\u0026quot;）表示匹配任何字符串的最新项目\n1 ./generate-objc-dependencies-to-json.rb -d -s \u0026#34;\u0026#34; \u0026gt; origin.js ; open index.html 在不指明生成哪个项目时，如 -s \u0026quot;\u0026quot; ，脚本默认对Xcode最后一次编译的项目作用。\n例如，如下生成命令，和输入日志：\n1 2 3 4 5 6 7 8 9 ./generate-objc-dependencies-to-json.rb -d -s \u0026#34;\u0026#34; 日志输入： find: /Users/boyer/Library/Caches/appCode*/DerivedData: No such file or directory There were 208 directories found Last modifications were in /Users/boyer/Library/Developer/Xcode/DerivedData/ObjcDepVisuTest-xxxxxtn/Build/Intermediates.noindex/ObjcDepVisuTest.build/Debug-iphonesimulator/ObjcDepVisuTest.build/Objects-normal/x86_64 directory at 2021-11-04 17:01:43 +0800 项目名称中包含任何内容（\u0026quot;\u0026quot;）的最新 Swift 项目 从传递的 SourceKitten 文档输出中解析并显示图形 从 Swift AST 转储输出解析并显示图形 项目名称以“PR”开头的最新项目依赖项 从目标文件 从多个目录中的目标文件 来自名为“X”的项目的特定目标“T” 来自名为“X”的项目的特定目标“T1”和“T2” 来自项目名称为“X”的特定子项目“S1”和“S2” 下载脚本文件 执行生成图谱脚本 通过 .o(object) 文件生成依赖图谱\n通过编译目录\n通过源码目录\n","date":"2021-11-23T15:17:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E4%BD%BF%E7%94%A8%E5%B7%A5%E5%85%B7%E7%94%9F%E6%88%90%E7%B1%BB%E4%BE%9D%E8%B5%96%E8%8A%82%E7%82%B9%E5%9B%BE/","section":"post","tags":null,"title":"通过源码文件生成类之间的依赖图"},{"categories":["学习笔记"],"contents":" \u0026#30446;\u0026#24405; 愿景 A1:追问和反思经验 I: 分析和整理信息 A2:内化和应用知识 谱写愿景 入门 愿景 A1:追问和反思经验 想通过打击垫来抒发情感，通过音乐来激发创造的乐趣，把生活过得更有意义和多彩。\nI: 分析和整理信息 想再短时间内掌握打击垫的用法，挑战自己的学习能力，和知识整理，搭建未知领域的知识体系，需要付出哪些，考验自我管理的方法，验证是否能够把一件事情有始有终的做到满意。\nA2:内化和应用知识 通过新奇的东西来激发灵感，反思锻炼个人的创造力，改变思维模式，生活是多样丰富的，相信自己在自我管理上可以有收获。\n谱写愿景 B站六节课程，想从基础的看，指定一个学习计划，丰富知识领域，创造一个可能性。\n入门 第一章：设置你的Launchpad\n连接midi设备\n第一次使用主要设置audio, 指定音频的输入／输出的设备名称。\n如果你的设备是lanuchPad, Live会自动自动检测lanuchPad, 并链接。\n新建项目\n快捷键： CMD + N\n切换轨道布局： Tab\n项目初始化，默认有四个轨道：两个MIDI轨道、两个声音轨道，由于两个声音轨道一般在最后导入音频时，才会用到。在demo 中演示中，仅对MIDI 两个轨道讲解。\n删除两个声音轨道，对两个MIDI 轨道做基本链接和采集设置。\n设置MIDI\n两个MIDI 轨道职责不一样，可以分为主轨道和辅助轨道。\n主MIDI(master)轨道：在live 的职责主要来收集和响应 lanuchPad ，其他辅助轨道，以此轨道的信息，作出辅助响应。 它主要收集lanuchPad 的信息，他的输入类型 auto,\n辅助轨道： 例如：配合主MIDI信息，来控制反应lanuchPad灯光效果的轨道，可以称为灯光辅助轨道。所以他的作用主要辅助作用，输出必须设置为 in 类型。\n例如：在 demo 中的两个轨道名称分别为：，Sample样例轨道和灯光轨道\n在轨道中添加收集器和处理器\n主要对Sample 轨道做说明：\n添加instrumentRack采集器\n在收藏夹中，选中乐器\u0026ndash; instrumentRack \u0026ndash; 选中，拖动到Sample轨道上，在底部就可以看到一个空的采集器。\n采集DrumRack 鼓组\n在收藏夹中，选中 鼓 \u0026ndash; DrumRack \u0026ndash; 选中，拖动到刚才新建的采集器中，这样就可以收集DrumRack相关信息。\n其他信息类似\n保存项目。\n","date":"2021-11-23T15:14:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/lanuchPad%E5%85%A5%E9%97%A8%E7%AC%94%E8%AE%B0/","section":"post","tags":null,"title":"lanuchPad入门教程笔记"},{"categories":["学习笔记"],"contents":" \u0026#30446;\u0026#24405; 目的 成本和价格 豆子库存 库存自动化管理的方法 目的 成本和价格 成本cost（ {} ）：当你买入一支股票的时候，每股所花的钱即是成本，表示方法： {}。\n价格price（ @: 单价 @@: 总价 ）：我们通常把某支股票的市场价（market price）称为它的价格。\n盈亏（PnL）：cost 和 price 在那一瞬间是相等的，在那之后，cost 不变，price 有涨有跌；在卖出时，cost 和 price的差价，就是每股的盈亏（PnL）。\n豆子库存 每一个豆子，在买入时，会指定豆子的种类和三个标签（成本、日期、备注），用来描述豆子的唯一特性。\n例如下面，两次买入的豆子的语法：\n1 2 7 AMZN {1000.00 USD, 2017-01-14} 5 AMZN {1575.39 USD, 2019-01-04} 当卖豆子时，也必须通过种类或三个标签，指定要卖出哪些豆子。\n例如：4 AMZN {1000.00 USD}\n库存自动化管理的方法 对于 held at cost 的证券，Beancount 提供了 5 种簿记方法：\nSTRICT：每次取豆子时，必须要明确匹配到某个 lot，不允许模糊匹配（例外是 {}，代表全部取出）。这也是默认的模式。 FIFO：即先进先出（First-In, First-Out），每次取豆子时自动从最老的豆子开始取，直到取光。 LIFO：即后进先出（Last-In, First-Out），与 FIFO 相反，最新的豆子优先被取出。 AVERAGE：每次重新计算 cost basis。该方法暂未实现。 NONE：完全不合并，允许不同符号的 lot 同时存在。 比如你可以改用 FIFO 簿记方法：\n1 1970-01-01 open Assets:Trade:Positions \u0026#34;FIFO\u0026#34; 在使用 FIFO 簿记方法之后，你只需要写 -4 AMZN {}，Beancount 就会自动取出最老的 4 颗豆子。\n盈亏受5 种方法的影响：\n假设今天 AMZN 的价格是 1300 USD，你希望卖出 4 颗豆子。如果你选择按 FIFO 卖出标签为 {1000.00 USD, 2017-01-14} 的豆子，那么你的 PnL 是盈利 1200.00 USD；如果你选择按 LIFO 卖出标签为 {1575.39 USD, 2019-01-04} 的豆子，那么你的 PnL 是亏损 1101.56 USD。同样一笔交易，按不同的簿记方法，一个是盈利，一个是亏损！\n谁会来关心你的 PnL 呢？除了你自己，当然是税务局了。比如 IRS 就是用 FIFO 的方式来计算 PnL 并据此征税的。对于投资者来说，盈利的话要缴税，亏损的话可以抵税；长期持有的股票卖出时所得税率低，短期持有的股票卖出时所得税率高——只有使用规范的 PnL 计算方法，才能算出正确的税务数据。\n","date":"2021-11-23T15:14:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/bean%E8%AE%B0%E5%BD%95%E8%AF%81%E5%88%B8%E7%9A%84%E6%96%B9%E6%B3%95/","section":"post","tags":null,"title":"使用beancount记录证券投资"},{"categories":["博客站务"],"contents":" \u0026#30446;\u0026#24405; 目的 目的 从博客分类吸收经验第四次博客文章分类调整 - 憧憬少的个人博客 从roam卡片管理 吸收经验 玩转 Obsidian | 打造知识循环利器 - 少数派 从拆为己用中，总结要领，形成自己的知识体系的架构\n拆为己用搭建自己的知识体系作为博客的中心思想，结合博客管理的两种分类法和卡片管理法，实现知识循环利用的目的。\n博客管理方式时，主要通过 分类 ， 标签 两种属性实现知识管理。\n卡片方式，是以知识为核心，采用卡片的三元素来管理只是碎片的， 主题 ， 目标 ， 场景\n","date":"2021-11-23T15:07:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/%E6%90%AD%E5%BB%BA%E7%9F%A5%E8%AF%86%E4%BD%93%E7%B3%BB%E7%9A%84%E5%8E%9F%E5%88%99%E5%92%8C%E8%A7%84%E8%8C%83/","section":"post","tags":null,"title":"搭建知识体系的原则规范"},{"categories":["我的思维"],"contents":" \u0026#30446;\u0026#24405; 时间管理 agenda 项目管理 todo 目标管理 使命宣言 愿景 知识体系管理 博客管理 ox-hugo DONE 使用tj3 制定周计划培养七习知识体系 目的 项目管理提升效率 安装使用 熟悉 Taskjuggler 问题 实战 使用plantuml梳理emacs体系 Doom自力更生\n想要掌控人生，要有工具和思想的支持。现在缺乏的是熟练，记忆。很多原则在总结之后，没有很好的实践。实践的前提是熟练记忆。如何把原则和宣言刻在骨子里，能在生活中警示自己的行为。就要有一套值得信任的工具，监控复盘自己的行为。\n我现在要确定两个目标：管理人生的工具的搭建，并严格执行工具中的法则。改善生活。有两个途径： 管理人生的工具，emacs学习使用。agenda的时间管理。\n管理人生工具使用两个小时来学习。 总结agenda视图和相关操作方法。hugo博客的标签分类要理解他们的应用场景，在这些基础上搭建自己的知识体系。\n知识体系可以改变人的思维方式，然后，改变人的态度，行为和习惯。\n现在的困境是是什么？\n做事情没有目的性，盲目徒劳之后，不到接下来会改变什么。容易忘记在做的事情，专注力太差，要提高专注力，一件事情要做好，并改变自己的目的。\n现在非常在意管理工具。 agenda的视图，统计视图的使用方法。 可以通过官方文档来学习。之前接触orgmode有很棒的文档，可以细读提炼，定制适用自己的视图。在发起这个想法同时，对hugo博客的分类非常失望。之前总结过capture工具的使用。做了详细的博客，但是它回顾的频率非常低，导致这种原因，我联想不起来它的上下关系，穿不起来该有的知识体系。现在就以emacs知识体系为实例，通过这个实例优化hugo分类机制。 emacs 是什么？它的那几部分功能吸引了你，最想掌握的知识点是什么，正在使用的功能有哪些，它是否改变了生活习惯？ emacs 是一个编辑工具，也是一个编辑引擎，基于这点，又大批优秀的工具备受欢迎。\n我比较喜欢的功能又几个：org-mode, 它能够记录任务状态，让文本支持树形结构和折叠功能。还有对hugo支持，可以自动把日常的文本导出为博客，分享经验非常的方便。还有agenda 时间管理工具的。\n现在亟待解决的几个问题：\n明确对应工具的愿景，具体要改变的行为。 时间管理 agenda 项目管理 todo 目标管理 使命宣言 愿景 知识体系管理 博客管理 ox-hugo DONE 使用tj3 制定周计划培养七习知识体系 目的 在学习tj3 过程中，考虑到是针对项目管理才会用到的技巧，学习中途搁置，没有产生归档文档。\n本次，受到亿学堂课程计划和七个习惯周计划的思想中启发到：\n长期困扰的无法坚持阅读的原因是什么？\n在培养七习的过程中，效率低，无法在生活中实践的原因是什么？\n在拆为己用学习中，吃的苦头，到头来，很少在阅读中实战，为什么带来的更多的是焦虑？\n在知识体系搭建的思想萌发，到现在举步维艰，是什么绑架了执行力？\n以上这些问题，都在折磨着，坠入了无法挣脱的困境。\n过程做了很多反思，总的来说，在理论、感慨的表面上做文章，很难从根本上剔除困扰。\n转换思维：\n在亿学堂12 堂课的引导下，重新认识了塑造富人思维的过程，它短期课程的安排，进度计划，可以在繁忙的工作中，点亮很多人学习的欲望，它的亮点在哪里？\n仔细分析对比，它是执行了以终为始，要事第一，激发了群众的积极主动的学习动力，它让人看到了成功的希望。\n如何嫁接这种前期的备课技巧，协助在七习中克服伤处几点困惑，这里已经推断出亿学堂的基本逻辑：\n设定目标\u0026ndash; 撰写宣言 \u0026ndash; 制定计划 \u0026ndash; 每日任务 \u0026ndash; 拆为己用 \u0026ndash; 输出感悟 \u0026ndash; 看见更好的自己\n在认识到自己的目的，如何在emacs 中真正的实践制定计划，激发行动力。第一想到的是甘特图，使用tj3 实现项目管理和跟踪的方式，看到每天的努力，看到目标的一步步实践的整个过程的渴望。\n项目管理提升效率 之前学tj3 的初衷是它是uml 甘特图的替代品，也是agenda 视图实现任务可视化管理工具。没有深刻认识到tj3项目管理的优点不止这些： TaskJuggler - A Free and Open Source Project Management Software - About Task\u0026hellip;\nTaskJuggler是一款现代、强大、开源的项目管理工具。和常用的甘特图编辑工具相比，新的 项目规划 和 跟踪方法 更灵活，更优越。 它适用于从开始的一个想法到项目完成的整个过程。即在项目范围、资源分配、成本和收入规划；风险管理和通信管理方面有有很好的实践方式。 tj3提供了一套优秀的项目计划功能，会根据项目大纲和你提供的约束，计算项目时间线和资源分配。 内置资源平衡器和一致性检查器，如果项目出现问题，将会卸载你不必担心的详细信息。 灵活的as-many-details-as-necessary方法允许你在开始时规划项目，使它的对于新的管理策略( 如极限编程和敏捷项目管理) 也非常理想。 Exporting Gantt charts with Taskjuggler v3 (tj3)\n使用Org-mode和TaskJuggler管理项目信息\n使用Org-mode + taskjuggler进行项目管理 | Z.Y. ☯ Cosmos\nPlanning with Org-Mode and Taskjuggler - New York Stag Hunts\n安装使用 tj3 和 plantuml 对比之前学习过plantuml 建模，搜集了很多便于编写uml 的代码快，在emacs 中编写，预览，同时集成到hugo 文章中一气呵成。\nplantuml 也提供了一套gantt 图的绘制支持，有一套语法需要标记任务开始，结束，下一项，里程碑的注脚语法。用起来虽然方便，但是和实际的任务进度跟踪不是很好，想实现任务计划便于实时的状态同步到甘特图上是比较费事的。\n有了tj3的支持，它提供了从org 中导出图，方便更新进度。\n创建一个学习博客，记录学习过程，包括环境搭建，语法使用，导出操作\n导出到hugo目录中，实现在hugo中预览进度\n创建博客记录tj3 的使用方法。\n安装 gem install --local taskjuggler\n安装终端之后，重新启动emacs, 执行导出操作时，会显示taskjuggler 选项。\n相关属性可以自定义的当前变量列表： org-taskjuggler-default-global-header org-taskjuggler-default-global-properties org-taskjuggler-default-project-duration org-taskjuggler-default-project-version org-taskjuggler-default-reports: 设置要使用的报告文件。这可以以文本格式写入（如设置为完整报告文本字符串的变量），或（可能更容易）.tji写入包含报告定义的文件。 org-taskjuggler-extension org-taskjuggler-final-hook org-taskjuggler-keep-project-as-task org-taskjuggler-process-command org-taskjuggler-project-tag org-taskjuggler-report-tag org-taskjuggler-reports-directory org-taskjuggler-resource-tag org-taskjuggler-target-version: 应该设置为命令的输出tj3 \u0026ndash;version，例如(setq org-taskjuggler-target-version 3.4) org-taskjuggler-valid-report-attributes org-taskjuggler-valid-resource-attributes org-taskjuggler-valid-task-attributes\n接下来就是学习任务属性，当加入到task 属性，就可以很方便的支持task 导出。\n熟悉 Taskjuggler tj3 项目的组成的部分 项目的基本信息：（开始日期、持续时间 ( +4m)、日期/时间语法、时区等） 帐号：Accounts （如果您不跟踪财务，则不适用） 可用资源：resource 包含工资、假期、工作时间/天信息等。 里程碑：Top level milestones 任务：Tasks, 按项目主要组成，分解为可执行的任务 报告：可定义的报告 常用设置 定义任务时间 start、end、depends、maxstart和maxend start\n定义任务持续时间 Effort、duration、length\nduration: 指定任务应该持续的时间。这是日历时间，不是工作时间。7d 表示一周。\n如果指定了资源，则在可用时分配它们。资源的可用性对任务的持续时间没有影响。它将始终是指定的持续时间。\n如果使用此属性，任务可能没有子任务。设置此属性将重置 Effort 和 lenght 属性。\nduration (min | h | d | w | m | y)\nlength : 将此任务的持续时间指定为工作时间，而不是日历时间。7d 表示 7 个工作日，或 7 次 8 小时（假设默认设置），而不是一周。\n具有长度规范的任务可能具有资源分配。资源在可用时分配。不能保证任务将获得分配的任何资源。资源的可用性对任务的持续时间没有影响。\n如果没有全球假期，那么没有指定资源可用的时间段仍被视为工作时间，并且相应地定义了全球工作时间。\n对于长度计算，除非任务已分配班次，否则全局工作时间和全局休假很重要。在后一种情况下，轮班的工作时间和假期适用于指定的时间段，以确定某个时段是否为工作时间。如果资源定义了额外的工作时间，则长度为 5d 的任务很可能会分配超过 40 小时的工作量。资源工作时间仅影响是否为特定时间段进行分配。它们不会影响任务的最终持续时间。\n如果使用此属性，任务可能没有子任务。设置此属性将重置 duration~、~Effort 和 milestone 属性。\nlength (min | h | d | w | m | y)\nEffort : 指定完成任务所需的工作量。 Effort: 6d （6资源天）可与2专职资源情况下，在3个工作日内完成。\n需要至少一个定义并分配给任务的资源，并将使用他的/她可用的工作时间/天，以确定任务需要多长时间。\n在分配的资源贡献了指定的工作量之前，任务不会完成。因此，任务的持续时间将取决于所分配资源的可用性。指定的 Effort值 必须至少与 timingresolution 一样大。\n警告：在几乎所有现实世界的项目中， Effort 并不是时间和资源的产物。仅当可以在不增加任何开销的情况下对任务进行分区时，这才是正确的。有关这方面的更多信息，请阅读Frederick P. Brooks, Jr. 的The Mythical Man-Month。\n如果使用此属性，任务可能没有子任务。设置此属性将重置 duration 持续时间和 length 长度属性。具有 Effort值 的任务不能成为里程碑。\neffort (min | h | d | w | m | y)\n定义依赖有多种方法可以定义任务之间的依赖关系。当来自 Org 模式背景时，您可能希望使用 Org 模式提供的工具来定义它们，它们是\nORDERED ： 该ORDERED属性允许您声明子任务必须按照它们出现的顺序完成（最上面在前）。 BLOCKER ： 允许您声明任务依赖于以下任一者的属性 值为 previous-sibling 时，依赖上一个item 的task 对象 值为某个任务的task_id 时，依赖对应的task depends ：定义在指定的任务完成之前不能启动任务，通过指定task_id 确定依赖关系。 其他汇总\ntj3 定义一个任务的几个属性，任务名称，任务Id,任务依赖，任务评估时长，开始，结束时间等：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 * TODO %^{Project name} [0%] :taskjuggler_project: DEADLINE: %^t :PROPERTIES: :CREATED: %U :task_id: :ORDERED: 任务关联 :Effort: ; 评估工作量 表示需要的工作时，而不是日历时 :BLOCKER: ; 前置工作 :efficiency: ;表示资源的效率，默认1.0。设置举例：如果一个人顶三个，则设置为3.0即可 :priority: ;任务优先级，0~1000之间的整数，如果资源数小于当时需要被配置的任务数时，则根据优先级自己安排 :limits: ; 最大工作时间 :leaves: ; leaves 请假 :allocate: ; 角色分配 :resource_id: ; 资源id :depends: 前置任务 :rate: 费率 :duration: 持续时间 :END: %^{OUTCOME}p %? ** Milestones Taskjuggler 语法到 Org-mode 的映射 如果您熟悉 Taskjuggler，那么了解 Taskjuggler 语法如何映射到 Org-mode 可能会有所帮助。这是通过属性Property Syntax (The Org Manual) 完成的，这是属性适用的标题下方的一个简单的键值对。\n大部分实际的 Taskjuggler 项目由task组成，这些task可以被赋予各种属性。可以在 tj3 手册的task 语法 规范中查看允许属性的完整列表。\nTaskjuggler 中的任务可能如下所示： 1 2 3 4 task entry_door \u0026#34;Install entry door\u0026#34; { depends buy_door effort 4h } 在此示例中， task 将以下文本定义为 Taskjuggler 编译的任务。 entry_door 是任务的 ID，它在当前子树中必须是唯一的。引号内 \u0026quot;Install entry door\u0026quot; 作为报告中的任务名称。\n此任务有两个属性： depends 和 effort 。在此示例中， entry_door 依赖于另一个任务 ， buy_door 估计所需的工作量是 4 小时。\n在 Org 模式下，等效的任务会像这样创建：\n1 2 3 4 5 6 * Install entry door :PROPERTIES: :task_id: entry_door :depends: buy_door :Effort: 4h :END: 一些属性可以通过两种方法设置。例如，任务的开始可以由 SCHEDULED 标签或 :start: 属性定义；以下是等效的：\n1 2 3 4 5 6 7 * Install entry door SCHEDULED: \u0026lt;2013-07-15 Mon\u0026gt; * Install entry door :PROPERTIES: :start: 2013-07-15 :END: 同样 DEADLINE 时间戳和 :end: 属性函数的方式相同。\n设计一个场景来计划下任务：\n比如这周，要完成及件事情，练习使用tj3 方式跟踪任务。同时考虑是否需要建立模板来快速创建tj3 任务。先看下任务和tj3 之间的差异。\n问题 导出时，需要设置为buffer 模式下导出，才能够显示全部任务状态。 属性不确定很大，不适合创建snippets 模板，不建议使用模板或代码块。 要想计划一周的任务还需要进一步熟悉tj3 的用法，熟练分析任务进度，提高习惯培养的积极性 支持指定忽略tag: :EXPORT_EXCLUDE_TAGS: ignore noexport 实战问题 有子任务时，不要在该节点添加effort 属性 在tj3 一级节点上，不要添加ordered 代替方案：使用节点中的blocked 属性控制依赖，显示甘特图上的顺序 在二级节点上，直接开启ordered ，有助于子任务的排序显示 当声明了tj3_resource 资源之后，导出会提示失败。需要在task 任务中关联资源之后，再次导出就正常了。 甘特图和资源图 \u0026ndash; 精确到周、日、小时的设置方式 taskreport 字段中 设置 chart 实战次序 先定里程碑 分解任务 处理依赖关系 确定里程碑 在评估工作量 声明资源 分配资源 实战 项目的基础信息 设置项目周期：project-duration\n设置项目标识： project-tag\n重写项目基础信息的函数： org-taskjuggler--build-project\n添加 actual 基准支持 扩展字段 电话 重写task 任务信息函数 org-taskjuggler--build-task 增加解析actual 字段代码\n1 (actual (org-element-property :ACTUAL task)) 在tjp 中增加actrual 字段\n1 (and actual (format \u0026#34; actual:%s\\n\u0026#34; actual)) 效果如下：\n1 2 3 4 5 6 7 ** 编写金和项目 :PROPERTIES: :task_id: jinher :allocate: dev :Effort: 1d :actual: effort 1d start 2021-09-17 :END: 导出tj3 之后的格式：\n1 2 3 4 5 6 7 task jinher \u0026#34;编写金和项目\u0026#34; { depends !swiftUI purge allocate allocate dev effort 1d actual:effort 1d start 2021-09-17 } 新增列 费用 、 收入 在 org-taskjuggler-default-global-properties 中添加\n1 2 3 account cost \\\u0026#34;费用\\\u0026#34; account revenue \\\u0026#34;收入\\\u0026#34; balance cost revenue 导入报告模板\n1 (setq org-taskjuggler-default-reports \u0026#39;(\u0026#34;include \\\u0026#34;reports.tji\\\u0026#34;\u0026#34;)) 定制报告信息在 reports.tji 中查看语法\n在org 中无法制定输出目录，支持tj3 命令行。可以在发布时，使用tj3 命令，借助 ourtputdir 辅助更新相应的项目。 :outputdir: \u0026quot;/Users/boyer/reports/\u0026quot; 仅在命令行时有效。\n替代方案：通过el 命令，指定目录\n1 2 (make-directory \u0026#34;~/reports/七个习惯\u0026#34;) (setq org-taskjuggler-reports-directory \u0026#34;~/reports/七个习惯\u0026#34;) task_id 不能以数字开头\ncomplate 跟踪task状态：仅支持DONE/TODO 状态，它仅用于回报信息，不会更新分配、剩余任务等信息。 Day_To_Day_Juggling\n设置里程碑和第一个task任务的依赖关系。设里程碑过程，需要注意第一个flag 应该被设置为起始任务，task_id 设置为start ，第一个模块依赖这个flag, 后续flag 模块一次依赖为：blocker:previous-sibling 即可。\n使用journalentry设置日志 :journalentry: 2021-09-09 \u0026ldquo;设定任务标题头部\u0026rdquo; {alert red summary \u0026ldquo;事件\u0026rdquo;}\n使用tracereport新增scrum燃尽图 Scrum Example Project - Product Burndown\ntracereport\n设置project 的 task_id 为 project\n在 report.tji 添加 tracereport burndown 模块。\n1 2 3 4 5 6 7 8 tracereport burndown \u0026#34;burndown\u0026#34; { headline \u0026#34;燃尽图\u0026#34; sorttasks id.up width 1000 columns opentasks # columns end { title \u0026#34;\u0026lt;-name-\u0026gt;\u0026#34; } hidetask plan.id != \u0026#34;project\u0026#34; } 设置导出命令，支持跟踪功能\n1 (setq org-taskjuggler-process-command \u0026#34;tj3 --add-trace --no-color --output-dir %o %f\u0026#34;) 实例赏析 新产品上市计划 - 项目综述 七个习惯学习计划 - 项目综述\n","date":"2021-11-23T15:05:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/emacs%E7%AE%A1%E7%90%86%E5%AD%A6/","section":"post","tags":null,"title":"emacs-管理学 [0/1]"},{"categories":["我的思维"],"contents":" State \u0026ldquo;CANCEL\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; \u0026lt;2021-11-23 周二 15:00\u0026gt; 前言 IT 编程开发近十年从业经验,一切效率为王,深受面向对象的 封装 、 继承 、 多态 编程思想的影响,代码层追求着复用性,扩展性和健壮性的原则,在代码管理上也接触了众多效率系统和软件工具,为了追究高效能付出了很多,但是在生活中不一定是一个高效能的人. 大概是工作原因,我性格逐渐变成了一个有着浓厚的理想主义人格的人.在做一件事之前,要先搞一通高效能方法论,预设一些场景,来设计编排一些事无巨细的计划,支持接下来的每一步工作,渴望每一步都做到不差分毫的稳准狠.拥有这种理想主义性格的人,一般都对生活充斥着不满,对社会不甘随波逐流,在事业上,十有八九都会不顺心,常常要承受不被理解的无奈.被朋友疏远,被同事排挤,被家庭嫌弃一事无成. 带着对高效能追求的偏执,在孤独的道路上越走越远,希望得到志同道合的朋友指点,但是知己难寻;希望能从书中克服心理障碍,革命效能,改变自己的生活. 几年前,在豆瓣上碰到了《高效能人士的七个习惯》一本书,众星捧月的评论,评分和销量的趋势下,阅读了对人性的解刨和习惯的定义,七个习惯的深刻讲义.无不在拨动着压抑很久的高效能的野心.初次见面确实找到高效的全新认知.由于之前不求甚解的读书习惯,在读读感动之后,拆解了章节做成了脑图;针对每个习惯之后的练习题,做了精美的问答调查卷的形式,意在可以定义填写练习,来检查七个习惯的成熟度.做了这么多,课后练习和总结.也难免被生活的琐碎和工作的压力,埋葬在尘埃里. 在经历这次不了了之的失败之后,开始探索 GTD 工具上的管理,期间遇到 org-mode 管理系统,花费了大量的精力开始学习 emacs,想通过 org-mode 强大的 agenda,capture 工具来提高效能.在 emacs 的付出的心血,超出了我的预想,从学习 spaces 到 doom 主题,从 org-mode 到全方位的 IDE 兼容 python/swift/oc 语言,有学习 roam 系统,plantuml 建模工具,等等.在熟练掌握之后,技巧工具对效能的提升微乎其微,苦苦练习培养时间管理也无法发挥 org-mode 系统强大的威力.意识到一切都在漫无目的的野蛮生长,完全偏离了最初的高效能期望. 终于在一次参加 CMMI 培训之后,对职业生涯的还是回归了七习的原点上,接触了在线樊登听书,学习了赵周老师拆为己用的便签法,构建知识体系的便签法,从思维层面的谆谆善诱的系统讲解,到《书这样读就够了》的研读,一步步构建自己的知识体系的理念,映入大脑,再结合《高效能人士的七个习惯》的解读,更加契合了理想主义人格的思想工具化,习惯案例化的培养,潜心研究学习,希望能够从两本书中,逐步提炼出适合自己的偏执爱好的学习方式.\n目的 对于一本书,一万个读者,有一万种思想.自己对两本抱有期望,希望一段时间的积累实践,能总结出一套便捷可靠,即插即用的操作流程,直面生活,改变生活. 在生活中遭遇到各种挑战时,能够拿起七习的盾牌,来保护一个中年人的尊严.中年人的世界,一句话的崩塌.\n生活中常面对的挑战 在一个习惯养成都会面临一些挑战,以下总结下经常干扰生活节奏,造成方向迷失的几种挑战.\n盲目目的的忙碌, 习惯的惯性,想养成一种好习惯,总要摆脱不好的行为,这种是正常现象,要敢于承认惯性的存在,才能保证积极理性,不要因为惯性就否定了之前的付出努力,要坚定目标信念. 情感压力/家庭压力/工作压力产生的焦虑,在生活中经常面临各种压力,要想克服这种挑战,必须在压力源治理,在这些方面要做出实际的改变,定下确切的目标,才能丛容面对焦虑,化焦虑为动力. 学习力和知识体系的挑战,面对问题时,没有成熟的解决方案,是经验不足,是知识储备有限,导致问题频频出现,这种挑战需要在各领域有知识体系的概念,培养在不同领域解决问题方案策略. 希望掌握哪些技能战胜挑战 如何面对生活中的挑战,我尝试了很多方式,就像在 前言 中叙述的经历,学习了很多工具和 GTD 理论书籍.现在明确卓见成效的方案是,《高效能人士的七个习惯》结合《这样读书就够了》两本书作为生活指导手册,磨练性格和习惯,为成为高效能人士而努力.\n想从两本书中解决生活中的哪些挑战? 想如何提高书中的习惯和熟练程度? 检查下这两本书是否对生活产生了影响,期望掌握到什么程度,才能发挥更大的作用? 七习的目标:期望七习带给我新的思维方式,希望我的生活是以原则为中心,希望我确定我的影响圈,希望改写人生剧本,希望能够实现第一次创造,希望能自我领导,希望独立思考,有自己的思维方式独立思考.希望有自己的使命宣言,做一个有原则的人,遇到困难时,不被外界因素影响,不受别人影响,自己在陌生场景下,也能保持清醒,积极主动的创造条件,理性决策,掌控局面走向. \u0026gt;要明白一点,七习前期目标时作为高效能人士,在自己的影响圈内,改写人生剧本,撰写使命宣言,以原则为中心,成为高效能人士.\n拆为己用的目标:通过知识,信息,经验三个维度,提升学习力,提高知识储备,重在搭建自己的知识体系,形成自己的思维方式. \u0026gt;两者有本质的区别,一个是为了效能,重在计划改变生活;一个是学习力,重在学习新知识,知识体系的成长和知识储备.\n现在有点急于融会贯通,想结合两者的技能提高效能,是否会混淆两者,导致不伦不类,影响掌握两本书的知识点,对提高效能适得其反.\n先把两本书独立开来看待,串一下两者之前会有什么样的连系,七个习惯个人管理和团队管理的方法论.它的目的是明确目标提高效能.拆为己用是成人学习的方法论,提高学习力和阅读能力的工具.可以用拆为己用的工具快速吸收七个习惯的知识点,并应用到生活中,提升效能.\n策略: 计划决策使用七习;反思复盘,技能提升,知识管理使用拆为己用.\n现在回归生活中的挑战,主要是心态上的调整,重点要发挥七习的潜力.接下来,看如何使用七习来改变生活吧.\n掌握七习提升效能 简述七个习惯: 《高效能人士的七个习惯》七个习惯,它解释了想成为高效能人士,必须具备七个习惯,它遵守生长原则:依赖期,独立期,互赖期三个成熟度来分解了人生的三个阶段. 独立期应具备积极主动,以终为始,要事第一三个习惯. 要想高效的培养三个习惯,必须要先理解一个人对事物的看法,即 思维方式 支配着一个人的一言一行,决定着一个人行为和态度,所以,想改变行为习惯,必须从思维转换着手. 思维转换的力量,如何进行一次思维转换,有一念之间的转换,有付出代价通过反思经验建立新的思维,有的通过读书,搭建知识体系,对一个事物,一个行业等,有全新认知也是一次思维转换.对于一个人可谓是刷新认知,是一场剧烈思想变革.\n以原则为中心的思维方式 知道了思维方式的对态度和行为的潜在影响,那怎么判断思维方式能正向引导行为态度呢.这就需要经历了世人积累下经验智慧和万变不离其宗的精华格言为准绳,来确定正确的原则,以正确的原则为中心的思维方式,才能够真正引导正确方向,带来智慧和安全感,产生源源不断的动力.\n首要习惯:积极主动 一个人只有在自我思维上保持着积极主动的习惯,才能激发四大天赋(自我意识,良知,独立意志,想象力). 积极主动的模式图谱,刺激\u0026ndash;自由选择\u0026ndash;反应.自由选择,即激发人的四大天赋,来做出符合意愿的反应.\n以终为始 以终为始,基于两大基础原则,两次创造,自我领导.做改写人生的剧本的第一次创造者,撰写使命宣言,发挥左右脑,心灵演练,加以确认.\n以终为始展望的是未来.\n使用拆为己用提升学习力 《这样读书就够了》拆为己用,它从读书难的问题说起,它采用了承认读书难的问题,但是从更高层来提高阅读技巧(拆为己用),来提高读书效率,拆为己用主要让读者结合书本是知识点案例,在自己生活中场景再现,更深层的理解书本知识.它给出了拆为己用的具体的实践工具,两种 RIA,AIA 便签法.拆为己用 RIA 便签法解决了从书本中吸收知识,AIA 拆为己用解决了从经验中总结知识的方法.拆为己用的分为信息,知识,经验三种知识形态.它还提供了知识体系搭建的方法,知识管理三个途径,点到面,面到点,经验反思.主动学习.\n借助拆为己用精进七习 现在我两两把本书混为一谈,似乎并不靠谱. 七个习惯,讲的是七个习惯,针对效能提升. 拆为己用,重在知识积累,知识体系的搭建,是形成新的思维方式的一种途径. 如何把思维方式,积极主动,以终为始,要事第一,和 AIA 混为一谈是否会会影响他们独立使用的效率呢. AIA 便签法,说的是经验反思,总结知识点,规划下一步行动在经验反思时,以这种流程来实现反思:现在我把这种分析整理问题方法应用在习惯养成上,A1 即经验反思,是分析问题整理经验的,转换思维的过程,I 知识点总结,则是以终为始,两次创造的过程,谱写愿景和目标.A2 下一步行动,即对应要事第一,我要做什么事情,来实现 I 中的愿景.\n结合自身常遇到哪些挑战:\n这就是我花费几年心血,孜孜不倦想想突破的生活利器,也在改变在自己的原则下,做真正的自己,不受外界影响, 一直想解决在工作和生活中的低劣的效能\n","date":"2021-11-23T15:00:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/%E6%8B%86%E4%B8%BA%E5%B7%B1%E7%94%A8%E5%92%8C%E4%B8%83%E4%B9%A0%E5%8D%8F%E4%BD%9C%E6%8F%90%E9%AB%98%E6%95%88%E8%83%BD%E7%9A%84%E6%96%B9%E6%A1%88/","section":"post","tags":["学习力","效能"],"title":"拆为己用和七习协作提高效能的方案"},{"categories":["我的思维"],"contents":"目的 在学习tj3 过程中，考虑到是针对项目管理才会用到的技巧，学习中途搁置，没有产生归档文档。\n本次，受到亿学堂课程计划和七个习惯周计划的思想中启发到：\n长期困扰的无法坚持阅读的原因是什么？\n在培养七习的过程中，效率低，无法在生活中实践的原因是什么？\n在拆为己用学习中，吃的苦头，到头来，很少在阅读中实战，为什么带来的更多的是焦虑？\n在知识体系搭建的思想萌发，到现在举步维艰，是什么绑架了执行力？\n以上这些问题，都在折磨着，坠入了无法挣脱的困境。\n过程做了很多反思，总的来说，在理论、感慨的表面上做文章，很难从根本上剔除困扰。\n转换思维：\n在亿学堂12 堂课的引导下，重新认识了塑造富人思维的过程，它短期课程的安排，进度计划，可以在繁忙的工作中，点亮很多人学习的欲望，它的亮点在哪里？\n仔细分析对比，它是执行了以终为始，要事第一，激发了群众的积极主动的学习动力，它让人看到了成功的希望。\n如何嫁接这种前期的备课技巧，协助在七习中克服伤处几点困惑，这里已经推断出亿学堂的基本逻辑：\n设定目标\u0026ndash; 撰写宣言 \u0026ndash; 制定计划 \u0026ndash; 每日任务 \u0026ndash; 拆为己用 \u0026ndash; 输出感悟 \u0026ndash; 看见更好的自己\n在认识到自己的目的，如何在emacs 中真正的实践制定计划，激发行动力。第一想到的是甘特图，使用tj3 实现项目管理和跟踪的方式，看到每天的努力，看到目标的一步步实践的整个过程的渴望。\n项目管理提升效率 之前学tj3 的初衷是它是uml 甘特图的替代品，也是agenda 视图实现任务可视化管理工具。没有深刻认识到tj3项目管理的优点不止这些： TaskJuggler - A Free and Open Source Project Management Software - About Task\u0026hellip;\nTaskJuggler是一款现代、强大、开源的项目管理工具。和常用的甘特图编辑工具相比，新的 项目规划 和 跟踪方法 更灵活，更优越。 它适用于从开始的一个想法到项目完成的整个过程。即在项目范围、资源分配、成本和收入规划；风险管理和通信管理方面有有很好的实践方式。 tj3提供了一套优秀的项目计划功能，会根据项目大纲和你提供的约束，计算项目时间线和资源分配。 内置资源平衡器和一致性检查器，如果项目出现问题，将会卸载你不必担心的详细信息。 灵活的as-many-details-as-necessary方法允许你在开始时规划项目，使它的对于新的管理策略( 如极限编程和敏捷项目管理) 也非常理想。 Exporting Gantt charts with Taskjuggler v3 (tj3)\n使用Org-mode和TaskJuggler管理项目信息\n使用Org-mode + taskjuggler进行项目管理 | Z.Y. ☯ Cosmos\nPlanning with Org-Mode and Taskjuggler - New York Stag Hunts\n安装使用 tj3 和 plantuml 对比之前学习过plantuml 建模，搜集了很多便于编写uml 的代码快，在emacs 中编写，预览，同时集成到hugo 文章中一气呵成。\nplantuml 也提供了一套gantt 图的绘制支持，有一套语法需要标记任务开始，结束，下一项，里程碑的注脚语法。用起来虽然方便，但是和实际的任务进度跟踪不是很好，想实现任务计划便于实时的状态同步到甘特图上是比较费事的。\n有了tj3的支持，它提供了从org 中导出图，方便更新进度。\n创建一个学习博客，记录学习过程，包括环境搭建，语法使用，导出操作\n导出到hugo目录中，实现在hugo中预览进度\n创建博客记录`tj3` 的使用方法。\n安装 gem install --local taskjuggler\n安装终端之后，重新启动emacs, 执行导出操作时，会显示taskjuggler 选项。\n相关属性可以自定义的当前变量列表： org-taskjuggler-default-global-header org-taskjuggler-default-global-properties org-taskjuggler-default-project-duration org-taskjuggler-default-project-version org-taskjuggler-default-reports: 设置要使用的报告文件。这可以以文本格式写入（如设置为完整报告文本字符串的变量），或（可能更容易）.tji写入包含报告定义的文件。 org-taskjuggler-extension org-taskjuggler-final-hook org-taskjuggler-keep-project-as-task org-taskjuggler-process-command org-taskjuggler-project-tag org-taskjuggler-report-tag org-taskjuggler-reports-directory org-taskjuggler-resource-tag org-taskjuggler-target-version: 应该设置为命令的输出tj3 \u0026ndash;version，例如(setq org-taskjuggler-target-version 3.4) org-taskjuggler-valid-report-attributes org-taskjuggler-valid-resource-attributes org-taskjuggler-valid-task-attributes\n接下来就是学习任务属性，当加入到task 属性，就可以很方便的支持task 导出。\n熟悉 Taskjuggler tj3 项目的组成的部分 项目的基本信息：（开始日期、持续时间 ( +4m)、日期/时间语法、时区等） 帐号：Accounts （如果您不跟踪财务，则不适用） 可用资源：resource 包含工资、假期、工作时间/天信息等。 里程碑：Top level milestones 任务：Tasks, 按项目主要组成，分解为可执行的任务 报告：可定义的报告 常用设置 定义任务时间 start、end、depends、maxstart和maxend start\n定义任务持续时间 Effort、duration、length\nduration: 指定任务应该持续的时间。这是日历时间，不是工作时间。7d 表示一周。\n如果指定了资源，则在可用时分配它们。资源的可用性对任务的持续时间没有影响。它将始终是指定的持续时间。\n如果使用此属性，任务可能没有子任务。设置此属性将重置 Effort 和 lenght 属性。\nduration (min | h | d | w | m | y)\nlength : 将此任务的持续时间指定为工作时间，而不是日历时间。7d 表示 7 个工作日，或 7 次 8 小时（假设默认设置），而不是一周。\n具有长度规范的任务可能具有资源分配。资源在可用时分配。不能保证任务将获得分配的任何资源。资源的可用性对任务的持续时间没有影响。\n如果没有全球假期，那么没有指定资源可用的时间段仍被视为工作时间，并且相应地定义了全球工作时间。\n对于长度计算，除非任务已分配班次，否则全局工作时间和全局休假很重要。在后一种情况下，轮班的工作时间和假期适用于指定的时间段，以确定某个时段是否为工作时间。如果资源定义了额外的工作时间，则长度为 5d 的任务很可能会分配超过 40 小时的工作量。资源工作时间仅影响是否为特定时间段进行分配。它们不会影响任务的最终持续时间。\n如果使用此属性，任务可能没有子任务。设置此属性将重置 duration~、~Effort 和 milestone 属性。\nlength (min | h | d | w | m | y)\nEffort : 指定完成任务所需的工作量。 Effort: 6d （6资源天）可与2专职资源情况下，在3个工作日内完成。\n需要至少一个定义并分配给任务的资源，并将使用他的/她可用的工作时间/天，以确定任务需要多长时间。\n在分配的资源贡献了指定的工作量之前，任务不会完成。因此，任务的持续时间将取决于所分配资源的可用性。指定的 Effort值 必须至少与 timingresolution 一样大。\n警告：在几乎所有现实世界的项目中， Effort 并不是时间和资源的产物。仅当可以在不增加任何开销的情况下对任务进行分区时，这才是正确的。有关这方面的更多信息，请阅读Frederick P. Brooks, Jr. 的The Mythical Man-Month。\n如果使用此属性，任务可能没有子任务。设置此属性将重置 duration 持续时间和 length 长度属性。具有 Effort值 的任务不能成为里程碑。\neffort (min | h | d | w | m | y)\n定义依赖有多种方法可以定义任务之间的依赖关系。当来自 Org 模式背景时，您可能希望使用 Org 模式提供的工具来定义它们，它们是\nORDERED ： 该ORDERED属性允许您声明子任务必须按照它们出现的顺序完成（最上面在前）。 BLOCKER ： 允许您声明任务依赖于以下任一者的属性 值为 previous-sibling 时，依赖上一个item 的task 对象 值为某个任务的task_id 时，依赖对应的task depends ：定义在指定的任务完成之前不能启动任务，通过指定task_id 确定依赖关系。 其他汇总\ntj3 定义一个任务的几个属性，任务名称，任务Id,任务依赖，任务评估时长，开始，结束时间等：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 * TODO %^{Project name} [0%] :taskjuggler_project: DEADLINE: %^t :PROPERTIES: :CREATED: %U :task_id: :ORDERED: 任务关联 :Effort: ; 评估工作量 表示需要的工作时，而不是日历时 :BLOCKER: ; 前置工作 :efficiency: ;表示资源的效率，默认1.0。设置举例：如果一个人顶三个，则设置为3.0即可 :priority: ;任务优先级，0~1000之间的整数，如果资源数小于当时需要被配置的任务数时，则根据优先级自己安排 :limits: ; 最大工作时间 :leaves: ; leaves 请假 :allocate: ; 角色分配 :resource_id: ; 资源id :depends: 前置任务 :rate: 费率 :duration: 持续时间 :END: %^{OUTCOME}p %? ** Milestones Taskjuggler 语法到 Org-mode 的映射 如果您熟悉 Taskjuggler，那么了解 Taskjuggler 语法如何映射到 Org-mode 可能会有所帮助。这是通过属性Property Syntax (The Org Manual) 完成的，这是属性适用的标题下方的一个简单的键值对。\n大部分实际的 Taskjuggler 项目由task组成，这些task可以被赋予各种属性。可以在 tj3 手册的task 语法 规范中查看允许属性的完整列表。\nTaskjuggler 中的任务可能如下所示： 1 2 3 4 task entry_door \u0026#34;Install entry door\u0026#34; { depends buy_door effort 4h } 在此示例中， task 将以下文本定义为 Taskjuggler 编译的任务。 entry_door 是任务的 ID，它在当前子树中必须是唯一的。引号内 \u0026quot;Install entry door\u0026quot; 作为报告中的任务名称。\n此任务有两个属性： depends 和 effort 。在此示例中， entry_door 依赖于另一个任务 ， buy_door 估计所需的工作量是 4 小时。\n在 Org 模式下，等效的任务会像这样创建：\n1 2 3 4 5 6 * Install entry door :PROPERTIES: :task_id: entry_door :depends: buy_door :Effort: 4h :END: 一些属性可以通过两种方法设置。例如，任务的开始可以由 SCHEDULED 标签或 :start: 属性定义；以下是等效的：\n1 2 3 4 5 6 7 * Install entry door SCHEDULED: \u0026lt;2013-07-15 Mon\u0026gt; * Install entry door :PROPERTIES: :start: 2013-07-15 :END: 同样 DEADLINE 时间戳和 :end: 属性函数的方式相同。\n设计一个场景来计划下任务：\n比如这周，要完成及件事情，练习使用tj3 方式跟踪任务。同时考虑是否需要建立模板来快速创建tj3 任务。先看下任务和tj3 之间的差异。\n问题 导出时，需要设置为buffer 模式下导出，才能够显示全部任务状态。 属性不确定很大，不适合创建snippets 模板，不建议使用模板或代码块。 要想计划一周的任务还需要进一步熟悉tj3 的用法，熟练分析任务进度，提高习惯培养的积极性 支持指定忽略tag: :EXPORT_EXCLUDE_TAGS: ignore noexport 实战问题 有子任务时，不要在该节点添加effort 属性 在tj3 一级节点上，不要添加ordered 代替方案：使用节点中的blocked 属性控制依赖，显示甘特图上的顺序 在二级节点上，直接开启ordered ，有助于子任务的排序显示 当声明了tj3_resource 资源之后，导出会提示失败。需要在task 任务中关联资源之后，再次导出就正常了。 甘特图和资源图 \u0026ndash; 精确到周、日、小时的设置方式 taskreport 字段中 设置 chart 实战次序 先定里程碑 分解任务 处理依赖关系 确定里程碑 在评估工作量 声明资源 分配资源 实战 项目的基础信息 设置项目周期：project-duration\n设置项目标识： project-tag\n重写项目基础信息的函数： org-taskjuggler--build-project\n添加 actual 基准支持 扩展字段 电话 重写task 任务信息函数 org-taskjuggler--build-task 增加解析actual 字段代码\n1 (actual (org-element-property :ACTUAL task)) 在tjp 中增加actrual 字段\n1 (and actual (format \u0026#34; actual:%s\\n\u0026#34; actual)) 效果如下：\n1 2 3 4 5 6 7 ** 编写金和项目 :PROPERTIES: :task_id: jinher :allocate: dev :Effort: 1d :actual: effort 1d start 2021-09-17 :END: 导出tj3 之后的格式：\n1 2 3 4 5 6 7 task jinher \u0026#34;编写金和项目\u0026#34; { depends !swiftUI purge allocate allocate dev effort 1d actual:effort 1d start 2021-09-17 } 新增列 费用 、 收入 在 org-taskjuggler-default-global-properties 中添加\n1 2 3 account cost \\\u0026#34;费用\\\u0026#34; account revenue \\\u0026#34;收入\\\u0026#34; balance cost revenue 导入报告模板\n1 (setq org-taskjuggler-default-reports \u0026#39;(\u0026#34;include \\\u0026#34;reports.tji\\\u0026#34;\u0026#34;)) 定制报告信息在 reports.tji 中查看语法\n在org 中无法制定输出目录，支持tj3 命令行。可以在发布时，使用tj3 命令，借助 ourtputdir 辅助更新相应的项目。 :outputdir: \u0026quot;/Users/boyer/reports/\u0026quot; 仅在命令行时有效。\n替代方案：通过el 命令，指定目录\n1 2 (make-directory \u0026#34;~/reports/七个习惯\u0026#34;) (setq org-taskjuggler-reports-directory \u0026#34;~/reports/七个习惯\u0026#34;) task_id 不能以数字开头\ncomplate 跟踪task状态：仅支持DONE/TODO 状态，它仅用于回报信息，不会更新分配、剩余任务等信息。 Day_To_Day_Juggling\n设置里程碑和第一个task任务的依赖关系。设里程碑过程，需要注意第一个flag 应该被设置为起始任务，task_id 设置为start ，第一个模块依赖这个flag, 后续flag 模块一次依赖为：blocker:previous-sibling 即可。\n使用journalentry设置日志 :journalentry: 2021-09-09 \u0026ldquo;设定任务标题头部\u0026rdquo; {alert red summary \u0026ldquo;事件\u0026rdquo;}\n使用tracereport新增scrum燃尽图 Scrum Example Project - Product Burndown\ntracereport\n设置project 的 task_id 为 project\n在 report.tji 添加 tracereport burndown 模块。\n1 2 3 4 5 6 7 8 tracereport burndown \u0026#34;burndown\u0026#34; { headline \u0026#34;燃尽图\u0026#34; sorttasks id.up width 1000 columns opentasks # columns end { title \u0026#34;\u0026lt;-name-\u0026gt;\u0026#34; } hidetask plan.id != \u0026#34;project\u0026#34; } 设置导出命令，支持跟踪功能\n1 (setq org-taskjuggler-process-command \u0026#34;tj3 --add-trace --no-color --output-dir %o %f\u0026#34;) 实例赏析 新产品上市计划 - 项目综述 七个习惯学习计划 - 项目综述\n","date":"2021-11-23T14:59:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/%E4%BD%BF%E7%94%A8tj3-%E5%88%B6%E5%AE%9A%E5%91%A8%E8%AE%A1%E5%88%92/","section":"post","tags":null,"title":"使用tj3 制定周计划培养七习知识体系"},{"categories":["我的思维"],"contents":" \u0026#30446;\u0026#24405; 写作目的 问：hugo 支持org 问什么转md 问：nikola没有坑，为什么要用hugo 问：用org-mode 做gtd太厚重，planner 更好用 如何规避不必要精力浪费 写作目的 在生活中，特别在没有明确计划的时候，注意力很容易被一件小事带跑偏，打乱本来就很脆弱的执行力。\n该怎么克制这种因小失大的毛病，在这里，想针对这个问题，做一下深层的刨析。\n一个问题在短短半小时延生了几个选择焦虑：\nhugo 渲染支持org 为什要转md hugo 的竞品nikola, 没有坑，为什么不用 org-mode 做时间管理太厚重，有一款plannermode 更好用 问：hugo 支持org 问什么转md 在emacs-china 提问中，主题本来是ox-hugo 导出时，汉字换行问题。\n又人突然在回复中提问： hugo 本身支持org 渲染，为什么要转markdown? 。\n这本来时很普通的问题，神经突然敏感紧张起来，这个问题该怎么回答，在经历曲折的工具探索中，终于决定以org+ox-hugo方式，作为博客写作工具。突然被问及，脑子一片空白，之前做过调研，为什么选择，选择的理由已经忘却了。\n带着这种不安，开始追溯之前做这个决定的理由，关键字搜索到一篇旧文章写了一篇使用 orgmode \u0026amp; hugo 撰写博文的流程介绍 。\n下面的评论中，也有同样的问题，作者的回答是，hugo 对 orgmode支持不理想，issues活跃度不高。于是选择了当下比较流行的hugo渲染md的方式，这样就引出了ox-hugo工具的妙用。\n问题到这应该就结束了。\n问：nikola没有坑，为什么要用hugo 在这篇文章下面的评论中，又出现新的疑惑点： nikola 陌生的关键字，这里更加直接的提问， hugo这么麻烦，为什么用没有坑的nikola替代\n情绪再一次被点爆了，一个陌生的关键字，暴露了自己的短板一样，这个竞品和hugo区别在哪，为什么之前没有接触过。\n于是有进入下一个焦虑的主题： nikola GitHub - getnikola/nikola: A static website and blog generator\nMoving from Nikola to Hugo - Learn. Share. Improve\n给出的答案时主题太少，活跃都不高吧。\n问：用org-mode 做gtd太厚重，planner 更好用 更意外意外的直接给出代替org-mode 建议的，又更加健全好用的plannermode 可以学习一下。\n在进一步资料搜索： EmacsWiki: Planner Mode 用 Planner Mode 和 Muse 实践 GTD 与笔记系统 - Emacs-general - Emacs China 写了一篇使用 orgmode \u0026amp; hugo 撰写博文的流程介绍 - Org-mode - Emacs China\n又一个庞大的学习成本放在面前。我要怎么面多。这就是我一天下来，面对的各种意想不到挑战，精力都消耗在了无用的焦虑中。\n如何规避不必要精力浪费 在写作目的中，有过分析：如果一天内没有明确任务和计划时，一人的注意力很容易被平时忽略，又敏感的话题吸引。\n","date":"2021-11-23T14:59:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/%E5%AE%B9%E6%98%93%E8%A2%AB%E5%B9%B2%E6%89%B0%E8%BF%98%E6%98%AF%E5%AE%9A%E5%8A%9B%E4%B8%8D%E5%A4%9F/","section":"post","tags":["效能"],"title":"为一个敏感问题，你愿意花费多少精力"},{"categories":["周报"],"contents":"周愿景 愿景：心灵演练 两个原则：两次创造，自我领导确立愿景和价值观，让自己的工作遵从这些重要的原则\n心灵演练 在头脑中构思，我想成就什么样的事业？\n心灵演练与情感确认\n使用swift开发demo项目\n每天运动两个小时VR光剑\n在感情上有进展\n严格使用emacs管理时间和生活安排\n编写剧本改变生活实施计划\n在管理上做到tj3的标准，在剧本上发挥七个习惯的原则和自我领导，两次创造，以终为始的原则，重新编写剧本。\n宁可在第一创作和上花费一个月，也不要在盲无目的的一个小时，要重新整理七个习惯，知识体系，学习力的培养，要实要整理资源\n确定周角色，设定目标\n开发者：启动swift 学习项目进度。完成三个练习项目，掌握基础语法和视图常用的第三方工具，自动布局，数据解析，网络请求，基础语法。\n运动者：每天晨练：6:00 - 7:00 ， 乒乓球开始（20分钟），光剑（30分钟），拳击（10分钟）\n管理者：做每天计划安排：7:00-8:00 做今天计划。洗漱上班。\n阅读者：阅读一小时： 20:00 - 21:00 ，提升学习力，搭建知识体系，转变思维方式\n管理者：回顾总结，发表博客：22:00 - 23:00 早睡早起\n使命宣言 确定在项目中的角色，撰写角色的使命\n开发者：tj3 自我领导，以终为始原则\n管理者：作出承诺，信守承诺\n阅读者：拆为己用原则，卡片整理法，以搭建知识体系为宗旨的阅读。\n里程碑：要事第一 关注基层，如果才能有效的办好事情？\n制定目标 培养习惯：每天完成几件事，培养三个习惯：阅读，管理，开发\n现在想通过周管理的当时实现目标管理，一周任务和一种总结管理，这样并不靠谱。\n这样会导致项目不明确，很难借助tj3 工具管理任务。\n该怎么调和周总结和项目之前的关系。\n周角色，任务，目标：可以在项目中呈现，以两周为迭代，三天例会的方式管理任务和总结。\n周记录，暂时不要介入项目管理。\n生活中的方方面面都可以作为项目要创造，不要局限七个习惯中的七天周期，七个习惯同样适应两周迭代的方式做项目总结。\n如果以项目为敏捷作为管理方式，就要坚定这种方式，不要被gtd 的方式困扰。gtd 是针对日常琐事的管理，要坚定敏捷管理。\n既然要敏捷管理，现在就针对敏捷管理演练一下一周的任务：\n敏捷管理的想法是比如要学习swift 开发，肯定是在project 中创建一个项目，让后确定愿景，演练整个过程确定目标和情感确认。\n比如，要锻炼身体，创建同样以项目的方式，创建专项，描述愿景制定目标，确定执行时间和要坚守的信念，每天坚持，坚持到项目周期，做评估，做反馈，迭代式完成锻炼身体的目标。\n比如，要阅读，创建自己的知识体系，同样以项目的方式，描述愿景制定目标，去诶都能够原则，每天坚持，做迭代总结，反馈，一步步实现自己的目标。\n描述了三个过程，明显要比目前想通过日历方式管理日常工作清晰的多，通过项目管理能够更深入对项目跟踪管理，不会想日历管理的方式，仅针对一周内事物做总结分解，无法站在全局的角度把控局面。\n在者三周里，为什么每次下决心想通过日历的方式，做周计划，都在计划上失败了。\n想在一周内，安排多个角色，每个角色要完成几件事的方式，是一个误区。\n先定义一件事情：比如要学习swift 开发，在日历管理方式里，它是作为一件事情来做的，即使经过思考想分解成几个模块来学习，视图布局，网络请求和基础语法学习。这样铺开之后，即使估算之后，一周内可以完成自动布局的学习和应用。\n接着下一周，安排网络请求模块的学习，可以想象日历gtd 的管理方式，是以时间为基线，来处理学习进度。\n很大部分目的是在保证时间的充实，每天都有安排的心理督促者你进行下一步的任务，这种gtd 是违背七个习惯原则，它让你成为了时间的奴隶，为时间安排一些乱七八糟的任务，然后为一直在时间的泥潭里无法。\n认真分析下需求，我的目的是学习swift ，我要先明确了这个目标，坚定了这件事情的对我的重要性，带着积极主动激发我的想象力，演练整个要掌握swift 过程需要面对的一切问题，要多预判复盘等操作。我要以终为始，为梦想奋斗，设定我的原则，制定一套为梦想奋斗的任务日程表。全新关注的做要做的事情。\n这就是如果使用敏捷管理可以实现的管理最佳体验。不再为时间焦虑。而是为梦想奋斗。\n该如何坚定这个信念，不再被gtd 方式干扰。\n我要宣言：坚决拥护七个习惯，舰队贯彻敏捷管理。恪守以终为始的坚定信念，目标必须优先行动。\n2021-11-22 星期一 2021-11-23 星期二 确定坚守敏捷管理tj3工具的信徒，今天就开始吧。emacs早已经等你回归了。 要做哪些事情呢。这次要完成的启用emcas 中有用的工具，agenda 的使用。先清理project 下的项目，保证三个项目的任务清晰。\n使用agenda 作为日常时间任务管理，这样就可以弥补使用项目方式管理，导致任务无法统一浏览的情况。\n清理agenda 界面\n创建项目，swift 开发，锻炼身体，阅读。从这三个方向，创建三个项目，展开敏捷管理的篇章。\n生成tj3 三个项目的甘特图，产出结果，为跟踪分析项目进度，打好基础。\n使用agenda 统计，回顾，反馈，一天，一周，一个月的时间消耗。agenda 统计，更新，回顾，三大功能。任务安排和优先级管理等。\n","date":"2021-11-23T09:50:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%91%A8%E6%8A%A5/2021-W47/","section":"post","tags":null,"title":"2021-W47"},{"categories":["周报"],"contents":"周愿景 愿景：心灵演练 两个原则：两次创造，自我领导确立愿景和价值观，让自己的工作遵从这些重要的原则\n心灵演练 在头脑中构思，我想成就什么样的事业？\n心灵演练与情感确认\n在掌握了禅道上管理模式，整理了一周来的iOS15兼容问题，基本确定管理方式契合emacs中taskjuggler一样，拆分任务估算时长等。\n这周应该正式进入swift开发学习，掌握基本方法和开发知识。搭建系统的swift知识框架，开发相关UI和优化技巧。\n所以本周的目的有两个：一个是技术，一个是情感要迈出一步。大胆实施自己的计划吧。\n还有一个项收获，在半个月来，基本熟悉了元宇宙，从购买oculus到经历了三次游戏资源的搜集的难题，确定了几款锻炼身体的游戏和益智类游戏。\noculus 可以开一个分类，每次玩过游戏之后，做经验和技巧分享，在心灵放松的心境里，提高专注力和生活质量，强健体魄的目的立一项专题。\n再者就是swift开发分享的专注，把游戏和开发两项落地实施。\n确定在项目中的角色，设定角色目标\n在捋清思路之后，感觉之前的摸着石头过河的方式，太愚蠢浪费时间。在开发上学而不用，不总结，造成现在很难快速上手的结局。\n在游戏上，每款游戏在经过使用手册之后，都说明了手柄的操作方式，在游戏中激情操作中领悟到的技巧也是稍纵即逝，要养成总结的习惯，把关卡和思想领悟写下来，并吸收归纳，成为自己的一种生活经验，最终影响真实的生活，改善生活质量。\n说这么多，主要针对两个角色做说明：\n开发者：要大胆的迈出一步，重新熟悉swift语言的特点和效率，要有框架思维，持续积累，构建适合自己的swift知识体系。\n从工程中抽取两个模块做迁移，并在关键的技术点上做到demo练习，归档总结的产出，要精简过程，激活记忆，然后再去探索感兴趣的部分。\n电竞者：娱乐化，放松身心，头脑清晰，思路敏捷，身体素质提高。\n要真三种类型的游戏做评测\n运动类：光剑，骑士，拳击，皮鞭街区，乒乓球，网球，力量比\n益智类：demo桌游，共和国，探长解密\n探险类：攀登，国家地理，僵尸类：生化危机，战锤，忍者。\n休闲类：钓鱼。\n先对这些游戏做分享，创建一个项目来维护控制每日游戏时长，劳逸结合开启新的生活方式。\n使命宣言 确定在项目中的角色，撰写角色的使命要想自由不被生活琐事绑架，一定要自我领导，要做一次心灵演练规划好一周的任务工作，才能有精力面对突发问题。一定要做到要事第一，把重要的事情放在第一位，改变生活状态已经基本就绪，现在就是专心做好要事，合理安排优先级，有过程记录和归纳总结，这样才能有能力抵御突如其来的不良情绪，杜绝在被坏情绪干扰。\n里程碑：要事第一 关注基层，如果才能有效的办好事情？\n制定目标 对swift开发立项和VR游戏立项，演练一周内要做的事情和要达到什么效果，估算时间消耗合理安排七天里的日常任务。周迭代：可以作为里程碑标记短期任务，不能以周为需求节点，周只适合做周报总结回顾调整任务的手段。立项，计划设计，估算工期，安排轻重缓急任务，明确任务消耗排期。\n2021-11-15 星期一 ","date":"2021-11-15T11:23:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%91%A8%E6%8A%A5/2021-W46/","section":"post","tags":null,"title":"2021-W46"},{"categories":["周报"],"contents":"TODO 45W愿景描述 swift基础开发Xcode使用tj3任务管理使用q2娱乐放松挖掘学习abletionLive\nTODO 愿景：心灵演练 两个原则：两次创造，自我领导确立愿景和价值观，让自己的工作遵从这些重要的原则\n心灵演练 在头脑中构思，我想成就什么样的事业？\n心灵演练与情感确认\n确定在项目中的角色，设定角色目标一周内要做到什么，要担起那些怎噩梦\n使命宣言 确定在项目中的角色，撰写角色的使命\n里程碑：要事第一 关注基层，如果才能有效的办好事情？\n制定目标 2021-11-08 星期一 两周内做了一些没有总结的事情，挑选值得记录的事件，写下经验，归档 在如愿得到q2之后，刚开始两天的体验并不理想，顶着头戴通过两个镜片android系统，只是多了两个操作柄，再观看了youtubeVR效果也不突出，第一感觉一点科技感没有。\n当时周五一早通过了海关，很快有人打电话寄送到了小区快递柜，当时还在专班，任务繁重，指导晚上9点多，才熬夜拆箱，前一晚上已经在小米路由器安装了clash，还没有测试翻墙的效果，拆箱之后，收集下载oculus app，登陆fb账号，关联绑定设备，很顺利就激活了设备，q2 激活之后，检测系统升级，速度还可以，大约20分钟左右成功升级启动，这时几乎已经凌晨了，睁大疲惫的眼镜，匆忙体验了裸机，这种并没有达到心理预期，因为周六要加班，就简单收拾下，睡了。\n第二天，\n接着带着失望的心情，在TG 群里，找到一个激活邀请，正好是十一月一号，老用户每个月会有五个邀请名额，很快就有人提供了连接，加了fb好友，使用message聊天，在指导下重置q2, 重新成功激活，看到账户里多了30可用币，fb好友告诉了几个资源论坛，在激活之后，便开始疯狂的搜集资源，下载资源。\n现在迷茫了。一段时间在VR世界里沉浸，在生活上荒废了一周时间，从专办结束之后，从使用路由器翻墙之后，一直在等待q2，然后在资源下载上花费了很多经历：clash使用，百度云盘，阿里云盘，迅雷云盘，PB双系统win11系统，激活air本双系统，支持win8.1安装，下载了28款游戏，熟悉极客VR论坛，学习了几款游戏，无线串连问题的排查，steam+steamVR安装的方面的实战。ALVR，skybox，观看电影的效果体验，对q2的适应：选择头戴和面罩的需求，近视眼镜等商品的论坛评价。确定在咸鱼入手配件。经一番交流，在q2找到了之友，有相同的问题，在自己有限的圈子内，努力的改变q2的体验。\n","date":"2021-11-08T14:40:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%91%A8%E6%8A%A5/2021-W45/","section":"post","tags":null,"title":"2021-W45"},{"categories":["周报"],"contents":"愿景 愿景：心灵演练 两个原则：两次创造，自我领导确立愿景和价值观，让自己的工作遵从这些重要的原则\n心灵演练 在头脑中构思，我想成就什么样的事业？\n心灵演练与情感确认在自我管理上更上一层楼，能够把重要的事情放在第一，能够为实现愿景，花时间做计划，演练整个过程，把愿望经过一次次演练，然后，遵守原则，把事情做好。 确定在项目中的角色，设定角色目标管理者的角色，把事情想明白，做事情有分寸， 使命宣言 确定在项目中的角色，撰写角色的使命好啦舒服\n里程碑：要事第一 关注基层，如果才能有效的办好事情？\n制定目标 阿舒服舒服\n2021-10-28 星期四 CANCEL 完成一件事的重要性 得到\n2021-10-30 星期六 总结使用oculus的感受 感觉画质分辨率一般，刷频率120, 效果没有太大变化。我目前只尝试了oc 自带的设置工具的基本操作。在昨晚一宿的尝试，印象是相对眩晕感。\n在系统设置页面视角边界容易导致眩晕，在进入游戏全屏的情况下，感觉还好，只要控制好手柄的左右前进后退行走，和左右前后转身的。\n6Dof手柄部分采用了环状设计，另外配有两个扳机键，在正面圆环部分是摇杆、Oculus键与A、B（X、Y）两个按键。一般情况下A键和食指的扳机键是确认、B键是返回、中指的扳机键是调整菜单的位置、Oculus键是呼出菜单进行操作，类似于HOME键的定位。\n","date":"2021-10-28T16:57:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%91%A8%E6%8A%A5/2021-W43/","section":"post","tags":null,"title":"2021-W43"},{"categories":["博客站务"],"contents":"hugo 开启支持自定义css 在长期使用org管理项目导出hugo博客时，在ox-hugo文档中有设置todo状态的方法。\n但是放在hugo效果中无法呈现逾期效果，经过一番查找，需要设在hugo配置文件中设置支持html自身css样式的加载，否则，hugo 会生成 \u0026lt;!-- raw HTML omitted --\u0026gt; html标签，禁止用户自定义样式。\ntodo-css 无效果问题解决\n1 2 3 4 [markup] [markup.goldmark] [markup.goldmark.renderer] unsafe = true twitter bootstrap - Hugo shortcode ignored saying \u0026ldquo;raw HTML omitted\u0026rdquo; - Stack \u0026hellip;\n借助org嵌套语法，添加css样式 在ox-hugo文档中介绍css加载的方法，经过一几番测试，在不同节点和宏 #include css 到博客中，都无法达到预期的效果。\n声明css 样式节点\n重点：设置 CUSTOM_ID 属性：todo-css\n有了 CUSTOM_ID 值，就可以通过org嵌套语法 #+include ，在其他节点嵌套该节点的内容。\n例如：在 all-posts.org 文件中，创建一个 CSS for TODO 节点，专门放置css 样式。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 ** CSS for TODO :noexport: :PROPERTIES: :CUSTOM_ID: todo-css :END: #+begin_export html \u0026lt;style\u0026gt; .org-todo { font-size: 0.8em; font-weight: 700; } /* *** Org TODO set to TODO state */ .org-todo.todo { color: #e60000; } /* *** Org TODO set to DONE state */ .org-todo.done { color: green; } \u0026lt;/style\u0026gt; #+end_export 使用 #+include: 嵌套语法，在 project.org 文件中嵌套 CSS for TODO 中css 样式内容。\n1 #+include: \u0026#34;./all-posts.org::#todo-css\u0026#34; :only-contents t org-hugo 导出博客后，查看博客html 效果和源码\n1 \u0026lt;span class=\u0026#34;org-todo done DONE\u0026#34;\u0026gt;DONE\u0026lt;/span\u0026gt; 人脸识别 ox-hugo.el高级定制 在设置了hugo支持绘制css样式之后，就想让博客支持更多的cancel状态的下的样式，下一个问题是如何扩展ox-hugo支持自定义更多的样式问题。\n经过查看ox-hugo 源码，在ox-hugo.el 文件中的方法 org-hugo--todo 可以对状态类型扩展。\n下面代码会在导出html 时，对节点添加的css 样式，在第19 行可以看出，目前支持 done ， todo 两种样式的设置\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 ;;;; TODO keywords (defun org-hugo--todo (todo info) \u0026#34;Format TODO keywords into HTML. This function is almost like `org-html--todo\u0026#39; except that: - An \\\u0026#34;org-todo\\\u0026#34; class is always added to the span element. - `org-hugo--replace-underscores-with-spaces\u0026#39; is used to replace double-underscores in TODO with spaces. INFO is a plist used as a communication channel.\u0026#34; (when todo (message \u0026#34;[DBG todo] todo: %S\u0026#34; todo) (message \u0026#34;[DBG todo] org-done-keywords: %S\u0026#34; org-done-keywords) (message \u0026#34;[DBG todo] org-todo-keywords: %S\u0026#34; org-todo-keywords) (message \u0026#34;[DBG todo] is a done keyword? %S\u0026#34; (member todo org-done-keywords)) (message \u0026#34;[DBG todo] is a todo keyword? %S\u0026#34; (member todo org-todo-keywords)) (message \u0026#34;[DBG todo] html-todo-kwd-class-prefix: %S\u0026#34; (plist-get info :html-todo-kwd-class-prefix)) (format \u0026#34;\u0026lt;span class=\\\u0026#34;org-todo %s %s%s\\\u0026#34;\u0026gt;%s\u0026lt;/span\u0026gt;\u0026#34; (if (member todo org-done-keywords) \u0026#34;done\u0026#34; \u0026#34;todo\u0026#34;) ;; (cond ;; ((member todo org-done-keywords) ;; \u0026#34;done\u0026#34;) ;; ((member todo org-todo-keywords) ;; \u0026#34;todo\u0026#34;) ;; (t ;; \u0026#34;cancel\u0026#34;)) (or (org-string-nw-p (plist-get info :html-todo-kwd-class-prefix)) \u0026#34;\u0026#34;) (org-html-fix-class-name todo) (org-hugo--replace-underscores-with-spaces todo)))) 要事第一，制定下一步行动 记录一下折腾笔记，确认要使用的样式，杜绝在小事上浪费精力。\n借助hugo配置加载自定义css样式 解决使用 #include: 方式嵌套css 样式，导致文章在主页中显示css 文本。\n在 hugodir/static/css/ 目录中创建todo.css 文件\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 .org-todo { font-size: 0.8em; font-weight: 700; } /* *** Org TODO set to TODO state */ .org-todo.todo { color: #e60000; } /* *** Org TODO set to DONE state */ .org-todo.done { color: green; } .org-todo.cancel { color: blue; } customCSS 参数加载自定义的css 样式\n1 customCSS = [\u0026#34;todo.css\u0026#34;] 效果\n1 \u0026lt;link rel=\u0026#34;stylesheet\u0026#34; href=\u0026#34;/css/todo.css\u0026#34;\u0026gt; ","date":"2021-10-28T15:17:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/ox-hugo%E5%AE%9A%E4%B9%89todo%E7%8A%B6%E6%80%81%E7%9A%84css%E6%A0%B7%E5%BC%8F%E6%96%B9%E6%B3%95/","section":"post","tags":null,"title":"学习ox-hugo自定义todo状态的css样式"},{"categories":["周报"],"contents":"TODO 这周目标计划 愿景：心灵演练 两个原则：两次创造，自我领导确立愿景和价值观，让自己的工作遵从这些重要的原则\n心灵演练 在头脑中构思，我想成就什么样的事业？\n心灵演练与情感确认要完成做到哪些目标 确定在项目中的角色，设定角色目标我要做好哪些责任 使命宣言 确定在项目中的角色，撰写角色的使命\n里程碑：要事第一 关注基层，如果才能有效的办好事情？\n制定目标 2021-10-24 星期日 [0/1] 使用周计划规划任务 总结晨检机开发：时序图，活动图 总结拍照逻辑，和开发文档资源 体验VR/ 整理VR 游戏资源 锻炼身体 阅读一本书 做一顿饭 听一首歌 学习攀登/ 阿里云盘资源整理学习 学习abletionLive TODO 写两篇博客 一周内要怎么掌控\n周愿景，周原则，周计划：配合emacs(week) 做hugo 周报汇总的过程总结，并在下一周可执行的步骤\n整理一片升级brew 教程\n熟悉M1 下window 使用记录\n总结本周任务 A1:追问和反思经验 使用周报的方式回报任务\nI: 分析和整理信息知识点 得到自己想要的动西 A2:内化应用知识，谱写愿景 完成这些就很重要\n要事第一，制定下一步行动 就是努力完成任务\n","date":"2021-10-24T01:10:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%91%A8%E6%8A%A5/2021-w24/","section":"post","tags":null,"title":"2021-W42"},{"categories":["解决方案"],"contents":"相机切换 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 //前后摄像头的切换 - (void)changeDeviceAction { [self.session beginConfiguration]; //改变会话的配置前一定要先开启配置，配置完成后提交配置改变 AVCaptureDevice *currentDevice = [self.imageInput device]; AVCaptureDevice *toChangeDevice; if([currentDevice position] == AVCaptureDevicePositionBack){ toChangeDevice = [self cameraWithPosition:AVCaptureDevicePositionFront]; }else{ toChangeDevice = [self cameraWithPosition:AVCaptureDevicePositionBack]; } //获得要调整的设备输入对象 AVCaptureDeviceInput *toChangeDeviceInput = [[AVCaptureDeviceInput alloc]initWithDevice:toChangeDevice error:nil]; //移除原有输入对象 [self.session removeInput:self.imageInput]; //添加新的输入对象 if ([self.session canAddInput:toChangeDeviceInput]) { [self.session addInput:toChangeDeviceInput]; self.imageInput = toChangeDeviceInput; } //提交会话配置 [self.session commitConfiguration]; } //定向获取摄像头设备 - (AVCaptureDevice *)cameraWithPosition:(AVCaptureDevicePosition)position { NSArray *devices = [AVCaptureDevice devicesWithMediaType:AVMediaTypeVideo]; for (AVCaptureDevice *device in devices) { if ([device position] == position) return device; } return nil; } 问题 控制摄像机 AVCaptureSession 运行状态\n初始化session\n1 2 //负责输入和输出设备之间的数据传递 @property(nonatomic)AVCaptureSession *session; 当页面加载完成时，激活session：startRunning\n1 2 3 4 5 -(void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; [self.session startRunning]; } 当页面消失时，停止session\n1 2 3 4 -(void)viewDidDisappear:(BOOL)animated{ [super viewDidDisappear:animated]; [self.session stopRunning]; } 上述代码，看似没有问题，但是放在以下场景中，会导致无法正常切换摄像头。\n场景描述：有两个拍照页面，先使用后置摄像头，拍环境照片，然后进入预览页面。再返回拍照页面，切换前置摄像头，进行正面拍照。这时，会出现无法切换摄像头的问题。\n问题分析：在当第一次拍照进入上传页面时，会 stopRunning 停止，这时如果在上传页面完成上传时，执行拍照的页面的带代理方法时，session 还是stop 状态，无法进行切换摄像头。\n解决思路：要在激活 session 才能进行摄像头切换。\n这样，需要在 viewDidAppear 方法中，确定执行 startRunning 之后，再执行摄像头切换：如：7-9 行代码。\n1 2 3 4 5 6 7 8 9 10 11 -(void)viewDidAppear:(BOOL)animated { [super viewDidAppear:animated]; if (!self.session.running) { [self.session startRunning]; //切换摄像头 if (self.style == 1) { [self changeDeviceAction]; } } } ","date":"2021-10-22T20:17:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E6%91%84%E5%83%8F%E5%A4%B4%E5%88%87%E6%8D%A2%E9%97%AE%E9%A2%98/","section":"post","tags":null,"title":"iOS在切换摄像头时，session可能导致的问题"},{"categories":["项目总结"],"contents":" Table of Contents 需求评审 需求评审 用例评审 技术调研 定制相机UI 文件上传工具 金和浏览器 webCore拦截器 获取门店Id 和orgId 业务开发 开发设计 引导页网页 第一步：人脸识别 [2/2] DONE 人脸采集 DONE 获取人脸图片 DONE 人脸识别 第二步：手部/着装卫生 [3/3] 第三步：晨检 [0/0] 获取晨检配置 [2/2] 答题+健康码 激活晨检机 智能设备 重写设备场景类型 重写保存/更新 删除设备兼容 提测发布 平台设置 [3/3] 提测测试 发布 需求评审 需求评审 用例评审 技术调研 列出项目中，可能用到的技术点，做好调研工作。\n定制相机UI iOS在切换摄像头时，session可能导致的问题 - 习七\n文件上传工具 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 //存储本地/上传图片 -(void)upload { UIImage *img = self.photo; NSString *path = [NSTemporaryDirectory() stringByAppendingFormat:@\u0026#34;%@.png\u0026#34;,[NSString getUniqueStrByUUID]]; //把图片直接保存到指定的路径（同时应该把图片的路径imagePath存起来，下次就可以直接用来取） NSData *photoAddedWatermarkData = UIImageJPEGRepresentation(img, 1); [photoAddedWatermarkData writeToFile:path atomically:YES]; NSString * serverUrl = [JHLiveBaseRequest addUrlProtocolAndEnvWithStr:@\u0026#34;fileserver.iuoooo.com/Jinher.JAP.BaseApp.FileServer.SV.FileSV.svc/UploadMobileFile\u0026#34;]; NSString* Environment = [JHUrlStringManager netEnvironment]; if (Environment.length == 0){ serverUrl = [JHLiveBaseRequest addUrlProtocolAndEnvWithStr:@\u0026#34;upfileserver.iuoooo.com/Jinher.JAP.BaseApp.FileServer.SV.FileSV.svc/UploadMobileFile\u0026#34;]; } NSDictionary *data = @{@\u0026#34;uploadData\u0026#34;:img, @\u0026#34;uploadDataName\u0026#34;:path.lastPathComponent, // @\u0026#34;uploadDataPath\u0026#34;:model.photoPath, @\u0026#34;uploadDataType\u0026#34;:@\u0026#34;Image\u0026#34;, @\u0026#34;uploadDataId\u0026#34;:[NSString getUniqueStrByUUID], }; [MBProgressHUD showHUDText:@\u0026#34;正在上传...\u0026#34; animated:NO]; [JHRoutingComponent openURL:@\u0026#34;Technology://UploadComponent:(uploadDatas:callBack:)\u0026#34; withParameter:@{@\u0026#34;datasArray\u0026#34;:@[data],@\u0026#34;serverUrlStr\u0026#34;:serverUrl,@\u0026#34;isSingleReturn\u0026#34;: @YES, @\u0026#34;isCallBackSchedule\u0026#34;: @YES} callBack:^(NSDictionary *resultDic) { ///上传成功 [[NSOperationQueue mainQueue] addOperationWithBlock:^{ [MBProgressHUD hideHUDanimated:YES]; if ([resultDic.allKeys containsObject:@\u0026#34;returnDicArray\u0026#34;]) { NSArray * dicArray = resultDic[@\u0026#34;returnDicArray\u0026#34;]; for (NSUInteger i = 0; i \u0026lt; dicArray.count; i++) { NSDictionary * dic = dicArray[i]; if ([dic.allKeys containsObject:@\u0026#34;FilePath\u0026#34;]) { NSString * urlHost = [JHLiveBaseRequest addUrlProtocolAndEnvWithStr:@\u0026#34;fileserver.iuoooo.com/Jinher.JAP.BaseApp.FileServer.UI/FileManage/GetFile?fileURL=\u0026#34;]; NSString *imgUrl = [[NSString alloc] initWithFormat:@\u0026#34;%@%@\u0026#34;,urlHost,dic[@\u0026#34;FilePath\u0026#34;]]; [self submitPhoto:path url:imgUrl]; } } } }]; }]; } 金和浏览器 在流程交互上，需要push方式展示金和浏览器，这样在调用diss之后，就可以将整合导航控制器关闭。\n1 2 3 4 5 //TODO: 金和浏览器 NSString *htmlUrl = [NSString stringWithFormat:@\u0026#34;%@%@\u0026#34;,baseUrl,mcn]; // [JHWebviewManager pushWebViewControllerWithURL:htmlUrl isShowReturnButtonAndCloseButton:YES title:nil andParentViewController:self]; UIViewController *web = [JHWebviewManager getWebViewControllerWithURL:htmlUrl isShowReturnButtonAndCloseButton:YES title:nil andHasTabbar:NO]; [self.navigationController pushViewController:web animated:NO]; webCore拦截器 js 调用脚本：\n1 jhoabrowser://sendMorningCheckResults?args=xxx\u0026amp;tag=xxx JS方法： sendMorningCheckResults\n注册拦截方法\n1 2 //晨检机 DECLARE_NODE_MAP(sendMorningCheckResults, WVMornInspecter) 实现原生响应类： WVMornInspecter\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 - (BOOL)webViewShouldStartLoadRequest { // 获取类名 id mornCls = NSClassFromString(@\u0026#34;JHMornInspecterController\u0026#34;); if (mornCls) { //初始化 UIViewController *morn = ((UIViewController * (*)(id, SEL))objc_msgSend)(mornCls,NSSelectorFromString(@\u0026#34;shared\u0026#34;)); //激活晨检机 ，js 回参：self.businessJson[@\u0026#34;args\u0026#34;] NSDictionary *args = self.businessJson[@\u0026#34;args\u0026#34;]; ((void (*)(id, SEL, id))objc_msgSend)(morn,NSSelectorFromString(@\u0026#34;startMornInspecter:\u0026#34;),args); } return NO; } 获取门店Id 和orgId 1 2 NSString *orgId = [storeDic objectForKey:@\u0026#34;orgId\u0026#34;]; NSString *storeId = [storeDic objectForKey:@\u0026#34;storeId\u0026#34;]; 业务开发 开发设计 产出时序图，类图，活动图，甘特图\n引导页网页 在页面中实现的相关业务。\n人脸识别验证 提交手部/着装卫生结果 获取验证配置条件（健康码/答题） 调用h5界面 响应JS原生交互 激活远程晨检机 第一步：人脸识别 [2/2] 是否需要采集\ntrue：人脸识别 \u0026mdash; 自查拍照\nfalse：采集人脸 \u0026mdash; 自查拍照 （采集成功之后，直接进入拍照，不做人脸识别操作）\nDONE 人脸采集 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 -(void)faceCatch { __weak typeof(self) weakSelf = self; [JHFaceRecognition goToFaceCatchPageBlock:^(BOOL success, BOOL backState, NSString *jsonString) { NSData *jsonData = [jsonString dataUsingEncoding:NSUTF8StringEncoding]; NSError *err; NSDictionary *dic = [NSJSONSerialization JSONObjectWithData:jsonData options:NSJSONReadingMutableContainers error:\u0026amp;err]; if (!backState) { if (success) { // 采集成功 NSString *faceUrl = [dic objectForKey:@\u0026#34;faceUrl\u0026#34;]; [weakSelf startCamera:faceUrl]; }else{ // 验证超时 [MBProgressHUD displayHudError:@\u0026#34;人脸采集失败\u0026#34;]; } } } orgID:[JHLiveBaseRequest orgIdInAppInfo]]; } 旧版采集人脸工具没有返回人脸图片，需要扩展人脸采集工具\nDONE 获取人脸图片 在联调代码人脸采集的定位到实现类和关键代码\n第一步先定位到采集人脸代码实现： FaceActionViewController.m\n第二步定位 完成按钮，回调逻辑的实现\n1 2 3 4 5 6 7 8 9 -(void)completeClick{ if (self.vertifySuccess) { NSString *json = [self.faceModel toJSONString]; self.handleFaceBlock(self.faceModel.state,0,json); [self.navigationController dismissViewControllerAnimated:YES completion:nil]; }else{ //略 } } 从第三行知道，API 中回调 json 数据来自在 faceModel 属性，需要在 FaceModel 类中新增想要得到的数据，这里新增人脸图片。\n在上面 faceModel 实例的属性 faceUrl 需要在 FaceBaseModel.h 新增：\n1 2 3 4 5 @interface FaceModel : JSONModel @property(nonatomic , assign) int state; ... @property (strong, nonatomic) NSString *faceUrl; @end 然后，找到给新增属性赋值的地方，即 采集人脸接口 RegisterFaceInfo 回调成功时，将入参： filePath 直接赋值给 faceUrl\n1 2 3 4 5 6 7 8 9 10 11 if (faceModel.IsSuccess) { //注册成功 _wks.vertifySuccess = YES; _wks.layer.strokeColor = HEX_COLOR(0x2CD773).CGColor; _wks.actionLabel.textColor = HEX_COLOR(0x2CD773); _wks.actionLabel.text = @\u0026#34;采集成功\u0026#34;; [_wks.completeButton setTitle:@\u0026#34;完成\u0026#34; forState:UIControlStateNormal]; _wks.faceModel.state = 1; _wks.faceModel.data = faceModel; _wks.faceModel.faceUrl = filePath; } 这样，在点击完成按钮时，会将新增的人脸图片地址，转为json 数据，回传给人脸采集接口。可以解析拿到 faceUrl 。\n1 2 3 4 5 6 7 8 9 10 if (!backState) { if (success) { // 采集成功 NSString *faceUrl = [dic objectForKey:@\u0026#34;faceUrl\u0026#34;]; [weakSelf startCamera:faceUrl]; }else{ // 验证超时 [MBProgressHUD displayHudError:@\u0026#34;人脸采集失败\u0026#34;]; } } DONE 人脸识别 调用人脸识别 调用晨检步骤 第二步：手部/着装卫生 [3/3] 后置拍照UI 上传图片 提交卫生信息 第三步：晨检 [0/0] 获取晨检配置 [2/2] 读取后端配置 确定验证方案 [3/3] 健康码解锁 答题解锁 健康码+答题解锁 答题+健康码 H5答题/健康码\n激活晨检机 通过webCore交互，调用原生方法激活晨检机\n智能设备 需求：替换 设备类型 为 设备场景类型 和新接口\n功能说明 新接口 旧接口 UI变更 设备场景类型 设备类型 设备列表 h5页面兼容 h5页面 设备场景类型 GetIOTDeviceSceneList GetIntelligentDeviceTypeSettingNew 保存设备 SaveIntelligentDeviceInfo 更新设备 SaveIntelligentDeviceInfo 删除设备 DeleteIntelligentDevice 重写设备场景类型 实现接口GetIOTDeviceSceneList 兼容添加设备UI, 删除多余cell 重写保存/更新 实现接口：SaveIntelligentDeviceInfo 兼容更新设备UI, 删除多余cell 删除设备兼容 删除接口实现 实现交互逻辑UI 提测发布 平台设置 [3/3] 依赖库\n智能设备：晨检机分支\nwebCore: master 分支\n人脸识别： master 分支\n反射类\n晨检自查：JHRefelctMornInspecterController\n1 2 3 4 UIViewController *morn = ((UIViewController * (*)(id, SEL))objc_msgSend)(mornCls,NSSelectorFromString(@\u0026#34;shared\u0026#34;)); [self.navigationController presentingViewController]; UINavigationController *nav = [[UINavigationController alloc] initWithRootViewController:morn]; [[UIViewController topMostController] presentViewController:nav animated:YES completion:nil]; 配置功能入口（井盖） 5寸晨检自查：JHRefelctMornInspecterController\n提测测试 发布 ","date":"2021-10-21T18:22:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E6%99%A8%E6%A3%80%E6%9C%BA%E5%BC%80%E5%8F%91%E5%AE%9E%E7%8E%B0/","section":"post","tags":null,"title":"晨检机"},{"categories":["解决方案"],"contents":"elfeed订阅初衷 在emacs中沉浸阅读体验使用elfeed插件必不可少，主要以来RSS订阅功能，可以逃离app束缚，使用喜欢的方式阅读。\n现在想通过RSS订阅自己的博客，但是会出现不是全文的情况，参看了hugo文档，设置RSS 订阅配置，就可以实现全文订阅。\nRSSHub订阅源的流行 现在支持RSS订阅功能的网站越来越少，造就了RSSHub的盛行，可以为帮助用户轻松订阅不支持RSS的王章，得益于很多人在贡献自己制作的订阅源，分享到到RSSHub网站上，提供给同样感兴趣的订阅者。\n比如前几天想通过telegram机器人实现微信公众号订阅源，但是最终以失败告终。不过学到了telegram机器人和公众号的爬去机制。\n制作微信公众号订阅源失败了，可以制作自己博客的订阅源，换个教书熟悉RSS技术，在过程中最好能够解决elfeed订阅RSSHub订阅失败的问题。\nhugo支持全文订阅 定制rss模板 在 hsg/.iNotes/layouts/ 新建文件 index.rss.xml\n核心代码行：\n\u0026lt;description\u0026gt;{{ .Content | html }}\u0026lt;/description\u0026gt;\n.Content ： 全文\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 {{- $pctx := . -}} {{- if .IsHome -}}{{ $pctx = .Site }}{{- end -}} {{- $pages := slice -}} {{- if or $.IsHome $.IsSection -}} {{- $pages = $pctx.RegularPages -}} {{- else -}} {{- $pages = $pctx.Pages -}} {{- end -}} {{- $limit := .Site.Config.Services.RSS.Limit -}} {{- if ge $limit 1 -}} {{- $pages = $pages | first $limit -}} {{- end -}} {{- printf \u0026#34;\u0026lt;?xml version=\\\u0026#34;1.0\\\u0026#34; encoding=\\\u0026#34;utf-8\\\u0026#34; standalone=\\\u0026#34;yes\\\u0026#34;?\u0026gt;\u0026#34; | safeHTML }} \u0026lt;rss version=\u0026#34;2.0\u0026#34; xmlns:atom=\u0026#34;http://www.w3.org/2005/Atom\u0026#34;\u0026gt; \u0026lt;channel\u0026gt; \u0026lt;title\u0026gt;{{ if eq .Title .Site.Title }}{{ .Site.Title }}{{ else }}{{ with .Title }}{{.}} on {{ end }}{{ .Site.Title }}{{ end }}\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;{{ .Permalink }}\u0026lt;/link\u0026gt; \u0026lt;description\u0026gt;最近更新的内容 {{ if ne .Title .Site.Title }}{{ with .Title }}in {{.}} {{ end }}{{ end }}on {{ .Site.Title }}\u0026lt;/description\u0026gt; \u0026lt;generator\u0026gt;Hugo -- iT-Boyer.github.io\u0026lt;/generator\u0026gt;{{ with .Site.LanguageCode }} \u0026lt;language\u0026gt;{{.}}\u0026lt;/language\u0026gt;{{end}}{{ with .Site.Author.email }} \u0026lt;managingEditor\u0026gt;{{.}}{{ with $.Site.Author.name }} ({{.}}){{end}}\u0026lt;/managingEditor\u0026gt;{{end}}{{ with .Site.Author.email }} \u0026lt;webMaster\u0026gt;{{.}}{{ with $.Site.Author.name }} ({{.}}){{end}}\u0026lt;/webMaster\u0026gt;{{end}}{{ with .Site.Copyright }} \u0026lt;copyright\u0026gt;{{.}}\u0026lt;/copyright\u0026gt;{{end}}{{ if not .Date.IsZero }} \u0026lt;lastBuildDate\u0026gt;{{ .Date.Format \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; | safeHTML }}\u0026lt;/lastBuildDate\u0026gt;{{ end }} {{- with .OutputFormats.Get \u0026#34;RSS\u0026#34; -}} {{ printf \u0026#34;\u0026lt;atom:link href=%q rel=\\\u0026#34;self\\\u0026#34; type=%q /\u0026gt;\u0026#34; .Permalink .MediaType | safeHTML }} {{- end -}} {{ range $pages }} \u0026lt;item\u0026gt; \u0026lt;title\u0026gt;{{ .Title }}\u0026lt;/title\u0026gt; \u0026lt;link\u0026gt;{{ .Permalink }}\u0026lt;/link\u0026gt; \u0026lt;pubDate\u0026gt;{{ .Date.Format \u0026#34;Mon, 02 Jan 2006 15:04:05 -0700\u0026#34; | safeHTML }}\u0026lt;/pubDate\u0026gt; {{ with .Site.Author.email }}\u0026lt;author\u0026gt;{{.}}{{ with $.Site.Author.name }} ({{.}}){{end}}\u0026lt;/author\u0026gt;{{end}} \u0026lt;guid\u0026gt;{{ .Permalink }}\u0026lt;/guid\u0026gt; \u0026lt;description\u0026gt;{{ .Content | html }}\u0026lt;/description\u0026gt; \u0026lt;/item\u0026gt; {{ end }} \u0026lt;/channel\u0026gt; \u0026lt;/rss\u0026gt; 设置订阅限制数\n{{- $limit := .Site.Config.Services.RSS.Limit -}}\n在模板代码中有获取配置文件 config.toml 属性值：\n1 2 # 制定RSS最大条数 rssLimit = 10 查看：rsslimit | Hugo\n更多：Site 参数获取 | Hugo\n特殊 ^H 符号导致RSS问题 特殊符号，会导致一下问题：\n1 2 3 This page contains the following errors: error on line 20461 at column 29: PCDATA invalid Char value 8 Below is a rendering of the page up to the first error. 在emacs 执行删除操作\n选中并拷贝 v y\n全文搜索： spc s d 目录\n替换： M-x:replace-string\n清理完成之后，重新编译即可。\nelfeed订阅RSSHub 方案和订阅源筛选 因为RSSHub大部分是用户分享的订阅源，存在失效情况。\n为增加订阅的成功率，可以参考RSSHub官网搭建私服服务的教程，配合RSSHub 公布的订阅源，把域名替换为私服路径，在验证是否有效。\n推荐使用heroku平台部署文档：一键部署到 Heroku\n已经个人的服务： https://i2rsshub.herokuapp.com\n验证RSS订阅源主要关注几点：\n订阅内容内容质量\n内容是否符合自己兴趣爱好，有质量，有新东西的网站，才能有高效阅读体验\n更新频率\n主要为了筛选过期的订阅源，节省精力。\n如果质量很好值得收藏，例如objc.io 已经停更，但是质量很高。\n对于高质量的订阅源，要利用好elfeed 的时间过滤条件，也能够轻松驾驭过期期刊。\n支持全文订阅\n如果不支持全文订阅，文章质量有很好，可以借助 pocket-reader 工具获取全文内容\npocket-reader 可以通过 pocket-reader-add-link 从org/elfeed/eww 等buffer 中的超链接，直接加入到pocket-reader 列表。\npocket-reader 提供了优秀的阅读体验，可以将订阅内容格式化为org 在 org-mode 模式下阅读，相当惊艳。\npocket-reader提升阅读幸福感 pocket-reader 本身不支持订阅，是通过文章URL, 抓取文章内容的机制，这样在emacs 中提升阅读体验提供了基础。\nGitHub - alphapapa/pocket-reader.el: Emacs client for Pocket reading list (ge\u0026hellip;\n掌握了这个阅读器，可以将网页内容，格式化为org 文章来阅读，这样提升阅读体验，在写博客时，也能沉浸在emacs 世界，尽情发挥想象力，全神贯注的投入创造。\n它的快捷键很多，需要切换到在 edit 模式。\n关于文章来源\npocket 有很多工具的支持，几乎可以实现随时随地推送一篇博客到pocket中。\n浏览器插件\nalfred工具\nelfeed\n微信公众号无解\n","date":"2021-10-21T18:11:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/hugo%E6%94%AF%E6%8C%81%E5%85%A8%E6%96%87%E8%AE%A2%E9%98%85%E7%9A%84%E8%AE%BE%E7%BD%AE/","section":"post","tags":null,"title":"hugo支持全文RSS设置问题"},{"categories":["解决方案"],"contents":"I:辨别知识和信息 RSSHub口号是万物皆可订阅，可以爬去任何网站的信息，格式化为rss订阅格式。可以使用feedly，google 插件等工具实现订阅。\n现在知识平台大部分都集中在公众号上，微信的封闭模式，倒是爬去信息非常麻烦。在网上看了一些教程和RSSHub公布的订阅渠道都不能使用。\n为了解决这个问题，尝试通过telegram机器人实现和微信互通，让后转为RSSHub订阅的方式。\nA1:激活/追问反思经验 RSS订阅技术对当前的学习环境并没有什么影响，但是想再emacs中实现集成阅读的化，只能通过elfeed工具订阅的体验方式才能达到沉浸体验。\n另一个原因是微信公众号订阅的渴望，尝试很多功能都无法实现公众号的订阅，就成了新病，想通过telegram机器人的方式实现。然后就有了这篇文章。\n可笑的elfeed并不支持订阅RSSHub的订阅源。\nA2:内化应用知识，谱写愿景 真正的问题是解决：elfeed 订阅 RSSHub 无效的原因是什么，该怎么解决？\n要事第一，制定下一步行动 DONE 如何实现elfeed 订阅RSSHub 订阅源。 基于web端微信订阅微信公众号efb2w安装 （微信web端官方已不支持，经测试订阅方案无法使用）\n为一个基于 efb v2 的公众号抓取输出方案提供支持\ndocker 方式安装： Docker镜像： lzyyauto/efb2w python 本地安装： 安装并使用 EFB：在Telegram 收发微信消息 ","date":"2021-10-21T18:11:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/telegram%E6%9C%BA%E5%99%A8%E4%BA%BA%E8%AE%A2%E9%98%85web%E7%89%88%E5%BE%AE%E4%BF%A1%E5%85%AC%E4%BC%97%E5%8F%B7/","section":"post","tags":null,"title":"使用teleagram机器人实现公众号订阅"},{"categories":["学习笔记"],"contents":"emacs 禅道 团队项目管理在长久实践敏捷管理，项目持续迭代过程会遇到一些协作问题，造成项目逾期，开发低效率，资源浪费等问题。\n在开发组上下齐心的推动下，质量部从公司自研的oa系统，迁移到了更适合开发管理的禅道平台上。目前采用禅道的开发版。经过上一次初步了解 禅道使用入门 ，较完整的实现了Scrum管理的模式。\n在使用emacs过程中，养成了使用org管理日常工作和时间安排，对于项目开发，可以借助taskjuggler工具来管理项目，特别是对资源分配，时间估算，任务安排，有很好的校验功能。也可以将org任务导出为甘特图，这样在管理过程中能直观高效的规划，跟踪，复盘整个项目。\n在经过emacs一番磨练，练就了自我管理和项目管理的能力，但这些也仅局限在个人效率的提升，但是无法在项目组中做到信息共享同步。\n这次借助禅道管理在团队内部的推行下，希望能尽快熟悉禅道的管理模式，掌握项目，任务，资源的相关管理，做到团队信息同步，管理方法同步，提升整个团队的开发效率。\n迁移项目到禅道 如何熟悉禅道的项目管理，当前是实战效率更快，目前手上没有项目，可以迁移旧项目来操练禅道管理流程。\n以连锁集团 为例，具体步骤如下\n先在emacs 创建tj3项目\n使用 new-jinher-template.org 模板：\n命令： spc n r n 项目名称 enter c p\n立项\n立项，设立目标，计划，分解任务，分配任务，管理时间\n遇到问题可以参考：使用tj3 制定周计划培养七习知识体系\n导出\n导出命令： spc m e j o\n导出在目录： ~/hsg/iNotes/iDocs/taskjuggler/项目名\n在目录中，会生成三个个文件\n甘特图html： 项目名文件\n微软Project： project.xml,\n可以共享到第三方工具管理，例如：OmniPlan ，可以通过更专业的方式，进一步校验tj3管理，完善项目的合并分配。\n在使用 OmniPlan 工具打开导出的 project.xml 导出的格式更加丰富，通过 OmniPlan 和其他应用共享数据，会更加友好。\n简报文件csv： 简报.csv\n导出方法：taskjuggler导出xml和csv方法实战\n在禅道创建项目 禅道开发版在第一次登录时，需要设定禅道服务器，然后就可以用管理员分配你的帐号登录了。\n创建项目\n需要设定 所属项目集 ，如果不设置此项，该项目作为项目集，本次测试项目，应该设置此项。\n其他项目属性，可以参照tj3 已经设置的属性，项目信息逐一填写。\n新建迭代\n了解Scrum 流程知道就不过多说明，禅道中项目启动，必须在迭代中进行\n新建任务\n任务是在迭代中创建\n批量导入任务：多项录入 禅道开发版本，暂不支持文件导入功能，只能借助昂贵的插件。\n在禅道唯一找的批量导入的功能是创建任务是，支持换行录入多个任务名称，任务其他属性需要手动设置。\n新建迭代\u0026ndash; 创建任务 \u0026ndash; 进入新建任务/ 新建子任务界面，点击右上角的多项录入\n多项录入 界面如下：\n从tj3 任务中拷贝任务项\n获取tj3 导出的任务\n例如：\n1 2 3 4 5 6 添加我的组织入口 [3/3] 选择组织身份页 [2/2] 搜索页面 [6/6] 管理我的下级页面 [10/10] 管理我的上级页面 [6/6] 联调接口 [6/6] 尝试过几种方式，都没实现\n导出csv 格式，倒是会有制表符影响录入\n导出MS-xml 使用OmniPlan 回去任务列表，也没有找到对应功能\n通过hugo 博客目录获取任务项\n上文在emacs 导出项目时，同时会导出hugo博客, 任务项主要从博客目录上拷贝，\n以连锁集团 为例，具体步骤如下\n录入禅道任务\n","date":"2021-10-21T13:10:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A6%85%E9%81%93%E5%AE%9E%E6%88%98%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86/","section":"post","tags":null,"title":"迁移tj3归档项目到禅道实战"},{"categories":["学习笔记"],"contents":"I:辨别知识和信息 元宇宙现状和技术知识体系\n主流VR平台和开发引擎简介 - 前沿洞察 - 恒生研究院\n未来是XR（VR/MR/XR）的天下，所有AI技术（机器学习）都将成为XR世界的一部分。\nAR是人工智能和人机交互的交叉学科，基础技术包括CV（计算机视觉）、机器学习、多模态融合等，借凌老师去年的一篇文章简单科普AR技术。\n虚拟现实（VR）和增强现实（AR）背后的核心技术是什么？ - 知乎\n增强现实（AugmentedReality，简称AR）和虚拟现实（VirtualReality，简称VR）概念的出现已经有了几十年的历史了，然而VR/AR大量出现在科技媒体上吸引各方眼球也就是最近的事情。\n2021年的元宇宙，1999年的互联网|vr|虚拟世界|ar|马克·扎克伯格_网易订阅\nARKit 官方简介 增强现实(AR)描述用户体验，将2D或3D元素从设备的摄像头中添加到实时视图中，从而使这些元素出现在真实世界中。\nARKit结合了设备运动跟踪，摄像镜头捕捉，先进的场景处理，以及显示方便来简化建立AR体验的任务。\nARKit开发文档\n理解AR: Augmented Reality 理解AR概念、特性和最佳实践来构建很好的AR体验。\nARSession ：一个共享对象，可以管理增强现实体验所需的设备摄像头和运动处理。\nARSessionConfiguration:只记录设备方向的轨迹的基本配置\nARWorldTrackingSessionConfiguration:一种跟踪设备定位和位置的配置，它可以检测设备摄像头看到的真实表面。\nAR标准视图具体实例 一个基本的AR体验DEMO\n配置一个AR会话并使用SceneKit或SpriteKit来显示AR内容\nProviding 3D Virtual Content with SceneKit\nARSCNView:一种显示AR体验的视图，它通过3D SceneKit内容增强了相机视图。\nProviding 2D Virtual Content with SpriteKit\nARSKView:一种显示AR体验的视图，增加了2D SpriteKit内容的摄像头视图。\n借助 ARKit 和 Core ML，基于 iOS 11 进行开发。\niOS 11 为开发者带来了各种可能性。借助 ARKit，开发者可将生动逼真的增强现实带到 app 之中。而有了 Core ML，开发者可利用机器学习来创建各种更智能的 app。\n进一步了解基于 iOS 的开发\nA1:激活/追问反思经验 做个技术开发接触过 Android/iOS、swift/objc/java/asp/web/js开发，要么是前端，后端。\n还有设计类的三剑客flash、photoshops、dreamwear，设计类工具之外，很少再去深入了解其他知识领域的技术实现和开发。\n在十几年的发展虚拟现实和大数据分析越来越流行，现在就这些新领域做些探索。\n对元宇宙初步认识，如果想开发oculus VR 游戏，无线设备依赖android 和双U IDE 开发工具的学习。pc 端游戏平台 steamVR 游戏商放弃了OSX 系统。\n在这种环境下，VR 头显只能尝鲜，玩玩VR 游戏，培养一个爱好，保持身心健康，就是最大的意愿了吧。\nA2:内化应用知识，谱写愿景 肯定的是要学习AR 开发更符合实际，可以做一个课程，学习swift 开发。用swift 做一些力所能及的工作。\n在自我领导和管理做了全面升级之后，是时候把工作重心迁移到编程开发，有目的有计划做一些高效的事情，提高自己效率和学习能力，磨练自制力。\n要事第一，制定下一步行动 阿里资源学习：看书，听讲座，写心得，保持头脑清醒灵活，积累知识，保持输出，培养七习原则，为成为一个高效能人士努力。\nswift 学习计划：演练掌握一项技能的过程，探索新的学习技巧，培养新的开发思维，搭建新语言的知识体系。\n","date":"2021-10-20T19:16:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/ARKit%E5%85%A5%E9%97%A8/","section":"post","tags":null,"title":"元宇宙初探"},{"categories":["解决方案"],"contents":"A1:追问和反思经验 在配合org导出tj3生成html回报格式，有了很好的成效，现在工作管理要迁移到禅道平台，联想到到tjp格式的文件导出通用的格式，就可以很方便的同步到禅道平台上。\n现在就着手做一些导出工作的延伸，将org格式导出tjp然后在生成通用的MS-project，CSV格式来共享计划。\nI: 分析和整理信息知识点 在org中做到了快速一键导出 spc m e j o ,生成甘特图html版的任务管理看板。\n可以参考之前配置记录：七个习惯和taskjuggler整合\n要导出xml，csv格式，应该在配置上大同小异，先确定如何导出，是否需要额外的tj3命令的学习。\nA2:内化应用知识，谱写愿景 在确定导出xml 和csv 找到了部分案例：\nexport 导出通用文件格式 export 语法：The TaskJuggler User Manual\nexport 的formats仅支持两种文件格式导出 MS-xml：支持在win 系统上通过 Project 应用打开。在Mac 上使用OmniPlan 工具打开。 tjp/tji ： 暂时没有用到。 从案例中可以知道，可以通过 export 语法来实现导出设置：\n1 2 3 4 5 # Export the scheduled project as Microsoft Project XML format. export \u0026#34;MS-Project\u0026#34; { formats mspxml loadunit quarters } export 节选任务导出 可以制定导出的哪类任务和指定要导出那个时间段的任务。\n也可以指定 formats属性 导出 xml/tjp 的格式。\n1 2 3 4 5 6 7 8 # Export only bookings for 1st week as resource supplements export \u0026#34;Week1Bookings\u0026#34; { definitions - start 2021-09-28 end 2021-10-15 taskattributes Bookings #* hideresource 0 } 使用节选功能\n因为这个功能，需要手动指定时间和分类等属性设置。\n暂时仅知识手动导入，不支持org 导出。\n步骤如下：\n先导出项目，即执行 spc m e j o\n在include 文件添加导出设置，指定时间等属性\nformats: 文件格式 start: 截取开始时间点 end: 截取的时间点 1 2 3 4 5 6 7 8 9 # Export only bookings for 1st week as resource supplements export \u0026#34;Week1Bookings\u0026#34; { formats msxml definitions - start 2021-09-28 end 2021-10-15 taskattributes Bookings #* hideresource 0 } 使用命令重新导出项目，会当前目录生成一个新文件：例如 Week1Bookings.xml 。\n1 tj3 --add-trace ~/hsg/iNotes/content-org/project.tjp csv 格式任务导出 textreport ：支持csv,html,niku\n但是遇到问题： textreport 'TODO_CSV' cannot be converted into CSV format\nexport ： 支持 msxml/tjp 格式。\n由于 textreport / export 都不支持cvs 格式。\ntaskreport 导出cvs\ntaskreport: 支持 csv, html, niku\n只需要指定 taskreport 的formats 属性指定为csv 即可，同样支持其他属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 taskreport TODO_CSV \u0026#34;简报\u0026#34; { formats csv # columns name columns bsi {title \u0026#39;WBS\u0026#39;}, name {title \u0026#39;名称\u0026#39;}, start{title \u0026#39;开始日期\u0026#39;}, end{title \u0026#39;结束日期\u0026#39;}, status{title \u0026#39;状态\u0026#39;}, complete{title \u0026#39;进度\u0026#39;}, resources{title \u0026#39;资源\u0026#39;}, note {title \u0026#39;备注\u0026#39; width 150} hideresource @all loadunit quarters scenarios actual caption \u0026#39;工作量以每人每天计算。\u0026#39; } 要事第一，制定下一步行动 现在已经有了两种格式的文件，通过整理，实现了org 导出多种格式的流程，统一导出到了归档项目工程目录下：iDocs/taskjuggler/项目名/.csv/.xml\n因为在项目下，文件统一的名称： 简报.csv, project.xml\n分享路径： https://it-boyer.github.io/iDocs/taskjuggler/连锁集团/简报.csv\n分享路径： https://it-boyer.github.io/iDocs/taskjuggler/连锁集团/project.xml\n放在了githubpage更方便下载分享。\n在实现导出功能之后，具体使用场景有哪些：\nMS-xml 的优势 导出MS-xml 可以通过OmniPlan 检查项目的合理性，在OmniPlan 专业的角度优化项目管理细节。 在OmniPlan 可以导出更美观的格式效果，生成pdf 更显得专业易懂。 可以节选一周任务/一月任务等，分段导出，只需要关注本周月的任务，能很大的简化了任务管理复杂度。 csv 的优势 csv 格式简单，在共享数据时有很大的优势。\n1 2 3 \u0026#34;WBS\u0026#34;;\u0026#34;名称\u0026#34;;\u0026#34;开始日期\u0026#34;;\u0026#34;结束日期\u0026#34;;\u0026#34;状态\u0026#34;;\u0026#34;进度\u0026#34;;\u0026#34;资源\u0026#34;;\u0026#34;备注\u0026#34; 1;\u0026#34;连锁集团\u0026#34;;\u0026#34;2021-09-28 09:00\u0026#34;;\u0026#34;2021-10-12 17:00\u0026#34;;\u0026#34;done\u0026#34;;\u0026#34;100%\u0026#34;;\u0026#34;\u0026#34;;\u0026#34;\u0026#34; 1.1;\u0026#34; 立项\u0026#34;;\u0026#34;2021-09-28 09:00\u0026#34;;\u0026#34;2021-10-12 17:00\u0026#34;;\u0026#34;done\u0026#34;;\u0026#34;100%\u0026#34;;\u0026#34;\u0026#34;;\u0026#34;\u0026#34; 使用macs 快速预览的效果，相当清新：\n","date":"2021-10-20T15:27:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/taskjuggler%E5%AF%BC%E5%87%BA%E6%94%AF%E6%8C%81%E5%AF%BC%E5%87%BA%E7%9A%84%E6%A0%BC%E5%BC%8F%E6%80%BB%E7%BB%93/","section":"post","tags":null,"title":"taskjuggler导出xml和csv方法实战"},{"categories":["解决方案"],"contents":"I:辨别知识和信息 现在在网上的知识资源，例如：严选、喜马拉雅、网易公开课、得到、攀登阅读等，资源越来越多，少则几百G，多则几T 。\n之前借助过ResilioSync Pro版本的选择性同步，可以对关注的内容选择同步，学习输入之后，及时移除释放空间，进行下一个关注学习。\n但是在阿里云盘退出不限速下载之后，免费空间也是非常诱人。\n资源分享圈活跃度多迁移到了阿里云盘。ResilioSync资源更新的越来越少。\n迁移阿里云盘的主要原因是资源丰富和据时俱进资源活跃圈。\nA1:激活/追问反思经验 ResilioSync 工具使用的经验 目前使用ResilioSync确实有很多资源，精心挑选过一些感兴趣的知识课程学习。\n同步不限速：ResilioSync 的去中心化的同步机制，对同一个节点的用户主机，及时服务器也是客户端。\n本地索引检索：不同步也可以检索有哪些资源，在本地会生成每个文件的索引文件，索引文件不占空间，这样就可以根据文件名称来检索需要的资源文件，然后，双击索引文件就会自动同步真实文件到本地。\n在mac 端 Alfred + ResilioSync + kindle 电子书资源，就可以实现本地检索，快速找到网上的资源，让后选择同步。\n不支持在线查看预览\n但是随着时间一长，同步到本地的文件越来越多，存放的目录又是无法查询，很难第一时间清理已经过时的文件，导致空间会越来月少，最近清理了一次ResilioSync ，释放了40+G 空间。\n有封禁的危险。\n由于4 原因，社区不活跃，相关资源更新滞后等问题。\n现在看的知识没有多少，主要原因是知识大部分在17年之前，多少干扰了学习的积极性。这次通过阿里云盘有收集到这些资源，它的特征是资源新，可以在线播放。不用担心硬盘警告了。\n个人原因：自制力差，自我管理还待提高。\n在资源到手时，非常兴奋，要立下决心提高学习力，但是每次都被打脸。\n经过一段时间的反思和自我管理的磨练，有了一套自己的学习模式，搭建自己的知识体系。\n阿里云盘的兴起 下步不限速 在线播放音视频 资源社区活跃，资源能保证最新 smb挂载不支持本地检索 A2:内化应用知识，谱写愿景 配合资源提升学习力，打造自己的知识体系。\n当下主要的两个目标方向 高效能人士的七个习惯 拆为己用，学习三种反思方式：RIA,IAA,AIA 团练三种思维模式，提升发现问题，解决问题，提升学习力，充实生活的目的。 挑选几个感兴趣的知识领域，打造自己的知识体系，实现七个习惯提升做事的高效人士。\n主要使用的工具 emacs 两个职责: 管理：使用taskjuggler工具制定学习计划，实现自我领导和自我管理的习惯。 产出：roam卡片搭建知识体系，吸收总结，输出hugo博客 阿里云盘，资源管理做好学习资源的收集，定期管理资源分类和学习。 要事第一，制定下一步行动 挂载阿里云盘，使用vlc播放阿里云盘资源，使用taskjuggler制定学习计划，在emacs中创建博客输出。\n搭建阿里云盘 在mac系统上使用webdav工具挂载阿里云盘 制定学习计划 ","date":"2021-10-19T18:50:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%9F%BA%E4%BA%8E%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98%E8%B5%84%E6%BA%90%E5%AD%A6%E4%B9%A0%E6%80%9D%E8%80%83/","section":"post","tags":null,"title":"基于阿里云盘资源学习思考"},{"categories":["解决方案"],"contents":" 阿里云盘挂在到本地硬盘\n安装webdav 工具\n安装docker\ndocker mac 版本，直接只用官网dmg 安装。\n使用brew 安装，会出现缺少组件问题：Cannot connect to the Docker daemon on macOS\nmessage/aliyundriver-webdav 安装\n在 dotfiles/docker/aliyundrive-webdav/compose.yaml\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 version: \u0026#34;3.0\u0026#34; services: webdav-aliyundriver: image: messense/aliyundrive-webdav container_name: aliyundriver environment: - REFRESH_TOKEN=9d3535a***d8e85 - WEBDAV_AUTH_USER=admin - WEBDAV_AUTH_PASSWORD=admin volumes: - /Users/boyer/docker/alidriver/:/etc/aliyun-driver/ ports: - 8686:8080 restart: unless-stopped docker-compase 使用\n使用docker-compose 可以方便管理镜像中的环境变量\n创建镜像，启动容器在 compose目录下，执行：\n1 docker-compose up -d 更新镜像环境属性\n1 2 3 4 5 6 7 8 9 10 #关闭 Docker 容器们 docker-compose down # 删除已停止的 Docker 容器 docker-compose rm # …… # 修改 docker-compose 配置文件 # …… # 再次开启 Docker 服务 docker-compose up -d 挂载云盘\n方式1: mac 端原生挂载方式：使用 cmd+k 访问：webdav路径： http://localhost:8686\n方式2: rclone 挂在云盘到本本地 oneDrive/aliyunpan\n","date":"2021-10-19T18:49:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%9C%A8mac%E7%B3%BB%E7%BB%9F%E4%B8%8A%E6%8C%82%E8%BD%BD%E9%98%BF%E9%87%8C%E4%BA%91%E7%9B%98/","section":"post","tags":null,"title":"在mac系统上使用webdav工具挂载阿里云盘"},{"categories":["解决方案"],"contents":"I:辨别知识和信息 在hugo导出过程中，文中如果出现roam链接，导出会出现问题。\n目前现象，如果roam链接的节点在同一个文件时，可以导出成功。如果roam链接的节点和hugo博客不在同一个org文件中时，导出就会失败。\n由于目前使用的roam2 版本，找到两个roam1解决方案，通过hook方法替换链接方式尝试解决，结果在roam2 中失败。\n1 Error (after-save-hook): Error running hook \u0026#34;org-hugo-export-wim-to-md-after-save\u0026#34; because: (org-link-broken 8bf3df1d-b8f3-4e26-99fb-da0bc476771f) 方案一 Updating backlinks of the destination post\n1 2 3 4 5 6 7 8 9 (defun jethro/org-roam-export-updated () \u0026#34;Re-export files that are linked to the current file.\u0026#34; (interactive) (let ((files (emacsql-sqlite [:select [to] :from links :where (= from $s1)] buffer-file-name))) (dolist (f files) (with-current-buffer (find-file-noselect (car f)) (org-hugo-export-wim-to-md))))) (add-hook! \u0026#39;after-save-hook \u0026#39;jethro/org-roam-export-updated) 在上文中用到的org-roam-sql 已经废弃，替换为 emacsql-sqlite\n新问题： Error (after-save-hook): Error running hook \u0026quot;jethro/org-roam-export-updated\u0026quot; because: (error Keyword argument /Users/boyer/hsg/iNotes/content-org/all-posts.org not one of (:debug))\nOn Android Termux, any access to the database fails with \u0026ldquo;middleware out of memory\u0026rdquo; error\nemacsql-sqlite returns \u0026ldquo;middleware out of memory\u0026rdquo; on Termux (Android)\n方案二 Exporting Org Roam notes to hugo - Sidharth Arya\n该方案针对roam1 版本，针对文件来导出roam 连接，经验证部分方法（ org-roam--org-roam-file-p ）已废弃：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ;替换链接 (defun org-hugo--org-roam-backlinks (backend) (when (equal backend \u0026#39;hugo) (when (org-roam--org-roam-file-p) (beginning-of-buffer) (replace-string \u0026#34;{\u0026#34; \u0026#34;\u0026#34;) (beginning-of-buffer) (replace-string \u0026#34;}\u0026#34; \u0026#34;\u0026#34;) (end-of-buffer) (org-roam-buffer--insert-backlinks)))) (add-hook \u0026#39;org-export-before-processing-hook #\u0026#39;org-hugo--org-roam-backlinks) ;添加hook方法保存 (defun org-hugo--org-roam-save-buffer(\u0026amp;optional no-trace-links) \u0026#34;On save export to hugo\u0026#34; (when (org-roam--org-roam-file-p) (org-hugo-export-wim-to-md))) (add-to-list \u0026#39;after-save-hook #\u0026#39;org-hugo--org-roam-save-buffer) A1:激活/追问反思经验 现在把博客分为了几个文件来管理\nhabit主要记录习惯和思维模式的转换相关总结，\nall-post主要记录博客项目，导出时专门对应ox-hugo做了类别分类，可以很好的处理博客的管理。\nproject:项目级别的主要放在project文件中管理，它的特色时tj3工具的集成，对管理项目有很好的兼容。\n在这三大类的处理之后，出现roam链接导出的问题。失去了很重要的一项机制。如果导出问题解决不了，就要考虑在一个文件中统一管理三个角色，充分应用roam机制。\nA2:内化应用知识，谱写愿景 目的：一定要激活roam的使用。\n方案一要使用两个小时来解决导出导出链接问题。\n方案二：把项目重新整合到一个文件中来管理博客，习惯，项目。要使用roam-ui回顾项目，把项目做到卡片机制，做到知识二次应用。\n要事第一，制定下一步行动 目前使用方案是放在同一个文件中管理每分类。\n","date":"2021-10-18T18:44:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%88%86%E6%9E%90hugo%E5%AF%BC%E5%87%BAroam%E5%87%BA%E7%8E%B0%E7%9A%84%E5%BC%82%E5%B8%B8%E9%97%AE%E9%A2%98/","section":"post","tags":null,"title":"hugo导出roam链接失败相关问题总结"},{"categories":["博客站务"],"contents":"设置主题色 主题的样式文件的位置： ${Hugo-Site}/themes/even/assets/sass/_variables.scss\n先确定配色方案\n背景色： #002b36\n字体色： #839496\n可以在 Solarized Color Scheme 找到更多的配色方案。\n下面步骤将用这个色值设置even 主题色，本博客就是最终效果。\n设置背景色\n在 _variables.scss 中找到 $global-background 属性值为 $white\n1 2 // Background color of the site. $global-background: $white !default; 修改 $white 色值\n修改为 #002b36 色号\n1 2 3 4 5 6 // ========== Color ========== // $black: #0a0a0a !default; $white: #002b36 !default; //#fefefe $light-gray: #e6e6e6 !default; $gray: #cacaca !default; $dark-gray: #8a8a8a !default; 设置字体的全局色\nGlobal 下 $global-font-color 的sRGB 值\n1 2 3 // ========== Global ========== // // Text color of the body. #34495e $global-font-color: #839496 !default; 其他\n在完成上两步之后，可以看到效果样式。还有toc 样式背景需要做统一色设置。\ntoc 浮动框背景色\n1 2 3 4 5 6 // ========== TOC ========== // // Width of the post toc. $post-toc-width: 260px !default; // Backgroud color of the post toc. rgba($deputy-color, 0.6) $post-toc-backgroud: rgba($white, 1) !default; 参考： 更新 hugo-even 主题样式 - Herbert\u0026rsquo;s Blog\n","date":"2021-10-14T11:50:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/even%E4%B8%BB%E9%A2%98%E8%89%B2%E8%AE%BE%E7%BD%AE%E6%96%B9%E6%B3%95/","section":"post","tags":null,"title":"设置even主题色"},{"categories":["解决方案"],"contents":"安装tdlib 安装方式有两种，一种使用brew, 一种使用源码编译tdlib\n在使用 brew install tdlib 之后，显示版本过时，无法使用，只能借助编译方式获得最新版本。\n编译教程：TDLib build instructions\n1 2 3 4 5 6 7 8 9 10 11 12 13 xcode-select --install /bin/bash -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/Homebrew/install/master/install.sh)\u0026#34; brew install gperf cmake openssl git clone https://github.com/tdlib/td.git cd td rm -rf build mkdir build cd build cmake -DCMAKE_BUILD_TYPE=Release -DOPENSSL_ROOT_DIR=/usr/local/opt/openssl/ -DCMAKE_INSTALL_PREFIX:PATH=../tdlib .. cmake --build . --target install cd .. cd .. ls -l td/tdlib 编译成功之后，可以会在 td/tdlib 目录下找到最新版本库文件。\n使用 brew info tdlib ，查看安装目录\n将brew 版本 替换为最新版本 tdlib\n1 2 3 4 5 6 7 8 9 10 11 # 拷贝 最新版库1.7.8拷贝到tdlib目录， cp -r ~/hsg/td/tdlib /usr/local/Cellar/tdlib/1.7.8 # 更新 1.7.0 软连接 删除久版本1.7.6 cd /usr/local//Cellar/tdlib ln -sf 1.7.8 1.7.0 rm -rf 1.7.6 # 删除旧版本库libtdjson.1.7.6.dylib 软连接 cd /usr/local/lib rm libtdjson.1.7.6.dylib # 创建新版软连接 ln -sf ../Cellar/tdlib/1.7.0/lib/libtdjson.1.7.8.dylib libtdjson.1.7.8.dylib 回到telega 执行：M-x telega\n","date":"2021-10-13T22:07:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/telega%E9%9B%86%E6%88%90%E5%88%B0emacs%E4%B8%AD/","section":"post","tags":null,"title":"emacs中使用telega客户端"},{"categories":["博客站务"],"contents":"理解卡片笔记法的原则 玩转 Obsidian | 打造知识循环利器 - 少数派\n对比使用目录和标签管理的弊端\n了解卡片的定义\n知识循环体系\n知识循环，指的是我们整理知识的目标一定是写作，在写作的过程中经历研究/阅读/记录和写作。\norg-roam V2升级问题相关\n作者概述：Releasing Org-roam v2 · Jethro Kuan\n网友尝鲜：在 Doom Emacs 中抢先体验 Org-roam V2 – 涂雨期的博客\nroam手册：Hitchhiker\u0026rsquo;s Rough Guide to Org roam V2 · org-roam/org-roam Wiki · GitHub\ndoom-emacs支持roam V2 hlissner/doom-emacs#5271 lang/org: Add +roam2 flag for org-roam v2 by Wetlize\norg-roam导出为hugo相关 Exporting Org Roam notes to hugo - Sidharth Arya\n","date":"2021-10-13T12:48:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/org-roam%E6%94%B9%E5%8F%98%E7%AC%94%E8%AE%B0%E4%B9%A0%E6%83%AF/","section":"post","tags":null,"title":"org-roam-v2迁移过程的预研"},{"categories":["日志随笔"],"contents":"拆页 默克尔的另一个“信条”，是严格遵循秩序，缜密制定计划。崇尚计划的缘起，或许也可以向她的孩提时代寻求解答：因为成长期间的“一个问题”，她在跑步及上下楼梯的过程中都很不顺利，算得上是一个“运动白痴”。为了避免尴尬和麻烦，她需要严格要求自己避免不必要的张望，专心探看脚下的路，每一步都要在计划内完成。\n阐述引导 崇尚计划，第一次听说计划的地位作为一个精神上的信条。\n激活经验 我做过这么的计划，tj3才真正的有了计划的影子，定目标，分解任务，演练过程，靠着想象力和愿景，激发自己积极主动的野心，经过两次创造，演练过程，做好计划，确定情感，并坚定做出承诺，信守承诺，将使命宣言和行动原则，牢记在生活中。\n谱写愿景 这种信条，其实坚守的是七个习惯，为要事第一服务，撰写信条，改写人生剧本，付出行动，将要事摆在第一位。\n","date":"2021-10-13T12:39:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E4%BA%BA%E7%89%A9%E4%BC%A0%E8%AE%B0--%E9%BB%98%E5%85%8B%E5%B0%94/","section":"post","tags":["anki"],"title":"默克尔总理的精神"},{"categories":["学习笔记"],"contents":"简介 禅道有三个版本:开源版 演示、专业版 演示 、企业版 演示\n专业版：禅道专业版使用帮助\n性价比 专业版与开源版对比\n愿景：禅道项目管理软件是做什么的？ 它集产品管理、项目管理、质量管理、文档管理、组织管理和事务管理于一体，是一款专业的研发项目管理软件，完整覆盖了研发项目管理的核心流程。禅道管理思想注重实效，功能完备丰富，操作简洁高效，界面美观大方，搜索功能强大，统计报表丰富多样，软件架构合理，扩展灵活，有完善的API可以调用。禅道，专注研发项目管理！\n管理思想简洁实效，可以帮助企业实现快速敏捷开发。 完善的社区机制，可以获得及时的技术支持和帮助。 禅道支持多种部署方式，可以私有部署，也可以选择云端服务。 Scrum原则：禅道项目管理软件的设计理念 禅道项目管理软件的主要管理思想基于国际流行的 敏捷项目管理方法—Scrum。Scrum方法注重实效，操作性强，非常适合软件研发项目的快速迭代开发。\nScrum只规定了核心的管理框架，还有很多细节流程需要团队自行扩充。禅道在遵循其管理方式基础上，结合国内研发现状，整合了bug管理，测试用例管理，发布管理，文档管理等功能，完整的覆盖了软件研发项目的整个生命周期。\n在禅道软件中，明确的将产品、项目、测试三者概念区分开，产品人员、开发团队、测试人员，三者分立，互相配合，又互相制约，通过需求、任务、bug来进行交相互动，终通过项目拿到合格的产品。\n主要功能 产品管理：包括产品、需求、计划、发布、路线图等功能。 项目管理：包括项目、任务、团队、版本、燃尽图等功能。 质量管理：包括bug、测试用例、测试任务、测试结果等功能。 文档管理：包括产品文档库、项目文档库、自定义文档库等功能。 事务管理：包括todo管理，我的任务、我的Bug、我的需求、我的项目等个人事务管理功能。 组织管理：包括部门、用户、分组、权限等功能。 统计功能：丰富的统计表。 搜索功能：强大的搜索，帮助您找到相应的数据。 扩展机制，几乎可以对禅道的任何地方进行扩展。 api机制，所见皆API，方便与其他系统集成。 资料 开源版：禅道开源版使用帮助\n专业版：禅道专业版使用帮助\n开源版本 禅道使用的基本流程和产品、研发、测试之间的三权分立 基本流程如下：\n产品经理创建产品 产品经理创建需求 项目经理创建项目 项目经理确定项目要做的需求 项目经理分解任务，指派到人。 测试人员测试，提交bug。 敏捷开发及scrum简介 敏捷开发 我们比较熟知的软件项目管理方法是瀑布。其基本流程是 需求-\u0026gt; 设计-\u0026gt;开发-\u0026gt;测试 。基本假设只要把每一个环节都做正确，那么终得到的结果也是正确的。\n瀑布开发有非常成功的案例，比如微软。但从总体来讲，瀑布项目失败率比较高。国外的软件先行者们针对瀑布开发中暴露出来的问题进行了一系列的探索、思考和总结，终提出了Agile的概念，中文翻译为敏捷开发。敏捷开发有很多种方式，其中scrum是比较流行的一种。\nscrum scrum里面的角色\nscrum由product owner(产品经理)、scrum master(项目经理)和team(研发团队)组成。\n其中product owner负责整理user story(用户故事)，定义其商业价值，对其进行排序，制定发布计划，对产品负责。 scrum master 负责召开各种会议，协调项目，为研发团队服务。 研发团队则由不同技能的成员组成，通过紧密协同，完成每一次迭代的目标，交付产品。 迭代开发与瀑布不同，scrum将产品的开发分解为若干个小sprint(迭代)，其周期从1周到4周不等，但不会超过4周。\n参与的团队成员一般是5到9人。每期迭代要完成的user story是固定的。每次迭代会产生一定的交付。\nscrum的基本流程\nscrum的基本流程如上图所示：\n产品负责人负责整理user story，形成左侧的product backlog。 发布计划会议：product owner负责讲解user story，对其进行估算和排序，发布计划会议的产出就是制定出这一期迭代要完成的story列表，sprint backlog。 迭代计划会议：项目团队对每一个story进行任务分解，分解的标准是完成该story的所有任务，终每个任务都有明确的负责人，并完成工时的初估计。 每日例会：每天scrum master召集站立会议，团队成员回答昨天做了什么今天计划做什么，有什么问题。 演示会议：迭代结束之后，召开演示会议，相关人员都受邀参加，团队负责向大家展示本次迭代取得的成果。期间大家的反馈记录下来，由po整理，形成新的story。 回顾会议：项目团队对本期迭代进行总结，发现不足，制定改进计划，下一次迭代继续改进，已达到持续改进的效果。 禅道和Scrum对应关系 概念的对应\nproduct:产品，禅道里面使用了产品的概念。 Scrum 禅道 备注 user story 需求 用户故事 sprint 项目 task 任务 team 团队 burndown 燃尽图 潜在交付物 发布 角色的对应 Scrum 禅道 product owner 产品经理 Scrum master 项目经理 team 团队成员 禅道新增的概念 ","date":"2021-10-13T12:30:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%A6%85%E9%81%93%E4%BD%BF%E7%94%A8%E5%85%A5%E9%97%A8/","section":"post","tags":["Archive"],"title":"禅道使用入门"},{"categories":["项目总结"],"contents":"立项 访问taskjuggler版本 连锁集团\n项目愿景 项目宣言 以终为始：两次创造，做第一创造者，改写剧本，确定项目目标愿景和项目宣言，做到在项目工期内，实现自我领导的效果。\n设里程碑 立flags 评审 UI 开发 提测发布 评审 需求评审 总公司/ 子公司和角色的关系：一个账户下，只能归属一种。 开发设计 设计时序图\n类图\n用例评审 开发 添加我的组织入口 [3/3] 功能code,平台配置：se_organization 跳转到选择组织身份页 跳转到组织管理 选择组织身份页 [2/2] 我要加入总公司栏 我要管理子公司栏 搜索页面 [6/6] 搜索功能实现 当选中时，显示加入按钮 toast提示:”加入成功”跳转到：组织管理页 支持分页：下拉显示更多 上下级相关逻辑：多选和单选 切换企业 管理我的下级页面 [10/10] 删除企业：清空时，跳转到【选择组织身份页】\n更换企业：跳转到【搜索页】\n分页：上下滑动查看更多信息；\n返回到入口页\n全选之后，再取消某个企业时，取消全选按钮的状态\n侧滑删除按钮背景色和icon\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 #pragma mark ---- 侧滑删除 //先要设Cell可编辑 - (BOOL)tableView:(UITableView *)tableView canEditRowAtIndexPath:(NSIndexPath *)indexPath { return YES; } - (UISwipeActionsConfiguration *)tableView:(UITableView *)tableView trailingSwipeActionsConfigurationForRowAtIndexPath:(NSIndexPath *)indexPath { if (@available (iOS 11, *)) { UIContextualAction *deleteAction = [UIContextualAction contextualActionWithStyle:UIContextualActionStyleDestructive title:@\u0026#34;删除\u0026#34; handler:^(UIContextualAction * _Nonnull action, __kindof UIView * _Nonnull sourceView, void (^ _Nonnull completionHandler)(BOOL)) { if (self.dataArray.count \u0026gt; indexPath.row) { self.chainModel = self.dataArray[indexPath.row]; [self delfirmAcion]; } completionHandler(YES); }]; deleteAction.image = [UIImage imageNamed:@\u0026#34;JHLivePlayBundle.bundle/unitorgdelbtn\u0026#34;]; deleteAction.backgroundColor = [UIColor colorFromHexRGB:@\u0026#34;FC681F\u0026#34;]; UISwipeActionsConfiguration *configuration = [UISwipeActionsConfiguration configurationWithActions:@[deleteAction]]; return configuration; } return nil; } 侧滑删除按钮背景高度一致问题\n前提在使用 UIContextualAction 方法实现侧滑按钮的情况下，要想满足侧滑按钮和cell 内边间距的内容高度一致，需要考虑一下两个问题：\ncell 上下间距有两种实现方式：\n常规的实现方式\n使用单个section, 返回多个cell, 在cell 中实现内边局和圆角，达到cell 上下间距的效果。\n这种方式，无法满足侧滑按钮高度和cell 内容高度一致。，无法配合 UIContextualAction 使用\n通过 tableView group 分组方式\n每个section 中只返回一个cell. 每个cell 就可以通过代理方法，获取对应的headerView 和 footerView.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 // 声明tableView style：UITableViewStyleGrouped _tableView = [[UITableView alloc]initWithFrame:CGRectZero style:UITableViewStyleGrouped]; // 返回section -(NSInteger)numberOfSectionsInTableView:(UITableView *)tableView { return self.dataArray.count; } //每个section返回单个row -(NSInteger)tableView:(UITableView *)tableView numberOfRowsInSection:(NSInteger)section { return 1; } // headerView 高度 -(CGFloat)tableView:(UITableView *)tableView heightForHeaderInSection:(NSInteger)section { return 12; } // 返回透明headerView -(UIView *)tableView:(UITableView *)tableView viewForHeaderInSection:(NSInteger)section { UIView *header = [UIView new]; header.backgroundColor = [UIColor clearColor]; return header; } // footerView高度为0.001 达到隐藏效果 -(CGFloat)tableView:(UITableView *)tableView heightForFooterInSection:(NSInteger)section { return 0.001; } // footerView 返回nil -(UIView *)tableView:(UITableView *)tableView viewForFooterInSection:(NSInteger)section { return nil; } 企业名浮动显示样式\nUILabel 中实现第二行缩进\n1 2 3 4 5 6 7 8 9 10 NSString *addr = [NSString stringWithFormat:@\u0026#34;地 址：%@\u0026#34;,model.address]; _name.text = name; //缩进 NSMutableParagraphStyle *para = [NSMutableParagraphStyle new]; para.alignment = NSTextAlignmentLeft; CGFloat emptylen = _addr.font.pointSize * 5; // para.firstLineHeadIndent = emptylen; para.headIndent = emptylen; NSMutableAttributedString *muAttr = [[NSMutableAttributedString alloc] initWithString:addr attributes:@{NSFontAttributeName: [UIFont systemFontOfSize: 15],NSForegroundColorAttributeName: [UIColor colorFromHexRGB:@\u0026#34;333333\u0026#34;],NSParagraphStyleAttributeName:para}]; _addr.attributedText = muAttr; 效果：\nalert 样式优化\n自定义JHAlertViewController github源码\n模态一个透明的控制器的方法\n1 2 3 4 5 6 7 8 9 // 核心代码 presentVC.view.backgroundColor = [UIColor colorWithRed:0 green:0 blue:0 alpha:0.3]; // 可以使用的Style // UIModalPresentationOverCurrentContext // UIModalPresentationOverFullScreen // UIModalPresentationCustom // 使用其他Style会黑屏 presentVC.modalPresentationStyle = UIModalPresentationOverCurrentContext; [self presentViewController:presentVC animated:YES completion:nil]; 圆角+阴影实现\niOS 给layer同时添加mask和shadow - 简书\n使用子类 JHShapeView.m 支持圆角，再单独添加阴影\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 -(instancetype)initWithCorners:(UIRectCorner)corners radii:(CGSize)radii { if (self = [self init]) { _corners = corners; _radii = radii; } return self; } //.m中实现贝塞尔曲线绘制圆角 -(void)layoutSubviews { [super layoutSubviews]; UIBezierPath *maskPath = [UIBezierPath bezierPathWithRoundedRect:self.bounds byRoundingCorners:_corners cornerRadii:_radii]; ((CAShapeLayer *)self.layer).path = maskPath.CGPath; } 单独阴影\n1 2 3 4 5 6 7 //声明圆角视图 self.alertView = [[JHShapeView alloc] initWithCorners:UIRectCornerBottomLeft|UIRectCornerTopRight|UIRectCornerBottomRight radii:CGSizeMake(14, 14)]; self.alertView.layer.shadowColor = [UIColor colorWithWhite:0 alpha:0.07].CGColor; self.alertView.layer.shadowOffset = CGSizeMake(0, 0); self.alertView.layer.shadowOpacity = 1; self.alertView.layer.shadowRadius = 8; 管理我的上级页面 [6/6] 删除企业：清空时，跳转到【选择组织身份页】 更换企业：跳转到【搜索页】 分页：上下滑动查看更多信息； 返回到入口页 企业选择仅支持单选 底部全选按钮设置为不可用 联调接口 [6/6] Swagger UI\nCheckEnterChain 校验门店是否存在组织关系 AddEnterChain 添加门店组织绑定关系 DelFirmChain 删除门店绑定关系 ModifyFirmChain 修改门店组织绑定关系 GetEnterChainList 查询门店组织关系列表 GetFirmChainList 门店组织关系绑定查询企业列表 提测发布 合并分支 live库：连锁集团 部署产品线：企业经营线 合并主工程：a库/bundle ，分支名：连锁集团 ","date":"2021-10-11T18:26:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E8%BF%9E%E9%94%81%E9%9B%86%E5%9B%A2/","section":"post","tags":null,"title":"连锁集团"},{"categories":["我的思维"],"contents":"","date":"2021-09-13T12:18:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/%E5%9F%B9%E5%85%BB%E5%AF%8C%E4%BA%BA%E6%80%9D%E7%BB%B4/","section":"post","tags":null,"title":"富人思维"},{"categories":["学习笔记"],"contents":" \u0026#30446;\u0026#24405; 目的 安装过程 游戏规则 《富爸爸穷爸爸》里的3张图-泽图专题 其他概念 体验游戏 目的 游戏的最终目的是使被动收入（非工资收入）大于总支出。在游戏中体会不同投资方式，生活方式带来的影响，从游戏中进行财商培养，总结。\n这款游戏与我们有什么关系?为什么我们要玩这款游戏?\n原因在于因为我们想要实现自己的财务自由,而要实现我们的财务自由,我们需要提高自己的财务智商。\n这套游戏就是一个很好的提高我们的财务智商的工具。所以我们所有想通过投资理财来实现自己的财务自由的人,最好都能亲自体验一下这个游戏。\n这款游戏,你玩得越多,你就越能提高你的财务智商,同时提高识别和把握你身边机会的能力。\n通过这套游戏,你可以:\n学会正确的投资思考模式,自我修正投资观念,找到实现财务自由的关键; 模拟真实人生历程,坦然面对变化。学习应对挑战,做出最好的投资以及理财决策; 开启自己的投资理财天赋,提高财务智商,迈向财务自由; 传授给你爱的人,让现金流游戏成为创造财务自由的工具。 安装过程 现金流游戏.exe下载： b站教程，存储在百度云盘\n破解版虚拟机下载：电报破解圈下载，出现无法打开的情况。\ncrossover 运行exe: 电报中破解圈下载\n手机版cashflow: 上传到 资源收集 圈\n游戏规则 现金流游戏共有两个游戏圈,一个是我们耳熟能详“老鼠赛跑”圈,另一个则是取得财务自由之人所在的快车道。\n这两种游戏圈其实代表了两种思维方式和两种生活方式。\n在“老鼠赛跑”圈内人们为金钱而工作,每月的支出主要靠工资来维持,没有属于自己的资产,或者虽有资产但带来的收入还不足以维持家庭的花费,所以只能在“老鼠赛跑”之中求生存。\n在快车道的人们是已经取得了财务自由的人,他们已经脱离了靠工资维持生活的思维方式,因为他们的收入主要是靠他们创造的资产带来的,他们的经济生活方式只是不断地创造更多的资产。\n获胜方式\n这个游戏的获胜的要求是:\n在“老鼠赛跑”中尽快获得资产收入,当你的资产收入超出你的总支出的时候,你就跳出了“老鼠赛跑”的陷阱,并进入了快车道。 如果你能在快车道实现你的梦想或者月现金流增加五万以上,你就获得了比赛的胜利。 当然了,在具体的游戏中,还有很多其他的规则,有些规则纯粹是为了娱乐,有些规则却能折射出我们的现实。关于如何了解这些规则,以及玩现金流游戏的步骤,请参考我的帖子,这里不再赘述。 现金流游戏-泽图专题\n《富爸爸穷爸爸》里的3张图-泽图专题 其他概念 格子种类\n可抽卡片类：小生意（有房地产、股票、基金、优先股、嫂子借钱、金币等）、大买卖（需要有6000元以上的美金）、市场风云、额外支出\n纯支出类：银行结算日，慈善，生孩子，失业\n损益表、资产负债表\n损益表：收入，支出。总收入-总支出=现金流。\n资产：股票、基金、房产。单价，首期支付、总成本\n负债：贷款\n体验游戏 富爸爸现金流游戏最全的玩法介绍与总结——人人都能做银行家！ - 简书 温州现金流游戏线下活动第一期银行家总结 - 简书\n","date":"2021-09-10T18:44:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/cashflowgame-%E6%B8%B8%E6%88%8F%E8%A7%84%E5%88%99%E4%BB%8B%E7%BB%8D/","section":"post","tags":null,"title":"cashflow现金流游戏教程"},{"categories":["学习笔记"],"contents":" \u0026#30446;\u0026#24405; 术语 报表工具 术语 Beancount读记 · GitHub\n损益表：Income Statement\n将一段时间内所有Income和Expenses类账号相关的transaction都找出来，然后将Income和Expenses相关部分的posting加起来. 就得到了Income和Expenses在此段时间内的所有账号的变化量总和.\nIncome和Expenses的总和相减,就得到 Net Income(净收入),用于交税或评估公司盈利能力.\n试算表：Trial Balance\n将所有的Accounts分类后,将所有posting的值相加起来,只显示最后的账号balance的列表.\n作用: 简单的反映每个账号在某个时间点的Balance情况. 同时所有账号balance的值加起来肯定为0. 通常用于财务计算是否存在简单的记录错误.\n收入清算：Clearing Income\n在做Income Statement之前,都需要进行 Clearing Income\n资产负债表：Baleance Sheet\n关心的是个人的资产与负债,作用是回答 \u0026ldquo;Where\u0026rsquo;s my money?\u0026rdquo; 的问题，只关注Assets和Liabilities的账号,将所有Assets和Libilities账号的balances列出来\n净值：Net Worth\nNet worth所代表的含义是: 当我们将所有的负债都清理后,我们的剩余有多少?\nNet Worth = Assets - Liabilities\n将所有的Assets和Liabilities的账号的balance都加起来,然后 Assets - Liabilities 就是净值.\n假如所有的 Income和Expenses的Accounts都被清算为零,所有的balances都转移到Equity的账号.那么Net Worth应该与所有 Equity账号balance的总和.\n报表工具 Grab Rich Dad financial literacy and cash flow tools here.\n个人财务计算器\n获取清晰且最新的财务报告卡快照。这份个人财务报表与 CASHFLOW 游戏中使用的记分卡非常相似。当您每月或每季度在损益表和资产负债表上填写数字时，电子表格将分析您现在所处的位置，并为您指明需要做什么才能实现财务自由。\n房地产评估员\n什么是好交易，什么是坏交易？Real Estate Evaluator 是一种快速简便的工具，可用于分析任何潜在的房地产投资，而无需实际前往该物业。\n填写必要的数字后，系统会自动为您完成分析。当您更改任何数字时，您将立即看到底线的效果。\n在您采取行动并迈向财务自由的旅程时，做出更明智、更明智的决定！\nBI三角\n商业智能三角对于企业家或投资者的成功至关重要。\n（BI 指现金流象限中的企业主和投资者象限。）使命、团队和领导力的外部完整性框架并支持内部五个完整性。请注意，现金流是“底线”。\n在现金流®象限\n在现金流®象限定义不同的人如何产生收入或金钱。\n在左侧，E（雇员）和 S（个体经营者或专家）专注于赚取收入，并非常重视安全可靠的工作或职业。\n在右侧，B（企业主）和 I（投资者）专注于创造资产以利用其他人的时间和金钱来提供他们的收入来源。最重要的是，他们重视财务自由。\n现金流棋牌游戏：老鼠赛跑\u0026ndash;个人财务报表\n富爸爸说：“要致富，就得懂数字。” 这就是为什么个人财务报表是您离开学校后的“成绩单”的原因。\n损益表、资产负债表和每月现金流中的数字说明了现金流的流向。\n现金流棋牌游戏：快速通道-个人财务报表\n啊丰富的生活。没有什么比这更像的。一旦您在 CASHFLOW 中逃离老鼠赛跑，您将需要使用所有这些额外的零来跟踪您的银行帐户。\n现金流棋盘游戏：现金分类账单\n在您玩了几十次 CASHFLOW 之后，您可能想要加快游戏速度。下载更多版本的现金分类帐，让您的财务状况井井有条。\n腾讯文档 x微软office模版\n","date":"2021-09-10T15:03:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E7%90%86%E8%B4%A2%E6%8A%95%E8%B5%84%E6%9C%AF%E8%AF%AD%E5%92%8C%E6%8A%A5%E8%A1%A8/","section":"post","tags":null,"title":"Beancount 常用术语和报表模版"},{"categories":["学习笔记"],"contents":"目的 学习emacs 中搜索和替换字符串的方法\n使用find-grep-dired 在指定的目录中批量替换字符串的操作流程\nEmacsWiki: Dired Search And Replace\n例如：在文件夹/dirA下替换str1为str2\noperation: M+x \u0026mdash;\u0026gt; find-grep-dired \u0026mdash;\u0026gt; str1 \u0026mdash;-\u0026gt; t \u0026mdash;-\u0026gt; Q \u0026mdash;-\u0026gt; str1 \u0026mdash;\u0026gt; str2 \u0026mdash;\u0026gt; 逐个确认是否替换；\n替换完成后保存替换： Ctrl + x \u0026ndash;\u0026gt; s\nnotice： ^ 逆向搜索，只能在本文件中进行，无法跨文件\ndoom 下，快捷键绑定\n1 2 3 ;;绑定快捷键 (map! :leader :desc \u0026#34;搜索替换文本\u0026#34; \u0026#34;sg\u0026#34; #\u0026#39;find-grep-dired) ;; 这个快捷键是SPC s g 全文替换 一字字替换：query-replace 正则替换： replace-regexp 搜索 文件名搜索 find-dired\nfind-grep-dired 递归所有子目录\ngrep 在当前目录中查找指定的 regexp\n文本搜索替换 grep-find 显示包含字段的行，递归子目录\n","date":"2021-09-09T18:19:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/find-grep-dired/","section":"post","tags":null,"title":"find-grep-dired在目录中批量替换字符串"},{"categories":["解决方案"],"contents":" \u0026#30446;\u0026#24405; 启发 开发bot 机器人 启发 在了解现金流游戏的过程，意外发现记账工具costflow 结合telegram 机器人，实现记账功能的方法。\n所以，萌生了通过swift 方式，开发个人机器人的想法，就有了这篇样例文章。\n先说下结果，swift 开发流程已经调通，本文仅介绍到swift 环境配置过程遇到的问题。在最后联调机器人时，出现了timeout 错误，还没有解决：\n1 2 endpoint: getMe, data: Unable to fetch bot information: Libcurl error 28: Timeout was reached 主要参考的文章：\nBots: An introduction for developers\nGitHub - rapierorg/telegram-bot-swift: Telegram Bot SDK for Swift (unofficial)\n使用 Telegram Bot + Beancount 记账 | Ahonn's Blog\n开发bot 机器人 主要基于 Xcode13 介绍 swift package manager 创造项目，并集成 TelegramBotSDK 库\n1 2 3 mkdir hello-bot cd hello-bot swift package init --type executable 配置依赖：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 // swift-tools-version:5.5 // The swift-tools-version declares the minimum version of Swift required to build this package. import PackageDescription let package = Package( name: \u0026#34;todo-bot\u0026#34;, products: [ .executable( name: \u0026#34;todo-bot\u0026#34;, targets: [\u0026#34;todo-bot\u0026#34;] ), ], dependencies: [ // Dependencies declare other packages that this package depends on. // .package(url: /* package url */, from: \u0026#34;1.0.0\u0026#34;), .package(url: \u0026#34;https://github.com/zmeyc/telegram-bot-swift.git\u0026#34;, from: \u0026#34;2.0.0\u0026#34;), ], targets: [ // Targets are the basic building blocks of a package. A target can define a module or a test suite. // Targets can depend on other targets in this package, and on products in packages this package depends on. .executableTarget( name: \u0026#34;todo-bot\u0026#34;, dependencies: [ .product(name: \u0026#34;TelegramBotSDK\u0026#34;, package: \u0026#34;telegram-bot-swift\u0026#34;), ]), .testTarget( name: \u0026#34;todo-botTests\u0026#34;, dependencies: [\u0026#34;todo-bot\u0026#34;]), ] ) 注意，在设置target 依赖时，要设置对象，指明依赖库的 name ： .product(name: \u0026quot;TelegramBotSDK\u0026quot;, package: \u0026quot;telegram-bot-swift\u0026quot;),\n在调制 main.swift 文件时，部分接口已经过时，更新为最新：\n1 2 3 4 5 6 7 8 9 10 11 12 13 //从环境变量中读取token //let token = readToken(from: \u0026#34;iTodos_BOT_TOKEN\u0026#34;) //token 格式： 数字:字母 let token = \u0026#34;*****:AAHqvrTKBtQcNHHreYWHmEW****\u0026#34; let bot = TelegramBot(token: token) while let update = bot.nextUpdateSync() { if let message = update.message, let text = message.text, let from = message.from { bot.sendMessageAsync(chatId: .chat(from.id), text: \u0026#34;Hi \\(from.firstName)! You said: \\(text).\\n\u0026#34;) } } fatalError(\u0026#34;Server stopped due to error: \\(bot.lastError)\u0026#34;) 执行build 并运行：\n1 2 3 4 5 6 swift build ./.build/x86_64-apple-macosx10.10/debug/iTodos-bot #打印： \u0026gt;endpoint: getMe, data: \u0026gt;Unable to fetch bot information: Libcurl error 28: Timeout was reached ","date":"2021-09-09T16:19:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/telegam%E6%9C%BA%E5%99%A8%E4%BA%BA%E5%BC%80%E5%8F%91/","section":"post","tags":null,"title":"使用swift开发telegram机器人方案"},{"categories":["项目总结"],"contents":" \u0026#30446;\u0026#24405; 知识点 行动 总结 猜谜游戏，用来记住世界上的很多标志。\n知识点 stacks, buttons, images, alerts, asset catalogs, and more.\n行动 创建GuessTheFlag项目。 Using stacks to arrange views Colors and frames Gradients Buttons and images Showing alert messages 总结 ","date":"2021-09-08T15:35:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E7%8C%9C%E6%97%97%E5%AD%90%E9%A1%B9%E7%9B%AE%E5%BC%80%E5%8F%91/","section":"post","tags":null,"title":"猜旗子"},{"categories":["项目总结"],"contents":" \u0026#30446;\u0026#24405; 知识点： 知识点： WeSplit简介 了解SwiftUI应用的基本架构 创建表格 添加导航条 修改程序状态 将状态绑定到用户界面控件 循环创建视图\n从TextField中读取文本 在表单中创建选择器 为小费添加百分比分段控件 计算每人的总数 为小费百分比添加分段控件计算每人的总数\n","date":"2021-09-08T15:32:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E9%A1%B9%E7%9B%AEweSplit%E5%AD%A6%E4%B9%A0%E6%80%BB%E7%BB%93/","section":"post","tags":null,"title":"WeSplit"},{"categories":["学习笔记"],"contents":" \u0026#30446;\u0026#24405; 目的 使用 问题 目的 在学习taskjuggler 工具过程中，碰巧一起学习emacs 中绘制甘特图的工具elgantt.\n在taskjuggler 实战中积累了一些技巧经验，认识到taskjuggler 基础用法和功能。它通过导出org 文件中的属性信息，创建网页版预览任务进度。整体预览效果比较好。\n回顾下tj3主要相关的字段. 项目基础信息，设置起始时间，设置每天工作时长，指定工作时间段，启动基准功能。\n任务信息：project 标签指定导出的项目，依赖项，优先级，评估量，持续时间 资源模块：分配资源 里程碑：设置依赖 具体信息可以参考：使用tj3 制定周计划培养七习知识体系\n使用 总之，甘特图三要素：任务，时间（开始，结束，里程碑），资源（人、机器、资金）。在三个素材之间找到平衡点，合理分配任务，规划资源就好。\n当看到elgantt 工具，是基于emacs 中绘制甘特图的功能，有灵活的自定义方式，能够很好的呈现甘特图的相关信息。\n现在说下，从README.md 中了解的几个功能点：\n安装和相关设置\n1 2 3 4 5 (package! elgantt :recipe (:host github :repo \u0026#34;legalnonsense/elgantt\u0026#34;)) (package! org-ql :recipe (:host github :repo \u0026#34;alphapapa/org-ql\u0026#34;)) 扩展elgantt 支持属性\n1 2 3 4 5 6 7 8 9 10 ;;========扩展elgantt的属性 (elgantt-create-display-rule add-org-properties-display :parser ( (elgantt-priority . ((org-entry-get (point) \u0026#34;PRIORITY\u0026#34;))) (elgantt-effort . ((org-entry-get (point) \u0026#34;Effort\u0026#34;))) (elgantt-blocker . ((org-entry-get (point) \u0026#34;BLOCKER\u0026#34;))) (elgantt-TOTAL_PAGES . ((org-entry-get (point) \u0026#34;TOTAL_PAGES\u0026#34;))) (elgantt-PAGES_READ . ((org-entry-get (point) \u0026#34;PAGES_READ\u0026#34;))) ) :body (())) ;; insert code here, which can use elgantt-priority variable 设置展示内容的起始日期设置展示的最早的时间点，相对tj3不支持设置项目工期。\n1 2 ; 设置展示内容的起始日期 (setq elgantt-start-date \u0026#34;2020-01-01\u0026#34;) 可以设定预览时，直接调到显示当前月份位置。\n1 elgantt-scroll-to-current-month-at-startup t 连线：根据相同特性，通过连线，显示之间的关系 hashtag 对应org 中的tag 必须添加井号 如:#tag:\n绘制阅读进度条\n绘制进度\n相比taskjuggler 功能简单，能满足查看任务简单的时间线，查看任务之间的关系，可以根据关注内容，定制不同的显示样式：outline,hashtag 等。\n支持加载多个org 文件，可以快速定位到任务位置。\n可以扩展字段，根据字段绘制进度条等样式。\n看了两天的readme, 一点点跟着操作，可以很快的掌握相关技巧。\n接下来，就是专注使用tj3 ，制定计划，规划任务进度。先熟练了在项目管理的概念，摸索实际中能快速实践的方法，然后，在扩展elgantt，目前的使用场景，当作日历，查看进度条，具体任务规划，严格按照tj3 来实现。\n问题 当出现中文时，elgantt 视图无法对齐。\nhashtag ：添加tag 时，必须井号（#）开始。 :#tag:\n","date":"2021-09-06T17:44:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/elgantt%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","section":"post","tags":null,"title":"学习elgantt.el"},{"categories":["周报"],"contents":"每天拿出半个小时，确定一天要做什么要事第一的原则要铭记愿景，才能提高行动力使用emacs 管理任务，用番茄钟记录时间购房计划理财计划阅读计划不要忘记，想要成为的什么样的人。要刻骨铭心，激发欲望和行动战斗力。\n该怎么牢记初心，形成使命宣言，时刻提醒自己要做的准则，以原则为中心，行使自己的责任。\n我这几个月在做什么，是否会影响今天和明天的选择，是否有必要浪费时间和精力在以前的事情上。没有必要。过去的事情就让过去，不要把情绪带到下一件事情上来。我学会割舍。\n牢记：每日反省为什么会中断，中间发了什么，让你放弃了自己坚持的事情。我想想我这几个月做了什么吧。为了避免再发生这种状态掌控自己的风险。主要在emacs 花费了太多的精力。增加了那些功能呢？ roam2 支持。卡片思想的了解和熟悉，搭建知识体系的重要性。 trime 定制键盘，在android 手机上快速整理收集灵感，了解了状态栏定制，事件绑定，练习公园内计划任务的能力。理财记账的能力的学习。学习了十二天小白课程。掌握beanncount 复式记账法的用途。这是在不知情的情况下，增加的附属内容，也是花费大量精力的地方。\n这几个知识点，在操作中，了解了相关内容和知识，有了基本的概念，要想扎根知识体系，要需要分析整理相关重要的内容，梳理他们的具体知识脉络。\n想锻炼思维，可以借助拆为己用的结构，激发一些思想上判断能力。让眼睛更加明亮，看透现实。\n如何从这里面提炼出重要的事情和原则，让后，写下愿景，展望未来，任务分解，付出行动，做到就好了。\n要事是什么，要遵守那些原则，该怎么坚持这些原则，初步愿景是什么？\n使用emacs 管理任务，坚持使用番茄钟记录时间的使用情况。 使用复式记账法，统计个人消费，熟悉个人财务问题，坚持使用复式记帐法，熟练分析消费状态。 学习swift 开发，熟练应用swift 开发的流程和思维方式。\n不做无用的阅读，阅读就要锻炼大脑，给出准确的分析。\n坚持使用拆为己用笔记法，锻炼大脑思考的逻辑。逻辑思维的能力。\n我的愿景\n我希望通过阅读提高，逻辑思维能力，提高知识体系的架构。\n我想通过emacs 的技巧工具，管理时间使用的效率，提高效能。\n我想通过学习 swift 掌握职业技能，提高自身竞争力。\n我的承诺\n在一周内，熟练应用emacs 管理工具，列出统计一周的时间利用效率。\n坚持使用拆为己用原则，提高阅读理解能力，架构自己的知识体系。\n坚持使用emacs ，番茄钟记录时间的消耗情况，分析提高工作效率。\n使用swift 提高技能竞争力。\n我的计划借助七习解锁要事第一的执行力，知道哪些事情应该摆在第一位，做到要事第一的决心和果断。\n阅读七习的习惯二，以终为始，两次创造，自我领导。做到矫正自己的生活中心，确定检查的方式，养成检查的习惯，每天演练这个过程，矫正生活中心。经过坚持确定校准，确定自己真正的生活中心是什么？\n计划阅读七个习惯的习惯二阅读拆读激活经验谱写愿景\n","date":"2021-09-01T11:38:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%91%A8%E6%8A%A5/%E5%B0%9D%E8%AF%95%E9%87%8D%E6%96%B0%E9%98%85%E8%AF%BB%E4%B8%83%E4%B9%A0%E5%85%88%E8%AE%A1%E5%88%92%E8%A7%84%E8%8C%83%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/","section":"post","tags":null,"title":"重新阅读七个习惯，提高习惯三的执行力"},{"categories":null,"contents":"每天拿出半个小时，确定一天要做什么要事第一的原则要铭记愿景，才能提高行动力使用emacs 管理任务，用番茄钟记录时间购房计划理财计划阅读计划不要忘记，想要成为的什么样的人。要刻骨铭心，激发欲望和行动战斗力。\n该怎么牢记初心，形成使命宣言，时刻提醒自己要做的准则，以原则为中心，行使自己的责任。\n我这几个月在做什么，是否会影响今天和明天的选择，是否有必要浪费时间和精力在以前的事情上。没有必要。过去的事情就让过去，不要把情绪带到下一件事情上来。我学会割舍。\n牢记：每日反省为什么会中断，中间发了什么，让你放弃了自己坚持的事情。我想想我这几个月做了什么吧。为了避免再发生这种状态掌控自己的风险。主要在emacs 花费了太多的精力。增加了那些功能呢？ roam2 支持。卡片思想的了解和熟悉，搭建知识体系的重要性。 trime 定制键盘，在android 手机上快速整理收集灵感，了解了状态栏定制，事件绑定，练习公园内计划任务的能力。理财记账的能力的学习。学习了十二天小白课程。掌握beanncount 复式记账法的用途。这是在不知情的情况下，增加的附属内容，也是花费大量精力的地方。\n这几个知识点，在操作中，了解了相关内容和知识，有了基本的概念，要想扎根知识体系，要需要分析整理相关重要的内容，梳理他们的具体知识脉络。\n想锻炼思维，可以借助拆为己用的结构，激发一些思想上判断能力。让眼睛更加明亮，看透现实。\n如何从这里面提炼出重要的事情和原则，让后，写下愿景，展望未来，任务分解，付出行动，做到就好了。\n要事是什么，要遵守那些原则，该怎么坚持这些原则，初步愿景是什么？\n使用emacs 管理任务，坚持使用番茄钟记录时间的使用情况。 使用复式记账法，统计个人消费，熟悉个人财务问题，坚持使用复式记帐法，熟练分析消费状态。 学习swift 开发，熟练应用swift 开发的流程和思维方式。\n不做无用的阅读，阅读就要锻炼大脑，给出准确的分析。\n坚持使用拆为己用笔记法，锻炼大脑思考的逻辑。逻辑思维的能力。\n我的愿景\n我希望通过阅读提高，逻辑思维能力，提高知识体系的架构。\n我想通过emacs 的技巧工具，管理时间使用的效率，提高效能。\n我想通过学习 swift 掌握职业技能，提高自身竞争力。\n我的承诺\n在一周内，熟练应用emacs 管理工具，列出统计一周的时间利用效率。\n坚持使用拆为己用原则，提高阅读理解能力，架构自己的知识体系。\n坚持使用emacs ，番茄钟记录时间的消耗情况，分析提高工作效率。\n使用swift 提高技能竞争力。\n我的计划借助七习解锁要事第一的执行力，知道哪些事情应该摆在第一位，做到要事第一的决心和果断。\n阅读七习的习惯二，以终为始，两次创造，自我领导。做到矫正自己的生活中心，确定检查的方式，养成检查的习惯，每天演练这个过程，矫正生活中心。经过坚持确定校准，确定自己真正的生活中心是什么？\n计划阅读七个习惯的习惯二阅读拆读激活经验谱写愿景\n","date":"2021-09-01T11:38:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E5%B0%9D%E8%AF%95%E9%87%8D%E6%96%B0%E9%98%85%E8%AF%BB%E4%B8%83%E4%B9%A0%E5%85%88%E8%AE%A1%E5%88%92%E8%A7%84%E8%8C%83%E8%AF%BE%E7%A8%8B%E5%AD%A6%E4%B9%A0/","section":"post","tags":null,"title":"重新阅读七个习惯，提高习惯三的执行力"},{"categories":["周报"],"contents":" Table of Contents 养成七个习惯的应该怎么实施？ 素材的获取 回顾之前失败的原因在哪里？ 入手 确定要做哪些思想上的改变，带着目的阅读七个习惯的书籍。\n目前知道的习惯一：积极主动。习惯二：以终为始。习惯三：要事第一。三个习惯里面，要确定补救的一个习惯。\n我现在的计划是，在过去的日记中寻找痕迹，汇总之前的反思，激活经验，重新提高对七个习惯的理解，达到七个习惯改变生活的目的。\n这样似乎并不靠谱。\n以前的反思，有可能都是吐槽，参考价值很低，不但没有收获，更有可能耽误了七个习惯的学习。\n养成七个习惯的应该怎么实施？ 模仿亿学堂的实践安排来练习七个习惯，锻炼思维方式。锻炼思维。富人思维。\n锻炼的技巧就是，阅读，读后感，拆为己用的方式来训练富人思维。\n我现在要的也是思维方式的锻炼，所以可以使用亿学堂的方式来计划十二天的任务。\n素材的获取 参考亿学堂，提供一篇在线文章，要求大家输出读后感和经历感受，将要通过什么方式提高自己的辨别能力\n早上：富人思维\n中午：防骗\n晚上：课堂学习，类似阅读读后感。\n可以参考亿学堂的学时安排，素材来源网上的想了解的资源问题。\n在七个习惯中，以课本为素材，每天又固定的实践读书学习和练习。\n明确在关注圈，确定影响圈，每天审视一下当前的状态，是否在影响圈内活动\n读书 编程 理财 聊天 这是借鉴的成功的教书方式，督促学习的技巧，在过程中会遇到哪些问题。\n早上7 点早读，读后感，拆为己用关注圈 \u0026ndash; 影响圈使命宣言原则\u0026ndash; 为什么会迷茫，应为目标的多重和不确定，是无法激发真实的动力，只有以原则为中心才能实现拆为己用思维场景\n中午，复盘回顾，总结\n阅读，七个习惯，认真练习分析个人的生活状态和目标\n坚持8 天课程，实现的预期结果\n下一步：制定阅读计划，为养成七个习惯，坚持几天的课程，改变自己的现状。用这种方式，打开不同知识体系的大门。学习力的实战。\n回顾之前失败的原因在哪里？ 没有确切的目标计划，没有可评估的机制，没有策划一堂课的能力。\n制定课程表 思维锻炼 swiftUI 开发 购房计划 通过三种项目，分解任务作出计划安排。 这样就用到了tj3 项目管理的机制 入手 跟着亿学堂的课程表，列出gantt 图的流程。每天检查更新进度。发布博客。\n分解任务：参考亿学堂的方式，设定目标，切分12 课时，每堂课的要求和与原则，目标。\n每天时间安排 05-08 09-10 12-13 17-19 20-22\n如何让使命能够得到实施\n铭记使命，撰写使命宣言\n铭记要成为什么样的人\n每天都要熟悉一次自己的目标，铭记的办法，每天看，每天读，每天培养一周的角色和目标：阅读者，开发者，理财者，管理者，高效者一天要检查的状态：日周任务状态，思维状态，读书状态，目标状态一天要使用的工具：使用tj3,agenda,番茄钟，roam 知识体系一天要坚持的思维：拆为己用，以终为始，要事第一，积极主动一天要有的结果：博客总结，复盘一天\n理论状态检查，反省\n计划：在以终为始的基础上，确定生活中心，原则，明确目标和愿景。通过心灵演练加深愿景，激发想象力，改善、创造环境，激发积极主动性，认识到责任感，使命感的意义，铭记目标和职责使命。根据要事第一的原则，确定目标任务的优先级，分解任务到可执行，可实现，能够铭记使命，解决困难，向目标努力。\n这就是我的理想状态，在emacs 的加持下，能够沉浸式的进入最佳的工作状态，完成预期的目标计划。\n这些属于要事第一的范畴： emacs 管理者，这一项基本告一段落。 tj3 需要一些管理知识的支持，这样在实现目标的过程中可能受到的哪些元素的影响，导致任务延期等。例如：时间，资源，假期，等甘特图相关的任务。\n要使用tj3 管理任务，需要考虑哪些问题？习惯，知识体系按照roam 卡片的形式管理，学习，积累。那是否适合使用管理方法呢。 tj3 特点是在org 单个文件中管理，用id 来代表一个任务。\n一天内的时间节点： 5-8 9-12 13-17 17-19 20-22\n积极主动，以终为始，要事第一 把个人使命宣言写出来，打印好，并设置成屏保\n","date":"2021-09-01T11:26:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%91%A8%E6%8A%A5/%E7%A1%AE%E5%AE%9A%E9%87%8D%E8%A6%81%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E5%9F%B9%E5%85%BB%E9%94%BB%E7%82%BC%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4/","section":"post","tags":null,"title":"确定重要的思维方式着重目标培养习惯"},{"categories":null,"contents":" Table of Contents 养成七个习惯的应该怎么实施？ 素材的获取 回顾之前失败的原因在哪里？ 入手 确定要做哪些思想上的改变，带着目的阅读七个习惯的书籍。\n目前知道的习惯一：积极主动。习惯二：以终为始。习惯三：要事第一。三个习惯里面，要确定补救的一个习惯。\n我现在的计划是，在过去的日记中寻找痕迹，汇总之前的反思，激活经验，重新提高对七个习惯的理解，达到七个习惯改变生活的目的。\n这样似乎并不靠谱。\n以前的反思，有可能都是吐槽，参考价值很低，不但没有收获，更有可能耽误了七个习惯的学习。\n养成七个习惯的应该怎么实施？ 模仿亿学堂的实践安排来练习七个习惯，锻炼思维方式。锻炼思维。富人思维。\n锻炼的技巧就是，阅读，读后感，拆为己用的方式来训练富人思维。\n我现在要的也是思维方式的锻炼，所以可以使用亿学堂的方式来计划十二天的任务。\n素材的获取 参考亿学堂，提供一篇在线文章，要求大家输出读后感和经历感受，将要通过什么方式提高自己的辨别能力\n早上：富人思维\n中午：防骗\n晚上：课堂学习，类似阅读读后感。\n可以参考亿学堂的学时安排，素材来源网上的想了解的资源问题。\n在七个习惯中，以课本为素材，每天又固定的实践读书学习和练习。\n明确在关注圈，确定影响圈，每天审视一下当前的状态，是否在影响圈内活动\n读书 编程 理财 聊天 这是借鉴的成功的教书方式，督促学习的技巧，在过程中会遇到哪些问题。\n早上7 点早读，读后感，拆为己用关注圈 \u0026ndash; 影响圈使命宣言原则\u0026ndash; 为什么会迷茫，应为目标的多重和不确定，是无法激发真实的动力，只有以原则为中心才能实现拆为己用思维场景\n中午，复盘回顾，总结\n阅读，七个习惯，认真练习分析个人的生活状态和目标\n坚持8 天课程，实现的预期结果\n下一步：制定阅读计划，为养成七个习惯，坚持几天的课程，改变自己的现状。用这种方式，打开不同知识体系的大门。学习力的实战。\n回顾之前失败的原因在哪里？ 没有确切的目标计划，没有可评估的机制，没有策划一堂课的能力。\n制定课程表 思维锻炼 swiftUI 开发 购房计划 通过三种项目，分解任务作出计划安排。 这样就用到了tj3 项目管理的机制 入手 跟着亿学堂的课程表，列出gantt 图的流程。每天检查更新进度。发布博客。\n分解任务：参考亿学堂的方式，设定目标，切分12 课时，每堂课的要求和与原则，目标。\n每天时间安排 05-08 09-10 12-13 17-19 20-22\n如何让使命能够得到实施\n铭记使命，撰写使命宣言\n铭记要成为什么样的人\n每天都要熟悉一次自己的目标，铭记的办法，每天看，每天读，每天培养一周的角色和目标：阅读者，开发者，理财者，管理者，高效者一天要检查的状态：日周任务状态，思维状态，读书状态，目标状态一天要使用的工具：使用tj3,agenda,番茄钟，roam 知识体系一天要坚持的思维：拆为己用，以终为始，要事第一，积极主动一天要有的结果：博客总结，复盘一天\n理论状态检查，反省\n计划：在以终为始的基础上，确定生活中心，原则，明确目标和愿景。通过心灵演练加深愿景，激发想象力，改善、创造环境，激发积极主动性，认识到责任感，使命感的意义，铭记目标和职责使命。根据要事第一的原则，确定目标任务的优先级，分解任务到可执行，可实现，能够铭记使命，解决困难，向目标努力。\n这就是我的理想状态，在emacs 的加持下，能够沉浸式的进入最佳的工作状态，完成预期的目标计划。\n一天内的时间节点： 5-8 9-12 13-17 17-19 20-22\n积极主动，以终为始，要事第一 把个人使命宣言写出来，打印好，并设置成屏保\n","date":"2021-09-01T11:26:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E7%A1%AE%E5%AE%9A%E9%87%8D%E8%A6%81%E6%80%9D%E7%BB%B4%E6%96%B9%E5%BC%8F%E5%9F%B9%E5%85%BB%E9%94%BB%E7%82%BC%E9%80%BB%E8%BE%91%E6%80%9D%E7%BB%B4/","section":"post","tags":null,"title":"确定重要的思维方式着重目标培养习惯"},{"categories":["我的思维"],"contents":"","date":"2021-09-01T09:55:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/%E4%BA%BF%E5%AD%A6%E5%A0%82%E6%95%99%E5%AD%A6%E6%A8%A1%E5%BC%8F%E5%AF%B9%E8%A6%81%E4%BA%8B%E7%AC%AC%E4%B8%80%E7%9A%84%E5%87%A0%E7%82%B9%E8%A7%A3%E8%AF%BB/","section":"post","tags":null,"title":"借鉴亿学堂教学模式对要事第一原则践行意义"},{"categories":["日志随笔"],"contents":"目的 在使命宣言中已经确定使用 emacs 作为唯一官方的时间管理工具，以后在生活中，会遇到其他效率问题，激发出各种提高效能的灵感和想法，如果能掌握 emacs 开发，及时的把灵感变为实用的工具，通过工具（技巧）来改变习惯，掌握了 emacs 开发，这将会是潜在的高效产能。\n通过工具来改变习惯的方式，将会特别有效，学习使用 el 语言和 doom 的设计模式\n确定了期望，如果想要想掌握一门语言需要实用的开发环境和好用的框架来支撑，才能在灵感窍门时，能够抓住机会，快速转换 emacs 思维，通过开发一套实用的工具，来改造自己的习惯。\n环境：mac 环境下，emacs 框架：doom 框架下开发\n入门：在 doom 下读文档的习惯\n第一步：熟悉在 doom 中实现基本的语法开发环境\n第二步：doom 加载 helloworld 方法，并实用\n在 org-mode 下编写 el 脚本，并运行：spc c e 或 C-x C-e 或 spc ;\n给方法添加注释: 使用双引号实现注释\n支持和 M-x 交互：(interactive)\n掌握基础语法：变量，数组，函数，循环，正则，字符串查找，清空 buffer\n进入文档：spc h d h package 管理器学习 doom 中 Package 管理器的机制\n安装方式的介绍：可以自定义安装库的路径，支持安装本地 Package，支持指定 git 提交版本。\n还有 package 配置相关，可以在指定时机设置属性，可以指定加载时机，可以在配置中禁用包。\n还有目前重要的：可以在 doom 中联调 el 脚本\nDoom 相关配置 Configuring packages :提供了 package 的下钩子的方法。 Reloading your config :提供了在 doom 下调试 el 表达式的方法。\n创建自己的模块 Writing your own modules 创建模块（即新建目录）：~/.doom.d/modules/abc/xyz\n激活模块（init.el 配置）：(doom! \u0026hellip; :abc xyz)\n覆盖内置模块：在 modules 下，新建内置模块同名模块即可\n模块的目录结构和文件功能介绍 File structure\n模块加载的配置：=config.el=\n模块依赖包关系：=packages.el=\n实现通用的工具方法: =autoload/*.el= OR =autoload.el=\n目前测试在两个文件声明的方法：\nhelloworld 在文件 boyer/helloworld/config.el helloworld_autoload 在文件 boyer/helloworld/autoload.el 添加 autoload 注释\n添加方法注释的方法：在 defun 第二行使用双引号在第二行实现注释：双引号\u0026quot;\u0026quot;\n1 2 3 4 5 6 7 8 9 (defun helloWorld_autoload () \u0026#34;在doom中创建的第一个方法，学习el基础语法，和doom模块的加载机制的学习，实现doom交互\u0026#34; (interactive) (message \u0026#34;我是一个支持交互的方法，请多多关照\u0026#34;) (switch-to-buffer-other-window \u0026#34;helloWorld_autoload\u0026#34;) (erase-buffer) (insert \u0026#34;加载我的方法\u0026#34;) (other-window 1) ) 支持 M-x 交互：(interactive)\nhelloworld_test 在 boyer/helloworld/autoload.el 主要验证不添加;;;#autoload 注释，也可以加载成功 验证 helloworld 模块是否安装成功\n重启 emacs 查找函数：spc h f helloworld 交互函数：M-x:helloworld 加速 doom sync 方法 https://github.com.cnpmjs.org https://hub.fastgit.org\n替换阿里代理\n1 git config --global url.https://github.com.cnpmjs.org/.insteadof https://github.com/ doom emacs 用户的福音 - Emacs-general - Emacs China\n在 init.el 中添加\n1 2 3 4 5 6 7 8 9 \u0026#39;emacs-china镜像 (setq package-archives \u0026#39;((\u0026#34;gnu\u0026#34; . \u0026#34;http://elpa.emacs-china.org/gnu/\u0026#34;) (\u0026#34;org\u0026#34; . \u0026#34;http://elpa.emacs-china.org/org/\u0026#34;) (\u0026#34;melpa\u0026#34; . \u0026#34;http://elpa.emacs-china.org/melpa/\u0026#34;))) \u0026#39;清华镜像 (setq package-archives \u0026#39;((\u0026#34;gnu\u0026#34; . \u0026#34;http://mirrors.tuna.tsinghua.edu.cn/elpa/gnu/\u0026#34;) (\u0026#34;org\u0026#34; . \u0026#34;http://mirrors.tuna.tsinghua.edu.cn/elpa/org/\u0026#34;) (\u0026#34;melpa\u0026#34; . \u0026#34;http://mirrors.tuna.tsinghua.edu.cn/elpa/melpa/\u0026#34;))) 在 doom 框架下创建自己的 helloword-mode[6/6] State \u0026ldquo;DONE\u0026rdquo; from \u0026lt;2021-04-09 周五 07:25\u0026gt; 在 emacs 读 doom 文档实现加载过程 在 helloword 模块中添加方法，doom 加载之后并使用 在 doom 中开发模块： boyer/helloworld 编写旅游团小程序，学习 el 基础语法 编写一个欢迎旅游团的小程序，在荧光屏打印欢迎语\n组织旅游团数组声明，方法声明，方法调用使用 seq 创建一个观光团：team\n1 2 3 4 5 6 7 8 9 10 11 12 13 ;;创建团队初始团队三人 (setq teams \u0026#39;(\u0026#34;张三\u0026#34; \u0026#34;里斯\u0026#34; \u0026#34;万二\u0026#34;)) ;;选一个队长 (setq leader (car teams)) ;;指定其他队友 (setq other (cdr teams)) ;;加入两个新成员 (push \u0026#34;于三\u0026#34; teams) ;;在点名方法 (defun call (name) (insert (format \u0026#34;点名: %s !\\n\u0026#34; name)) ) (mapcar \u0026#39;call teams) 在车上欢迎队友窗口切换，擦除 buffer，切换到当前页面\n1 2 3 4 5 6 7 8 (setq car \u0026#34;专121公交台\u0026#34;) (defun greet () (switch-to-buffer-other-window car) (erase-buffer) (mapcar \u0026#39;call teams) (other-window 1) ) (greet) 欢迎语临时变更，更新荧光屏上欢迎语字符串搜索，报错问题\n1 2 3 4 5 6 7 8 9 10 (defun replace_call_greet () (switch-to-buffer-other-window car) (goto-char (point-min)) ;; `nil\u0026#39; 参数的意思是 : 查找并不限于某个范围内 ;; `t\u0026#39; 参数的意思是: 当什么都没找到时，不给出错误提示 (while (search-forward \u0026#34;点名\u0026#34; nil t) (replace-match \u0026#34;欢迎\u0026#34;)) (other-window 1) ) (replace_call_greet) 在荧屏上加粗队员名称正则的使用方法更新字体的方法\n1 2 3 4 5 6 7 8 9 10 (defun bold_name () (switch-to-buffer-other-window car) (goto-char (point-min)) (while (re-search-forward \u0026#34;欢迎：\\\\(.+\\\\)!\u0026#34; nil t) (add-text-properties (match-beginning 1) (match-end 1) (list \u0026#39;face \u0026#39;bold))) (other-window 1) ) (bold_name) doom/reload 刷新问题 当遇到方法找不到的问题，先找到 mode 的源码库名，进入~/.emacs.d/.local/straight/repos/mode 库名。重新拉去代码，在执行编译命令 doom sync。\n例如： compilation-buffer-name: Symbol’s function definition is void: projectile-compilation-buffer-name\n当遇到环境问题，例如:无法找到 emacs 的提示，此时考虑环境变量，iterm 环境和 doom 环境是不同的，doom 环境配置需要执行 doom env 生成 doom 的环境变量。\n1 2 3 \u0026#34;/Users/venkobas/doom-emacs/bin/doom\u0026#34; sync -e Can\u0026#39;t find emacs in your PATH Comint exited abnormally with code 1 at Sun Jan 17 00:59:49 ","date":"2021-08-30T17:20:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%88%91%E7%9A%84%E6%80%9D%E7%BB%B4/doom-%E8%87%AA%E5%8A%9B%E6%9B%B4%E7%94%9F/","section":"post","tags":null,"title":"Doom自力更生"},{"categories":["解决方案"],"contents":" 设置 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 ;; 设置agenda 显示中文 月、周、日 ;; https://emacs-china.org/t/agenda/7711/4 (setq-default ;; inhibit-startup-screen t;隐藏启动显示画面 ;; calendar-date-style \u0026#39;iso calendar-day-abbrev-array [\u0026#34;周七\u0026#34; \u0026#34;周一\u0026#34; \u0026#34;周二\u0026#34; \u0026#34;周三\u0026#34; \u0026#34;周四\u0026#34; \u0026#34;周五\u0026#34; \u0026#34;周六\u0026#34;] calendar-day-name-array [\u0026#34;周七\u0026#34; \u0026#34;周一\u0026#34; \u0026#34;周二\u0026#34; \u0026#34;周三\u0026#34; \u0026#34;周四\u0026#34; \u0026#34;周五\u0026#34; \u0026#34;周六\u0026#34;] calendar-month-name-array [\u0026#34;一月\u0026#34; \u0026#34;二月\u0026#34; \u0026#34;三月\u0026#34; \u0026#34;四月\u0026#34; \u0026#34;五月\u0026#34; \u0026#34;六月\u0026#34; \u0026#34;七月\u0026#34; \u0026#34;八月\u0026#34; \u0026#34;九月\u0026#34; \u0026#34;十月\u0026#34; \u0026#34;十一月\u0026#34; \u0026#34;十二月\u0026#34;] calendar-week-start-day 1 org-agenda-deadline-leaders (quote (\u0026#34;最后期限: \u0026#34; \u0026#34;%3d 天后到期: \u0026#34; \u0026#34;%2d 天前: \u0026#34;)) org-agenda-scheduled-leaders (quote (\u0026#34;要事:\u0026#34; \u0026#34;%2d次☞\u0026#34;)) ;; ------时间戳汉化------ system-time-locale \u0026#34;zh_CN.UTF-8\u0026#34; ;; \u0026#34;C\u0026#34;:英文格式 org-time-stamp-formats \u0026#39;(\u0026#34;\u0026lt;%Y-%m-%d 周%a\u0026gt;\u0026#34; . \u0026#34;\u0026lt;%Y-%m-%d 周%a %H:%M\u0026gt;\u0026#34;) org-display-custom-times t org-time-stamp-custom-formats \u0026#39;(\u0026#34;\u0026lt;%Y-%m-%d 周%a\u0026gt;\u0026#34; . \u0026#34;\u0026lt;%Y-%m-%d 周%a %H:%M\u0026gt;\u0026#34;) org-deadline-warning-days 5;;最后期限到达前5天即给出警告 ) 测试脚本 1 2 3 4 5 6 7 ;;系统时间设为英文 ;;(setq system-time-locale \u0026#34;C\u0026#34;) (setq system-time-locale \u0026#34;zh_CN.UTF-8\u0026#34;) (format \u0026#34;系统环境：%s\u0026#34; system-time-locale) (getenv \u0026#34;LANG\u0026#34;) (format-time-string \u0026#34;%Y-%m-%d %a\u0026#34;) (format-time-string \u0026#34;%A\u0026#34;) termux android 端问题：插入的内容还是英文。\n","date":"2021-08-30T09:58:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/emacs-%E6%B1%89%E5%8C%96%E6%97%A5%E6%9C%9F%E6%97%B6%E9%97%B4%E6%88%B3%E7%9A%84%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","section":"post","tags":null,"title":"emacs中汉化显示星期遇到的问题"},{"categories":["学习笔记"],"contents":" \u0026#30446;\u0026#24405; 目的 在doom上开启google工具 ox-trello和gcal同步协作 目的 通过gtd 提高执行力。相关的技巧工具： org-roam agenda org-gcal 谷歌日历APP创建申请谷歌日历API 密钥获取谷歌日历id 获取谷歌订阅路径在iCalendar 日历中订阅在emacs中使用cfw浏览任务在gtd 中同步trello board card 在gtd 中同步谷歌日历在gtd 中添加谷歌事件，使用snippet:gcal 使用方法：add-to-default-calendar/add-to-fournal-calendar 在gtd 中添加trello 事件\n在doom上开启google工具 开启在 init.el app calendar 开启日历工具。\n配置kidd/org-gcal.el: Org sync with Google Calendar. 在goole中申请日历API访问权限\n1 2 3 4 5 6 7 8 9 10 11 (use-package! org-gcal :ensure t :config (setq org-gcal-default-calendar \u0026#34;test@gmail.com\u0026#34; org-gcal-client-id \u0026#34;xxxxxx.apps.googleusercontent.com\u0026#34; org-gcal-client-secret \u0026#34;xxxx-Mvpvxxxxx0Bzz\u0026#34; org-gcal-fetch-file-alist \u0026#39;( (org-gcal-default-calendar . \u0026#34;~/org/gtd.org\u0026#34;) ;;(\u0026#34;another-mail@gmail.com\u0026#34; . \u0026#34;~/task.org\u0026#34;) )) ) 添加辅助方法\n1 2 3 4 (defun add-to-calendar () (interactive) (org-set-property \u0026#34;calendar-id\u0026#34; org-gcal-default-calendar) (org-gcal-post-at-point)) 添加hook\n1 2 (add-hook \u0026#39;org-agenda-mode-hook (lambda () (org-gcal-sync) )) (add-hook \u0026#39;org-capture-after-finalize-hook (lambda () (org-gcal-sync) )) 禁用hook org-gcal会自动添加事件，导致在每次capture完成时，都会执行 org-gcal--capture-post 方法，导致不必要的警告提示等。\n1 2 ;禁止gcal的capture完成时的同步事件 (remove-hook! \u0026#39;org-capture-after-finalize-hook \u0026#39;(org-gcal--capture-post)) ox-trello和gcal同步协作 1 (add-hook \u0026#39;org-capture-after-finalize-hook (lambda () (org-trello-sync-buffer) )) ","date":"2021-08-24T00:00:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/org-mode%E5%90%8C%E6%AD%A5%E8%B0%B7%E6%AD%8C%E6%97%A5%E5%8E%86%E5%90%8C%E6%AD%A5%E5%AE%9E%E7%8E%B0/","section":"post","tags":null,"title":"org-mode和google日历同步和相关技巧"},{"categories":["学习笔记"],"contents":" \u0026#30446;\u0026#24405; 目的 主要的依赖设置 通过xcodeproj在工程的xxx group下引入xx.h和xx.m文件 通过xcodeproj在工程中引入framwork、.a文件和bundle文件 通过xcodeproj在把xx.framework xxx.h xxx.bundle 加入到copy files phase中 通过xcodeproj设置证书和otherlink 目的 场景\niOS开发过程中,build setting 相关配置的问题时常发生,后来有了cocoapods减轻了很多重担。但是有些项目还是需要手动配置，实现简单的自动化。这样就要深入了解xcode项目的结构Monobjc 。针对项目结构的解析工具，最常用的要属 Xcodeproj (1.21.0) 比较流行，它基于ruby 语法实现的。今天主要介绍swift版本的XcodeProj: 📝 Read, update and write your Xcode projects 。\n下面主要参考xcodeproj使用 | 小玉的技术博客 介绍使用swift 版实现常用的几种操作。\n主要的依赖设置 通过xocde工具新增两个依赖。\nXcodeProj PathKit 1 2 import XcodeProj import PathKit 通过xcodeproj在工程的xxx group下引入xx.h和xx.m文件 先获取project\n工程中的group 配置在project中，先获取project\n1 2 3 4 5 let path = Path(\u0026#34;/Users/boyer/Desktop/XcodeTest/XcodeTest.xcodeproj\u0026#34;) // Your project path let xcodeproj = try! XcodeProj(path: path) let pbxproj = xcodeproj.pbxproj // Returns a PBXProj // 获取到project let project = pbxproj.projects.first! // Returns a PBXProject 拿到project, 处理group, 主要通过 addFile(at:sourceRoot:) 引入文件。\n1 2 3 4 5 6 7 // 修改目录结构 let mainGroup = project.mainGroup let group = try mainGroup?.addGroup(named: \u0026#34;MyGroup\u0026#34;) let newgroup:PBXGroup? = group?.last newgroup?.children.append(fileee!) let filep = Path.init(\u0026#34;/Users/boyer/Desktop/test/tet.txt\u0026#34;) try newgroup?.addFile(at: filep, sourceRoot: Path(\u0026#34;/Users/boyer/Desktop/\u0026#34;)) at: 指定将要引入的文件绝对路径 sourceRoot: 指定xcode项目路径的父目录。 通过xcodeproj在工程中引入framwork、.a文件和bundle文件 先获取target，在中 target 中方法 frameworksBuildPhase() 获取framework属性。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 pbxproj.nativeTargets.forEach{ target in print(target.name) //phase let obj:PBXFrameworksBuildPhase? = try! target.frameworksBuildPhase() //打印当前frame 清单 obj!.files?.forEach({ filess in print(\u0026#34;Framework \\(filess.file?.name)\u0026#34;) }) // 添加新的framework let frameworkfile = PBXFileElement(path:\u0026#34;/Users/test/YunCeng.framework\u0026#34;,name:\u0026#34;YunCeng.framework\u0026#34;) let buildfile:PBXBuildFile? = try! obj?.add(file: frameworkfile) // 打印加入后的最新清单 obj!.files?.forEach({ filess in print(\u0026#34;Framework \\(filess.file?.name)\u0026#34;) }) } 通过xcodeproj在把xx.framework xxx.h xxx.bundle 加入到copy files phase中 通过xcodeproj设置证书和otherlink 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 pbxproj.nativeTargets.forEach{ target in print(target.name) //配置 target.buildConfigurationList?.buildConfigurations.forEach({ config in print(\u0026#34;buildconfig == \\(config.name)\u0026#34;) //config.buildSettings 字典类型 //证书配置配置: config.buildSettings[\u0026#34;PROVISIONING_PROFILE_SPECIFIER\u0026#34;] = \u0026#34;xxProfileName\u0026#34; config.buildSettings[\u0026#34;DEVELOPMENT_TEAM\u0026#34;] = \u0026#34;xxTeamName\u0026#34; config.buildSettings[\u0026#34;CODE_SIGN_IDENTITY\u0026#34;] = \u0026#34;xxIdentityName\u0026#34; config.buildSettings[\u0026#34;CODE_SIGN_IDENTITY[sdk=iphoneos*]\u0026#34;] = \u0026#34;iPhone Developer\u0026#34; //OTHER_LDFLAGS: if let kj = config.buildSettings[\u0026#34;OTHER_LDFLAGS\u0026#34;]{ print(\u0026#34;other link ld flags \\(kj)\u0026#34;) config.buildSettings[\u0026#34;OTHER_LDFLAGS\u0026#34;] = \u0026#34;-fobjc -objc\u0026#34; }else{ print(\u0026#34;OTHER_LDFLAGS 不存在..\u0026#34;) config.buildSettings[\u0026#34;OTHER_LDFLAGS\u0026#34;] = \u0026#34;-fobjc -objc\u0026#34; } //修改配置 print(\u0026#34;===== end =====\u0026#34;) }) } ","date":"2021-08-20T18:36:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/XcodeProj%E5%9F%BA%E7%A1%80%E6%96%B9%E6%B3%95%E7%9A%84%E5%AD%A6%E4%B9%A0%E4%BD%BF%E7%94%A8/","section":"post","tags":null,"title":"使用swift版XcodeProj读取和修改项目的build配置"},{"categories":["学习笔记"],"contents":" \u0026#30446;\u0026#24405; 目的 制作 目的 学习swift集成库的管理方法，掌握包集合的制作和使用方法\n主要 Swift.org - Package Collections Swift 新闻之 Package Collections 是什么 - SwiftUI自学网站\n包集合 主要使用json文件整理和多个包的信息，制作过程中需要通过swift-package-collection-generator工具辅助完成。\n使用：添加到自己的项目中的两种方式：\n方式一：xcode13 新增的功能\n方式二：spm命令：swift package-collection add url\n制作 安装生成器工具：swift-package-collection-generator package-collection-generate 命令没有在swift命令集中，需要clone 源码 ，编译成可执行文件.\n1 2 3 4 5 git clone swift-package-collection-generator.git cd swift-package-collection-generator swift build #安装 cp .build/x86_64-apple-macosx/debug/package-collection-generate ~/../bin 我使用dotfiles方式管理本地环境，所以安装时，只要把可执行文件cp到相应的bin目录即可。在终端加载之后，可以方便在其他地方快速调用。\n新建json 我想整理swift-sh终端开发经常用到的几个库，就可以新建一个json文件 swift-sh ，添加库的路径即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 { \u0026#34;name\u0026#34;: \u0026#34;终端工具依赖库\u0026#34;, \u0026#34;packages\u0026#34;: [ { \u0026#34;url\u0026#34;: \u0026#34;https://github.com/apple/swift-argument-parser.git\u0026#34; },{ \u0026#34;url\u0026#34;: \u0026#34;https://github.com/tuist/XcodeProj.git\u0026#34; },{ \u0026#34;url\u0026#34;: \u0026#34;https://github.com/SwiftyJSON/SwiftyJSON.git\u0026#34; },{ \u0026#34;url\u0026#34;: \u0026#34;https://github.com/sharplet/Regex.git\u0026#34; },{ \u0026#34;url\u0026#34;: \u0026#34;https://github.com/iT-Boyer/AlfredSwift.git\u0026#34; }, { \u0026#34;url\u0026#34;: \u0026#34;https://github.com/pvieito/PythonKit\u0026#34; } ] } 生成标准json 生成包集合的命令： package-collection-generate json源文件 collection.json\n1 package-collection-generate packages.json collection.json 部署到远程\n使用githubpage作为在线服务，放在私有项目的文档库:iDocs中，\n服务路径： https://it-boyer.github.io/iDocs/\n把上一步生成的标准包集合json文件，放在idocs目录下的 SPM-JSON/swift-sh 目录中。\n让后既可以提交部署到githubpage服务了。\n使用\n路径区分大小写。\n通过命令：\n1 swift package-collection add https://it-boyer.github.io/iDocs/SPM-JSON/swift-sh/collection.json ","date":"2021-08-20T14:08:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/swift-package-collection%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/","section":"post","tags":null,"title":"学习创建自己的SPM新增库集合package-collection"},{"categories":["项目总结"],"contents":" \u0026#30446;\u0026#24405; 相机权限 layer 导致问题 UIButton layer层无法点击问题 RichScanDemo\n相机权限 奔溃问题：\n1 [access] This app has crashed because it attempted to access privacy-sensitive data without a usage description. The app\u0026#39;s Info.plist must contain an NSCameraUsageDescription key with a string value explaining to the user how the app uses this data. info.plist 添加权限字段： NSCameraUsageDescription\nlayer 导致问题 错误提示：\n1 void UIViewReportBrokenSuperviewChain(UIView *__strong, UIView *__strong, BOOL)() 原因分析：\n添加摄像头预览视图的layer\n1 2 3 4 5 @property (strong,nonatomic)AVCaptureVideoPreviewLayer * preview; //覆盖视图 @property (nonatomic, strong) UIView *overlayView; [self.view.layer insertSublayer:_preview atIndex:0]; 添加遮罩层\n1 2 //问题行： [self.view addSubview:self.overlayView]; [self.view.layer insertSublayer:self.overlayView.layer atIndex:2]; 结论：在VC初始化过程，self.view添加视图时，被添加的对象只能是一种，要么通过图层，要么添加UIView视图。同时添加会造成上述错误。参考： DEBUG - UIView.h#190 | 继刚的博客 Assertion failure in void UIViewReportBrokenSuperviewChain(UIView *__strong, \u0026hellip;\nUIButton layer层无法点击问题 解决办法，借助导航条实现：\n目前只需要一个返回按钮，使用在导航条上添加返回按钮，避开在self.view添加button layer。\n设置导航条透明IOS开发-UINavigationBar透明设置 - 简书\n1 2 3 4 5 -(void)viewWillAppear:(BOOL)animated{ [super viewWillAppear:animated]; [self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; [self.navigationController.navigationBar setShadowImage:[UIImage new]]; } ","date":"2021-08-17T18:51:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E4%BA%8C%E7%BB%B4%E7%A0%81%E5%8A%9F%E8%83%BD%E9%A2%84%E7%A0%94%E5%AE%9E%E7%8E%B0/","section":"post","tags":null,"title":"开发二维码扫描功能学习"},{"categories":["投资理财"],"contents":" Table of Contents 早读 量化思维 🌟量化思维的价值取向 量化实战 午间防骗 晚课 早读 量化思维 .巍巍老师: 老师一直强调说要有富人思维 那什么是富人思维呢？ 穷人思维富人思维有什么本质区别呢？ .巍巍老师: 🎈【量化思维】是富人思维最重要的思维之一，从今天开始重视自己的时间价值，哪怕是目前一无所有的人，只要利用好时间，未来一样可以变得非常富有。 .巍巍老师: 老师作为一个已经初步脱离了“穷人思维”的人，对于“穷人思维”带来的负面影响，依然历历在目 .巍巍老师: ⚠当然这也让我更加体会到“量化思维”的重要性！ .巍巍老师: 有的同学对于量化不是很能理解，今天就来解释下： .巍巍老师: 记得刚来北京时住在离公司很远的地方（因为房租便宜），每天光上下班就要花3-4个小时，这些时间都在路上听听音乐浪费掉了 。 .巍巍老师: [茶]根据当时的月收入，每个小时的价值大概50元，3个小时就值150元，一个月下来也值4000元了，而每个月便宜的房租不到一千，距离公司近的房租要一千五左右，看似节省了房租，其实亏大了 .巍巍老师: 这就是时间成本，也是穷人思维导致的看不到的损失 .巍巍老师: 日积月累这个损失是不可估量的，穷人与富人的差距也是这样慢慢拉开的[闪电] .巍巍老师: 如果我把浪费的这些时间选择用在工作或学习提升自己上，获得的价值是远远大于节省的几百元房租的 .巍巍老师: 另外我曾经也非常喜欢【便宜】甚至【免费】的东西 💢 .巍巍老师: 我曾经也不愿意买书，在网上找免费的电子书，结果害的电脑中毒，拿去修花了 180 元外加半天时间。这可比直接买书贵多了 .巍巍老师: 我曾经想学英语，但想到花钱学习太贵，于是就自己学习。由于方法不对，不但浪费了很多时间，最后还是半途而废了[心碎] .巍巍老师: 这些都是看似免费东西背后，实际上都是自己看不到的损失[凋谢] .巍巍老师: 虽然网上现在免费的知识资源很多，但往往并不系统和深入，一知半解，却也占用了人大量的时间，很多时候并没有给我们带来切实有效的价值，尤其在【生钱】这里 .巍巍老师: 有了【量化思维】，我发现【便宜】的东西其实【更贵】，【免费】的东西简直【贵的离谱】 .巍巍老师: 曾经经常淘宝买不到100元的衣服，但很多只穿了1次2次。后来改为买质量好，贵一些的衣服，能穿几年，由于被使用的频率高，算下来贵的衣服其实便宜很多，这也是价格和价值的区别[跳跳] .巍巍老师: 价值不是单一的衡量价格，而是背后带给我们的使用价值、回报价值 .巍巍老师: 我第一次买股i票的时候，是跟朋友推荐，也就是跟风瞎投 .巍巍老师: 自己啥也不懂盲目的跟投，开始赚了8千多，后来想获利更多，结果就亏了2万多，被割了韭菜 .巍巍老师: 因为不懂有效的投资理财方法，确切的说是走错了方向，自己不懂，乱投被割了韭菜[菜刀] .巍巍老师: 看了昨天大家给老师写的财富目标，不少同学应该都有相似的经历 .巍巍老师: 因为靠【投机】迟早是会被割，短期的投机心态，是无法收获持续的“下的金蛋的”🥚 .巍巍老师: 之前看到【巴菲特的一顿午餐】拍卖要200多万美元（折合人民币1500万人左右），和巴菲特吃顿饭，大概也就4个小时要花1500万人民币。 .巍巍老师: 今年的巴菲特午餐成交价创出历史新高，达到4567888美元，与2018年的3300100美元相比，高出126 .巍巍老师: 大家看看这个视频👆 .巍巍老师: 当时看到这个新闻，老师心里想这些花钱请巴菲特吃饭的人一定是脑子进水了 .巍巍老师: 这1500万做什么不好，请巴菲特吃饭能有多大用啊，当时还不懂理财，不禁感叹\u0026hellip;真是不懂有钱人的世界，太任性了 .巍巍老师: 现在有了【量化思维】这种富人思维以后，再看这些请巴菲特吃饭的人，发现他们赚大了，而且很有头脑[强] .巍巍老师: 巴菲特先生身价900多亿美元，每年能赚100多亿美元，巴菲特每个小时的价值大概180万美元，4个小时的价值是720万美元，花200多万美元买巴菲特4个小时还是超值的 .巍巍老师: 虽说是天价的午餐，但是我们却是以较低的价格购买了巴菲特的时间了⏱ .巍巍老师: 事实上请过巴菲特吃饭的人，后来确实赚到的早就远远超过那顿饭钱了，绝对物超所值\n🌟量化思维的价值取向 【关于量化思维】假设我们以钱为目标，可以做两件事\n让自己在物质上占有更多的钱。 让自己在心态建设上要像一个值得拥有那么多钱的人。 .巍巍老师: 你会选1还是2呢？ .巍巍老师: 如果你的第一反应只是在前者金钱上面，认为有钱之后才能获得值得拥有的想法，那一定要反思一下自己的思维是不是还是停留在穷人思维上。 .巍巍老师: 大家一定要警惕自己是不是已经习惯了“权衡式思维”，还是我们之前讲的“穷人思维”来考虑事情 .巍巍老师: 当一个人处于长期性的资源（比如金钱、时间）稀缺中，大脑中的注意力被稀缺资源过分占据，就会引起认知和判断力的全面下降，更加重视短期利益，忽略长期利益[凋谢] .巍巍老师: 所以很多人总觉的时间没所谓白白浪费掉，金钱稀缺，特别当自己处于为了满足生活所需，不得不精打细算时，基本会很难用理性的角度去考虑投资自己的头脑和未来的发展 .巍巍老师: 所以大多数人忙忙碌碌最后剩不下什么钱，而富人有钱又有闲 .巍巍老师: 所以有些事情，看似花了钱，实际上我们按照这种思维量化一下，反而是产生了很大的收益。例如花钱买书，你就是花了很少的钱，买了别人几年甚至几十年的经验总结~[咖啡] .巍巍老师: 大家花了1元钱在小白营学习12天，其实背后买的是李放老师十几年的投资经验和数十本投资书籍的精华积淀❤ .巍巍老师: 你把时间花在了打游戏上，意味着这段时间你无法利用它高效学习。你把时间花费在了刷抖音上，这意味着你这段时间你无法利用它提升自己的技能 .巍巍老师: 今天的早读课程之后，老师希望大家既要重视起自己的【钱】，把自己的钱花在能产生更大效益的地方 .巍巍老师: 更要重视起自己的【时间】，时间也要放到能产生最大收益的地方⏳ .巍巍老师: 【金钱】和【时间】这是每个人都拥有的 2 种财富，而这二者之间往往是可以互相交换的[闪电] .巍巍老师: 例如我们绝大多数人其实都是通过工作来出售自己的时间取金钱。但富人往往通过金钱购买别人的时间做事，来为自己创造财富💰 .巍巍老师: 时间这个财富对于所有人几乎都是平等的，我们每个人都有 24 小时，每个人的寿命都是几十年，这是我们唯一可以说和富人在同一起跑线的财富 .巍巍老师: 我们一定不能浪费这个“财富”，而要充分利用好每一天、每一分钟的时间。 .巍巍老师: 所以大家千万不要“前半辈子拿命换钱，后半辈子拿钱换命”，那样就悲剧了。[炸弹] .巍巍老师: 从现在开始，就要给自己创造“非工资收入” .巍巍老师: 这样，当你的非工资收入逐渐多了起来，你就会发现不再是你为了钱打工，而是钱在给你打工，钱在帮你赚钱。[转圈] .巍巍老师: 具体怎么让钱帮你赚钱？[疑问] .巍巍老师: 昨天我们刚学的，买入生钱资产就行了，买什么样的生钱资产？这个明天晚上会 一 一 讲解 .巍巍老师: 没有钱，每个月只有一点点钱，也能买生钱资产吗？也能变得富有吗？ .巍巍老师: 当然可以，今天晚上就告诉大家，只要你每个月有几百元结余，利用好了，20 年以后也能变成百万富翁！ .巍巍老师: 另外说一下啊，有同学都私聊跟我请假，说，老师，我的时间不够用，我太忙了。我还要家务要做。。。。 .巍巍老师: 但转头见他发了四五条朋友圈[流汗] .巍巍老师: 有这发朋友圈的 10 分钟时间回看一下课程就这么难吗？ .巍巍老师: 从今天开始，重视起自己的【每一分钟】，把自己的每一分钟都利用到最大化的利益上！[拳头] .巍巍老师: 老师知道学完这12天内容，大家就能实现财务自由是不现实的，但是我希望通过这12天的学习，每位小伙伴都要摆脱穷人思维，开始初步建立富人思维 ，建立正确的理财认知，不要再用投机的思维去思考投资 .巍巍老师: 知道用钱生钱，让钱来为自己工作，脱离理i财小白。知道实现财富自由的核心是【生钱资产】，是【非工资收入】，知道投资不是短期的一夜暴富，而是正确的资产配比持续的复利积累而爆发💦 .巍巍老师: 我们已经知道了【时间就是金钱】。所以我们就要研究一下如何通过时间让自己赚到更多的钱💴 .巍巍老师: 再多说一点，给大家加个餐\n量化实战 .巍巍老师: 可能很多人都没有量化过，我帮大家量化一下，其实想要达成这个目标有 3 种方式👇 .巍巍老师: 🌟第 1 种：让自己的单位时间更加值钱。通过提升自己的工作技能，提升自己的能力来做到 .巍巍老师: 这也是绝大多数人能想到的一种方式 .巍巍老师: 你们公司的高管和你之间的唯一差别不是他有三头六臂，而是因为他掌握了一些企业经营的技能，而你不会，如果你能学好这些技能，也能提升自己单位时间的价值 .巍巍老师: 🌟第 2 种：把你的一份时间出售很多次 .巍巍老师: 举个例子，比如说你用半年时间写了一本书，但是你这半年时间写出来的书能一直一直出售下去。你的这 1 份时间可以出售多次。 .巍巍老师: 绝大多数文化、传媒、出版等等业务，都具有此类特征。比如出唱片、网上视频授课、出书等等。往往后面很多年还能收到版税和分成 .巍巍老师: 🌟第 3 种：用钱来买别人的时间，用别人的时间为你自己赚钱。这也是最高级的一种赚钱方式 .巍巍老师: 比如说，你投资了一家企业，其实这个企业的高管就在出售自己的时间帮你赚钱 .巍巍老师: 所以说这也是为什么投资圈经常说，投资一家公司最重要的是看公司的团队。因为本质上你就是在买创始团队的时间，让他们出售时间在帮你赚钱💴 .巍巍老师: 老师就分享到这里啦，大家可以想想，你现在处于第几种状态？\n你希望成为第几种状态呢？[疑问] .巍巍老师: ——早读分享结束—— .巍巍老师: 大家可以群内开始分享感悟啦 .巍巍老师: 新知识有了新感悟的时候，才更容易被自己所运用，才会变成自己的，输出的过程就是将知识【内化】成自己的一个过程 .巍巍老师: 有反思有思考，才会改变[奋斗] .巍巍老师: 不然学过的知识12天还没结束就会还给老师了[流汗] .巍巍老师: 比如昨天的早读：收入－结余＝支出，现在有没有开始计划呢？ .巍巍老师: 大家的感悟总结也会帮助其他同学梳理思路 .巍巍老师: [爱心]【早安心语】穷人不珍惜时间，用时间换钱，富人用钱买穷人的时间为自己“续命” .巍巍老师: 好了，老师分享完了，接下来的时间交给大家 .巍巍老师: 各位同学开始输出你的感悟吧 .Ys: 老师在优先级、单位时间的效能方面如何判断与排优先级 .Ys: 或者能说说时间管理嘛？ .狮子🦁: 为了避免时间浪费，果断卸载抖音很久了，没有抖音好像也没有缺失什么，但是确实空出来很多时间，用空出来的时间看书，考证，提升自己，虽然目前还没考下来，但是感觉自己也在进步[呲牙] .天 空: 量化思维是很重要的，我们计算成本时不能局限于金钱，更重要要考虑到时间，要学着珍惜时间，花低成本买物超所值的东西，特别是学习，学习可以续命 .喜欢你的笑容: 良好的学习习惯十正确的思维十理性的理财=财务自由 .狮子🦁: 第一次看见“学习可以续命”这话，脑洞大开 .宇飞: 学习就是续命，时间最宝贵 .: 有空闲时间，多看看书，少玩网络的东西。 .一叶知心: 时间就是金钱，时间就是生命 .A忠实珠宝: 思维决定命运，行为决定命运，贵贱往往不取决于事物 表面价值，要结合自身。关于时间问题，每个人都可以给自己的时间定价的。 .巍巍老师: @Ys @Ys @狮子🦁 @天 空 @喜欢你的笑容 @宇飞 @. @一叶知心 @宇飞 没错，学习可以续命，在有限的时间内，做最高效，对人生最有益的事情，比如学习理财 .巍巍老师: @A忠实珠宝 说的很好，在有限的时间内学到的知识才是自己最大的财富 .平凡: 时间才是最珍贵的，要重视自己的时间价值，学会管理自己的时间。时间价值比较低的人，要努力学习、提升技能，才能有效提升自己单位时间的价值，时间是投资中最大的杠杆，也是最重要的因素。 .边Jenny.: 珍惜时间，不断学习，提升技能和认知 .荷塘月色: 早读感悟：重视时间，不让费生命，让时间武装自己，用时间提升自己，学会量化思维用有限的财富购买无限的时间和知识然后加以致用转变为自己的财富 .巍巍老师: @荷仙子 @峰 @平凡 @边Jenny. @慕容海 @荷塘月色 穷人和富人的区别也在于对时间的利用，富人总会给自己时间学习，每年都会预留投资自己的资金，但是穷人总会找借口说自己忙，说自己穷，没钱去学习，最终导致富人越来越富穷人越来越穷 Ys: 时间是唯一对大家都公平的资源，但是时间花在何处，如何可以最大效能的利用这个因人而异。可能觉得时间还会有，因为有明天，但是明天真的到来的时候，昨天是否充实，是否让自己增值这个就值得思考。 .巍巍老师: 富人每年都会给自己预留学习的资金，投资自己大脑，提升自己的技能，将来能赚更多的钱，而穷人却不舍得投资自己，眼光短浅，只会把钱花在吃喝玩乐，最终导致越来越穷，恶性循环 .巍巍老师: 很多时候，不是自己的人生没有选择，而是以自己见过的认知，根本看不到有其他的路可以走。所以需要多学习，拓展自己的认知边界 .喜欢你的笑容: 平时光顾着拿死工资，下班就开始刷剧、刷抖音，大把可以提升自己的时间，都无形中被消耗殆尽。上了小白课，最近这2天，时间紧凑，每天能学到新知识，同时有老师督促，直面自己的生活状态，积极调整资产分配，不再做一个三分钟热度、混吃等死熬日子的人 .巍巍老师: @蚊子 后面的早读会讲到时间四象限分配，其实现在你也可以根据自己的收入，量化一下自己的每小时收入，以后再做决策时，就知道哪些该做，哪些不该做 .李敏: 早读感悟：凡事都是思维先行，技巧其后，尽量花时间去武装大脑，而不是为了节约开支而浪费大把时间，因为时间才是最珍贵的。所以，别轻易的把时间卖掉，但是反过来我们花钱去买别人的时间，某种意义上就是延长了我们自己的生命！ .蓝色海洋: 时间比金钱宝贵，在有限时间里学习或提高自己的知识和技能是生钱的最佳途径 .蓝色海洋: 时间就是金钱，合理利用自己的时间 .巍巍老师: 大家有感悟直接发群里就行，大家一起分享交流哈，不要私藏 .巍巍老师: 给大家多引申一下 .巍巍老师: 富人把优良资产（生钱）保存珍藏起来，穷人手里只有现金，劣币驱逐良币，市场上流通的更多是现金，普通人不会想到生钱资产。 .巍巍老师: 所以富人越来越富，穷人越来越穷！关键的是思维和认知！凡事不仅要金钱，更要量化时间！小双: 珍惜当下时间，武装头脑，变成智慧型。拓展对世界的认知。和自己财富相匹配。 .巍巍老师: 我们可以想一下，通货膨胀是无形的杀手，用量化思维计算下实际通胀10%左右，这就是现金每年的增长是-10% .巍巍老师: 大家可以结合昨天讲的，想想货币本身是3大资产里的什么资产呢？穷人持有的是什么资产？富人持有的是什么资产呢？张永超: 我算是一个老股民，深受18年股灾迫害，今年疫情我知道也是好机会，但就是因为没有学好投资理财，不懂盲目乱买，凭感觉买，我希望我能学会投资理财把自己丢在股市的钱赚回来。人无论做啥都要有规划，有规划才会有计划，活到老要学到老，一切都要从思维开始改变，然后在行动，努力做了，还会有结果。穷人和富人的区别，逆向思维，还要有改变的勇气，和做事的自信，把学到的付诸于行动。 .巍巍老师: @张永超 记住是投资理/财不是投机理/财，股/票投机者最终结局是韭菜，先系统学习，收益多少和自身技能直接挂钩。切记不懂不要投，懂了放心投 .荷塘月色: @巍巍老师 有个问题老师，那需要如何量化，就按照价格和时间的比值吗？ .天 空: 老师这两天的课重要都围绕定投理财的目标，关键是投就没有分险吗？我觉得分险是同比的。投的利润增长点约高按照比例分险也越高。我是不是可以这样认为 .巍巍老师: @天 空 风险和自身的理/财能力直接挂钩，一个低风险工具，如果你不懂，那对你来说就是高风险的，就像咱们开车，对吧，不同的人开车上路风险也不同，但是这个风险不来源于车，不来源于路，而是来源于开车的人对不对？ .张永超: 是的，深有感触，因为之前赶上牛市，也是受益很高，甚至中新股，好几倍的受益都有，但是就是因为不懂，自以为是，后面赔进去了，希望这次跟着老师可以好好改变一下 .巍巍老师: @荷塘月色 比如花费时间少，收益会更多的事，我们要多做，比如理/财。花费时间多，收益非常少的事要少做或者不做，比如追剧。后面还会有更详细的讲解 .蚊子: 最近喜欢一句话，你要偷偷努力，悄悄拔尖然后惊艳所有人 .巍巍老师: 2分钟法则，对拖延症非常管用，大家可以试试 .辉辉: 要从思维开始改变，然后在行动，努力做了，才会有结果。还要有改变的勇气，同时要规划学习时间和内容，把学到的付诸于行动。 .惠通: 我出身农村，被灌输的思维就是典型的穷人思维，看到一样东西，首先问的是直多少钱？从来没有想过还有时间成本。我们都以为时间是最廉价的，最不值钱的。今天终于认识到了时间的重要性。 .巍巍老师: @平凡 没错，二八定律永远存在。爱学习的永远是少数，能赚到钱的也永远是少数，就看你自己怎么选择，看你想做哪种人了 .糖糖🍬: 计划执行多学习拓展自己去认知边界在有限的时间内用有限的精力，做最有价值的事情。 .巍巍老师: 咱们班有部分同学过去有多年的理/财经验，但是没有赚到什么钱，可以想一下原因是什么？自己有没有系统学习过，有没有对一个企业进行分析？有没有进行财/报分析？有没有制定自己的投资策略？有没有计算好价格，如果没有，那就空杯心态，认真学习，而不是被过去的认知所限制，否则是无法成长进步的 .巍巍老师: 不要让过去的经验成为你成长路上的绊脚石去往成为超级大富婆的路上😄: 量化思维很重要。重视自己的时间成本。不要浪费，每天刷没用的社交网站浪费时间无形中还是在穷人思维里。 .巍巍老师: 老师看了大家的感悟，几乎每位同学都提到了思维的重要性，量化，时间，价值，思维决定行动，行动带来结果！免费的是最贵的，还浪费了很多时间。任何事情不能凭感觉，要量化！ .巍巍老师: 每天的晨读感悟是对课程的深入思考和总结吸收的学习好方法，同学们一定要认真对待输出的过程,输出的过程也是将知识内化的一个过程，只有这样知识才更容易被自己所应用，真正变成自己的东西，从穷人思维到富人思维也需要一个过程，我们需要不断的总结，反思，实践，再总结 .巍巍老师: 大家以后一定要赚看的懂得钱，不要拿自己辛辛苦苦赚的钱去试错，好好学习，对自己的钱负责，对自己的家人负责，先投资自己的大脑 .巍巍老师: 每天坚持学习，每天进步一点点上面同学的感悟都很好，其他同学可以继续分享 .巍巍老师: 大家记得吃早餐哈，身体是1财富是0，没有1，再多0也无用 .涓涓细流768: 量化思维是富人最重要的思维之一，从今天开始重视你自己的时间价值。哪怕是目前一无所有的人，只要利用好时间，就可以变得非常富有。 .捡起六便士: 利用好时间，为自己续命，提升能力和自身价值，这就是生钱资产。有了富人思维，格局好像一下子打开了！！当下在没有更多的资金去投资生钱资产的情况下，只有提升能力，增加收入去创造生钱资产 .三哥: 感悟：用战术上的努力去掩盖战略上的懒惰，这句话对我触动很大。平时我们表面上看起来忙忙碌碌，无非是用自己有限的生命换取那一点可怜的工资，有时候甚至觉得自己目前的状态跟某些同学朋友相比，还有那么一点点值得骄傲的地方，从而获得一些些虚荣心和满足感，从而迷失了前进的方向，开始变得平庸不堪。从现在开始，务必开展自我批判，改掉种种陋习，加强学习不断进步，谋划好时间，争取早日拥有非工资性收入。[拳头] .喵小甜: 凡事都是思维先行，技巧其后，量化思维，利用好时间，提升自己的能力，养成富人思维，逐步实现财务自由 .伍晓辉: 量化思维，努力利用时间提升自己，希望在12天的时间里突破自己的穷人思维 .蔡医生18627784424(土生金生水): 我就是第一个，总在提升自己的工作技能，总想提高自己工资收入。学习了这几天后才发现我必须还要提升非工资收入，这次疫情搞得诊所都没病人了，工资收入也没了。另外一点，平时我还是比较爱学习的，以前总看专业书，今年开始也在看财商方面的书籍。每天我都给自己安排了学习的时间。平时不太喜欢为了免费打折排队而浪费时间，因为我觉得不如多学习一点有用的东西，赚到的钱远远大于这些个节省下来的钱。只是不懂理财，也不知道如何理！ .马俊峰15121828800: 量化思维，有数据支撑的逻辑比，拍脑门决策靠谱地多，这是一个典型的富人思维，成功人士懂得如何去利用有限的时间去创造更多的财富，而我天天满足于现状，得过且过，坚持学习，努力改变自己 . 王泽: 早读感悟：每天合理安排时间，只要利用好时间，就会慢慢变得富有。做好量化思维是富人思维最重要的思维之一。 .绿竹: 早读感悟:赚钱一定是思维先行，有了富人的思维，然后认真学习正确的投资方法，才能事半功倍。时间成本我们也要在做事的时候考虑进去，别小看这每件事可能耽误的时间，如果串起来，利用起来那就是突破自己能力的法宝，量化思维是富人最重要的思维之一，从今天开始重视你和考虑自己的时间价值，合理利用才能不虚度光阴 .讲给风听: 早读感悟：金钱和时间是每个人都拥有的 2 种财富并可以互相交换的，要提升认知和判断力，用富人思维看长远利益。 .津南律师事务所: 如何从穷人思维过渡到富人思维, 可以看出思维的转变是至关重要的, 凡事思维先行, 没有富人思维, 赚不了钱成为不了富人, 即使靠投机取巧赚了钱, 也不能持久, 最终还是会变回穷人, 这就是” 财不配位”, 周立波曾经说过, 上帝的账都是要轧得平的, 你需要Hold 住你所拥有的财富, 能hold 说的就是需要有正确的思维。有了正确的思维(富人思维), 才能不断的增加生钱资产, 才能持续不断的赚更多的钱。 .追梦少年: 早读感悟:古语就说一寸光阴一寸金，要充分利用时间，武装自己的大脑，做一个有思维的人。 .白家: 早读感悟：时间规划和提升单位时间的价值很重要，这样富裕出来的时间还可以再做有意义的事情。这个时间成本穷人思维的人是不会考虑在内的，穷人思维只是已付出的金钱来衡量这件事到底值不值，目光短浅，只看到了眼前利益。穷人思维只是心里觉得不值，没有考虑到有些投入会对以后产生的深远积极的影响。拿我自己举例，我基本没在自己身上做过任何有可能提升自己价值的投资，买东西都会在网上花大把的时间去比较价格挑便宜的，也很少买书，电子书也不怎么看，做事情没坚持，3分钟热度，自己没钱也是自做自受，觉得自己浪费了自己的大好年华，岁月蹉跎，现在一事无成。自己的思维模式在孩子的教育上也体现出了消极的一面，给孩子购买的网课也因为各种原因不能坚持上，老师都换了好几个了，对孩子的投入变成了老师讲的坏支出，没起到好的作用。就分享这么多吧，感觉自己跑题了。 .大人: 早间感悟：之前没有去量化时间，认为只有工作的时间才是有价值的，今天听了老师的分享，原来我们休息的时间也是有价的。原来上班路时间都在手机刷屏上了，这些时间都可看些有价值，丰富自己思想，提高自身能力的东西上，比如老师的推荐的读物及分享，让自己的时间更有价值。 .ʚ夏天来啦ɞ: 时间才是我们最大的本钱，要学会量化思维，衡量我们每分每秒的价值，与其浪费时间去做一些毫无实际意义的事情，不如做好规划，把时间多花在投资自己的大脑，提升自己的能力上 .巍巍老师: 大家的感悟都非常棒[强][强][强]，量化思维可以应用到我们生活方方面面，当你因为一件事无法做出决定是，那就用量化思维量化到每一天的收获上，去对比 .巍巍老师: 当你把单位时间所具有的价值量化出来，一切都会变得清晰[OK] .巍巍老师: 人这一辈子最重要的就是活的好 .巍巍老师: 同时我们更要对孩子负责，我们是什么样的认知和眼界，是什么样的格局，还有是什么样的思维？就是我们孩子的眼界，格局和思维 .巍巍老师: 言传身教是非常重要的，我们过不好，何谈让孩子比我们过得好呢？ .巍巍老师: 所以大家没得选择，只有努力学习，充实自己的大脑，不辜负今天，为明天努力！！！！ .伍晓辉: 老师说的非常对，感觉最失败的是没有把孩子教育好[衰] .巍巍老师: @伍晓辉 有太多的父母把自己的情感全都转移到孩子身上自己没有做到的事，反而去要求希望孩子去做到，所以说言传身教就是要提升自己父母的高度决定孩子的高度，因为孩子就是父母的复印件 .巍巍老师: 那我们希望孩子成为什么样的人，首先自己就要变成什么样的人，所以说呢，现在唯一能够做的就是提升我们自己让我们自己去影响孩子，而不是去教导孩子。因为孩子肯定不是教导出来的，而是被影响出来了。 .巍巍老师: 后面我们还会讲到孩子的财商教育，因为孩子的财商也是一样至关重要的，财商的提升巴菲特曾经说过越早开始越好，所以当你自己在提升财商的同时，也一定要想着如何去提升孩子的财商，我们后面也会去展开讲述。大家都加油吧，争取成为高财商的父母。因为当咱们自己都没有财商知识，那如何去影响孩子对吧，现在国家已经把孩子财商教育纳入到课本，国民教育体系当中所以说重要性可想而知。 .国窖1573: 我们最大的错误就是认为时间不是没有价值的，或者是无限的，从来没有量化这个问题。我以前就给人均16万的试错成本投资过，股票，平台，资金盘，加起来应该有十万左右。现在意识到必须先学习，以前太傻了。\n午间防骗 防骗：如何一个人没有理财的基础常识时，加上各个平台高汇报的噱头宣传，在利欲薰心的大环境，很容易把握不住，怎么有效规避，识别有效的理财产品，理性投资消费，只能有扎实的理财知识，用本领躺赚睡后收入。\n晚课 ","date":"2021-08-13T14:35:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/%E4%BB%8E%E7%A9%B7%E4%BA%BA%E6%80%9D%E7%BB%B4%E8%BF%87%E5%BA%A6%E5%AF%8C%E4%BA%BA%E6%80%9D%E7%BB%B4/","section":"post","tags":["tj3"],"title":"【第二课：复利】0813 从穷人思维过度富人思维"},{"categories":["投资理财"],"contents":" Table of Contents 早读：在案例中学习并确定理财的愿景目的 晚课：人生穷富的关键：生钱资产和耗钱资产 🌟核心重点一：【理财】 🌟核心重点二：【三大资产】 ⭐生钱资产 ⭐耗钱资产 ⭐其他资产 财富自由 综合题，提问 工资收入和非工资收入 理财要先资产结构正确,趁早两条腿走路 🌟核心重点三：【穷人和富人的区别】 中产思维 富人思维 如何成为富人 今日作业 早读：在案例中学习并确定理财的愿景目的 :巍巍老师: 巍巍老师在这篇文章中看到自己的影子。我的家也是很普通的家庭，我也经历过挺长一段时间的月光负债生活。 :巍巍老师: 事实上越是月光没钱，越是负债，越应该尽早开始理*财。事实上越是月光没钱，越是负债，越应该尽早开始理*财。 :巍巍老师: 学习理/财恰恰是治疗“财务病”的药方 :巍巍老师: 我昨天看了很多同学的资产、债务情况和原因，其实不难想象的是没有良好的理*财技能造成[发抖] :巍巍老师: 即使是突然有一大笔钱从天而降，帮你还上了，但是过不久你还是会因为你的消费观，再次陷入月光、负债的问题 :巍巍老师: 其实大家基本上都是有稳定收入的，你和你身边的人收入可能也差不多，但是可能有些朋友现在已经身价不菲，而有些人却陷入月光、负债 :巍巍老师: [蜡烛]因为有这种“财务病‘’，才会出现这种困局 :巍巍老师: 【所以学习理*财，越早越好！】 :巍巍老师: 比如在如今高通货膨胀率情况下，还仅仅把钱放在3%左右的银行定存或者是余额宝上，收益率是远远跑不过通胀率的，那么钱就在贬值缩水[凋谢] :巍巍老师: 毫不夸张的说：不会理*财技能的人是很难过好这一生的，也会一生被钱所困扰 :巍巍老师: 大家看看身边那些有着各种不幸的人是不是精通理*财技能?有没有发现哪个精通理*财技能的人，会让自己生活缺钱、月光或负债的呢？💨 :巍巍老师: 而那些精通理*财技能的人虽然也会遇到生活的挫折，但是我们发现他们不久又东山再起，活的很滋润了 :巍巍老师: 为什么呢？ :巍巍老师: 👉因为钱作为最重要的资源，精通理*财的人掌握了生钱的方法，人即便会遇到生活意外，也依然还会有机会，再加上自身的努力，所以东山再起是迟早的。 :巍巍老师: 在理*财技能和思维这方面，一开始老师也是个负面典型的例子 :巍巍老师: 刚刚大学毕业的时候工资只有几千元，那时候我每个月都月光。当时我就想，等我月薪几万就好了，就能有结余了，生活可能就会好很多。 :巍巍老师: 结果等我月薪几万的时候，我还是没有结余，甚至开始有负债了，因为除了必须的开销之外，我还想着去买一些奢侈品，包包、一些不理智的消费。 :巍巍老师: [发抖]月薪几万的时候，我感觉自己过得还不如月薪几千的时候。那时候每天都加班到凌晨，工资收入虽然提升了，但是想要的更多了。 :巍巍老师: 后来老师也是学习理*财技能之后才意识到，那是因为自己缺乏正确的金钱观。 :巍巍老师: 家里父母的财商教育几乎没有，也没告诉我该怎样合理利用，这种有钱就花光的思维根深蒂固。 :巍巍老师: ⚠所以这也是为什么我们看到很多人中了彩票一夜暴富，但几年后生活就又穷困潦倒了。 :巍巍老师: 很多人说，这就是“财运”，这就是富人的命。 :巍巍老师: 但其实不是，是因为他们有“富人思维和技能”。 :巍巍老师: 如果你有了富人的思维和技能，即使你现在穷困潦倒未来也会富有起来。 :巍巍老师: 🌟但如果你没有富人思维和技能，就像老师以前一样，即使你的工资收入提升了 3 倍、5 倍，也依然会很穷 :巍巍老师: 从本质上来说，贫富的差别，其实还是思维方式的差别。 :巍巍老师: 只有拥有了富人思维，在赚钱、管钱方面才能做到事半功倍 :巍巍老师: 🌟如果你一直都是穷人思维，即使你中奖中了 1 个亿，继承了 100 个亿的财产也没有用。财富照样会离你远去 :巍巍老师: 比如前山西首富的儿子从他爸那继承了 100 多亿财富，他用了几年就败光了还欠了 2 亿多的债。现在他已经被国家列入失信名单，以后连飞机、高铁都不能坐了[心碎] :巍巍老师: 还有昨天晚课里老师讲的那个中彩票的卡罗尔也是一样 :巍巍老师: 而福建龙岩的富豪王苗没有给他的儿子王兴多少钱，王苗主要培养了王兴的富人思维，在富人思维的指导下，王兴创办了美团，成了百亿富豪[强] :巍巍老师: 👉都是富二代，我们从理*财角度就可以了解到这两种命运结果不同的本质原因，不是投胎问题，而是财商问题 :巍巍老师: 其实富人思维、穷人思维和你有多少钱没有太大的关系 :巍巍老师: 富人思维、穷人思维只和你的金钱观、理*财技能有关！ :巍巍老师: 想要更好地打理金钱，就要学会富人思维，掌握好理*财技能，这将使你更快的奔向财务自由。 :巍巍老师: ⚠敲黑板，学会富人思维 :巍巍老师: 有同学说我现在还只是个学生，或者说我还是个月光族，我没有钱，这其实都是思维的一种局限性 :巍巍老师: 月光不可怕，可怕的是你明知自己月光还不自省不行动 :巍巍老师: 很多同学说要开源，要节流，其实这些虽然没错 :巍巍老师: [玫瑰]但其实投资自己才是最先要解决的问题，而不是房子车子，很多人的目标都是房子车子，但是反而买了房子在车子的大多数人都是被房子车子拴住 :巍巍老师: 被房贷车贷负债压的喘不过气[叹气] :巍巍老师: 只有当你的思维开始转变了，你的行动才会改变，进而你的财务状况才会真正发生变化 :巍巍老师: 我们再来看看富人思维和穷人思维的区别[鼓掌] :巍巍老师: 一边是各种放弃的理由，一边是各种努力的理由，可以直观的看富人思维和穷人思维的区别 :巍巍老师: 理*财就是理生活 :巍巍老师: [图片] :巍巍老师: 老师希望同学们以后都做个行动派，而非观望派 :巍巍老师: 【富人在行动，穷人在观望】 :巍巍老师: 💢没有钱只是结果，是过去思维呈现的结果！！ :巍巍老师: 所以自己现在是什么思维和怎样的选择会决定未来自己的财务状况。 :巍巍老师: 是单一的工资收入，还是已经开始积累钱生钱了呢[疑问] :巍巍老师: 所以没钱，只是结果，不是不开始理*财的理由。 :巍巍老师: 要学会看到形成结果的底层原因，看到本质，找到核心的原因，从本质上去解决问题。 :巍巍老师: 💜现在收入少不可怕、月光不可怕，负债不可怕，可怕的是明知自己收入单一/月光/负债/不会钱生钱，还不自省、不行动、不改变、不努力去找办法解决。越不重视理*财，越是财商低，这样只会恶性循环下去 :巍巍老师: [玫瑰]正确的理*财方式是：先学习富人思维，开始行动改变自己思维，时间放在重要的事情上，掌握好理财技能，每月收入一部分强制去投资，让投资的收益率远远高于通胀率，实现真正的【钱生钱】。 :巍巍老师: 有同学问：“老师，现在每个月都有负债，收入也不高，怎么理*财啊？” :巍巍老师: 老师的建议是：先学会理*财，然后将每月的收入分成几部分去支出，每月强制拿出一部分去投资，然后再去还债，再去生活消费。 :巍巍老师: [图片] :巍巍老师: 👆这个配置表参考，就是可以在这个基础上，根据自己的情况优化和调整，分为几部分 :巍巍老师: 同时， 把每年的收入和支出列在纸上都写一写，最后得出多少的结余，这样从现在起每月适合拿出收入的百分之多少比例去投资生钱，规划适合自己的。 :巍巍老师: 这里给大家一个【个人资产配置】参考👇 :巍巍老师: 也可以像下面这位同学这样写一写 :巍巍老师: [图片] :巍巍老师: 大多数月光族会认为：收入-支出=结余，于是就是月光或负债[心碎] :巍巍老师: [爱心]更好的富人思维是：收入-结余（强制投资）=支出，就会剩余大量的生钱资产。 :巍巍老师: 敲黑板！‼ :巍巍老师: 摆脱月光的公式【收入-结余=支出】 :巍巍老师: 摆脱月光的公式【收入-结余=支出】 :巍巍老师: 摆脱月光的公式【收入-结余=支出】 :巍巍老师: 重要的事说3遍👆 :巍巍老师: 很多时候， 我们稍微调整下思维就能解决的问题，但是惯性思维和固定性思维很多时候会影响我们的思考 :巍巍老师: 一旦你换种思维方式，你的结余马上就会增加，这就是思维的力量。 大家一定要记住这个公式，尤其是目前处于月光和负债的同学，如果不改变花钱方式，很难改变月光和负债的结果 :巍巍老师: 👉举个例子：假如你月收入只有 5000 元，你至少可以存下 10%：500 元，剩下的 4500 元再去消费 :巍巍老师: 这和你拿着 5000 元去消费，想着我剩多少存多少，结果会完全不一样[NO] :巍巍老师: 你会惊讶的发现：使用收入的那 90%去生活和 100%相比，其实根本没有什么区别！ :巍巍老师: 但是却能有效的储蓄养鹅 :巍巍老师: ✨有些财务状况很差的同学说每个月结余500很难，那结余100还难吗？最重要的是开始有结余，哪怕是100元。 :巍巍老师: 如果想摆脱月光和负债，就必须改变思维，学会这种思考方式【收入-结余=支出】 :巍巍老师: 而不是一味的花光所有仅有的工资收入 :巍巍老师: 有些同学可能会想，每个月100块钱能干嘛[疑问] :巍巍老师: 可不要小看小钱，其实100 元就可以开始投资，任何财富都是积少成多，集腋成裘💪 :巍巍老师: 至于怎样利用 100 元这样的“小钱”来投资，接下来的 10 天你会学到很多实用的理*财工具 :巍巍老师: [太阳]让我们从今天开始，让自己拥有正确的思维，彻底告别：月光、负债的问题！ :巍巍老师: 【先结余、再消费】开始增加自己的“睡后收入” :巍巍老师: 好了，老师就分享到这里了，接下来该大家分享了[机智] :巍巍老师: 最后统一回复一下大家关心的问题： 12天我到底能学多少东西？\n🌟这 12 天一定坚持，你们可以学会 1、理\\*财工具的实操，学会就可以操作 2、有效消除负债，提高收入的具体方法 3、从 0 开始增加非工资收入的 3 大核心工具和 6 大重要工具 4、通过财报进行自我财务分析的方法，解决自身财务问题 5、长期赚钱可以无脑赚的具体理\\*财工具和投\\*资方法 .巍巍老师: 我来统一回答一下🎤：咱们亿学只教最好的理\\*财技能，不会推荐任何理财产品保险等，如果有任何人打着亿学的名义推荐理\\*财产品一定是骗子，大家一定要给老师举报。 .巍巍老师: 小白营的课程里，我会教大家一些理\\*财工具，这12天课程是我们亿学学堂的【第一阶段】课程，主要是帮助大家脱白的：我会带着大家学习15条富人思维+理\\*财的基础知识框架（包括简单认识21种工具，建立投资的框架财报-企业分析等）。 .巍巍老师: 但是如果大家表现好，每次都能积极上课参与课堂讨论，积极按时完成作业，对于课程理解吸收的也很好，我会考虑给大家加餐一些【进阶课】的内容。 .巍巍老师: 💢如果大家希望学完12天就能一夜暴富，老师也可以明确的说，这是不现实的，我教不了你。如果学完12天之后还想要深入学习，亿学学堂也有【第二阶段】课程，学习22周时间，大家根据自己的情况考虑是否要继续学习，这里说明白了大家就清楚了。 .巍巍老师: 12天能教的我会毫无保留，不能教的也看你们表现加餐，如果你认为1块钱学这些知识不值，可以马上来找老师退费，如果大家觉得值，留下来好好听课，我相信认真学完12天课程的同学都会有巨大收获 .巍巍老师: 以往有投资经验的同学，但收益率不理想甚至亏损，建议空杯心态学习，一定会颠覆你的认知 .巍巍老师: [闪电]下面时间交给大家，同学们可以开始输出「早读感悟」了，一定要善于思考，因为没有任何输出形式的填鸭学习是低效率的，感悟就是将知识内化的过程，慢慢变成自己的。 .巍巍老师: 不知道怎么写感悟的同学，这里老师帮大家梳理了一个分享总结的思路：👇 1.通过学习新知识，收获到了什么？ 2.总结自己过去的模式看清自己 3.现在有什么新的想法和想做出哪些改变？朝着什么方向努力 4.思考下未来自己的方向构划未来，目标清晰明确 .巍巍老师: 然后1234..去梳理 想想自己以前都做了什么？没钱一定是有原因的 现在自己能做什么？ 开始找解决方法 未来自己想要什么？目标清晰，怎么去一步步落实 晚课：人生穷富的关键：生钱资产和耗钱资产 亿学学堂\n.巍巍老师: 咱们学院好的理i财方法自然有，关键是你想不想学，能不能坚持，从今天开始，每位同学都要开始做笔记了，后面的课程都很重要，特别是前三天非常关键[太阳] .巍巍老师: 下面正式开始今天的内容，我言简意赅，让每个同学都听明白。如果有不懂的地方大家就直接跟我说哈 .巍巍老师: 今天的晚课是小白营的核心——生钱资产，课程的内容都是围绕生钱资产这个概念来展开的！[转圈] .巍巍老师: 今天的课程分为 3 个部分：👇 .巍巍老师: ✨1、什么是理i财？必须有很多钱才能理i财吗？\n✨2、三大资产，到底什么东西能帮我们赚钱？哪些东西会让我们亏钱？\n✨3、穷人和富人之间的差别是什么？\n🌟核心重点一：【理财】 .巍巍老师: 很多同学觉得理i财和自己没关系，其实并不是，理财和每个人息息相关，你的每一笔花费，每一次收入的分配，都是在理i财 .巍巍老师: 投*资≠理*财，投*资只是理*财的一部分，理*财是一个很广泛的概念 .巍巍老师: 比如制定家庭日常消费计划、投*资计划、保险计划、教育金计划、养老金计划等都是理*财的一部分[握手] .巍巍老师: 所以不要觉得非得投资几十万几百万才是理*财。只要你花钱，其实就已经在理*财了 .巍巍老师: 投资只是属于理i财的范畴，比如投资股i票、基i金、房地产等 .巍巍老师: 这里提前告诉大家：股i票、基i金几百块起就可以投资的，后边课程会展开跟大家讲 .巍巍老师: 那什么是资产呢？[疑问] .巍巍老师: 简单说，就是一切可以用货币计量的东西 .巍巍老师: 房子、车子、票子、桌子、椅子、手机、电脑、锅、碗、瓢、勺、股/票、基/金等都是资产✔ .巍巍老师: 大家都预习了，这里老师提问一下 .巍巍老师: 🎤提问：资产的内涵是什么？ .Not: 现金流 .绿竹: 资产的内涵是现金流 .蚊子: 就是把资产配置成良性循环 .巍巍老师: 资产的内涵就是【现金流】✨，一定要注意审题哈 .巍巍老师: 答错的要反思一下了[敲打] 一定要做好预习再来上课 .巍巍老师: 关于现金流的概念，可能有同学有点晕，老师简单说两句 .巍巍老师: 回答错的同学记好了哈，资产的内涵就是【现金流】！ .巍巍老师: 我们希望现金是流动的，对吧 .巍巍老师: 最好是源源不断的往自己兜里面流💦 .巍巍老师: 那我们要是有一种资产，它能一直让钱往我们兜儿里面流，是不是就好了？我们就会越来越富有了！💴 .巍巍老师: 要是我们拥有的这个资产，它让钱反着往外流，从兜里往外流，我们就会穷[凋谢] .巍巍老师: 大家一定记住资产的内涵，这个也是非常重要的，在以后的学习中我也会反复强调资产的内涵！\n🌟核心重点二：【三大资产】 .巍巍老师: 资产产生现金流的不同决定了资产的不同 .巍巍老师: 也就是：【现金流向】不同，代表【不同的资产】 .巍巍老师: 根据资产产生现金流的不同，可以把资产分成3种\n⭐生钱资产\n⭐耗钱资产\n⭐其他资产\n⭐生钱资产 .巍巍老师: 接下来我带着大家好好拆分下不同资产的概念👇 .巍巍老师: ✅生钱资产：持有期间能给你【持续】带来净现金流入的东西 .巍巍老师: 就是不断给你赚钱的，相当于一只持续在家下金蛋的鹅🥚 .巍巍老师: 这里我们可以想一下，假设你拥有的这个资产，一直让钱往你兜里流，你肯定很喜欢，也会越来越富有💴 .巍巍老师: 有了生钱资产，你就可以躺着数钱了，这就是所谓的【睡后收入】 .巍巍老师: 为什么叫【睡后收入】？[疑问] .巍巍老师: 因为你睡着之后你的生钱资产还在为你赚钱 .巍巍老师: 生钱资产和人的区别[闪电]是它可以每天工作24小时，全年无休的为你赚钱，并且它还感觉不到累 .巍巍老师: 拥有生钱资产，你想不富都难，生钱资产养人呐！ .巍巍老师: 这里强调一下：🔺【持续】很重要，持续指每个月、每个季度或每年能不断的给你带来净现金流入 .巍巍老师: 有人可能会想，生钱资产的价格也会下跌吧？不也是会亏钱吗？ .巍巍老师: 我来说一下👇 .巍巍老师: 生钱资产的价格短期内确实也会下跌，但不同的是，生钱资产即使价格下跌了，生钱资产依然会为你带来【持续】的净现金流入，你依然会定期收到钱，也就是说，即使价格下跌，你也会持续的【赚钱】✨ .巍巍老师: 我大白话举例：👇 .巍巍老师: 假设，你在北京有个公寓，30 间屋子，出租出去 1000 一间一个月，这就是生钱资产 .巍巍老师: 你睡着了钱一样往你兜儿里面进 .巍巍老师: 比如现在行情不好，房子价格下跌了，但是对你一点影响没有，它还是生钱资产，你还是能把房子出租出去赚租金，钱还是往你兜里进👈 .巍巍老师: 我只是举个例子，方便大家理解概念，不是说让大家去投资公寓啊 .巍巍老师: 并且由于生钱资产具有很高的内在价值，生钱资产的价格即使短期下跌了，长期也会涨上来[转圈] .巍巍老师: 这个很容易理解，一个能持续产生现金流的东西，没有人会不想要。只要有很多人想要，价格就会涨 .巍巍老师: 因此持有生钱资产，你会同时获得【净现金流】和【价格上涨】双重收益，所以长期来看生钱资产的收益率会更高 .巍巍老师: 生钱资产的特点决定了它是一种【无论价格涨跌都能赚钱】的资产，拥有这样的资产，就相当养了一只持续下金蛋的鹅，想不富有都难[拳头] .巍巍老师: 现在同学们知道为什么有的人会越来越富有了吧？ .巍巍老师: 因为他生钱资产多呀！[哇] .巍巍老师: 常见的生钱资产有：股/息、版税、利息，房屋租金等等 .巍巍老师: 很多人把钱存入余额宝，也属于生钱资产 .巍巍老师: 但是余额宝收益率很低，年化收益2%左右，远远跑不赢通货膨胀，其实钱还是在贬值，属于劣质的生钱资产[凋谢] .巍巍老师: 那么哪些工具是收益率高，可以跑赢通货膨胀的生钱资产呢？第四天晚课我会讲到的，咱们一步一步来[拳头]\n⭐耗钱资产 .巍巍老师: 接下来，让我们闹心的资产来了[发抖] .巍巍老师: 👉耗钱资产：持有期间能给你【持续】带来净现金流出的资产 .巍巍老师: 有了耗钱资产，你躺着的时候还在付钱。这就是所谓的【睡后支出】，耗钱资产需要被人养 .巍巍老师: 大家想想贷款买的房子（没有租金或租金无法覆盖贷款利率）和车子，是不是自己要不断的为它们付钱？ .巍巍老师: 耗钱资产需要被人养，耗钱资产耗人啊，因为这个资产让你的钱，从兜儿里一直往外流💦 .巍巍老师: 由于耗钱资产持续不断的带来净现金流出，持有耗钱资产的人只有在一种情况下能赚钱，那就是卖出价格大幅高于买入价格时（价差收益还需要覆盖持有期间的净现金流出） .巍巍老师: 但是未来的价格是很难确定的！ .巍巍老师: 耗钱资产的持有损失是确定的，未来价差收益是不确定的，所以风险就很大。而有一些耗钱资产，未来价格也是确定会比买入价格低的，那亏损就更大了[凋谢] .巍巍老师: 现在同学们应该知道为什么有些人突然有钱了然后没过几年又变穷的原因了吧？ .巍巍老师: 因为他们有钱了之后把钱都换成了耗钱资产，耗钱资产会把钱源源不断的带走[心碎] .巍巍老师: 你持有的【耗钱资产】越多，你就越没办法停止工作。因为你一旦停止工作了，你的耗钱资产还是在不断的把你的钱带走，所以一旦你停止工作，就会破产[炸弹] .巍巍老师: 接下来开始提问了[玫瑰] .巍巍老师: 🎤提问：既然耗钱资产这么不好，那么我们要不要持有耗钱资产呢？ .平凡: 理财的目的就是改善生活，就必须要购置那些耗钱资产 .巍巍老师: 大家说的没错[强]还是要的，有些刚需无法避免 .巍巍老师: 比如我们看有些富人天天坐私人飞机，住豪宅，开豪车，这些都是耗钱资产啊✈ .巍巍老师: 但是他的生钱资产相当庞大！这些生钱资产赚的钱足以覆盖耗钱资产的支出了 .巍巍老师: 所以我们努力的方向是什么呢？[疑问] .巍巍老师: 就是要用生钱资产去【养】耗钱资产！ .巍巍老师: 当你的生钱资产比例很大的时候能覆盖你的耗钱资产就没问题[OK] .巍巍老师: 【敲黑板！】：要用生钱资产养耗钱资产\n⭐其他资产 .巍巍老师: 我们继续再说最后一个资产👇 .巍巍老师: ✨其他资产：持有期间产生的净现金流为0的东西 .巍巍老师: 有了其他资产，你躺着的时候你就是在躺着，因为兜里不进钱也不用往外掏钱 .巍巍老师: 其他资产在你持有期间不能给你产生任何收益，你只能在未来卖掉它的时候赚价差，至于未来你的卖出价是否一定会比买入价高，这个只能到时才知道呢！😔 .巍巍老师: 只有你卖出的时候才会产生现金流，但不一定是流入还是流出。因为可能会亏，也可能会赚 .巍巍老师: 你的收益有很大的不确定性，所以想通过其他资产长期稳定的赚钱也很难🙅 .巍巍老师: 以上就是我们今天要学习的重点——生钱资产，耗钱资产，其他资产。也是理i财中最最重要的概念！ .巍巍老师: 今天的晚课搞懂了，可以说你就一脚踏入了富人的世界[胜利] .巍巍老师: 给大家1分钟消化一下 .巍巍老师: 好了，三大资产的概念讲完了，接下来我提问一下，看看大家是不是真的理解了 .巍巍老师: 先问一个有意思的问题 .巍巍老师: 🎤黄金是什么资产？ .巍巍老师: ✨答案是其他资产 .巍巍老师: 大家想想有没有【持续】的为你带来现金流入或现金流出？ .巍巍老师: 你买了1斤黄金，在你不卖的时候，他是不是不能给你带来现金流入？ .巍巍老师: 就只能在家里放着，如果你持有黄金，不卖出，就不会产生任何现金流 .巍巍老师: 所以黄金是👉其他资产！ .巍巍老师: 因为它的收益是不确定的，当你卖出以后你有可能赚钱，也有可能亏钱 .巍巍老师: 黄金是赚不可预测的差价，没有持续的净现金流入，所以是其他资产 .巍巍老师: 我们判断一种资产是什么类型的资产，是看这种资产带来的【现金流方向】 .巍巍老师: 无论是生钱资产还是耗钱资产，【持续】两个字是很重要的，大家一定要记住这两个字，【持续】！📍 .巍巍老师: 它不能带来持续的净现金流入或者流出，那它就是【其他资产】 .巍巍老师: 买入其他资产，这种就是【投机行为】 .巍巍老师: 这也是实现财务自由的五条禁令的第2条 .巍巍老师: 不赌博、不投机！🙅 .巍巍老师: 今天赚了明天赔了，又怎么可能实现财务自由呢？ .巍巍老师: 所以说咱们一定要多持有生钱资产，带来稳定持续的净现金流入💴 A忠实珠宝: 按老师的意思理解，好像大部分的股票都属于其他资产[捂脸] .巍巍老师: 股/票的问题大家明白了吗？明白了咱们就过 .巍巍老师: 到底是什么决定了人生的穷富？人生穷富的关键是什么？[疑问] .巍巍老师: 穷人之所以穷，富人之所以富的关键，其实就在这两个资产 .巍巍老师: 优质的【生钱资产】是一定能让我们变富的，是解决我们所有财务问题的核心[蜡烛] .巍巍老师: 我们目前大部分人遇到的财务问题，就是生钱资产太少，或者压根就没有🥀 .巍巍老师: 这也是我们理*财要学习的重点，如何选出优质的【生钱资产】才是关键，大家要先把底层概念理解透彻[拳头] .巍巍老师: 没关系，咱们后面就开始学习如何挑选优质的生钱资产 .巍巍老师: 那怎么样理i财才能让自己变富呢？[疑问] .巍巍老师: 一定是先培养自己对理*财的正确认知，再了解各种理*财工具，然后再进一步学习如何正确方法去投资，之后再去完善好家庭的生钱资产配置，一步步的提升自己，才能理好财变富💗 .巍巍老师: 下课以后好好想一下，自己都有哪些耗钱资产让自己越来越累？关于钱的问题，大家不要疏忽大意，不懂理财一生就亏大了！💔 .巍巍老师: 生活中我们遇到的90%的问题都可以用钱来解决，剩下10%也可以用钱来缓解，所以大家都离不开它👌 .巍巍老师: 🎤再问大家一个问题，加深理解一下 .巍巍老师: 大家觉得银行的【定期存款】是什么资产？ .A忠实珠宝: 劣质的生钱资产 .巍巍老师: 先不用考虑通货膨胀等其他情况，单纯的从现金流的角度考虑 .巍巍老师: 大部分同学说的没错 属于生钱资产，它是生钱资产但是是劣质的[凋谢] .巍巍老师: 例如：余额宝，支付宝理/财产品，微信理/财产品，返还型保险等等 .巍巍老师: 可能大家有疑问了[疑问]我们到底该怎么找生钱资产呢，其实这也是我们理/财要学习的重点，如何选出优质的【生钱资产】才是关键，但是大家要先把底层概念理解透彻 .巍巍老师: 明天学习到复利的时候，大家会更加深刻体会到【现金流】的力量💪\n财富自由 .巍巍老师: 咱们继续下一个知识点 .巍巍老师: 既然想实现财务自由，起码得先清晰自己的财务自由标准是什么✊ .巍巍老师: 【敲黑板！】：当你的生钱资产，产生的非工资收入，覆盖日常总支出，你就财务自由了 .巍巍老师: 也就是说非工资收入（睡后收入）\u0026gt;生活支出，你就财务自由了 .巍巍老师: 财务自由就是不上班也有钱花，这样即使你不工作，你是不是也不必为钱担忧！ .巍巍老师: 同学们想想：如果你投资的生钱资产每个月为你赚的钱，大于你一家人一个月的消费，这样即使你不工作，你是不是也不必为钱担忧，这时候就是财务自由了[转圈] .巍巍老师: 明天晚上我手把手带你们通过计算器来计算，你们每个人实现财务自由的时间⏱ .巍巍老师: 财务自由了，与家人共享天伦之乐[爱心] .巍巍老师: 想干什么就干什么了 .巍巍老师: 当然前提是在法律范围内哈[偷笑] .巍巍老师: 财务自由是咱们同学共同的奋斗目标 .巍巍老师: 所以我说学好理i财是人生必修课！[拳头] .巍巍老师: 你拥有一点点生钱资产，生钱资产就会给你生一点点钱 .巍巍老师: 你不断增加自己持有生钱资产的数量，生钱资产给你创造的收入就会越来越多 .巍巍老师: 等到有一天，生钱资产给你创造的收入大于你的生活总支出的时候，你就财务自由了，你就不用为了工作而工作了！✨ .巍巍老师: 所以说，大家今天学习了生钱资产这个概念，就应该已经知道，财务自由是一定会实现的事情，只是时间问题⏳\n综合题，提问 .巍巍老师: 具体怎么选择生钱资产，我后面会具体的讲，先把大家的思路梳理清楚 .巍巍老师: 相反，如果你不懂得生钱资产、耗钱资产的概念，你有了很多钱可能会把钱都换成耗钱资产[凋谢] .巍巍老师: 就像同学们很多人财富目标，有了钱立刻去拿钱换大房子、换好车，结果又没钱了。。。 .巍巍老师: 然后就一直这么循环下去，有了钱就买耗钱资产，然后变穷，继续努力赚钱继续买耗钱资产，继续变穷 .巍巍老师: 所以知道为什么你努力工作这么久，钱也赚了不少，但是越来越累了吗？检视一下自己的资产状况就知道了 .巍巍老师: 同学们的财富目标中占比较多的是关于拥有【房子】和【车子】，那我们来说说这两个[闪电]\n房子是什么资产呢？🎤 .Not: 出租时，是生钱资产 自用时，是耗钱资产 .A忠实珠宝: 有房租的是生钱资产，自己住的又按揭是耗钱资产 .巍巍老师: 接下来老师来分析一下👇 .巍巍老师: 大家认真听 .巍巍老师: 假如你有一套房子，没有贷款，租出去获得了租金，给你带来了持续的现金流，它就是👉【生钱资产】 .巍巍老师: 或者说有贷款，但租金能够覆盖每个月的月供和物业费，同时还有结余，那这也是【生钱资产】✨ .巍巍老师: 顺便说一下，这时的贷款就是好负债，好负债也会让你的钱越花越多 .巍巍老师: [跳跳]相反，如果是三成首付买的房子自住，不但没有租金收入，每个月还要支付大笔房贷月供以及相应的物业费，那么它就是👉【耗钱资产】 .巍巍老师: 当然即使【没有贷款】的房子，【自己住】的这段时间里你还需要为房子付物业费、保险费，产生持续的现金流出，所以没有贷款的自住房也是【耗钱资产】 .巍巍老师: 如果是三成首付买的房子投资，出租出去，租金【刚好等于】月供、物业费各种支出。那这时它就是👉【其他资产】啦！ .巍巍老师: 同样是房子，不能一概而论，房子可以是3种不同的资产[闪电] .巍巍老师: 但不管什么资产，两个条件判断\n✨1.持续的\n✨2.净现金流入 就是生钱资产 .巍巍老师: 之前有同学问我，老师我的房子是耗钱资产，我要搬出去吗？ .巍巍老师: 🔺再次说明一下 .巍巍老师: 这里拿房子举例，只是帮大家更好地理解生钱资产、耗钱资产，其他资产，不是说你就一套房子，还是耗钱资产，你就不住了 .巍巍老师: 而是指导大家在未来投资房产或其他项目的时候，要系统的分析一下，这是耗钱资产还是生钱资产，有没有投资价值[玫瑰] .巍巍老师: 希望大家能明白这个道理[握手] .巍巍老师: 理*财小白营的核心就是带大家看懂哪些是小白能赚到的钱，哪些是不能赚的，不能的以后就不碰，以及如何去持续积累自己的【优质生钱资产】[爱心] .巍巍老师: 正确理*财的核心是让自己不断的拥有【优质的生钱资产】，占比越高越好 .巍巍老师: 目前月光或负债的同学，检视下自己现在是不是生钱资产几乎为零？[疑问] .巍巍老师: 要想增加自己的非工资收入，核心方法就是增加自己的【生钱资产】，这是必经之路[茶] .巍巍老师: 所以大家可以检视一下耗钱资产有多少？生钱资产有多少？其他资产有多少？ .巍巍老师: 明晰之后才能做出对应的改变\n私家车是什么资产？🎤 .巍巍老师: 接下来再说一下【车子】的问题🚗 .巍巍老师: 大家说说，私家车是什么资产？🎤 .巍巍老师: 大家说的很对，因为私家车是自用的，每年都有保险费、保养费、停车费、加油费等支出，私家车持续的带来净现金流出，所以私家车是👉【耗钱资产】 .巍巍老师: 如果用这个车在业余时间跑个顺风车，收入能覆盖掉自己的日常用车支出，还有结余，那么是什么资产呢？ .巍巍老师: 从私家车的属性讲，车还是【耗钱资产】 .巍巍老师: 因为这是你的【劳动收入】，开私家车拉活赚的钱需要你投资大量时间，是自己付出劳动所得的，如果你不拉活，就没有这笔收入，劳动收人不是由车本身带来的净现金流入 .巍巍老师: 你不拉活就没有这个收入，这个持续不是私家车驱动的，而是人在驱动[快哭了] .巍巍老师: 👉有一种情况：你把车通过某个租车平台出租出去，租金去掉各项支出后还有净现金流入，这种情况下私家车是【生钱资产】，不过既然是私家车，一般也不会出租，所以私家车是【耗钱资产】 .巍巍老师: 以后大家再看房子/车子/各种理*财工具，一定不能只看长相了，要看内涵，要看它产生的净现金 .巍巍老师: 🔺大家注意：这里举例说明的就是私家车 .巍巍老师: 举例是为了让大家明白生钱资产的内涵[转圈] .巍巍老师: 其实这就引出了下一个很重要的概念 .巍巍老师: 接下来，我要和大家来说一下👉【工资收入】、【非工资收入】\n工资收入和非工资收入 .巍巍老师: 【工资收入】就是自己付出时间、精力、汗水挣来的钱 .巍巍老师: 像大部分同学都是需要拿工资，必须去上班才有收入，这种就是工资收入 .巍巍老师: 当然了老师也有工资收入， 但是我基本不靠它生活 .巍巍老师: 【非工资收入】就是，你不需要去劳动，也能有收入 .巍巍老师: 就像有人说的：躺着就把钱赚了或者不干活也有钱，比如利息、股息、分红、租金，出书的版税等 .巍巍老师: 只有工资形成了结余 → 用结余去换成生钱资产 → 生钱资产产生非工资收入 →非工资收入帮助我们实现财务自由[爱心] .巍巍老师: 这段话要背下来哈👆 .巍巍老师: 以后你们也会学习配置非工资收入 .巍巍老师: @蚊子 我的非工资收入，公司分红， 股/票，指/数/基/金，REITs收益等，还有投资一些其他产业 .A忠实珠宝: 首先得有鹅（工资）利用好鹅生蛋（非工资） .巍巍老师: 咱们继续~~ .巍巍老师: 我们常说的理*财收入，就叫【非工资收入】 .巍巍老师: 如果你要出卖时间、精力，那么财务自由就无从谈起了👊 .巍巍老师: 财务自由的最高境界是时间自由，有更多的时间陪家人💏 .巍巍老师: 如果牺牲过多时间来换取金钱，这是不可取的💢 .巍巍老师: 所以想要实现财务自由，我们应该工资收入和非工资收入两手都要抓，两手都要硬🙌 .巍巍老师: 因为只靠工资收入是很难实现财务自由的💢 .巍巍老师: 因为只靠工资收入是很难实现财务自由的💢 .巍巍老师: 因为只靠工资收入是很难实现财务自由的💢 .巍巍老师: 重要的事情说三遍✔ .巍巍老师: 这12天每天都会带给大家颠覆常规的认知，一定跟上脚步👣 .巍巍老师: 这是建立富人思维其中的一个关键因素 .巍巍老师: 我会带大家从理财角度了解到，还有更多的人生模式可以去选择 .巍巍老师: 认真跟课学习，你一定能获得1元百倍千倍的价值✊\n理财要先资产结构正确,趁早两条腿走路 .巍巍老师: 接下来大家思考：月光或者钱不多的人，为什么不能等有钱再学习理财？ .巍巍老师: 大家积极思考回答🎤 .巍巍老师: 我看看哪些同学每次都在积极思考，回答问题 .蚊子: 没有认识到理财知识，只有学到了才会改变 .蔡医生18627784424(土生金生水): 因为未来有很多风险，靠工资收入太慢，不一定能够抵御风险。一旦停止工作，就没有收入了。 .狮子🦁: 没有理财思维的人，就算工资涨了，消费也会跟着增加，还是不会有结余 .巍巍老师: 大家说的都很好[强] .Not: 穷则思变，越穷越要提高自己，改变思想，养自己的鹅，并让鹅下金蛋！ .荷仙子: 老师，我问个问题，保险算什么资产，其它资产吗 .巍巍老师: 积少成多，永远不要看不起几百小钱，复利的作用下威力很大[炸弹] .巍巍老师: @荷仙子 保险是好支出不是资产 .巍巍老师: 明天咱们就讲复利 .巍巍老师: 有一些小伙伴说没钱，但没钱只是不学习理财的结果 ，而不是你不学习理财的原因 .巍巍老师: 如果不改变思维，再过5年、10年财务状况还是同样的模式在循环[凋谢] .巍巍老师: 🔺谨记：没钱、负债、月光，不会钱生钱， 是不理财的结果 ，越是没钱越更要早早开始理财。 .巍巍老师: 改变思维，调整资产结构，减少坏支出，逐步提高生钱资产 .巍巍老师: 具有富人思维的人即便是月光，或者积蓄不多的时候，就会【从一开始】就通过工资和非工资收入【两条路径】来增加自己的收入💴 .巍巍老师: 财富滚雪球的秘密是先要资产的结构正确，而不是等有钱再来堆雪球⚽ .巍巍老师: 所以聪明的小伙伴在获得第一笔工资收入时，就开始选择合适的理i财工具来积累自己的本金和非工资收入了 .巍巍老师: 两条腿走路肯定比只靠工资收入一条腿走的更快更远🚲 .巍巍老师: 老师早上也说了，月光的同学要强制储蓄，收入-结余=支出✌ .巍巍老师: 这里的结余，我们拿出去做投资，每个月都坚持，坚持下来你就会发现，等生钱资产足够庞大的时候送，工资收入已经微不足道了 .巍巍老师: 咱们要善于利用复利的威力，明天就讲[呲牙] .巍巍老师: 生钱资产结合复利，就像滚雪球一样，让财富越积越多 .巍巍老师: [爱心]一句话再总结下：提升财富要靠工资和非工资收入两条腿走路，绝对不能独腿前行。（非工资收入要有强大的知识沉淀自己，不然进场容易变韭菜，容易亏钱） .巍巍老师: 悄悄地[嘘]我已经把今天的第一条富人思维告诉大家了 .巍巍老师: 记住，一边工作一边理财投资，两条腿走路🏃\n🌟核心重点三：【穷人和富人的区别】 中产思维 .巍巍老师: 这是普通人或者说中产阶级的现金流，大家看看跟自己像不像？？ .巍巍老师: 咱们国内的生活水平还是较高的，大多数家庭都能够得上贷款买房、买车，所以咱们就拿中产示范，我来说下图的内涵 .巍巍老师: 中产就是大部分的普通人，能勉强开始贷款购房购车 .巍巍老师: 中产可能有贷款也可能没有贷款 .巍巍老师: 中产的收入主要来自工资收入 .巍巍老师: 非工资收入要有强大的知识沉淀自己，叫好 .巍巍老师: 中产把工资收入变成了耗钱资产（房子、车子），耗钱资产不停消耗中产的钱 .巍巍老师: 为了养耗钱资产，中产是不能停止工作的，一旦停止工作，收入来源就断了。。。[发抖] .巍巍老师: 由于耗钱资产的存在，中产几乎是很难变富有实现财富自由的。 .巍巍老师: 你会一直被工作拴住，停止工作，也就失去了财务的来源[凋谢] .巍巍老师: 🎤请问这是大家最想要的财富目标吗？ .巍巍老师: 没钱的时候，向往有房有车的生活 .巍巍老师: 真的有房有车了，你发现更累 .巍巍老师: 累的原因就是理i财的姿势不对 .巍巍老师: 大家知道中产和穷人之间隔着的是什么吗？[疑问] .巍巍老师: 其实中产和穷人的之间只隔着一场大病🏥 .巍巍老师: 老师身边就见过很多中产最后折在父母的突发疾病医疗费上\u0026hellip;原本很体面的生活，瞬间崩塌\u0026hellip; .巍巍老师: 也说明看似体面有房有车的中产，资产的实质结构抗意外风险系数是极低的 .巍巍老师: 网上有段话很火的视频是这样说的：👇 .巍巍老师: 24年的存款只够在ICU病房住一个礼拜， 在ICU病房住几天就可以压垮一个家庭 .巍巍老师: 全国年平均收入为5万，但是ICU病房一天的花费是3万。一场ICU病房的治疗足矣让中产家庭脱层皮，让工薪家庭陷入贫困。 .巍巍老师: 刚刚说的网上流传的视频，3分钟给大家看看👆 .荷仙子: 然后我觉得没有好的投资项目，不就用来买房了嘛，房子还升值了呀 .巍巍老师: @荷仙子 房子以前是适合用来投资，但是呢，近几年他是不太适合投资的，因为国家一直在提倡住房，是用来住的，不是用来炒的。 .巍巍老师: 如果说你对炒房比较热衷的话，那我们第七节reits 晚课一定要来，好好听。 .巍巍老师: 好，大部分同学都看完了，咱们继续~ .巍巍老师: 我们大多数人一生中都会经历生活中不可预知的意外，有大环境的，有来自家庭小环境的 .巍巍老师: 只是每个人经历时间的早晚不同，解决问题需要花的钱多钱少不同 .巍巍老师: 一定要谨记，早一点开始理i财，早一点提高家庭抗风险系数，对自己和家人都是最好的负责 .巍巍老师: 不要等没钱，等发生意外，等负债累累，等人到中年压力最大的时候，财务出现大的债务危机时才意识到财务健康出了问题，因为这时想翻身实现财务自由门槛会变得很高 .巍巍老师: 而且月光和经历债务危机的人，机会成本是很高的☝ .巍巍老师: 什么叫【机会成本】？[疑问] .巍巍老师: 当一个好的学习机会，好的赚钱机会摆在你面前，你却抓不住 .巍巍老师: 假设现在有个5万赚50万的低风险赚钱机遇，十年一遇。月光或有负债的人，就拿不出，抓不住这样的机会，这就叫机会成本高\n富人思维 .巍巍老师: 富人思维，一定是 从一开始，获得第一笔收入的时候 就健康的理财，两条腿走路🚲 .巍巍老师: 更高财/商的人，还会从孩子会用钱的那一天起，就教会孩子如何去支配钱，使用钱 .巍巍老师: 财务两条腿走路，当生活一番风顺的时候，可以不断的增加生钱资产，自由度越来越高 .巍巍老师: 当生活经历意外的时候，也可以具备理i财的能力，将坏负债转变好负债，并不断的积累生钱资产，这样不久后就又可以财富自由了[转圈] .巍巍老师: 一个人有没有理i财能力的更本质差别，不仅仅在账户财富数字收益上，更重要的是体现在驾驭人生的自由度上 .巍巍老师: 有的人，即便遇到生活意外，也还会东山再起🌳 .巍巍老师: 有的人，就会因此一蹶不振，十年井绳 .巍巍老师: 那该怎么做呢？ .巍巍老师: 我们再来看一下富人的现金流👇 .巍巍老师: [图片] .巍巍老师: 跟上一张中产的图对比看一下，我们会发现：👇 .巍巍老师: 富人的收入主要来自【生钱资产】✨ .巍巍老师: 生钱资产产生的现金流入完全能够覆盖各种支出 .巍巍老师: [图片] .巍巍老师: 大家看看MY，他投资了这么多企业 .巍巍老师: 这些企业就是他的生钱资产 .巍巍老师: 富人不用为了生活而去工作！ .巍巍老师: 同样一个实现财富自由的人，也是不怕失业的 .巍巍老师: 富人买多少耗钱资产都没关系，因为生钱资产赚的钱足够🎈 .巍巍老师: 未来的你们就是这个样子的[拥抱] .巍巍老师: 其实当下现在，大多数人的现金流量表都是中产 .巍巍老师: 离富人最近 .巍巍老师: 但是一不小心，走错路了，可能比穷人过的还惨 .巍巍老师: 中国改革开放40多年，中国富有的人越来越多，也就是大家口中的中产阶级 .巍巍老师: 他们大多是通过自己努力工作赚钱，随着改革开放的步伐，年薪20万—40万的中产越来越多，但是他们也是最容易出现财务危机的人，为什么？[疑问] .巍巍老师: 还有在北京国贸，金融街、CBD商圈或者美团和华为的IT精英年薪都在20—40万 .巍巍老师: 但是他们财务自由了吗？ .巍巍老师: No 没有 .巍巍老师: 他们穿着最贵的西装，喷着最贵的香水，敷着最贵的面膜，也熬着最贵的夜，他们不敢不工作，因为他们和银行签了卖身契，贷款10——30年，也就是在未来的10-30年，你要一刻不停歇的为银行打工，不敢停歇 .巍巍老师: 因为他们完全只靠工资收入，没有驾驭金钱的能力，买入过多的耗钱资产，没有合理的规划让钱生钱🐎 .巍巍老师: 其实我们是未富先老的国家，人口红利在慢慢消失，所以才有了二胎政策，来挽救未来的人口危机👼 .巍巍老师: 日本是先富了，然后人口老龄化，至少还能负担的起养老问题，因为人口少，还是发达国家 .巍巍老师: 但是我们是人口大国，占比全球人口总数1/4，现在还在发展中国家阶段不是发达国家，你认为未来最大的问题是什么？ .巍巍老师: 👉就是养老 .巍巍老师: 如果不会驾驭金钱，老了以后将面临着什么样的生活？❓ .巍巍老师: 而且未来的一个孩子要养4-6个老人 .巍巍老师: 所以同学们以后的养老想想，能靠谁？ .巍巍老师: 只能靠自己 .巍巍老师: 大家有点忧患意识，为自己筹谋一下\n如何成为富人 .巍巍老师: 好了言归正传，要成为富人要怎么做呢？ .巍巍老师: 富人成功的两个秘密：\n✅ 生钱资产占总资产的80%以上；\n✅ 好支出占总支出的80%以上。 .巍巍老师: 只有现在开始学会理财，实现财务自由，然后才能给自己养老 .巍巍老师: [图片] .巍巍老师: 这就是富人的两个秘密！大家一定要牢记！ .巍巍老师: 同样，那对应穷人的两个死穴又是什么？ .巍巍老师: 🌟相对应的穷人的第一个死穴：毫无任何生钱资产可言！生活唯一的经济支柱就是工资！\n🌟 相对应的穷人的第二个死穴：不知道支出也分好坏！坏支出占了总支出的80%以上。 .巍巍老师: [图片] .巍巍老师: 大家看看自己身上有没有这个死穴，如果有，要尽快改变 .巍巍老师: 那么问题又来了，普通家庭为什么不能满足于自己的工资收入中？ .巍巍老师: 时间关系，老师直接说了 .巍巍老师: 大家认真看👇 .巍巍老师: 普通家庭看似收入比较稳定，其实抗风险能力不强，他们有房贷要还，小孩要养，甚至父母还要大量的开销 .巍巍老师: 🌟【孩子还未成人的家庭】\n孩子没有收入，花销逐年增大，这时候如果夫妻中有一人遇到一段时间不能工作的情况，家庭财务整体情况可能会出现较大落差，进而影响生活质量. .巍巍老师: 🌟【全职宝妈的家庭】\n女性负责照顾孩子，没有工资性收入，只有丈夫一人的收入是家庭收入的主要来源，如果丈夫遭遇大裁员等意外情况，家庭很可能立即陷入坐吃山空的财务危机中，或者啃老的尴尬境地 .巍巍老师: 所以普通家庭更需要尽早尽快建立自己的非工资收入体系👇\n【在没发生意外的时候】，可以为家庭提供一份额外的收入，补贴家用，防患于未然\n【在发生意外的时候】，能够抵御财务风险，不至于到毫无收入的被动地步。前提是学习并掌握获得非工资收入的能力 .巍巍老师: 就像疫/情，很多家庭的财务危机立即暴露了 .巍巍老师: 🔥一句话总结：普通中产的【财务安全】来自工资收入和非工资收入的双管齐下，没有充足非工资收入的普通家庭，财务状况并不安全 .巍巍老师: 好啦，今天的课程主要内容就是这些 .巍巍老师: 结合昨天我们讲的内容，我来问两个问题看看大家掌握了没 .巍巍老师: 🎤提问，我们办健身卡是好支出还是坏支出？ .A忠实珠宝: 坚持锻炼就是好支出 .蚊子: 如果钱不够 花健身卡就是坏支出 .天 空: 早就开始健身了 .江学爱: 好支出要实践去用对身体有益 .蔡医生18627784424(土生金生水): 好支出，投资健康 .蚊子: 办了卡去健身了就是好的支出，只是去拍照打卡的是坏的支出 .巍巍老师: 🎤那同理， 大家说12 天小白营的 1 元学费是好支出还是坏支出呢？ .小双: 好支出 .蚊子: 学习了，好支出 .蔡医生18627784424(土生金生水): 非常好的支出 .Ann: 锻炼不一定要办卡[偷笑] .巍巍老师: 🔺注意：办健身卡锻炼身体是好支出，但是如果不去就办卡扔在那里，就是坏支出了 .巍巍老师: 没错，坚持学习，学以致用，1 块就是好支出，要是半途而废，就是坏支出 .巍巍老师: 🎤那大家知道接下来怎么做了吗？ Ann: 学习要 好支出 .蔡医生18627784424(土生金生水): 坚持学习 .A忠实珠宝: 坚持学习，学以致用 .峰: 坚持学习 .马俊峰15121828800: 坚持学习，增加自己的生钱资产，减少自己的坏支出 .巍巍老师: 坚持学习，1块就是好支出，要是放弃了，就是坏支出。我们不要小看这1块钱。看不起小钱，就挣不了大钱 .巍巍老师: 生活习惯是有惯性的，坚持不下来的，对于其他事情也会有同样的惯性，3分钟热度 .巍巍老师: 只要你想学，老师会不遗余力的帮助你 .巍巍老师: 学习是给自己学的，收益的也是自己的，好好学将来家人朋友会对你刮目相看👀 .巍巍老师: 老师相信你们，会坚持学习 .巍巍老师: 后面的作业别让我天天找你催哈[敲打] .巍巍老师: 如何区分好支出和坏支出？其实很容易区分，我最后来说一下 .巍巍老师: 刚刚不懂的认真听一下 .巍巍老师: 👉投资自己、投资生钱资产、投资未来都可以是好支出\n👈反之投资耗钱资产、不必要消费就是坏支出 .巍巍老师: 争取让好支出占总支出的80%以上，你离富人就不远了 .巍巍老师: 大家加油，学好理i财技能，2021年让自己活得更自由[转圈] .巍巍老师: 好了，今天的课程主要内容就是这些，我来总结一下！ .巍巍老师: ⭐三大资产：生钱资产、耗钱资产、其他资产，判断他们的关键是【持续的】净现金流的流入和流出。\n⭐两大富人思维！ .巍巍老师: [图片] .巍巍老师: [图片] .巍巍老师: 一共学到三条富人思维了，今天的两条保存好[玫瑰] .巍巍老师: 大家要把关键富人思维收藏，很重要，接下来，我要留作业了\n今日作业 .巍巍老师: 群公告 开始布置第一次正式作业 .巍巍老师: 🔺🔺🔺作业重要信息\n各位同学，从今天开始咱们就有作业了。作业大家一定要认真做，这是对自己晚课学习效果的检验。做作业的同学比不做作业的同学，学习效果要好3倍以上 .巍巍老师: 晚课作业3个选择题，1-2分钟完成，很简单。另外作业做完以后，要记得打卡图片私发给我 .巍巍老师: 【打卡方式】：完成作业提交后点击我要打卡，之后将【打卡图片】长按转发老师即视为打卡成功 .巍巍老师: 老师再强调一下，只有完成前3次作业的同学才能获得学院给的价值千元的奖励[礼物]没有完成作业的同学不能获得 .巍巍老师: 我先来预告一下明天内容，再发作业 .巍巍老师: 明天咱们学习爱因斯坦说的世界第八大奇迹——复利！ .巍巍老师: 很多同学都跟老师说，老师我现在没有钱，每个月只有几百元怎么做理i财？ .巍巍老师: 明天我们会讲，哪怕你每个月只有几百元，通过复利也可能会变成富人。明天晚上我们一起来看一看，学会理财技能的巴菲特，是如何将自己的资产从114美金变成 919 亿美金的💵 .巍巍老师: 晚课结束了，大家可以好好想一想，自己为什么会有现在的财务问题呢？你真正缺的是钱吗？还是对于财富的正确认知呢？你又要如何去做呢？[疑问] .巍巍老师: 认真思考一下，欢迎来和老师交流 .巍巍老师: ⭐【作业一】人生穷富的关键 https://wx.yixuetianxia.cn/#/s/ZoMnTX .巍巍老师: 有问题的同学，写完作业可以提问，没有问题的可以去做做笔记了 .荷塘月色: @巍巍老师 老师，想问现在给人买商业保险是可取吗[愉快] .巍巍老师: 老师只推荐必要的消费型保险@荷塘月色 .蔡医生18627784424(土生金生水): 保险人总推荐买年金，啥是年金？ .张永超: 我想问问老师，现货到底是什么东西？ .林爱琴: 人生穷富的关键是学会理财。 .宇飞: 老师他们经常提到的“渣房”是什么资产 .荷仙子: 老师，您说买保险是买投资型理财产品还是大病保险好 .天 空: 银行理财顾问什么的，真的能够帮助我们钱生钱吗？ .喜欢你的笑容: 老师，整容是好支出还是坏支出 .巍巍老师: [语音] .A忠实珠宝: @巍巍老师 贷款买的房即使当下是耗钱资产，但是5年后房价翻倍，那是不是意味着这套房子具有双重属性呢？ .天 空: 贷款买的房也要分自住或者出租投资吧？不是一概而论吧 .A忠实珠宝: 现在的房价很难说 .巍巍老师: @A忠实珠宝 这套房子依然是耗钱资产，虽然耗钱资产是有可能赚钱的，但是有很大的不确定性。咱们不要忘记资产的内涵哈，未来的房价是任何人没有办法去预测的，有可能上涨，有可能跌，但是现金流它是实实在在的，我们想要实现财务自由不能靠预测市场去实现 .巍巍老师: 大家没问题的话可以去做做笔记了 .国窖1573: 听完老师的课，感觉太受益了，颠覆了以前所有的投资理念。如果不是听了老师这样的课，以后还会一直错下去，既使有钱又会变得负债累累 .捡起六便士: 爬楼完毕，今天明白了什么是生钱资产、耗钱资产、其他资产，以后多多积累生钱资产、减少耗钱资产，用一些其他资产帮助生钱资产实现更多.更大的现金流，今天受益良多，谢谢老师的分享[玫瑰]\n","date":"2021-08-12T10:37:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%8A%95%E8%B5%84%E7%90%86%E8%B4%A2/12%E6%97%A9%E8%AF%BB%E5%AD%A6%E4%B9%A0%E7%90%86%E8%B4%A2%E8%83%BD%E6%94%B6%E8%8E%B7%E4%BB%80%E4%B9%88%E7%9A%84%E6%A1%88%E4%BE%8B/","section":"post","tags":["tj3"],"title":"【第一课：生钱资产】0812 富人思维和生钱资"},{"categories":["博客站务"],"contents":"目的 plantuml-mode介绍 plantuml-mode 支持设置几个属性输出格式：svg png txt\n执行方式：jar server executable\n预览命令：C+c C+c\n输出格式：仅在eamcs-plus版本支持svg\n在emacs-plus上预览，jar模式下，svg/png显示空白，txt 格式错误。server模式：卡死。在emacs上预览：jar/server下，png 乱码，提示type未知。\nexecutable: 提示 找不到文件时，需要安装plantuml ， brew install plantuml\n基于doom中内置配置 自定义私有配置 设置org模式下的相关属性\n1 2 3 4 (setq org-plantuml-jar-path \u0026#34;~/.emacs.d/.local/etc/plantuml.jar\u0026#34;) (setq org-plantuml-executable-path \u0026#34;/usr/local/bin/plantuml\u0026#34;) (setq org-plantuml-executable-args \u0026#39;(\u0026#34;-headless\u0026#34;)) (setq org-plantuml-exec-mode \u0026#39;jar) ; \u0026#39;jar \u0026#39;executable 设置plantuml-mode模式下的相关属性\n1 2 3 4 5 6 7 8 9 ;; Sample jar configuration (setq plantuml-executable-path \u0026#34;/usr/local/bin/plantuml\u0026#34;) (setq plantuml-jar-path \u0026#34;~/.emacs.d/.local/etc/plantuml.jar\u0026#34;) (setq plantuml-default-exec-mode \u0026#39;jar) ; \u0026#39;jar \u0026#39;executable (add-to-list \u0026#39;auto-mode-alist \u0026#39;(\u0026#34;\\\\.plantuml\\\\\u0026#39;\u0026#34; . plantuml-mode)) (add-to-list \u0026#39;org-src-lang-modes \u0026#39;(\u0026#34;plantuml\u0026#34; . plantuml)) (setq plantuml-server-url \u0026#34;https://www.plantuml.com/plantuml\u0026#34;) 问题 org 中嵌套plantuml时装svg图片时，仅支持 @startuml 可以点击超链接。\n不支持 @startmindmap 脑图和 @startwbs wbs图，转svg错误。\n@@md: 嵌套在org的svg格式，在hugo中显示为图片，无法点击超链接。在hugo中显示，无法点击超链接。\n1 @@md:![](http://www.plantuml.com/plantuml/proxy?cache=no\u0026amp;idx=0\u0026amp;fmt=svg\u0026amp;src=https://it-boyer.github.io/iDocs/uml/demo-class.plantuml)@@ @@html: 嵌套在org的svg格式，在hugo中显示为图片，无法点击超链接。在hugo站中不显示, 在gitlab上可以显示，无法点击超链接\n1 @@html:\u0026lt;img src=\u0026#34;http://www.plantuml.com/plantuml/proxy?cache=no\u0026amp;idx=0\u0026amp;fmt=svg\u0026amp;src=https://it-boyer.github.io/iDocs/uml/hugo/static-imgresource.plantuml\u0026#34; alt=\u0026#34;sdfds\u0026#34; align=\u0026#34;left\u0026#34; title=\u0026#34;image title\u0026#34;/\u0026gt;@@ plantuml-mode预览问题\n预览xx.plantuml文件时，现空白问题 server模式错误 plantuml-mode语法高亮问题\n该方案过期\nfork plantuml-mode 参考issue问题，修复高亮问题：\nsyntax error from examples of plantuml.com · Issue #101 · skuro/plantuml-mode\u0026hellip;\n1 2 3 4 5 6 7 (defun plantuml-server-encode-url (string) \u0026#34;Encode the string STRING into a URL suitable for PlantUML server interactions.\u0026#34; (let* ((coding-system (or buffer-file-coding-system \u0026#34;utf8\u0026#34;)) ;(encoded-string (base64-encode-string (encode-coding-string string coding-system) t))) (encoded-string (base64-encode-string string t))) (concat plantuml-server-url \u0026#34;/\u0026#34; plantuml-output-type \u0026#34;/-base64-\u0026#34; encoded-string))) 使用修复的代码：\n1 2 3 4 (package! plantuml-mode :recipe (:host github :repo \u0026#34;it-boyer/plantuml-mode\u0026#34; :branch \u0026#34;develop\u0026#34;)) 使用 plantuml 建模规范 建模的两个标准，原则，避免选择上的纠结。\n在idocs库中建模，使用在线工具预览uml效果\n通过确定plantuml现有版本问题导致在预览情况下无法正常工作,借助在线预览工具实现预览，然后使用md标记引用到org中。\n在iDocs中创建plantuml源码文件，在线工具校验预览，使用 @@md 嵌套在org中。\n在org中建模\n结构简单的模型，在org中建模，以png格式为主。切记脑图/wbs图不支持svg格式。\n","date":"2021-08-10T19:26:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/plantuml-modeissues/","section":"post","tags":["uml"],"title":"plantuml-mode使用问题汇总"},{"categories":["解决方案"],"contents":"目的 过度依赖github，长期受网速问题的困扰，尝试使用forge工具，通过接口，将issues暂存到本地，快速预览和管理issues\n在使用过程中遇到了几个问题：\n使用 hub.fastgit.org 代理，导致forge提示不支持 如何不clone库文件，直接在本地查看A库中的issues的操作 forge添加平台域名支持 当在 .gitconfig 中替换域名的情况下:\n1 2 [url \u0026#34;https://hub.fastgit.org/\u0026#34;] insteadof = https://github.com/ 这是使用 forge 会提示一下问题：\nCannot determine forge repository. https://hub.fastgit.org/iT-Boyer/hugo.git 1 isn’t a forge url\n这种情况是forge不支持未知域名，如果要正常使用就需要手动配置 forge-alist ，告知forge。\n例如要新增 hub.fastgit.org 域名，它作为github.com的代理服务，调用的方法和github.com一致： forge-github-repository 。\n在doom.d私有配置 config.el 添加域名到 forge-alist 配置中：\n1 2 3 4 5 (after! forge (add-to-list \u0026#39;forge-alist \u0026#39;(\u0026#34;hub.fastgit.org\u0026#34; \u0026#34;api.github.com\u0026#34; \u0026#34;hub.fastgit.org\u0026#34; forge-github-repository) ) ) 让后，执行 Ctrl+x Ctrl+e 或 spc h r r 使配置生效。\n确认添加成功 M-x：spc h v 搜索 forge-alist 。\n使用forge管理issues\n可以愉快的使用常用的操作：添加 ： forge-add-repository\n列表： forge-list-repositories\n查看： forge-visit-repository\npull： forge-pull\n使用forge拉去issues 实际场景：在库A中访问库B的issues，但是不clone 库B\n添加库B到forge中：forge-add-repository 库B 进入forge库列表：forge-visit-repositories return 在forge库B中执行：forge-pull 完成之后就可以看到issues列表。 想在其他库目录下例如：库A中，访问库B的issues，只需要执行forge-visit-repositories 切换到库B。\n结论：forge仅依赖forge-add-repositories库设置，其默认支持在git库的目录下获取该库的issues。\n","date":"2021-08-10T14:42:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/forge%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E8%BF%87%E7%A8%8B%E4%B8%AD%E7%9A%84%E9%97%AE%E9%A2%98/","section":"post","tags":["ARCHIVE"],"title":"使用forge工具管理issue支持多平台或代理服务"},{"categories":["博客站务"],"contents":"目的 了解plantuml server 强大的代理功能，实现在github上插入uml原型图。目前使用的方式，在org中插入脚本，生成本地文件，再加载到org中，会产生图片附件，需要维护和空间的占用。经过学习，可以通过代理方式，只需要指定uml的源文件，服务器就可以返回已经绘制原型图。 The servlet for server side\n代理服务介绍 通过代理服务，PlantUML 服务器可以从远程plantuml文件中获取uml的源码。\n代理服务使用以下 URL 方案： /plantuml/proxy?src=RESOURCE\u0026amp;idx=INDEX\u0026amp;fmt=FORMAT\nRESOURCE ： uml源码（如：@startxxx和@endxxx标签）远程文件的完整 URL ，它可以是一个 .html 或一个 .txt 文件。 INDEX 是可选的，它指定当远程文档中有多个图描述时，将解析的图描述的出现（从 0 开始）。它默认为零。 FORMAT 是可选的，它指定要返回的格式。支持的值是： png ， svg ， eps ， pstext 和 txt 。默认为 png 。 例如: http: www.plantuml.com/plantuml/proxy?src=https: raw.github.com/plantuml/plantuml-server/master/src/main/webapp/resource/test2diagrams.txt \u0026gt;注意远程文档的地址是作为参数指定的，所以不需要对URL进行URL编码。\n其他资料 git - How to integrate UML diagrams into GitLab or GitHub - Stack Overflow\nMarkdown native diagrams with PlantUML | Andreas\u0026rsquo; Blog 作者的两个案例： GitHub - anoff/plantbuddy: nodeMCU based moisture monitoring for plants 🌱 wit\u0026hellip; GitHub - devradar/devradar: Competence Management for developers\n","date":"2021-08-09T22:33:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/plantuml%E4%BB%A3%E7%90%86%E4%BD%BF%E7%94%A8%E6%96%B9%E5%BC%8F/","section":"post","tags":["uml"],"title":"借助plantuml代理服务实现在markdown中绘制原型图"},{"categories":["博客站务"],"contents":" \u0026#30446;\u0026#24405; 目的 资源： 目的 看到画图软件，而且是开源APP, 没有抵抗力，收藏。\n配合slate 本绘图。手上又一个 wacom slate 智能本，吃土了好多年，据说支持mac端连接wacom画板，经验证不支持slate本。\nmac 端app 情况\nwacom 官方有mac版本 Wacom inkspace APP ，支持数码本的slate 软件，目前在连接过程出现问题，有可能M1版本兼容问题，M1蓝牙问题验证，蓝牙键盘断连的情况严重。\n资源： Xournal++ Mobile\nXournal++\nxournalpp/MacBuild.md at master · xournalpp/xournalpp · GitHub\nHow to Install and Use Xournal Note Taking App on Ubuntu – Linux Hint\n","date":"2021-08-09T16:20:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/Xournal%E6%B6%82%E9%B8%A6%E7%AC%94%E8%AE%B0/","section":"post","tags":["工具"],"title":"Xournal++涂鸦笔记使用"},{"categories":["博客站务"],"contents":"1 目的 使用图床方式托管图片，减小hugo源文件对github库的占用控件。\n在使用markdown时，可以使用 ！[](imgUrl) 语法加载图床中的图片。\n现在想在org-mode中实现同样的效果，尝试了以下几种方式，都无法实现。\norg-mode插图仅支持文件模式:\n具体插入流程：org-download本身会自动在org文档当前目录下创建一个与文档同名的文件夹来保存图片，然后支持多种途径的图片插入，插入之后会复制或者下载一张图片到图片文件夹下面。\n参考的资料：\nImages in Content — ox-hugo - Org to Hugo exporter\n利其器─Emacs/orgmode插入图片 - 知行合一\n使用Emacs中的org-mode写cnblogs之图片插入 - yangwen0228 - 博客园\n2 探索插入图片的几种方案 外连接图片直接粘贴路径到org中即可。\n1 2 #+ATTR_HTML: :width 50% :align center https://devalot.com/assets/articles/2008/07/project-planning/expanded.jpg 导出md后的格式：\n1 2 \u0026lt;figure\u0026gt;\u0026lt;img src=\u0026#34;https://devalot.com/assets/articles/2008/07/project-planning/expanded.jpg\u0026#34; width=\u0026#34;50%\u0026#34;\u0026gt; \u0026lt;/figure\u0026gt; 使用脚本生成图片\nsnippet命令：uml/xmd/wbs\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #+BEGIN_SRC plantuml :file ../iPics/images/emacs.png @startmindmap caption 总结emacs 知识体系 title emacs 知识体系 center header 通过结构来描述emacs 最受用的工具 endheader * root node ** child node left side ** child left node ***_ child2 left node \u0026#39;给图表添加备注 legend right 完成相关技能的总结回顾 endlegend center footer 结束 endfooter @endmindmap \\#+END_SRC img直接导出markdown语法\nsnippet命令：umlimg\n1 @@md:![](http://www.plantuml.com/plantuml/proxy?cache=no\u0026amp;src=https://it-boyer.github.io/iDocs/uml/UGM-gtd.plantuml)@@ markdown语法必须使用反转义包围： @@md: md语法 @@ 否则，导出的会添加反斜杠转义符: \\![](imgUrl) 导致在hugo中无法正确显示图片。\nExport snippet Markdown ❚ ox-hugo Test Site\n宏的使用\n习七 Issue #85\nMultiple ATTR_HTML\nsnippet命令：img\n1 2 3 4 #+html: \u0026lt;style\u0026gt;.foo img { border:2px solid black; }\u0026lt;/style\u0026gt; #+attr_html: :alt Org mode logo #+attr_html: :width 300 :class foo [[https://ox-hugo.scripter.co/test/images/org-mode-unicorn-logo.png]] SVG 支持\n1 2 3 4 5 6 7 8 9 10 #+begin_src plantuml :file ../iPics/images/ox-hugo/svg-with-hyperlinks.svg :exports results skinparam svgLinkTarget _parent start :[[https://ox-hugo.scripter.co/ ox-hugo homepage]]; stop #+end_src #+caption: An SVG with *hyperlinks* -- generated using PlantUML #+attr_html: :inlined t #+RESULTS: [[file:../iPics/images/ox-hugo/svg-with-hyperlinks.svg]] Inlined SVG ❚ ox-hugo Test Site\n问题：\nhomebrew 安装emacs 27.1 不支持svg吗? - Emacs-general - Emacs China\n无法显示 svg，Invalid image type \u0026lsquo;svg\u0026rsquo; - Emacs-general - Emacs China\n3 org-download工具使用 org-download本身会自动在org文档当前目录下创建一个与文档同名的文件夹来保存图片，然后支持多种途径的图片插入，插入之后会复制或者下载一张图片到图片文件夹下面：\n用url把图片插入，然后自动下载； 复制图片文件路径，然后插入； 拖拽图片插入。 支持两种 org-download-method 方式： 方式1： attach 1 (setq org-download-method \u0026#39;attach) 在这种模式下，存在两个问题\n问题1:在插入图片时，图片会被存到 ~ /org/.attach 下一个很长串的目录下。\n这种附件方式，无法指定图片的存放位置，导致无法使用托管图库，导致库文件大。\n解决办法：将 .attach 目录作为图库的托管目录，这样就可以把较大的附件托管给子模块库中。\n问题2:在插入了attachment后，headline添加一个名为 :ATTACH: 的tag\n因为ox-hugo在导出org时，会把headline的tag作为tag或分类，导出到hugo站中。对于hugo来说 ATTACH 意义不大。\n解决办法：关闭导出标签的开关 (setq org-export-with-tags nil) 这种方式在ox-hugo导出无效。\n方式2： directory 1 (setq org-download-method \u0026#39;directory) doom-emacs下安装 在init.el中的org模块下增加 +org-download .\n使用 spc m a P: yank\nspc m a p: clipboard\nz i: 预览图片开关\n图片大小控制 通过下面的属性可以分别控制图片在emacs里面显示的大小以及导出的html的图片的大小。\n1 2 3 #+ATTR_ORG: :width 200 #+ATTR_HTML: :width 50% :align center [[attachment:_20210805_170910proxy.png]] ","date":"2021-08-09T14:31:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/org-download%E4%BD%BF%E7%94%A8%E6%8A%80%E5%B7%A7/","section":"post","tags":null,"title":"org-mode插入图片的方法"},{"categories":["博客站务"],"contents":"警告 本文前期思路：借助hugo 和ox-hugo 之间 static 目录的特征，以static 作为github托管目录，由于hugo 在编译过程中，会直接将 static 目录所有内容，拷贝至 public 目录中，包括 .git 版本目录。这样就会覆盖 public 中的git版本目录。\nstatic 目录介绍 - Hugo中文文档\n= 故，得出定论： static 无法用于托管目录，本章的托管方案废弃。\n目的 单纯想把图片资源从hugo库中隔离到单独库中，避免hugo库增大，超出1G空间。\n用到的三个知识点：\nhugo资源库目录结构 static org-download: 支持拖动图片到org中，自动保持到指定目录 ox-hugo :org导出为md过程，将org资源拷贝到 static 的机制介绍 图1 本文涉及到的知识点和问题汇总概览\nox-hugo导出机制 Image Links — ox-hugo - Org to Hugo exporter\n对hugo站结构做了相应的支持,ox-hugo在导出资源时，会自动将org文件的文件附件，自动拷贝到 hugo根目录下的static目录中。\n引用static目录下的文件例如当文件foo.png 文件在static目录下： ~/hugo/static/images/foo.png, 在org 种只需要 /images/foo.png 。\n引用static目录之外的文件当file 引用的文件在其他目录时，ox-hugo 定义了相关规则，会自动将文件拷贝到static 目录下，具体规则：Source path contains static\n如何禁止ox-hugo 自动拷贝的Disable auto-copying\n1 (setq org-hugo-external-file-extensions-allowed-for-copying nil) 实现托管的方法 开启 ox-hugo 自动保存功能托管的方案的主要依赖的ox-hugo 的功能， 即 org-hugo-external-file-extensions-allowed-for-copying 变量默认值即可。\n1 2 ;;默认值， (setq org-hugo-external-file-extensions-allowed-for-copying (\u0026#34;jpg\u0026#34; \u0026#34;jpeg\u0026#34; \u0026#34;tiff\u0026#34; \u0026#34;png\u0026#34; \u0026#34;svg\u0026#34; \u0026#34;gif\u0026#34; \u0026#34;mp4\u0026#34; \u0026#34;pdf\u0026#34; \u0026#34;odt\u0026#34; \u0026#34;doc\u0026#34; \u0026#34;ppt\u0026#34; \u0026#34;xls\u0026#34; \u0026#34;docx\u0026#34; \u0026#34;pptx\u0026#34; \u0026#34;xlsx\u0026#34;)) 从主库中拆出 static ，并托管到github 中，作为图床。主要使用命令： git subtree split Git 仓库拆拆拆 - SegmentFault 思否\n托管到github 之后，在以submodule 子模块方式，集成到主库中。\n设置 org-download 自动保存在 static 目录\n1 2 (setq org-download-method \u0026#39;directory) (setq-default org-download-image-dir \u0026#34;~/hsg/iNotes/static/ox-hugo\u0026#34;) 当停用自动拷贝的功能，file 引用的路径就会为相对路径，导致图片资源无法加载。\n如何解决这个问题： 将org-download 的下载目录设置在hugo站资源的static 目录。\n这样通过org-download 添加到org 的图片和ox-hugo 自动保存的目录一致，然后把static 使用subtree 命令，拆出一个新库，专门存放附件资源。\n然后，通过 submodule 的方式从新加入到hugo 中，以git 子模块的方式，来减轻git 库的大小。\n把file 自动引用的路径设置为 hugo目录下的static,\n1 (setq-default org-download-image-dir \u0026#34;~/hsg/iNotes/static/ox-hugo\u0026#34;) 开启自动拷贝功能。这样，file 引用的外链接有 /static/, 当ox-hugo自动拷贝资源时，会按照static 规则.\n","date":"2021-08-09T14:31:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/%E5%AD%A6%E4%B9%A0ox-hugo%E6%89%98%E7%AE%A1%E5%9B%BE%E5%BA%93/","section":"post","tags":null,"title":"ox-hugo托管图库，轻量化hugo站库（废弃）"},{"categories":["项目总结"],"contents":"这本书的契机 学习这本书的契机，是在听得到资源的音频课程，意外发现的，它有六节课，每节课一个小时，刚听时比较难以接受的，当时正在收集书籍，来规划从书中提高自身的能力，在知乎上做过一段时间的调查，读书是要系统化，才能吸收并应用知识，提高自身的能力.\n刚听时，内心是比较抵触的，但是在反复听了三遍，才认识到成人学习的概念，成人教育的五大公理，然后，拆书的理念又和麦肯锡高效阅读法和聪明都在用的方格笔记本的理念不谋而合 （三分法：板书-发现-行动/I-A1-A2） .\n方格笔记本从“记思传”（学习笔记本/工作笔记本/提案笔记本）三个方面来打破对笔记本的认知，提供了方格笔记本的方法培养人的逻辑思维能力。\n拆为己用的原则 拆为己用的适用边界：成人教育，致用类书籍！原则是：反求诸己，对学习者负责。\n在拆为己用的概念中加入了成人教育的角度来说读书的方法的问题，这也迎合了方格笔记本中的工作笔记本法的观念。拆为己用在读书难的老问题中的反思和追问下，开始了超越式的解决读书难的问题，即拆为已用的理论的提出依据。\n标签法 VS 方格笔记三分法 方格笔记本三分法重在由事实问题，到发现问题，再到方案的策划。\n提案笔记本 是解决问题为目的，对应拆为己用的 A1IA2 标签法 以经验为基础反思整理再到策划付诸行动。\n学习笔记本 板书到发现到行动是内化知识，应用知识的过程和拆为己用的 IA1A2 标签法 便签概念保持一致。\n可知在笔记本的方法论的基础基础上，三分法是笔记的根本，思想上基于事实，激活个人经验叙述为故事来内化知识，在制定行动中应用知识。在拆为己用提供一套三步法的完整的标准。\n所以现在的情况是，标签法已经基本掌握，如何吸收知识还没有真正的应用到实践中。如何把拆为己用的理论方法，内化为自己的知识，在阅读中应用起来。需要培养拆为己用的习惯。\n标签法 VS 七个习惯 对比了方格笔记本的深刻了解了方法论的重要性，怎样付诸行动，可以对比下高效能人士的七个习惯的技巧。即如何把拆为己用内化为习惯。\n高效能人士的七个习惯中心在于从转换思维的层面来彻底改变人的行为和态度，即要想改变行为和态度必需现在思维方式进行转换。要找习惯所遵循的原则，明确以什么原则为中心的思维方式，然后确定产出和产能的角色是谁，遵循产出和产能平衡原则才能实现高效能。\n七个习惯的首要习惯积极主动，刺激和回应之间的选择自由原则，赋予了作出承诺，信守承诺的责任。在开发一个习惯时，要发挥人的四大天赋，自我意识，独立意志，良知和想象力。基于这些，才能有效的确认和开发习惯。\n习惯的养成，是要有新的思想水平：必需由内而外，以原则为中心的思维方式。\n在学习拆为己用的过程中，很明显在前几章中，着重于改观学习的观念，从思维方式上的转换，达到在学习力上的改进。提升学习能力。\n拆为己用符合习惯的标准吗？\n知识 ：理论范畴,思维方式转换，你是哪个哪个境界的阅读者。\n技巧 ：适用 IA1A2 便签法\n意愿 ：内化知识，应用知识，激活经验（鲜活，故事，关联，反思），付诸行动（目标，行动，关联，可控）\n拆为已用要革新什么思维方式？如何转换，转换后会带来什么变化？\n拆为己用是一种能力，一种观念，从书本、经验中获取知识，并引用的方法。\n充分实践拆为己用的习惯，达到快速阅读，内化知识应用知识的效果。\n如果重技巧工具轻内化知识和应用知识的能力，就无法提高吸收应用新知识的本领。\n拆为己用的产出是什么，产能是什么，如何保证效能平衡？\n产能：拆为己用的理念和拆的便签法\n产出：提高学习新知识/掌握新能力的质量和速度\n拆为己用的习惯 知识 ：理论范畴，做什么，为何做\n技巧 ：怎么做，如何做\n意愿 ：确定态度\n原则 ：便签法阅读\n从拆为己用中学到了什么，该如何内化知识，在阅读中应用到拆为己用的理论和能力。\n","date":"2021-08-03T18:44:00+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/%E6%8B%86%E4%B8%BA%E5%B7%B1%E7%94%A8%E8%AF%BB%E5%90%8E%E6%84%9F/","section":"post","tags":null,"title":"《这样读书就够了》读后感"},{"categories":["博客站务"],"contents":" \u0026#30446;\u0026#24405; hugo中集成Fuse.js实现站内搜索 hugo中集成Fuse.js实现站内搜索 5分钟给Hugo博客增加搜索功能 :: /dev/ttyS3 — 回首向来萧瑟处 也无荒野也无灯\nFast, instant client side search for Hugo static site generator · GitHub\n配置config.toml outputs:支持json 在layouts/_default/新建 index.json 在layouts/_default/新建 baseof.html 先拷贝even主题下的文件，在把搜索样式添加到文件末尾 在static中添加js脚本 在fastsearch.js中配置**CMD+/**显示隐藏快捷键 ","date":"2021-08-03T14:00:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/hugo%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/","section":"post","tags":null,"title":"使用Fuse.js实现hugo站内搜索功能"},{"categories":["日志随笔"],"contents":"我以前常以诗篇的形式，反思、畅想、记录生活的点滴，一篇几十字下来，半个小时已经过去，在这个等同冥想的体验，身心得到了短暂的释放，把内心的喜怒哀乐，装饰成屏幕上的二十八个文字，借助微信发圈，代替自己的心态和心境，也是自我慰籍的唯一方式。\n早上在读的文章，被质朴敦厚，甚至有点神经质的表达给打动了，其实生活本来就是没有逻辑的，是文字强加了太多自我感情，让生活产生距离感，不可方物。\n生活是用来享受的，在记录生活记忆时，文字是不需要逻辑的，只要放声去笑，任性去蹦去挑，用最真切的感受享受生活的酸甜苦辣。\n在不公时，勇敢说不，在欢快时，不吝分享，在生活里，活出自己的样子，用自己舒服的方式表达所见所闻所想，在这种抒情方式中感知自己的态度，只有这样，才能看到真实的自己，才能探索到自己生活中真正的中心是什么，自己最关心最要紧的是什么。\n","date":"2021-07-28T11:06:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E6%B2%89%E9%97%B7%E7%9A%84%E4%B8%80%E5%A4%A9/","section":"post","tags":["效能"],"title":"沉闷酷热早晨，一篇朴实无华的公众号，带来了些许凉意"},{"categories":["日志随笔"],"contents":" \u0026#30446;\u0026#24405; 写作目的 迷茫期 写作目的 公司要求，需要结合培训内容，来理解公司的价值观，使命，责任，让后在这些思想上武装自己，做好自己的工作。\n迷茫期 最近处于迷茫期，职业的属性，性格的使然，很少关心未来和职业规划，成为了迷茫的元凶。\n在这种状态下，参加了金才计划培训，令我倍感深刻是公司的使命感，责任感，就像对社会的庄重的使命宣言。\n金和人一代代，都在坚守着公司使命，奔走奋斗在全国一线，为此三十年的不懈努力付出，成就了现在依然不停直面挑战，敢于变革的雄厚实力和底气，成就一个又个全新的服务体系。\n在培训中，老师对创始人奋斗史的讲述，生动形象，入木三分，对于自己来说印象最深的是，创始人刚毕业作为第一代计算机毕业生加入国家大厂，一个人担起大厂为一台计算机工作经历。\n在四堂课中，创始人也亲自讲述了这段经历，他作为工厂的唯一计算机大学生，被工厂十分优待，一个人拥有自己的办公室，据说是因为计算机当时格外珍惜，要求工作环境非常干净，每天需要着特质工作服，只身一人和计算机为伴；这段经历何尝不是当下程序员的真实写照呢.\n但是创始人并没为这份特殊的优待和舒适迷失自己，而是，选择了褪去该有光环，带着对工厂的责任对未来梦想，走了出去，和工人打成一片，向工人学习机械的使用，了解工厂的管理模式，甚至工厂维修下水道，也要熟悉学习；在这么勤苦的努力下，半年时间已经了解工厂的运营模式，机器的运转原理，工人的调度管理。\n创始人自豪的说，这次初入职场经历，勤奋积累下来的知识和管理经验，影响了他未来的未来几十年的职业生涯:从初出茅庐下海，到创业街一哥；又到贡献社会，著作了精确管理；再自我提升，开拓讲师培训；时刻在影响他人，为他人提供最高效的管理经验，影响了一代的企业家；又不忘民生，带领团队奔赴食品安全一线，普及饮食安全，竭力做好每一件小事上，成就着一件件大事。\n开挂的人生，都有一套心法为他助力;我确信,就是公司的责任，使命;字字如金，刻在了创始人的骨子里，志在感染更多金和人，把这些口号，，不仅人生付诸行动，更要借助公司影响力来改变社会。\n一个到人生的一定阶段，都会面临这种那种的抉择，从初出茅庐一心扑在事业上，不懂得什么人情世故，与家人、朋友聚少离多，社交也越来越少，局限在工作圈内。\n","date":"2021-07-23T15:27:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%87%91%E6%89%8D%E8%AE%A1%E5%88%92%E5%9F%B9%E8%AE%AD%E6%80%BB%E7%BB%93/","section":"post","tags":["ARCHIVE"],"title":"金才计划培训中的收获和感想"},{"categories":["解决方案"],"contents":" \u0026#30446;\u0026#24405; 问题情况描述 解决办法 问题情况描述 在appstore安装过程中，有可能因为网络异常导致安装异常中止，但是进度依然显示安装中，此时无法通过appstore撤销安装。\n在这种异常中止的情况下，我尝试安装几种方式，都会出现阻塞，无法正常安装。\n以安装 oneDrive为例,尝试了三种安装方法：\nAppStore 安装失败\nhomebrew\nbrew search onedrive\nbrew install onedrive\n在执行过程，出现阻塞。\npkg\n从官网下载安装包，双击通过系统安装器安装\n在安装过程中会有提示： 等待其他安装完成\n解决办法 重启电脑，可以重新正常安装 免重启，解决办法： sudo killall -1 installd\nmacos - Installer hangs on \u0026ldquo;waiting for other installations to finish\u0026rdquo; despit\u0026hellip; ","date":"2021-07-21T16:40:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E5%AE%89%E8%A3%85%E8%BF%87%E7%A8%8B%E5%A4%B1%E8%B4%A5%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/","section":"post","tags":["ARCHIVE","管理"],"title":"解决appstore安装app过程进度停止问题"},{"categories":["博客站务"],"contents":" \u0026#30446;\u0026#24405; DONE 写作目的 导出时todo 状态隐藏的问题 隐藏todo 状态转换之后的时间戳的方法 自定义todo 关键字的样式 温习了几个标签的使用 意外收获 DONE 写作目的 开这篇文章的目的是，总结今天在导出博客过程中遇到的问题和解决方式和办法。也希望在以后使用ox-hugo过程中，在遇到类似问题可以统一在这里汇总，在这里找到解决问题的思路和办法。\n今天遇到的几个问题：\n导出时todo 状态隐藏的问题 隐藏todo 状态转换之后的时间戳的方法 自定义todo 关键字的样式 温习了几个标签的使用 意外收获 解题思路是走官方提供的一套demo，在demo 检索相关操作和实现，收获了几个方法\n检索上：在目录中，搜索关键，检索当前目录下的所有文件 ： spc s d\n导出时todo 状态隐藏的问题 想要使用ox-hugo 规范化写作流程，就需要通过agenda管理跟踪日常的写作。这就必须面对进度状态关键字和ox-hugo 导出过程的兼容问题。\n今天针对这个问题，查看了官方demo 给的例子， todo 选项控制在导出时，隐藏或显示todo关键字。\n导出时，显示：当在写作阶段，在网页段显示todo状态，可以方便跟踪任务状态和进度，把todo 设置为t即可。\n1 2 3 :PROPERTIES: :EXPORT_OPTIONS: todo:t :END: 导出时，隐藏：在完成写作校对之后，导出成品时，可以通过设置todo 为 nil 隐藏todo 关键字。\n1 2 3 :PROPERTIES: :EXPORT_OPTIONS: todo:nil :END: 隐藏todo 状态转换之后的时间戳的方法 在切换任务状态时，会有活动状态变更log记录，在ox-hugo导出时，这些记录显示会显示网页中：\n1 - State \u0026#34;DONE\u0026#34; from \u0026#34;TODO\u0026#34; [2021-07-15 Thu 19:22] 如何即保留这些记录，导出时，ox-hugo又可以忽略这些记录，在看了官方demo发现针对该问题的属性： :LOG_INTO_DRAWER: t\n1 2 3 :PROPERTIES: :LOG_INTO_DRAWER: t :end: 当该属性开启状态时，日志信息会自动添加到 LOGBOOK 中，此时在执行导出，状态记录会被自动忽略。\n1 2 3 :LOGBOOK: - State \u0026#34;DONE\u0026#34; from \u0026#34;TODO\u0026#34; [2021-07-15 Thu 19:22] :END: 自定义todo 关键字的样式 这个功能是在学习隐藏显示todo 关键字过程中的意外发现，目前测试还没有生效，先贴上代码，以后在做研究：\n具体方法：\n先声明todo 的css样式\n在org 文件声明方式，即新建一个节点，例如 CSS for TODO, 并设置不支持导出 :noexport:,如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 CSS for TODO :noexport: :PROPERTIES: :CUSTOM_ID: todo-css :END: #+begin_export html \u0026lt;style\u0026gt; .org-todo { font-size: 0.8em; font-weight: 700; } /* *** Org TODO set to TODO state */ .org-todo.todo { color: #e60000; } /* *** Org TODO set to DONE state */ .org-todo.done { color: green; } \u0026lt;/style\u0026gt; #+end_export 在节点处引用自定义的css样式\n上述样例中，最关键是提供一个id :CUSTOM_ID: todo-css, 让后就可以引入：\n1 #+include: \u0026#34;./all-posts.org::#todo-css\u0026#34; :only-contents t 温习了几个标签的使用 在导出过程中，有很多重要的属性，经常忘记，今天重新熟悉了几个，作为巩固学习。\ntoc ： 是否生成索引目录， 可以指定索引的深度，例如： toc:2 生成两级以内的索引，配合使用还有 num, 例如： num:2 给索引添加索引号码，支持两级内。 h:3 ：支持导出的等级数。 意外收获 目录下检索关键字在目录中，搜索关键，检索当前目录下的所有文件 ： spc s d\n需要安装第三方工具：ripgrep brew install ripgrep\nTODO 转为DONE ，自动添加Colsed\n(setq org-log-done \u0026rsquo;time)\n或\nClosing items (The Org Manual)\n","date":"2021-07-16T12:43:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/ox-hugo%E5%B7%A5%E5%85%B7%E7%BB%8F%E9%AA%8C%E7%A7%AF%E7%B4%AF/","section":"post","tags":["hugo"],"title":"ox-hugo在博客写作过程积累总结"},{"categories":["日志随笔"],"contents":"沉闷酷热早晨，一篇朴实无华的公众号，带来了些许凉意 我以前常以诗篇的形式，反思、畅想、记录生活的点滴，一篇几十字下来，半个小时已经过去，在这个等同冥想的体验，身心得到了短暂的释放，把内心的喜怒哀乐，装饰成屏幕上的二十八个文字，借助微信发圈，代替自己的心态和心境，也是自我慰籍的唯一方式。\n早上在读的文章，被质朴敦厚，甚至有点神经质的表达给打动了，其实生活本来就是没有逻辑的，是文字强加了太多自我感情，让生活产生距离感，不可方物。\n生活是用来享受的，在记录生活记忆时，文字是不需要逻辑的，只要放声去笑，任性去蹦去挑，用最真切的感受享受生活的酸甜苦辣。\n在不公时，勇敢说不，在欢快时，不吝分享，在生活里，活出自己的样子，用自己舒服的方式表达所见所闻所想，在这种抒情方式中感知自己的态度，只有这样，才能看到真实的自己，才能探索到自己生活中真正的中心是什么，自己最关心最要紧的是什么。\n利用emacs培养自己的生活号，探索内在的自我 回想之前写诗篇的时候，使用一部手机扛起了记录生活的大旗。抒写着对生活的理解，迷茫，失望；记录着每次面对挫败，独自顽抗的日子。但是无论多么努力也无法摆脱被生活抛弃的命运。\n反思之前的写作态度，一篇篇虽然是由感而发，性情使然，作为精神寄托，了却了短暂的焦虑感，再细品昨日情真意切的文字，是对生活的不理解，是面对现实时，无助和焦虑，为了表达而强说愁的无力叹息。\n要真正改变生活，应该思考什么，从哪些方面理解生活，才能发挥写作的作用，让理想走进现实。\n像那样不思后果的学习，力所能及的学习，顽强不屈的学习，自己又是一个半途而废的人，又坚信在书海中有想要的出路和明天。最终在最后的努力中，寻觅到两大技巧，以为掌握了这两大技巧七习和拆为己用，就能掌握自己的人生改变命运了。\n在七习中我学会自我意识，想象力的作用，在拆为己用中，我学会了经验反思，知道知识体系的样子。我开始有了自我意识，想象力和经验反思，搭建自己知识体系的意愿。我深刻知道，治愈焦虑最有效的方式是：思考。\n从上可知，我一个知识焦虑对人生缺少规划的人，希望在七习之后，能够掌控自己的命运。\n使用emacs助力，开启七习改变生活的新篇章。\n初心：因为工具，因为emacs，成了噩梦 在工具的偏执的影响下，心理上的扭曲，恪守着矫情荒唐的观念：计划只能emacs有权制定，没有计划，就没有生活，没有计划，就没有人生，没有计划，就没有没有价值。\n这样，计划制定被emacs限制，人被观念限制，日复一日，恐惧生活，不敢迈出一步。因为没有计划，就是失败的一天，没有计划，就是不责任的一天。\nemacs成了新生活的唯一的救命稻草，生杀大权掌握在一个疯子手上，整个人又陷入工具陷阱无法自拔，每天都在努力使用emacs改变生活，创造价值，无疑是与虎谋皮，荒唐可笑。\n在偏执狂的淫威下，趋炎附势了一辈子，甘作工具的奴隶，疯狂的学习emacs的各种技巧，高级方法，耗尽心血，换来的是变本加厉，更高的学习成本。\n初心愿景，在工具面前为什么这么容易忘记，不堪一击。\nemacs愿景是做作计划，思考问题，分解任务，只要能圣人gtd职能就行，跟踪任务进度，监督任务健康就行。\n现在的emacs成了什么，庞大到不可同日而语，耗尽了两年心血，把所有的想象都倾注在了emacs中。却没有做好最初的愿景，荒废中人生。在心理作用下，一直被奴役，一心一意服务emacs.\n重生：自由选择 把所有精力投入到高效能的苛求上，特别在emacs练习应用中，无所不用其极透支自身精力，我的愿景是，把所有力所能及的事情，统一在emacs中实操七习，一站式领导管理设计反思（博客的性质），开启全新沉浸式的生活。\n在思维转换上，思考很久，确切地说是消沉，两个月前，开始消沉，否定过去，自甘堕落，潜意识里驱使着疲惫的身心，想换一种轻松一点的生活方式，想摆脱那个整日因为焦虑而忙碌到焦头烂额的人。\n终于，要在心态上摆正emacs,摆正工具的位置\n要克制对工具的依赖，坚定初心，制定计划，跟踪计划，调整计划的作用。\n","date":"2021-07-15T11:05:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/emacs%E7%BC%96%E5%86%99%E5%85%AC%E4%BC%97%E5%8F%B7%E5%8F%91%E5%B8%83%E6%B5%81%E7%A8%8B%E6%8E%A2%E7%B4%A2/","section":"post","tags":["效能"],"title":"博主的写作日常，是否可以利用emacs提升一些效率"},{"categories":["日志随笔"],"contents":"飞快的车轮 第一次下班,这么期待坐公交车\n我想在第一时间,感受转换思维之后\nemacs会对我的生活带来哪些改变\n以前,耗尽心血在丰富插件,完善它功能\n今天终于可以在心理上得到应用\n开始把它作为工具来看\n我以前写作,依赖微信\n我现在有自己写作平台\n我要给我能够从容\n","date":"2021-07-14T18:55:00+08:00","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E7%A9%BA%E8%B0%83%E5%85%AC%E4%BA%A4%E5%B0%9D%E8%AF%95%E7%BC%96%E5%86%99%E4%B8%80%E7%89%87%E7%9F%AD%E6%96%87/","section":"post","tags":null,"title":"苦闷天,尝鲜空调公交的浪漫行"},{"categories":["解决方案"],"contents":"rime rime 是一款输入引擎，它开放了一套配置协议，为多元的输入法（同文输入法、鼠须管输入法等）的基础，输入法和rime引擎之间通过这套协议实现多样化的输入方案。\n官方解释：rime是啥？ \u0026gt; Rime 不是一种输入法。是从各种常见键盘输入法中提炼出来的抽象的输入算法框架。因为Rime 涵盖了大多数输入法的「共性」，所以在不同的设定下，Rime 可化身为不同的输入法用来打字。\n下載及安裝 | RIME | 中州韻輸入法引擎\n输入方案 rime是一款开源的输入法引擎，约定了配置规范，根据这套规范可以定制自己的 输入方案 ，由此，应运而生配置管理工具 東風破 plum 维护着大量优秀的 输入方案 。\n官方解释： \u0026gt;要让Rime 实现某种具体输入法的功能，就需要一些数据来描述这种输入法以何种形式工作。即，定义该输入法的「个性」。 \u0026gt;如「汉语拼音」、「注音」、「仓颉码」、「五笔字型」，这些方法可凭借Rime 提供的通用设施、给定不同的工作参数来实作。以本文介绍的规格写成一套套的配方，就是Rime 输入方案。\n常用的输入方案：rime-luna-pinyin: 【朙月拼音】輸入方案\n如果想定制键位/快捷键可以参考： CustomizationGuide · rime/home Wiki · GitHub\n创建自己的 输入方案 ：RimeWithSchemata · rime/home Wiki · GitHub\n安卓版:trime 详细的文档 ：trime.yaml詳解 trime输入方案 使用输入法配置库：rimerc, 大牛配置好的配置，包括同文和squirrel 配置。\n配置路径在/sdcard/rime, 将rimerc 库中的trime.z7 解压到该目录。\nrimerc 库内容已经变化，作者还没有更新readme.\n定制候选词条的个数 在 default.custom.yaml 文件中添加\n1 2 patch: menu/page_size: 10 隐藏侯选框的方法 在 luna_pinyin.schema.yaml 定制：\n1 2 - name: _hide_candidate reset: 0 #默认开启这个开关，隐藏候选栏 设置输入法偏好 汉字与小写半角 汉字与中文标点配套 英文与英文标点 在 luna_pinyin.schema.yaml 定制：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 switches: - name: ascii_mode reset: 1 states: [ 中文, 西文 ] - name: full_shape states: [ 半角, 全角 ] - name: simplification reset: 1 states: [ 漢字, 汉字 ] - name: ascii_punct reset: 0 states: [ 。，, ．， ] # - name: _hide_candidate # reset: 0 #默认开启这个开关，隐藏候选栏 # 这个按键用来收起软键盘 # - options: [ _key_Control_L ] # states: [ \u0026#34;CTRL\u0026#34; ] # - options: [ _key_Escape ] # states: [ \u0026#34;ESC\u0026#34; ] # - options: [ _key_Alt_L ] # states: [ \u0026#34;Alt\u0026#34; ] 键位设置 trime 键位分为两种，26键和36键\ntrime默认26键位,绑定键位的方法： querty\n1 \u0026#34;preset_keyboards/qwerty/keys/@26/click\u0026#34;: date_time 开启36键位的方法： querty0\n1 2 \u0026#34;preset_keyboards/luna_pinyin/import_preset\u0026#34;: qwerty0 \u0026#34;preset_keyboards/qwerty0/keys/@43/long_click\u0026#34;: Mode_switch 键位绑定支持两种方式：键位占用和键位长按\n1 2 3 4 # click绑定键位 \u0026#34;preset_keyboards/qwerty/keys/@26/click\u0026#34;: date_time # long_click绑定键位长按 \u0026#34;preset_keyboards/qwerty/keys/@26/long_click\u0026#34;: date_time 声明键事件并绑定\n声明方式使用 \u0026quot;preset_keys/custom_key\u0026quot;:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 # 参考trime.yaml内置的date键，新建一个按键date_time \u0026#34;preset_keys/date_time\u0026#34;: command: date label: 时间 option: \u0026#34;yyyy-MM-dd HH:mm:ss\u0026#34; #通过`option`参数控制输出的日期和时间格式 send: function #Clear: {label: 清除, text: \u0026#34;{Control+a}{BackSpace}\u0026#34;} #全選並刪除 \u0026#34;preset_keys/cg\u0026#34;: label: 撤销 send: Control+g \u0026#34;preset_keys/cc\u0026#34;: label: 完1 text: \u0026#34;{Control+c}{Control+c}\u0026#34; \u0026#34;preset_keys/control\u0026#34;: label: CTR send: Control_L #space+colon 用data_time替换原预设26键键盘中的time\n1 2 3 \u0026#34;preset_keyboards/qwerty/keys/@26/long_click\u0026#34;: date_time \u0026#34;preset_keyboards/qwerty/keys/@33/long_click\u0026#34;: Mode_switch \u0026#34;preset_keyboards/qwerty/keys/@36/long_click\u0026#34;: todo 让朙月拼音使用36键键盘布局\n1 2 3 4 \u0026#34;preset_keyboards/luna_pinyin/import_preset\u0026#34;: qwerty0 \u0026#34;preset_keyboards/qwerty0/keys/@36/long_click\u0026#34;: date_time \u0026#34;preset_keyboards/qwerty0/keys/@43/long_click\u0026#34;: Mode_switch \u0026#34;preset_keyboards/qwerty0/keys/@46/long_click\u0026#34;: todo 定制长按空格键切换中英文 在 trime.custom.yaml 中定制如下操作： Mode_switch 是切换中英文事件，区分大小写。绑定到空格的键位 @33 上。\n1 \u0026#34;preset_keyboards/qwerty/keys/@33/long_click\u0026#34;: Mode_switch 定制长按Enter键输入 ~ - [ ] ~ 在 trime.custom.yaml 中定制如下操作：声明输入的文本\n1 2 3 \u0026#34;preset_keys/todo\u0026#34;: label: \u0026#34;- [ ]\u0026#34; text: \u0026#34;- [ ] \u0026#34; 添加到长按事件中\n1 \u0026#34;preset_keyboards/qwerty/keys/@36/long_click\u0026#34;: todo 状态栏添加菜单项 trime.yaml詳解 ·switches 在状态栏上添加按键：\n示例： 在状态栏放置按键（试验功能） option 格式：\n_key_ + 按键 （这里的按键可以是功能键、符号、字母、任意文本） _keyboard_ + 键盘布局ID （一些比较特殊的id：.default返回当前主键盘，.next下一个键盘，.last在最近使用的两个键盘间轮换，.last_lock返回上一个标记为lock的键盘） 需要在方案文件的 xx.custom.yaml 中添加如下配置：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 switches: # 这个按键用来收起软键盘 - options: [ _key_Hide ] states: [ \u0026#34;▼\u0026#34; ] #states是显示在状态栏的图标，options是实际执行的功能 # 这个按键用来调出输入法切换菜单 - options: [ _key_IME_switch ] states: [ \u0026#34;🌐\u0026#34; ] # 更多功能键请查阅trime.yaml/preset_keys # 这是一个空按键，按下去不会执行任何动作 - options: [ _key_VoidSymbol ] states: [ \u0026#34; \u0026#34; ] #空键的宽度由这里的空格决定 # 这个按键用来输出句号 - options: [ _key_period ] #period是句号的英文名，也可以直接写成[ _key_. ] states: [ \u0026#34;。\u0026#34; ] squirrel 网上教程很多，输入法目录在~/Library/Rime 下，可以借助plum 工具安装. 本人使用rimerc 库中的配置，clone 之后，解压安装到Rime 目录即可. 设置多台设备同步：sync_dir: \u0026ldquo;Users/boyer/ResilioSync/RimeSync/squirrel\u0026rdquo;\nemacs-rime 安装 librime 先安装鼠须管，里面有输入法方案。\n然后直接下载编译好的 librime 的 Releases 版本。\n1 2 3 curl -L -O https://github.com/rime/librime/releases/download/1.7.1/rime-1.7.1-osx.zip unzip rime-1.7.1-osx.zip -d ~/.emacs.d/librime rm -rf rime-1.7.1-osx.zip emacs 配置 在 doom 下安装\n1 (package! rime) 偏好设置： rime-librime-root : 指定为安装 librime 的目录 ~/.emacs.d/librime/dist\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 (use-package! rime :custom (default-input-method \u0026#34;rime\u0026#34;) (rime-emacs-module-header-root \u0026#34;/Applications/Emacs.app/Contents/Resources/include/\u0026#34;) (rime-librime-root (expand-file-name \u0026#34;librime/dist\u0026#34; user-emacs-directory)) (rime-cursor \u0026#34;˰\u0026#34;) (rime-show-candidate \u0026#39;posframe) ;;https://emacs-china.org/t/doom-emacs-rime/12499/18?u=huos3203 ;; (rime-share-data-dir \u0026#34;/Users/boyer/Library/Rime\u0026#34;) ;; (rime-user-data-dir \u0026#34;/Users/boyer/Library/Rime\u0026#34;) (rime-posframe-properties (list :background-color \u0026#34;#073642\u0026#34; :foreground-color \u0026#34;#839496\u0026#34; :internal-border-width 1 :font \u0026#34;Input Mono Narrow\u0026#34; )) ;; (rime-disable-predicates \u0026#39;(rime-predicate-evil-mode-p rime-predicate-after-alphabet-char-p rime-predicate-prog-in-code-p)) ;;; 具体参考 mode-line-mule-info 默认值，其中可能有其它有用信息 (mode-line-mule-info \u0026#39;((:eval (rime-lighter)))) ;;在 minibuffer 使用后自动关闭输入法 (rime-deactivate-when-exit-minibuffer t) :config (set-face-attribute \u0026#39;rime-default-face nil :foreground \u0026#34;#839496\u0026#34; :background \u0026#34;#073642\u0026#34;) ) 高低配置 设置默认输入法： Mx: rime-open-configuration 打开文件： ~/L.emacs.d/.local/etc/rime/default.custom.yaml,不存在时，新建。 1 2 3 patch: schema_list: # 對於列表類型，現在無有辦法指定如何添加、消除或單一修改某項，於是要在定製檔中將整個列表替換！ - schema: luna_pinyin_simp #默认简体输入法 设置用户配置同步目录不能和 squirrel 共用同步目录，会出现配置无效等异常问题。 emacs-rime 同步目录： sync_dir: \u0026quot;/Users/boyer/ResilioSync/RimeSync/emacs-rime/\u0026quot; 有帮助的资料：作者总结经常问题：GitHub - DogLooksGood/emacs-rime: RIME ㄓ in Emacs ","date":"2021-06-22T00:00:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E8%BE%93%E5%85%A5%E6%B3%95%E5%AE%89%E8%A3%85%E5%92%8C%E9%85%8D%E7%BD%AE%E7%AE%A1%E7%90%86/","section":"post","tags":["管理者"],"title":"trime,emacs-rime和squirrel输入法和配置管理"},{"categories":["学习笔记"],"contents":" State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; \u0026lt;2021-06-20 周日 19:43\u0026gt; 场景描述 ios 通知提醒有三种展示样式：铃声、震动、弹出条。\n通知提醒有哪些开关，可以通过几种方式来控制? 开关可以分为两种，系统开关和 App 开关: 系统开关：由用户自由控制，即通过系统设置，来控制系统是否把消息（本地通知/apns 通知）通知到 app。 app 开关：由开发者控制，即开发者在开发对 app 定制支持消息展示样式。 app 开关实现 远程通知的展示时机分两种情况,第一种当 APP 未启动时,第二种 app 在前台时. 在前台时,需要在 Appdelegate.m 中实现代理方法:\n设置消息通知弹出形式，支持在 APP 在前台时，弹出提示 userNotificationCenter:willPresentNotification:withCompletionHandler:\n1 2 3 支持在前 台时，弹出提示 // 在前台、后台都支持弹出 通知弹出，且带有 声音、内容和角标 completionHandler(UNNotificationPresentationOptionSound | UNNotificationPresentationOptionAlert | UNNotificationPresentationOptionBadge); 联想其他场景 在本地通知的情况下，是否支持app在前台时，显示状态栏弹出的样式。这种情况需要定制本地通知的接收逻辑，在本地通知代理方法中重新配置消息通知的样式，具体可以参看表单本地通知的具体实现。\n","date":"2021-06-16T12:54:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E8%BF%9C%E7%A8%8B%E9%80%9A%E7%9F%A5%E7%9A%84%E6%B6%88%E6%81%AF%E7%9A%84%E5%B1%95%E7%A4%BA%E6%9D%A1%E4%BB%B6%E6%8E%A7%E5%88%B6/","section":"post","tags":["Archive"],"title":"iOS 通知提醒几种展示方式和具体代码配置"},{"categories":["解决方案"],"contents":"项目遇到的实际问题 在实现 单个页面支持横竖屏 的需求,有两种解决方案.\n实际案例:在项目中,针对电子巡查有直播功能,需要支持全屏查看直播,同时支持录制直播画面的需求.\n为满足需求,电子巡查页面需要关于横竖屏适配的两点技术:\n查看全屏直播,页面需要实现手动横竖屏切换功能 全屏录制,页面在全屏录制时,需要禁用自动旋转 基于 info.plist 应用设置实现 思路:通过应用级配置文件 info.plist 设置 app 横竖屏属性,如何在代码中实现对指定页面横竖屏的支持?需要借助 Appdelegate 协议方法 application:supportedInterfaceOrientationsForWindow: 通过代码来实现同等效果,然后扩展 Appdelegate 一个关于支持横竖屏属性,使得任意特定页面中,可以自由激活 App 横竖屏的支持.\n基于这个思路,以下是两个类的具体实现.\n在 Appdelegage 设置 APP 支持方向 基于 Appdelgate 中的方法,添加新属性,来控制横竖屏\n0 1 //适配电子巡查横屏播放,录制禁止旋转:当VC处于横屏时,禁止自动旋转,且必须返回横屏方向 @property (nonatomic, assign)BOOL hengStatus; 在 Appdelgate.m 协议方法中添加适配代码\n250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 - (UIInterfaceOrientationMask)application:(UIApplication *)application supportedInterfaceOrientationsForWindow:(UIWindow *)window { if (_allowRotate) { return UIInterfaceOrientationMaskAllButUpsideDown; } else { //解决个别界面横屏完在竖屏问题 if (_hengPRotate) { [AppDelegate forceLandscape]; // return UIInterfaceOrientationMaskLandscapeRight; } if (_hengStatus) { return UIInterfaceOrientationMaskLandscapeRight; } return UIInterfaceOrientationMaskPortrait; } } 在页面中激活横竖屏支持 在电子巡查实现类中 PatrolOnlineViewController.m\n切换全屏方法: clickFullScreenAction.\n实现了两个操作:手动横屏操作和监听横竖屏切换事件通知 UIDeviceOrientationDidChangeNotification\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 - (void)clickFullScreenAction{ [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(orientChange:) name:UIDeviceOrientationDidChangeNotification object:nil]; //启动Appdelegate旋转屏幕适配 AppDelegate * delegate = (AppDelegate *)[UIApplication sharedApplication].delegate; delegate.allowRotate = YES; if ([[UIDevice currentDevice] respondsToSelector:@selector(setOrientation:)]) { delegate.isHengStatus = !isFullPlay; if (isFullPlay == NO) { [[UIDevice currentDevice] performSelector:@selector(setOrientation:) withObject:(id)UIInterfaceOrientationLandscapeRight]; }else{ [[UIDevice currentDevice] performSelector:@selector(setOrientation:) withObject:(id)UIInterfaceOrientationPortrait]; } } } 旋转后,UI 的适配监听到屏幕旋转之后,针对横屏显示的两套 UI 布局样式,UI 更新完成之后,关闭横竖屏的支持,移除监听事件.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 - (void)orientChange:(NSNotification *)noti { UIDeviceOrientation orientation = [UIDevice currentDevice].orientation; CGRect customFrame; if (orientation == UIDeviceOrientationLandscapeLeft || orientation == UIDeviceOrientationLandscapeRight) { if(self.screenCAPManager == nil) { //开启录屏windows self.screenCAPManager = [QHScreenCAPManager createScreenCAPManager]; self.screenCAPManager.delegate = self; } //获取横屏布局frame customFrame = [UIApplication sharedApplication].keyWindow.bounds; }else{ //恢复竖屏布局frame if (orientation == UIDeviceOrientationPortrait) { customFrame = self.playerView.bounds; } } isFullPlay = !isFullPlay; //横竖屏适配 _customPlayView.isFull = isFullPlay; _customPlayView.frame = customFrame; [_customPlayView setNeedsLayout]; recordPlayView.frame = _customPlayView.bounds; //显示隐藏逻辑 self.tableView.hidden = isFullPlay; _uploadBut.hidden = isFullPlay; //关闭横竖屏支持 AppDelegate * delegate = (AppDelegate *)[UIApplication sharedApplication].delegate; delegate.allowRotate = NO; [[NSNotificationCenter defaultCenter] removeObserver:self name:UIDeviceOrientationDidChangeNotification object:nil]; } 基于容器控制器实现横竖屏 通过视图控制器或容器控制器实现单个页面横竖屏支持,针对这种实现方式,网上有很多详细教程,因为涉及到 横竖屏事件的传递,如果项目比较复杂时,理解其原理相当重要,推荐一篇图文介绍:「iOS」终极横竖屏切换解决方案 - 知乎\n项目中电子巡查 VC 视图控制器,需要在导航控制器并模态展示.基于 横竖屏事件传递机制 ,想要导航控制器中的视图控制器支持横竖屏,需要封装一个重写两个方法(支持横竖屏)的导航控制器.\n根据电子巡查页面的两个需求,导航控制器要根据视图控制器的状态控制横竖支持.\n三个状态: 原始状态*、 *全屏状态 、 旋转状态.\n根据三种状态,横竖屏的方法的返回值逻辑:\nshouldAutorotate 方法:仅在旋转状态下返回 true, 原始/全屏状态返回 false 禁止自动旋转.\nsupportedInterfaceOrientations 方法:默认返回竖屏. 在全屏状态下,返回横屏,确保录制过程保持横屏.\n实现如下:\n先声明一个 导航控制器子类,重写横竖屏支持的自定义方法: AutorotateNavController 继承 UINavigationController\n0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 @implementation AutorotateNavController - (void)viewDidLoad { [super viewDidLoad]; } //是否支持自动旋转,在旋转过程中,支持自动旋转 -(BOOL)shouldAutorotate { return isRotating; } //指定视图控制器支持的旋转方向 - (NSUInteger)supportedInterfaceOrientations { if(isFullScreen){ return UIInterfaceOrientationMaskLandscapeRight; }else{ return UIInterfaceOrientationMaskPortrait; } } @end 参看文章 iOS 强制横竖屏 Swift_w13776024210 的博客-CSDN博客_swift 强制横屏\n「iOS」终极横竖屏切换解决方案 - 知乎\nobjective c - setStatusBarHidden is deprecated in iOS 9.0 - Stack Overflow\n关于iOS横竖屏适配 - 简书\nuiwebview不调用webViewDidFinishLoad的解决办法_夺命红烧肉的专栏-CSDN博客\niOS最新StatusBar状态栏设置方式 - 简书\niOS UIViewController 无法关闭自动旋屏（自动旋转、手动旋转、兼容IOS6之前系统）_jeffasd 的专栏-CSDN博客\n","date":"2021-05-20T08:20:00+08:00","permalink":"https://it-boyer.github.io/post/%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/%E7%A6%81%E6%AD%A2-APP-%E9%A1%B5%E9%9D%A2%E8%87%AA%E5%8A%A8%E6%97%8B%E8%BD%AC%E5%AF%B9%E6%8C%87%E5%AE%9A%E9%A1%B5%E9%9D%A2%E6%89%8B%E5%8A%A8%E5%88%87%E6%8D%A2%E6%A8%AA%E7%AB%96%E5%B1%8F/","section":"post","tags":["iOS"],"title":"禁止 APP 页面自动旋转,对指定页面实现手动切换横竖屏"},{"categories":["博客站务"],"contents":"漫长的经验积累 在工作中，一直在探索如何提高效率，如何把任务合理分解效果，如何坚持知识产出，搭建自己的知识体系。但往往会沉迷在收集工具的使用上，在没有评估该工具到底在实际项目中是否实用。以至于看似每天都非常忙碌，但是工具收集之后，很少真正的实践，产出很少，违背了产能和产出平衡原则。所有的专注力应该集中在真正能改变生活的事情上，耗费了时间和精力反省总结经验，还是无法改变自己的生活，无法改变生活，这都是浪费生命。\n回归正题，在确定学习某项技能时，应该先设定学习目的，要实现什么样的愿景。\n就拿学习 ox-hugo 的过程，虽然经历了一段漫长的积累，但技能的来源全是网上零碎的知识点拼凑的，没有认真考虑过这些知识点的内在联系，它的体系结构什么，导致这块的知识积累都是一盘散沙，再真正使用时，连基础的应用都不知道。现在梳理了之后，有了一些认识，在这里说说:\nox-hugo 支持 org 导出 md 格式，可以指定导出的目录地址，支持 subtree 导出 md 文件，可以指定导出的 md 格式。toc,num,导出时生成目录，toc 指定是标题的等级，num:标题显示索引.\n目标:工作:目标:认真:学习:\n通过搜集工具（spc X h），新建一篇博客，指定时间和文件名称。指定目录名预览：spc m e H h 导出 md，访问 hugo 服务预览效果。发布到 github\n现在关注的点：导出的目录样式，添加分类和 tags\n总结 ox-hugo 在 emacs 的高级使用\n输出格式的设置 收集工具的支持 section 目录的定义 options：可选项的理解 org\u0026ndash;hugo 属性之间的对应关系 STARTUP 作用:启动项设置,即打开 org buffer 时,预设显示内容\n1 #+STARTUP: overview 值类型:数组支持以下属性,指定显示内容的属性\noverview:只显示一级标题 content:所有标题 showal:禁止折叠任何入口 showeverything:显示抽屉中的内容 indent:以打开组织缩进模式开,动态虚拟缩进由变量(setq org-startup-indented t) noindent:在组织缩进模式关闭的情况下启动 hugo_code_fence 切换两种语法高亮的方式\n1 #+hugo_code_fence: nil 值类型: 布尔\nt: 转为 md 语法高亮块:```code```\nnil:转为 hugo 高亮语法块:{{}}\n问题:出现代码块无法左对齐问题\nOPTIONS \\n 作用:在转 md 兼容 org 中的换行\n1 #+options: \\n:t org 变量: org-export-preserve-breaks\n值类型:布尔\nt:开启换行\nnil:关闭换行\n问题:遇到中文字符时无法识别,目前暂时通过设置中文键盘时,输入半圆角字符\n^ 作用:禁用下标样式转义\n1 #+OPTIONS: ^:nil 值类型:枚举\n^：{}: 'a_ {b}' 被转义时，会保持原样 'a_b'\n等价:(setq-default org-use-sub-superscripts nil)\ntoc~和~num 设定导出时,哪些等级的 subtree,可以导出为目录\n1 2 #+OPTIONS: toc:t #+OPTIONS: toc:2 num:2 值类型: int\ntoc: 等价(setq org-export-with-toc t)\nnum: 等价(setq org-export-with-section-numbers 2)\np 导出项目计划信息比如\n1 #+OPTIONS: p:true 值类型:布尔\nt:导出时,保留 schedule time, deadline time 等信息\nnil:不导出计划信息\n一手资料 hugo 文档:Front-matter | Hexo\nox-hugo 文档:ox-hugo - Org to Hugo exporter\norg-mode 文档:Export Settings (The Org Manual)\n导出的设置项\norg-mode，最好的文档编辑利器，没有之一 | 心内求法\n","date":"2021-05-14T13:45:59+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/ox-hugo-%E4%B8%AD-options-%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%9E%E6%80%A7/","section":"post","tags":["hugo"],"title":"ox-hugo 常用的导出设置和+OPATIONS:选项"},{"categories":["学习笔记"],"contents":"本敏捷规范是在现有正在运行的敏捷实践上的体系化，重点明确项目过程各阶段的动作细节，让整个团队的敏捷管理动作标准化，提升团队敏捷开发的能力.\n笔记原文\n第一、问题识别 当前敏捷管理重点关注的问题是：\n信息对称问题 项目节奏的把控问题 在项目管理的各个阶段都要重点关注这两个问题，这也是很多过程动作设置的初衷。\n第二、敏捷项目过程 一、需求及架构评审： 1.目的： 需求是否满足准入要求； 进行架构及关键技术方案的设计、把控； 项目团队组建 2.领域负责人划分： 智慧治理类：张三、里斯.\n千人千面-任务引擎：张思、木刊.\n考培：庞贝、姚策.\n业务生成平台：甘泉、木刊.\n3.动作清单： 需求质量评审:\n核心规则是否完备;\nAxure 原型必要的交互是否进行了实现 技术风险点，及对应的方案 明确项目经理、项目组成员 架构设计：组件图、实体图、前端架构设计； 4.其他说明： 产品架构体系、技术难点的识别、协调处理，有该过程负责，不强调项目组的架构掌控能力； 希望有更多的，有架构能力的团队加入的该过程。 能力要求：熟悉对应产品、技术体系；有架构设计能力；能用 UML 进行架构描述； 二、项目启动会 参加人员：项目经理组织，项目全员参与；目的：明确项目相关信息及规则动作清单:\n组织会议，明确项目相关信息;\n微信确认，项目经理把相关信息按模板要求发布到项目官方群中，项目成员确认;\n项目相关信息，按模板要求填写，初稿如下:\n项目沟通微信群：二维码.\n相关文档存放目录：xxxxxxxxxxxxxxxxxx.\n项目周期时间 ：08 月 15 号 到 08 月 30 号.\n项目组成员：AAA(产品经理)、BBBB(项目经理)，CCC(后端开发)、DDD(测试人员)\u0026hellip;.;\n集成联调时间点：08 月 22 号（全天）介绍集成测试.\n送测时间点：08 月 23 号（全天）.\n发布时间点：08 月 30 号.\n（可选）上下游对应关系：未华提供组织 xxxx 接口（08 月 17 号）；培伟提供 xxxx 接口（08 月 16 号）\n项目规则:\n发布日，全员共进退.\n需求规则调整，第一更新规格文档；第二，发到微信群里每人确认。需求调整完，产品经理一定要再微信群里通知到全员，全员必须再群里回复收到；\n按照模板填写内容，启动会上宣贯，会后发到项目微信群里，项目全员回复收到检查方式：项目结束提供项目启动的，基于模板任容的微信消息截图\n三、需求评审 参加人员：项目全员参与；对应的业务架构团队；方式：产品经理讲需求；\n四、业务架构讲解 参加人员：项目全员参与；对应的业务架构团队；方式：业务架构师介绍架构思路\n五、需求反讲 参加人员：项目全员参加；备注：需求返讲，已经让团队对需求的理解达成了共识，测试用例返讲不作为必做动作。\n六、模块设计 先做好接口设计前端:xxxxxxxxx\n规范要求定义包括：接口命名，入参、返回值展现形式：必须以文档的方式，放入 TFS\\SVN\\GitLab;\n维护：持续维护，接口变动，要更新文档，并通知到各方\n七、站立会议 频次：每日必开；站立会议产品经理可以不参加动作清单：内容：协调，不断强调规则、项目节奏的时间点等；\n备注：集成测试、送测、发布当天晨会一定要开：安排集成测试（开发自测）；要明确送测、发布的规则、明确这个节点项目全员一定要共进退；晨会下来一定通知到上下游的配合同事也都共进退；检查内容：项目结束，提供微信让大家开站立会议的消息截图项目总结里要有，对站立会议实践的经验、教训总结，要结合项目细节。\n八、回顾会议 1-3 个迭代做一次；这个由部门级领导组织、或者推动由回顾负责人整理回顾总结\n备注：公司级的，上线流程、规范不变\n敏捷管理 7 原则 产品需求变化信息要对称 （产品经理一定要更新需求规格文档，并通知到全员，确保全员已知、并回复确认。） 集成测试一定要专项去做 （要单独留出至少半天的时间，上下游的团队也要通知到位），是说开发把最新版本发到测试环境（没有开发环境）上的自测、联调； 集成测试的输出：程序的部署包、数据库更新脚本等 打包发布要规范 服务端不能直接从开发环境打包更新生产和预上线，一定按开发环境打包，该包依次按顺序部署验证：照测试-》灰度-》生产 非功能性需求要关注 压测工作的安排 手机兼容性测试的安排 送测日、发布日整个团队共进退 协调好项目的上下游 接口！接口！！接口！！！ 明确联调、送测、发布时间点 风险点有没有？ 培训的目的：\n1、人才梯队建设;\n2、团队规模越大；规范越重要；团队内部要形成自己的技术、项目语言;\n3、规范是为了支撑目标，目标是研发效能在项目阶段的提升，规范可以调整；目标是部门团队的目标，要着眼于更高的层次思考;\n其他问题： 对于过程的检查大家有什么建议？ 从部门、技术栈的维度组织代码走查，各部门技术栈自己组织，频次 2 次/月 以上 对于项目计划，各部门负责把控一下，2周迭代的项目要做下评审；（任务工作量估算；项目关键的三个节点集成测试、送测、发布是否都有；） 明天对各部门的项目经理进行培训；下个迭代开始实践；9月份过渡；10 月份正式实施； 研发能力模型建设： 敏捷项目管理能力； 架构设计能力; 大家开始学习 UML：S1（用例、时序、组件）；S2（活动） 基于云的问题分析的能力； 对前端/服务端架构体系的掌握整理； 压测、追踪脚本的能力； ","date":"2021-05-13T11:44:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/%E6%95%8F%E6%8D%B7%E7%AE%A1%E7%90%86%E7%9A%84%E8%A7%84%E8%8C%83%E5%92%8C%E6%89%A7%E8%A1%8C%E5%BB%BA%E8%AE%AE/","section":"post","tags":["管理"],"title":"敏捷管理规范"},{"categories":["项目总结"],"contents":" State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-01-07 Tue 09:58] 叙述几个比较深刻的项目\n拍枪杆 19 年是一个自省年，项目组重组之后，在团队协作上都是一种新的挑战，从拍抢干项目第一次接触新的开发模式，本着学习的心态勤奋努力敲代码，在领导的培训下，给出了设计是第一生产力，努着劲自学类图、用例、流程图和时序图来提升开发效率，从根本上弥补自己的短板，在拍抢干中着实挑战了自我，在开发实践中，有意识的摸索提高考虑的开发流程中，明显对产品需求分析更加积极，理解的更加透彻，在自我提升的同时，就着对项目负责的态度，多次在会议上提出产品的设计缺陷和尝试商讨出一个弥补缺陷的方案.\n提前发现问题，确保项目第一次尝试敏捷开发进度能够健康交付，期望是美好的，开发后期，产品设计和开发过程中之间状态百出，为保证两周迭代周期的生死线，不得不每天加班至四个小时，来弥补产品前期设计，需求评审的不严谨导致工作量估算严重不符，后期需求的变更成了家常便饭一样诡异现象。\n电梯药店 临近年关，药店和电梯相对陌生的术语迎面扑来，在大家都不知道为何物时，领导却在不留余力的造势，一味的纠集所有开发者，快速评审需求，产品在台上滔滔不绝的讲述原型设计，导致刚从上一个项目中出来的几十号开发者,没有看过文档，没做丝毫准备就被强行开会，只能在这样紧迫时间下，听领导走马观花式流程图概述，然后全凭自个的悟性去消化理解！两个产品经理滔滔不绝，仅用一个半小时把所有的需求灌输给了一脸懵逼的程序员，会议上各个云里雾里，面面相觑，整个团队都是蒙的，更别提无效的讨论和所谓的自由发问的话语权，诺大个开发团队却鸦雀无声的傻坐着，唯独先入为主的测试人员了解一点需求，洋装着烘托气氛提问上几句不知所以然的问题。也许所有开发者都寄厚望在需求反讲上吧，事实证明，项目的紧迫特殊性跳过了需求反讲，仅上演了团队内部对工作量估算的考核和对工期压缩的大义凛然!\n本期开发需求描述多以复用已有功能，对开发者而言，新功能近乎没有具体需求，旧功能也不是自己所熟悉的范围，再者项目管理的长期以来的通病，不仅没存档任何需求文档和开发文档，连少的可怜的代码注释也是凤毛菱角，产品和领导只能施压程序员，让程序员自己去挖掘旧功能弥补新需求，这无疑是对开发者极大的挑战，也致使项目结束后，整个团队的战斗力已经造成不可恢复的耗损。\n自我建议和目标 设计能力提高 设计驱动开发，设计不仅启发于功能需求，更是检查需求合理性的工具，应该站在整个项目角度来衡量架构模型。团队对设计环节忽视，很难有多余时间用于设计，以致于开发前期对需求理解不透彻，反讲不到位；后续的开发过程中，甚至在联调接口时，才暴漏的需求问题和代码设计上的缺陷，有时不得不再耗费大量时间来重构。\n目标:在需求用例反讲之后,开始代码架构设计,希望能通过需求用例 uml 图,分解可复用的功能,引导开发设计,封装可复用的功能代码块.实现灵活应对需求变更问题.\n进度掌控力 在需求评审不做设计，对需求理解模糊和 UI 评审滞后的情况下，仅凭原型图和开发经验来评估工作量的项目管理模式下，对 UI 页面和相关需求逻辑作出正确的评估是一项极大的挑战。经常会出现实际开发周期和估算周期有很大出入。除了提高开发效率和提高对需求理解能力同，才能更准确的预估项目工作量，有效的把控项目进度，稳步向前推进。\n目标:在充分理解需求之后,评估开发量和工作时间安排,合理估算开发周期,才能保质保量如期完成开发任务.\n设计归档 19 年设计汇总：http://192.168.1.44/huoshuguang/hsg/issues\n","date":"2021-05-13T11:33:25+08:00","permalink":"https://it-boyer.github.io/post/%E9%A1%B9%E7%9B%AE%E6%80%BB%E7%BB%93/2019-%E9%A1%B9%E7%9B%AE%E6%B1%87%E6%80%BB%E6%80%BB%E7%BB%93/","section":"post","tags":["管理"],"title":"2019 项目总结"},{"categories":["博客站务"],"contents":" State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2021-05-12 Wed 10:41] 一直在尝试使用 ox-hugo 提升编写博客的效率,苦于资料苦涩难懂,网上资源缺失,一直处于又爱又恨的情绪,导致效率不升反降的尴尬境地.\n今天发奋图强,自我感觉找到了效率密码,尝试在这里做一次分享,希望可以帮助到和我同样处境的小伙伴.\n主要涉及到几个知识点,会分几个小结也说明下:\n先看看 ox-hugo 官方放出的 capture 实现方式 在看看 org-capture 自定义方式实现,管理更加灵活方便 本人使用的是 doom 主题,用得它自带的命令快捷键,和读者的快捷键有可能存在差异.\norg-capture 基础 考虑到对 cupture 不太熟悉的小伙伴,在进入主题之前,先简单科普下 capture,我会贴上官网地址,然后,参考网上的介绍坐下快进.\nCapture (The Org Manual)\n官方介绍: org-capture 功能使您可以在不中断工作流程的情况下快速存储笔记。\n设置 capture :设置哪些目录下的 org 文件可以使用 capture 功能\n1 ((setq var ) org-default-notes-file (concat org-directory \u0026#34;/notes.org\u0026#34;)) 配置好之后,重新加载下配置, 使用这个和自己的快捷键有关,目前使用 doom 主题,所以 spc shift x 激活 capture 功能页面\n模版定义和加载 针对不同的 note 样式,定义自己的模版.\n这是重要章节:Capture templates (The Org Manual)\n灵活的模版功能,基于三个特征,使得模版能够灵活满足用户的体验.\n模版成员:Template elements (The Org Manual)\nkeys:绑定键 (\u0026quot;b\u0026quot; \u0026quot;功能描述\u0026quot;)\ndescription: 功能描述.\ntype:插入的 note 类型,目前支持的类型: entry item checkitem table-line plain\ntarget:指定插入的节点位置,支持的关键字 file id file+headline file+olp file+regexp file+olp+datetree file+function clock function\nproperties:属性, :immediate-finish :jump-to-captured :empty-lines :clock-in :clock-keep\ntemplate:模版的实体它支持文件,字符串,甚至方法来实现\n1 2 (file \u0026#34;/path/to/template-file\u0026#34;) (function FUNCTION-RETURNING-THE-TEMPLATE) 模版扩展 % 转义符(占位符):Template expansion (The Org Manual)\n在 capture 模版中,支持 ％ 转义符,动态插入 note 信息.\n%[FILE]:Insert the contents of the file given by FILE.\n%(EXP):支持表达式,动态添加信息\n％\u0026lt;FORMAT\u0026gt;:FORMAT 规范上的 format-time-string 的结果.\nformat-time-string: 指定一时间戳格式化样式org-time-stamp-custom-formats\n1 2 \u0026lt;[%H:%M]\u0026gt; ;;生成的结果是: [17:09] \u0026lt;%d %m %Y %a [%H:%M]\u0026gt; ;;生成的结果是: 02 12 2021 Fir [17:09] 真实案例:\n1 2 3 4 5 6 7 (\u0026#34;g\u0026#34; \u0026#34;日总结周总结做日志记录、日记写作,file+weektree顺序排列\u0026#34; entry (file+weektree org-agenda-file-gtd) \u0026#34;* %\u0026lt;[%H:%M]\u0026gt; %^{title} %^g\\n %?\\n\u0026#34; :empty-lines 1 ;; :immediate-finish t ;; :jump-to-captured 1 ) ％t:时间戳记，仅日期.\n％T:带有日期和时间的时间戳.\n％u / ％U:时间\n%^g:提示输入标签，并在预选框中显示目标 org 文件中 tags.\n%^G:提示输入标签，并在预选框中显示所有 org 文件中的所有的 tags。\n模版定制:Templates in contexts (The Org Manual)\n略..\n加载模版\norg-capture-templates:属性,定义好模版之后,需要把模版添加到这个属性中才会生效.有两种加载模版的方式\n初始化时,加载\n1 2 3 4 5 (setq org-capture-templates \u0026#39;((\u0026#34;t\u0026#34; \u0026#34;Todo\u0026#34; entry (file+headline \u0026#34;~/org/gtd.org\u0026#34; \u0026#34;Tasks\u0026#34;) \u0026#34;* TODO %?\\n %i\\n %a\u0026#34;) (\u0026#34;j\u0026#34; \u0026#34;Journal\u0026#34; entry (file+datetree \u0026#34;~/org/journal.org\u0026#34;) \u0026#34;* %?\\nEntered on %U\\n %i\\n %a\u0026#34;))) 借助 add-to-list 方法加载\n1 2 3 (add-to-list \u0026#39;org-capture-templates \u0026#39;(\u0026#34;!l\u0026#34; \u0026#34;Link\u0026#34; entry (file org-agenda-file-inbox) \u0026#34;* TODO 阅读：%:description\\nCaptured On: %U\\n\\n%:link\u0026#34; :immediate-finish t)) oh-hugo 官网案例 先放上地址:Org Capture Setup — ox-hugo - Org to Hugo exporter\n先介绍下基础功能:获取用户输入的博客名,设置导出文件名:\n1 2 (let* ((title (read-from-minibuffer \u0026#34;Post Title: \u0026#34;)) ;Prompt to enter the post title (fname (org-hugo-slug title))) 获取到到文件名 fname 之后,会在插入到 org 时,填充给必须属性: :EXPORT_FILE_NAME:.\n官网的 capture 主要实现在用湖创建一篇新博客时,会自动填充属性栏中的导出文件名的值,这样用户就可以直接进行博客编写,不需要关心导出时的相关设置.\n自动获取用户输入的内容,作为输入文件路径\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ;; Populates only the EXPORT_FILE_NAME property in the inserted headline. (with-eval-after-load \u0026#39;org-capture (defun org-hugo-new-subtree-post-capture-template () \u0026#34;Returns `org-capture\u0026#39; template string for new Hugo post. See `org-capture-templates\u0026#39; for more information.\u0026#34; (let* ((title (read-from-minibuffer \u0026#34;Post Title: \u0026#34;)) ;Prompt to enter the post title (fname (org-hugo-slug title))) (mapconcat #\u0026#39;identity `( ,(concat \u0026#34;* TODO \u0026#34; title) \u0026#34;:PROPERTIES:\u0026#34; ,(concat \u0026#34;:EXPORT_FILE_NAME: \u0026#34; fname) \u0026#34;:END:\u0026#34; \u0026#34;%?\\n\u0026#34;) ;Place the cursor here finally \u0026#34;\\n\u0026#34;))) Code Snippet 1: 获取subtree名称,设置导出文件名 然后通过 add-to-list 加入到模版列表:\n1 2 3 4 5 6 7 8 9 (add-to-list \u0026#39;org-capture-template s \u0026#39;(\u0026#34;h\u0026#34; ;`org-capture\u0026#39; binding + h \u0026#34;Hugo post\u0026#34; entry ;; It is assumed that below file is present in `org-directory\u0026#39; ;; and that it has a \u0026#34;Blog Ideas\u0026#34; heading. It can even be a ;; symlink pointing to the actual location of all-posts.org! (file+olp \u0026#34;all-posts.org\u0026#34; \u0026#34;Blog Ideas\u0026#34;) (function org-hugo-new-subtree-post-capture-template)))) 官方推荐了几个属性:\n:EXPORT_HUGO_BUNDLE: 导出到 Page Bundle\n:EXPORT_DATE: 插入时间戳借助脚本获取当前时间,赋值到属性上:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 (defun org-hugo-new-subtree-post-capture-template () \u0026#34;Returns `org-capture\u0026#39; template string for new Hugo post. See `org-capture-templates\u0026#39; for more information.\u0026#34; (let* (;; http://www.holgerschurig.de/en/emacs-blog-from-org-to-hugo/ (date (format-time-string (org-time-stamp-format :long :inactive) (org-current-time))) (title (read-from-minibuffer \u0026#34;Post Title: \u0026#34;)) ;Prompt to enter the post title (fname (org-hugo-slug title))) (mapconcat #\u0026#39;identity `( ,(concat \u0026#34;* TODO \u0026#34; title) \u0026#34;:PROPERTIES:\u0026#34; ,(concat \u0026#34;:EXPORT_FILE_NAME: \u0026#34; fname) ,(concat \u0026#34;:EXPORT_DATE: \u0026#34; date) ;Enter current date and time \u0026#34;:END:\u0026#34; \u0026#34;%?\\n\u0026#34;) ;Place the cursor here finally \u0026#34;\\n\u0026#34;))) ","date":"2021-05-11T17:58:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/ox-hugo-%E7%9B%B8%E5%85%B3-capture-%E7%9A%84%E9%85%8D%E7%BD%AE/","section":"post","tags":["hugo"],"title":"ox-hugo 使用 org-capture 模版搜集灵感提高效率"},{"categories":["博客站务"],"contents":"ox-hugo 帮助用户很好的使用，专门提供了一个测试用例站点.\n下面介绍下如何在本地轻松搭建一个测试用例站点，对于刚刚开始使用 emacs 写博客的新手,有很大的帮助.\n你在编写博客遇到 ox-hugo 语法不确定时,都可以在测试用例站点,检索这些基础语法的实际案例:\n单行字符串样式:加粗,斜体,高亮等样式对照表 Formatting 在 emacs 中常用的字体语法: Nested bold and italics 自定义 Front matter :Custom front matter 都可以在这个文件ox-hugo/all-posts.org下找到真实语法案例\n搭建过程 Hugo test site for this package — ox-hugo - Org to Hugo exporter\nclone 项目到本地\n1 git clone --recurse-submodules -j8 https://github.com/kaushalmodi/ox-hugo 确保安装 pandoc: brew search pandoc\n部署\n1 2 3 cd ox-hugo/test/site/ hugo server -D --navigateToChanged open http://localhost:1234 #预览 使用 emacs 导出 org\n在 emacs 中打开 all-posts.org 文件，\n1 emacs ox-hugo/test/site/content-org/all-posts.org 并执行导出命令：spc m e H A,导出目录：test/site/content/posts/\n在浏览器上访问上面的 hugo 站点，会看到新增的内容。\n","date":"2021-05-10T12:30:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/%E5%88%A9%E7%94%A8%E5%A5%BD-ox-hugo-%E6%B5%8B%E8%AF%95%E7%94%A8%E4%BE%8B%E7%AB%99%E7%82%B9/","section":"post","tags":["hugo"],"title":"在 emacs 写博客精进手册:搭建 ox-hugo 测试用例站点"},{"categories":["博客站务"],"contents":"目的 要想实现在 hugo 站点实时预览 org 生成的 md 效果,需要借助 ox-hugo 提供的自动导出的功能,配合 hugo server 实时刷新的特性,达到实时预览的目的.\n实时预览:hugo server 是 hugo 常用的命令,只要启动了站点服务,就可以实时预览 md 的变更. 自动导出:ox-hugo 是基于 实时预览,为 emacs 用户提供了一个强大的 自动导出 md 的功能.\n即:当每次编写完成保存 org 文件时,会根据 Export 相关属性,自动导出 md 文件到 hugo 站点,从而实现在 hugo 实时预览 md 效果. ox-hugo 的自动导出功能有类似作用域的概念,可以针对目录下所有文件,也可以仅在当前 org 文件中起作用,也可以指定 org 文件不支持自动保存.\n您可以按照以下步骤进行操作，这些步骤适用于 org 文件和 subtree 节点：\nAuto-export on Saving — ox-hugo - Org to Hugo exporter\n下面仅对自动导出功能的配置说明.\n作用在当前 org 文件 当仅想在一个文件中自动保存,可以在 org 文件底部添加如下:\n1 2 3 4 5 * Footnotes * COMMENT Local Variables :ARCHIVE: # Local Variables: # eval: (org-hugo-auto-export-mode) # End: 作用在目录下所有 org 文件 举例,当想在 ~/your/org 目录下:\n1 vi ~/your/org/.dir-locals.el 在文件中添加如下内容\n1 ((org-mode . ((eval . (org-hugo-auto-export-mode))))) 保存之后,在 emacs 编辑 org 并保存,验证是否成功.\n屏蔽该目录下 org 自动保存 1 2 3 4 5 ​* Footnotes ​* COMMENT Local Variables :ARCHIVE: # Local Variables: # eval: (org-hugo-auto-export-mode -1) # End: ","date":"2021-05-08T19:32:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/ox-hugo-%E6%94%AF%E6%8C%81-org-%E5%AF%BC%E5%87%BA-md/","section":"post","tags":["hugo"],"title":"在 hugo 站点实时预览 org 生成的 md 效果"},{"categories":["博客站务"],"contents":"5分钟给Hugo博客增加搜索功能 :: /dev/ttyS3 — 回首向来萧瑟处 也无荒野也无灯\nFast, instant client side search for Hugo static site generator · GitHub\n配置config.toml outputs:支持json\n在layouts/_default/新建 index.json\n在layouts/_default/新建 baseof.html 先拷贝even主题下的文件，在把搜索样式添加到文件末尾在static中添加js脚本在fastsearch.js中配置**CMD+/**显示隐藏快捷键\n","date":"2021-05-07T21:18:29+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/hugo%E4%B8%AD%E9%9B%86%E6%88%90Fusejs%E5%AE%9E%E7%8E%B0%E7%AB%99%E5%86%85%E6%90%9C%E7%B4%A2/","section":"post","tags":["hugo"],"title":"hugo中集成Fuse.js实现站内搜索"},{"categories":["解决方案"],"contents":"安装 swift-mode swift 自动补齐相关插件 swift-mode State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;DELEGATED\u0026rdquo; [2019-12-11 三 09:30]\n[终端支持 swift 自动补齐](post/shell/终端支持 swift 自动补齐)\nflycheck-swift\nnathankot/company-sourcekit\nswift-emacs/swift-mode 创建可执行项目 spi \u0026ndash;type executable\n上述命令`spi`的区别是`Package.swift`不同，Source 中多一个 main.swift 文件。当 source 中存在 main.swift 时，`spx`生成的 xcodeproj 中 target 清单，会显示可执行图标。\n在 emacs 中进入项目目录 新建项目目录：SPC p a hello\n切换项目：SPC p p hello\n编辑 swift 代码，执行 lldb 调试 swift swift 终端： 启动： M-x: run-repl\n退出： :exit RET\nlldb 联调程序(仅在单个 target 项目中测试通过) 启动：M-x: debug-swift-mode\n退出：exit RET\n使用该调试方式，无法支持多个 target 的项目，即\nPackage.swift 中有多个 taget 时，debug 失败。\n在 swift-mode 如何多个 target 不知道如何指定 target 调试 [swift-mode暂不支持多个target](https://github.com/swift-emacs/swift-mode/issues/162) 断点使用 help breakpoint 断点使用文档： help b 熟悉一个 filter 命令，是哪个命令的 ","date":"2020-09-13T22:40:23+08:00","permalink":"https://it-boyer.github.io/post/old/swift-%E5%9C%A8-doom-%E4%B8%AD%E7%9A%84%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5/","section":"post","tags":["doom","swift"],"title":"swift 的 doom 环境"},{"categories":["学习笔记"],"contents":"xcrun/swift 命令工具 第一种\nvi test.swift\n#!/usr/bin/env xcrun swift\nprint(\u0026ldquo;hello\u0026rdquo;)\n$ chmod 755 test.swift\n$ ./test.swift\n第二种\n$ cat \u0026laquo;EOF \u0026gt; script\n#!/usr/bin/swift\nprint(\u0026ldquo;Hi!\u0026rdquo;)\nEOF\n$ chmod u+x script\n$ ./script\nHi!\nswift-sh 支持库依赖 安装命令\nbrew install swift-sh 使用\n$ cat \u0026laquo;EOF \u0026gt; script\n#!/usr/bin/swift sh\nimport PromiseKit // @mxcl ~\u0026gt; 6.5\nprint(Promise.value(\u0026ldquo;Hi!\u0026rdquo;))\nEOF\n$ chmod u+x script\n$ ./script\nPromise(\u0026ldquo;Hi!\u0026rdquo;) 升级\n$ git clone https://github.com/mxcl/swift-sh.git\n$ cd swift-sh\n$ swift build\n把编译后的可执行文件 swift-sh，拷贝到 dotfiles/swift-sh/bin/swift-sh /**\n^^Import local files https://github.com/mxcl/swift-sh/issues/17\n^^ import Foobar // ./test2.swift\n^^仅支持导入由 SPM 管理的项目（Package.swift）\n^^暂时不支持 swift 文件导入方式，不能像 ruby 一样加载另一个 rb 文件\n*/\n","date":"2020-09-13T22:33:34+08:00","permalink":"https://it-boyer.github.io/post/old/swift-%E8%84%9A%E6%9C%AC%E6%96%87%E4%BB%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"post","tags":["swift"],"title":"创建单个 swift 可执行文件"},{"categories":null,"contents":" 问题 1:如何支持 iOS 项目到目前为止，它仅支持命令行工具和服务器端 Swift 应用程序\nSwift Package Manager for iOS – Guide \u0026amp; New Features | TSH.io\n无论您是使用第三方依赖关系，开发自己的内部框架，还是只想提取应用程序代码的一部分以使其模块化和有序（或同时包含所有内容），Swift Package Manager 都将非常有用。随着 Xcode 11 的发布，它将成为 Apple IDE 的重要组成部分。现在，SPM 软件包可与所有 Apple 平台一起使用，包括 iOS 系统（到目前为止，它仅支持命令行工具和服务器端 Swift 应用程序）。如果您尚未使用 SPM，现在是尝试一下的最佳时机！ Adopting Swift Packages in Xcode - WWDC 2019 - Videos - Apple Developer\nCreating Swift Packages - WWDC 2019 - Videos - Apple Developer\n特点 可以看作是独立于 Xcode 的 workspace 的子项目 非常适合重构可重用代码 未版本化 可以发布和共享 Creating local packages spi : 创建库\nspi \u0026ndash;type executable:创建可执行文件\nsps：显示库依赖\nspx:生成 Xcode 项目文件\nspf: fetch 依赖库\nspu: 更新依赖库上述命令`spi`的区别是`Package.swift`不同，Source 中多一个 main.swift 文件。当 source 中存在 main.swift 时，`spx`生成的 xcodeproj 中 target 清单，会显示可执行图标。\nPublishing packages 配置 pkage.swift，发布到 github 上，可以轻松共享源码，类似 cocoapods 库分享机制。\nPackage manifest API Swift.org - Swift Package Manager Manifest API Redesign\nEditing packages Open source project ","date":"2020-09-12T23:14:07+08:00","permalink":"https://it-boyer.github.io/post/old/SPM-%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","section":"post","tags":null,"title":"SPM 管理库依赖和发布私库工具"},{"categories":null,"contents":"集成命令 配置 spec 索引文件 设置本地依赖库的方式:\n库存放地址问题：不支持库外路径例如：~/等，只能在 spec 目录中存放库。在提交到私有仓库的时候需要加上\u0026ndash;use-libraries\n依赖 .a 静态库\ns.vendored_libraries = \u0026lsquo;JinherSDK/Libs/*.a\u0026rsquo;\n依赖 framework\ns.vendored_frameworks = \u0026lsquo;JinherSDK/Libs/*.framework\u0026rsquo;\n实战案例 ORM 私库整理 State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-04-20 一 13:38] 配置 ffdb 依赖\npod lib create ORM2FMDB 验证\npod lib lint ORM2FMDB.podspec \u0026ndash;allow-warnings \u0026ndash;verbose 发布\npod repo push it-boyer ORM2FMDB.podspec \u0026ndash;allow-warnings 创建 jinher 的 pod 私库，抽取相关依赖，使用 pod 管理 demo 依赖 pod lib create JinherSDK\npod lib lint JinherSDK.podspec \u0026ndash;allow-warnings \u0026ndash;verbose\npod repo push it-boyer JinherSDK.podspec \u0026ndash;allow-warnings\n","date":"2020-09-12T23:04:50+08:00","permalink":"https://it-boyer.github.io/post/old/pods-%E7%A7%81%E5%BA%93%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","section":"post","tags":null,"title":"Cocoapods 使用"},{"categories":null,"contents":"下载历史 jar包plantuml.jar历史版本路径\n命令行 uml 预览 您也可以使用下面的命令行运行 PlantUML:\njava -jar plantuml.jar file1 file2 file3\n这将在 file1, file2 和 file3 中寻找 @startXYZ。 对于每个图表, 都将创建一个 .png 文件。 对于处理整个文件夹, 您可以使用:\njava -jar plantuml.jar \u0026ldquo;c:/directory1\u0026rdquo; \u0026ldquo;c:/directory2\u0026rdquo;\n此命令将寻找 @startXYZ 和 @endXYZ 位于 c:/directory1 和 c:/directory2 目录中的 .c, .h, .cpp, .txt, .pu, .tex, .html, .htm 或.java 文件。 辅助方法在 dotfiles/doom/aliases.zsh 中添加别名。\nalias plantuml=\u0026lsquo;java -jar ~/.emacs.d/.local/etc/plantuml.jar\u0026rsquo; M-x: plantuml-download-jar State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-04-10 Fri 17:31] 当缺少 jar 时，使用命令该命令安装 jar\n安装 graphviz@28.6 State \u0026ldquo;CANCEL\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-04-20 Mon 13:41] 暂时不知道怎么安装旧版本 需要安装老版本，官方提示：2.40.1 版本存在问题，目前无法找到旧版的安装方法\nbrew install libtool\nbrew link libtool\nbrew install graphviz\nbrew link \u0026ndash;overwrite graphviz\ngraphviz安装说明\nplantuml 安装第三方服务器 State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-04-20 Mon 13:42]\n官网服务器\ndocker run -d -p 8080:8080 plantuml/plantuml-server:jetty\ndocker run -d -p 8080:8080 plantuml/plantuml-server:tomcat\n在线预览韩国版\nnpm install\nnpm run flow-typed\nnpm run serve\nnpm run build\nnpm run test:unit\nnpm run test:e2e\n问题问题 1：npm run flow-typed 执行命令失败问题 2: 访问http://localhost:8080 提示如下：\nFailed to compile.\n./src/components/UmlSvg.vue\nModule Error (from ./node_modules/eslint-loader/index.js):\n/Users/jhmac/hsg/plantuml-editor/src/components/UmlSvg.vue\n7:19 error Cannot resolve module axios flowtype-errors/show-errors\n✖ 1 problem (1 error, 0 warnings)\nhaha98k\n$ git clone https://github.com/iT-Boyer/haha98k.git\n$ cd web\n$ yarn install\n$ yarn run dev\n$ yarn run build\n$ yarn start\n$ yarn run generate\nProOne 电脑上 plantuml-mode 失效问题 State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-04-10 Fri 17:31] plantuml-mode丢失问题\n解决办法：~/.emacs.d/.local/straight/repos/plantuml-mode\ngit reset HEAD .\ngit checkout .\ndoom sync\ndoom refresh\n","date":"2020-08-30T23:02:53+08:00","permalink":"https://it-boyer.github.io/post/old/plantuml%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93/","section":"post","tags":null,"title":"plantuml 使用"},{"categories":null,"contents":"编辑命令 撤销：undo (u)\n重做：C + r :undo-fu-only-redo\n只读：spc t r\n浏览编辑历史树：M-x: undo-tree-visualize(C-x u)\n安装和配置 dotfile 中的配置 hugo 项目中管理 doom 版本 doom 工具的基本命令（install/refresh/upgrade）使用 State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-03-24 二 15:46] `控制工作`：任务任用\n升级 doom 和 package 方式一：\ndoom upgrade # or \u0026lsquo;doom up\u0026rsquo;自动升级\n方式二：手动升级\ncd ~/.emacs.d\ngit pull # updates Doom\ndoom clean # Ensure your config isn\u0026rsquo;t byte-compiled\ndoom sync # synchronizes your config with Doom Emacs\ndoom update # updates installed packages\n仅升级 package To upgrade only your packages (and not Doom itself):\ndoom upgrade \u0026ndash;packages\n重装 doom 环境 重装两种方式：\nrm -rf ~/.emacs.d/.local\ndoom sync\ndoom 中的 module 创建和实现 helloword 加载实现 doom 帮助文档的使用 统计命令 org-insert-columns-dblock C-c C-x i 对任务列表生成列表视图.C-c C-x C-c 生成临时的任务列表\norg-clock-in C-x C-x C-i 统计实际任务执行时间\norg-clock-out C-c C-x C-o 统计任务结束的总时长\norg-clock-report C-c C-x C-r 统计光标的任务时间报告\n插入命令 插入代码片段:\nC-c C-q 标签命令\nC-c i s 插入脚本\n, i h 插入同级节点\nC-c C-w org 文件之间迁移节点\n, i p 添加 org 属性\n目录命令 进入 Dired 模式：spc f d 启动 treemacs 模式：spc o p 搜索 文件名搜索 find-dired\nfind-grep-dired 递归所有子目录\ngrep 在当前目录中查找指定的 regexp\n文本搜索替换 grep-find 显示包含字段的行，递归子目录\nagenda 命令 编辑 tag(提炼任务，矩阵化) 在 buffer 中：spc + m + q\n在 agenda 中：c t\n过滤任务 在 agenda 视图中：s 筛选任务\n标签过滤 进度过滤 安排行程 spc m s :org-schedule 设置日期在 agenda 中：t 打开状态视图在 org 文件中：shift + 左右键\n跟进进度 在 agenda 中：a 给任务添加备注信息在 agenda 中：c T 设置番茄钟倒计时\n导出 markdown spc + m + e 导出窗口\nspc + m + o 设置条目属性：EXPORT_FILE_NAME\nhttp://holbrook.github.io/2012/04/12/emacs%5Forgmode%5Feditor.html\n文档元数据\n##+OPTIONS 是复合的选项：支持在文档头部定义，也可以在条目下:PROPERTIES:属性中定义。\ntodo: off:不显示任务条目的状态符号（TODO，DONE）等。 tasks: nil:移除所有的任务项 todo:保留 todo 状态任务 done:保留 done 状态任务不设置时，显示所有任务项 \\n: t:开启，自动换行 \u0026lt;: 时间戳 tree 结构 升/将级节点 option + 左右键（升/将）编辑状态下，Tab 当前节点\n定位/展开/关闭当前节点 定位：C+x n s org-narrow-to-subtree\n定位 buffer：spc b -\n展开：z a org/taggle-fold\n关闭：z c org/close-fold\n关闭父节点：shift + tab\n新增节点 同级节点: org-insert-heading 热键：option + 回车终端：C+c return\n子节点: org-insert-subheading option + command + 回车\n新增 TODO 节点 org-insert-todo-heading : 同级 todo\norg-insert-todo-subheading : 子节点 todo\n新增 checkbox markdown-insert-gfm-checkbox\neww 浏览器 配置默认搜索引擎 State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-05-06 三 16:15] 在 config 中配置：默认搜索引擎\n(setq eww-search-prefix \u0026ldquo;https://github.com/search?q=\u0026rdquo;)\n常用命令：M-x: eww 书签： 收藏：m\n收藏列表：g b 历史记录：g h 修改路径 o:打开地址栏\nH:返回上一页\n打开文本链接 Link M-x: org-agenda-open-link:在系统浏览器中打开 org 中的超文本链接\n表格编辑 新建：M-x table-insert 或 org-table-create\n编辑：M-x org-edit-speical (spc m \u0026lsquo;)\n脚本运行命令 C-c C-c: 执行命令,光标必须定位在 BEGIN_SRC 模块\nemacs 配置命令 SPC f e d 打开配置文件\nSPC f e R 重加载配置文件\nShift h 查看当前 buffer 启动的 mode\n我最近开始使用 emacs 。Evil 和 org 模式。 当在组织模式下记录时，程序会进入 模式，我可以在框架底部的状态栏上看到。 启动 emacs 时，我通常在状态栏上看到一个 。我认为\n- 用于正常模式\n- 用于插入模式什么是 模式？如何在不重新启动 emacs 的情况下返回到正常模式？\nEmacs Evil 模式和org模式_emacs_HELPLIB 编程知识库\nyasnippet 使用 暂时把所有的 snippet 都移动到 org-mode 中，可以正常加载使用\n1 mv plantuml-mode org-mode 仅支持在 org 文件内，使用`Tab`展开。\nmagit 版本控制命令 spc g s 进入 status 窗口\n? 进入 git 帮助窗口\nc commit 输入提交信息\nC-c C-c 完成提交\nC-c C-k 取消提交操作\nl 查看 git 日志\nz stash 命令\nF pull 命令\n\u0026rsquo; submodule 命令\n\u0026quot; subtree 命令\n在 treemacs 中无法启动 file-templates 问题 State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-05-11 一 09:35] 在 ~/.doom.d/config.el 加入如下脚本：\n(add-hook! \u0026rsquo;treemacs-create-file-functions\n(defun expand-file-template (file)\n(with-current-buffer (or (get-file-buffer file)\n(find-file-noselect file))\n(when-let (rule (cl-find-if #\u0026rsquo;+file-template-p +file-templates-alist))\n(apply #\u0026rsquo;+file-templates\u0026ndash;expand rule)))))\n","date":"2020-07-19T21:41:57+08:00","permalink":"https://it-boyer.github.io/post/old/doom-%E5%AE%89%E8%A3%85%E5%92%8C%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/","section":"post","tags":null,"title":"doom 使用"},{"categories":null,"contents":"指南 Xcode调试工具Instruments指南 - CSDN博客\nTime Profiler：CPU 分析工具分析代码的执行时间。\nCore Animation：离屏渲染，图层混合等 GPU 耗时。\nLeaks：内存检测，内存泄漏检测工具。\nEnergy Log：耗电检测工具。\nNetwork：流量检测工具。\n学习调试案例 如何使用Instruments诊断App（Swift版）：起步 - CocoaChina_一站式开发者成长社区\nHow to get Flickr API Key - WP Frank\n解决两个问题：\n笨重问题进入一个详情界面非常慢，另外滑动查询结果的列表也是慢得难以置信\u0026ndash;这是一款笨重的 app\n泄漏问题\n怎样使用 Time Profiler 工具来定位你的代码中的\u0026quot;高消耗点（hot-spot）\u0026quot;，从而让你的代码更加有效率。\n怎样使用 Allocations 工具来检测和改正代码中的内存管理问题，例如循环强引用。\n调用树（call tree） Separate by Thread：每个线程被单独考虑。这能让你知道哪一个线程占用 CPU 最多。 创建自定义的 Instrument WWDC 2018：创建自定义的 Instrument - 掘金\n","date":"2020-07-19T21:41:43+08:00","permalink":"https://it-boyer.github.io/post/old/xcode/Instruments%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","section":"post","tags":null,"title":"Instruments 工具使用"},{"categories":null,"contents":"增加 web 端打开短视频 APP\n参考教程：http://docs.getui.com/getui/mobile/ios/applink/\n协调李军峰在分享组件中添加 SchemeUrl 配置字段协商之后，使用分享组件添加 schemeUrl，目的为了便于其他 APP 快速支持第三方打开 APP 配置短视频支持第三方打开 在短视频 APP 中，添加分享组件，设置 schemeUrl 值：/shortVideoCode 打包，查看配置结果正式环境：https://jhbac.iuoooo.com/apple-app-site-association\n测试环境：http://testbac.iuoooo.com/apple-app-site-association 在 Xcode 配置 APP 的 Associated Domains\n测试环境：applinks:testbac.iuoooo.com\n正式环境：applinks:jhbac-ui.iuoooo.com 验证第三方打开测试环境：暂不支持测试，需要把 Associated Domains 的测试 links 同步到主工程才行。暂时不考虑测试地址:https://testbac.iuoooo.com/shortVideoCode\n正式环境：平台下载包安装到手机之后，正式地址：https://jhbac.iuoooo.com/shortVideoCode\n使用 Safari 访问下面路径，既可打开短视频 APP 当 APP 已经安装自动启动 applink 所指向的 APP，甚至可以定位到 app 的具体页面。 当没安装 APP\nSafari 会自动打开 applink 指向的网页。需要 web 服务器在改地址下提供一个有效的网页（自动跳转到 AppStore 或者 web 端设计一套下载引导页） ","date":"2020-07-19T21:40:54+08:00","permalink":"https://it-boyer.github.io/post/old/AppLink%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"post","tags":null,"title":"APPlink 的使用"},{"categories":null,"contents":" Xcode 重签名证书：钥匙串访问—证书助理：创建证书 — 名称：XcodeResign 类型：代码签名签名：sudo codesign -f -s XcodeResign（证书名） /Applications/Xcode.app 签名问题\n/Applications/Xcode.app: replacing existing signature\n/Applications/Xcode.app: resource fork, Finder information, or similar detritus not allowed\n解决命令：\nsudo xattr -cr /Applications/Xcode.app\n查看 Xcode 签名 UUID：defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID\n替换插件的 UUID：\nfind ~/Library/Application\\ Support/Developer/Shared/Xcode/Plug-ins -name Info.plist -maxdepth 3 | xargs -I{} defaults write {} DVTPlugInCompatibilityUUIDs -array-add defaults read /Applications/Xcode.app/Contents/Info DVTPlugInCompatibilityUUID\n安装 Xvim2\ngit clone https://github.com/XVimProject/XVim2.git\ncd XVim2\ngit checkout xcode10.1\nmake\ndefaults delete com.apple.dt.Xcode DVTPlugInManagerNonApplePlugIns-Xcode-x-x\n完成后，重启 Xcode\n","date":"2020-07-19T21:40:00+08:00","permalink":"https://it-boyer.github.io/post/old/xcode/Xcode%E5%AE%89%E8%A3%85Xvim2%E6%8F%92%E4%BB%B6%E6%96%B9%E6%B3%95/","section":"post","tags":null,"title":"XVim 插件"},{"categories":null,"contents":" State \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;TODO\u0026rdquo; [2020-05-16 六 20:45]\nState \u0026ldquo;TODO\u0026rdquo; from \u0026ldquo;DONE\u0026rdquo; [2020-05-16 六 20:45]\nState \u0026ldquo;DONE\u0026rdquo; from \u0026ldquo;CANCEL\u0026rdquo; [2020-03-07 六 10:21]\n新建 Tab 页： command + t\n关闭 tab 页： command + w 左右切换 tab 页： shift + command + [ 或 ] 预览所有 tab 页： shift + command + \\ 选中激活 tab 页： command + . editer 编辑器\n新建 contrl + command + t 切换编辑区： control + ` 激活编辑区： command + j 激活下一个区域：alt + command + ` 激活下一个编辑区： control + ` 在新编辑区打开：alt + command + ， 关闭文件 buffer： contrl + command + w 关闭编辑器：control + alt + command + w 帮助\nhelp\u0026ndash;\u0026gt;search : shift + command + / 文档 search： shift + command + 0 只显示编辑区： command + return\n打开 swiftUI 实时预览： alt + command + return\n显示所有操作： shift + command + a\n编辑所有关键字： control + command + e\n文件检查器： alt + command + 0\n定位导航页： shift + command + j\nstructure: 代码结构快捷键\n格式化 control + i 前后对齐： command + ]/[ 整行上下移：alt + commnad + ]/[ 添加注释： command + / 添加文档注释： alt + command + / code folder\n关闭/打开代码块： alt + command + \u0026lt;- / -\u0026gt;\n关闭/打开备注/方法/函数： control +alt + command + \u0026lt;- / -\u0026gt;\nselection\n多行选择编辑： control + shift + 上下键\n切换 scheme\ncontrol + 0 ： 选择\ncontrol + command + [ ] 上一个/下一个\ndebug\n打开输出台：shift + command Y\n激活输入台：shift + command C\ncounie: control + commmand Y\ncounie line:control +command C\n下一步： F6\n进入： F7\n退出：F8\n","date":"2020-07-19T21:31:04+08:00","permalink":"https://it-boyer.github.io/post/old/xcode/Xcode%E5%BF%AB%E6%8D%B7%E9%94%AE%E4%BD%BF%E7%94%A8%E6%80%BB%E7%BB%93/","section":"post","tags":["xcode"],"title":"Xcode 快捷键使用"},{"categories":["学习笔记"],"contents":"DONE jazzy工具使用实现基本的文档的生成,并同步到hugo目录中 支持oc/swift文档\nswift文档\noc 文档\n.jazzy.yaml配置文件使用\n1 2 3 4 5 6 7 8 author: Alamofire Software Foundation author_url: http://alamofire.org/ github_url: https://github.com/Alamofire/Alamofire root_url: https://alamofire.github.io/Alamofire/ module: Alamofire output: docs theme: fullwidth xcodebuild_arguments: [-workspace, \u0026#39;Alamofire.xcworkspace\u0026#39;, -scheme, \u0026#39;Alamofire iOS\u0026#39;] 使用test.sh\n1 2 3 4 5 #!/bin/bash jazzy --config .custom.jazzy.yaml jazzy --config .admin.jazzy.yaml jazzy --config .swiftfire.jazzy.yaml echo \u0026#34;Jazzy completed\u0026#34; DONE 在Xcode 11 bata5之后,无法显示类结构问题 参看:https://github.com/realm/jazzy/issues/1095#issue-488350044\nDONE cocoapods私库的使用,在iSmallAPP中使用私库 在ismallAPP的bundle中发布一个私库\n总结发布流程,运用到工作中,并发布jazzy文档\n使用fastlane发布cocopods私库\n1 - ERROR | [iOS] unknown: Encountered an unknown error (Could not find a `ios` simulator (valid values: ). Ensure that Xcode -\u0026gt; Window -\u0026gt; Devices has at least one `ios` simulator listed or otherwise add one.) during validation. 解决办法: 升级CocoaPods（使用的gem 源： https://gems.ruby-china.com/）\n1 2 3 4 sudo gem install cocoapods fastlane podPushLane version:1.3 project:LogSwift 或 pod lib lint LogSwift.podspec --allow-warnings 错误2\n1 - NOTE | xcodebuild: error: SWIFT_VERSION \u0026#39;3.0\u0026#39; is unsupported, supported versions are: 4.0, 4.2, 5.0. (in target \u0026#39;LogSwift\u0026#39; from project \u0026#39;Pods\u0026#39;) 原因: Usage of the .swift\\_version file has been deprecated! Please delete the file and use the swift\\_versions attribute within your podspec instead. 解决: 删除目录下.swift_version\n错误3:\n1 2 3 4 5 6 7 8 9 10 11 12 13 Validating spec -\u0026gt; LogSwift (1.6) - ERROR | [iOS] unknown: Encountered an unknown error (Unable to find a specification for `RNCryptor (~\u0026gt; 5.1.0)` depended upon by `LogSwift` You have either: * out-of-date source repos which you can update with `pod repo update` or with `pod install --repo-update`. * mistyped the name or version. * not added the source repo that hosts the Podspec to your Podfile. Note: as of CocoaPods 1.0, `pod repo update` does not happen on `pod install` by default. ) during validation. [!] The `LogSwift.podspec` specification does not validate. 解决方法: pod repo update 更新pod索引库重新发布: pod repo push PodRepo \u0026lsquo;LogSwift.podspec\u0026rsquo; \u0026ndash;allow-warnings\n问题4\n1 2 3 4 5 6 7 8 9 10 11 [!] The repo `PodRepo` at `../../../../.cocoapods/repos/PodRepo` is not clean 原因: git status .DS_Store ArcProgressUI/.DS_Store LogSwift/.DS_Store MusicLrc/.DS_Store $ git clean [参数] //-n 显示将要删除的文件和目录 -f 删除文件 -df 删除文件和目录 使用fastlane生成jazzy私库 DONE fastlane工具使用,编译Xcode工程,并发布到蒲公英 使用fastlane编译APP生成ipa(暂不支持personal teams) \u0026gt;Xcode已经支持个人账号(不是开发者账号)运行在真机,在这种情况下,如何使用 fastlane编译app并运行到真机上? fastlane doesn\u0026rsquo;t support personal Apple IDs for now 上传ipa到蒲公英\n类似jenkins的工具学习集成的基本操作流程 [2019-08-30 Fri 09:55]\n","date":"2019-09-07T20:47:00+08:00","permalink":"https://it-boyer.github.io/post/old/%E4%BD%BF%E7%94%A8fastlane%E9%9B%86%E6%88%90cocopads%E5%92%8Cjazzy%E5%B7%A5%E5%85%B7%E6%8F%90%E9%AB%98%E5%B7%A5%E4%BD%9C%E6%95%88%E7%8E%87/","section":"post","tags":["文档"],"title":"总结集成工具使用文档"},{"categories":["项目总结"],"contents":"STARTED UI实现 新建列表UI,继承到门店详情中,实现跳转流程.\n集配门店code:StoreDistribution\nUI:在gb组件中新建实体类:StoreDistribution,实现列表\n跳转:集配门店模块跳转到门店需要接口提供的门店的相关数据:\n1 2 3 4 5 6 - (void)showDetailContentWithStoreId:(NSString *)storeId shopId:(NSString *)shopId storeAppId:(NSString *)storeAppid storeName:(NSString *)storeName storeState:(NSString *)stState userCoordinate:(CLLocationCoordinate2D)userCoordinate 门店详情,插件框架理解 StoreCustomCommomCell模式 为其他库提供自定义门店插件cell的支持.插件code需要对应cell类名,并且该类需要实现,StoreCustomCommomCell是基于方式二的一种特殊情况\n1 +(UIView *)contentViewWithAppid:(NSString *)appid shopAppid:(NSString *)shopId storeId:(NSString *)storeId containsVC:(UIViewController *)vc delegate:(id)delegate title:(NSString *)title; 自适应cell高度的方法: 在实现上述方法的基础上,回去到cell指针,调用contentViewHeightHasChanged:方法来修改cell高度.\n1 ((void(*)(id,SEL,CGFloat))objc_msgSend)(delegate,NSSelectorFromString(@\u0026#34;contentViewHeightHasChanged:\u0026#34;),190); 该方法会创建一个view,当门店详情中,配置了该插件的code,就会创建该view,显示在门店详情对应的cell中\n方式二:在liveplay组件中创建一个插件 以StoreDistributionCell为例.新建StoreDistributionCell继承TMPItemBaseCell,然后在StoreTemplateManager中注册插件code,指定cell的高度属性StoreDistributionCell上.\n父类TMPItemBaseCell中两个重要的方法: 属性cell高度的接口:可以通过该方法来刷新cell. 在异步请求结束时,可以通过该方法属性cell数据样式.\n1 - (void)sendNotificationForFreshUI; cell加载数据接口: 在cell加载完毕之后,会触发这个接口,便于在此处添加请求接口.\n1 2 #pragma mark - requestAPI -(void)requestToShowContent; 2.1 声明插件code code由后端和前端协商确定,会通过接口返回插件code,加载插件视图,例如:当门店详情接口返回插件code:StoreDistribution等\n1 2 #pragma mark - 集配门店 const NSString *TemplateStoreDistribution = @\u0026#34;StoreDistribution\u0026#34;; 2.2 映射code到实现类管理加载插件的字典,将code映射到实现类上:例如将StoreDistribution插件code映射到 StoreDistributionCell上.\n1 2 3 4 5 6 7 8 9 #pragma mark - 集配门店 const NSString *TemplateStoreDistribution = @\u0026#34;StoreDistribution\u0026#34;; - (NSDictionary *)templateClassNamesDict{ if (_templateClassNamesDict == nil){ _templateClassNamesDict = @{ TemplateStoreDistribution.lowercaseString:NSStringFromClass([StoreDistributionCell class]) return _templateClassNamesDict; } } API实现 ","date":"2019-08-21T11:32:00+08:00","permalink":"https://it-boyer.github.io/post/old/%E5%BC%80%E5%8F%91%E9%9B%86%E9%85%8D%E9%97%A8%E5%BA%97%E6%8F%92%E4%BB%B6%E7%BB%A7%E6%89%BF%E5%88%B0%E9%97%A8%E5%BA%97%E8%AF%A6%E6%83%85/","section":"post","tags":["文档"],"title":"集配门店样式和跳转功能"},{"categories":["博客站务"],"contents":"统计命令 org-insert-columns-dblock C-c C-x i 对任务列表生成列表视图.C-c C-x C-c 生成临时的任务列表 org-clock-in C-x C-x C-i 统计实际任务执行时间 org-clock-out C-c C-x C-o 统计任务结束的总时长 org-clock-report C-c C-x C-r 统计光标的任务时间报告\n插入命令 插入代码片段: C-c C-q 标签命令 C-c i s 插入脚本 , i h 插入同级节点 C-c C-w org文件之间迁移节点\n目录命令 SPC f j + 创建目录 ivy搜索：C-s 调用swiper C-c C-c: 执行命令,光标必须定位在BEGIN_SRC模块\nyasnippet使用 暂时把所有的snippet都移动到org-mode中，可以正常加载使用\n1 mv plantuml-mode org-mode 仅支持在org文件内，使用Tab展开。\nmagit版本控制命令 spc g s 进入status窗口 ? 进入git帮助窗口 c commit输入提交信息 C-c C-c 完成提交 C-c C-k 取消提交操作\n[2019-08-19 一 17:07]\n","date":"2019-08-20T23:25:00+08:00","permalink":"https://it-boyer.github.io/post/old/emacs%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%E6%80%BB%E7%BB%93%E6%8C%81%E7%BB%AD%E6%9B%B4%E6%96%B0/","section":"post","tags":["doom"],"title":"emacs常用快捷键"},{"categories":["博客站务"],"contents":"场景说明 hugo配合emacs编写博客，借助emacs中org-mode的强大功能，对知识逻辑梳理和层级整理的神级操作，结合hugo+githubPage静态网页的支持，能够很好的将emacs本地知识体系分享到网络上。hugo的对知识点的可读性和体系，都有一个套完整的解决方案。\n目的 hugo支持本地部署网页服务，可以实时预览博客 emacs上org-mode支持日程管理和代码高亮，有ox-hugo的插件的支持，能够在日常管理中，实现知识输入的需求。 server命令的介绍 本章先解下hugo的server命令。在终端可以通过help命令得到详细的帮助的信息：\n1 hugo help server 如果想在本地调试网页，就需要启动hugo服务，直接通过本地IP来访问网页：\n1 2 hugo server Web Server is available at http://localhost:1313/ (bind address 127.0.0.1) 以上命令，默认绑定的iP地址是：127.0.0.1，这样只有在本机才能访问到hugo服务。\n如果想在该局域网内的其他客户端（手机/iPad）上访问电脑上hugo服务，就需要设置绑定参数：\u0026ndash;bind为0.0.0.0。这样局域网内所有客户端的地址都可以访问服务。\n1 2 hugo server --bind=\u0026#34;0.0.0.0\u0026#34; Web Server is available at http://localhost:1313/ (bind address 0.0.0.0) -p设置服务端口号，也是一个常用的参数，默认1313，有时会随机监听一个端口号，这时就可以通过-p参数来指定一个固定的端口。\n1 2 hugo server --bind=\u0026#34;0.0.0.0\u0026#34; -p 1234 Web Server is available at http://localhost:1234/ (bind address 0.0.0.0) ","date":"2019-08-09T19:53:00+08:00","permalink":"https://it-boyer.github.io/post/old/%E8%AE%BE%E7%BD%AE%E5%B1%80%E5%9F%9F%E7%BD%91%E5%86%85%E8%AE%BF%E9%97%AEhugo%E6%9C%AC%E5%9C%B0%E6%9C%8D%E5%8A%A1server/","section":"post","tags":["hugo"],"title":"设置局域网内访问 hugo 本地服务 server"},{"categories":null,"contents":"需求描述 本人使用oh-my-zsh终端主题，它提供了很多快捷命令，还有平时也积累的一些alias快捷命令,配置在.zshrc中，方便每次打开终端，加载命令工具。但是如何在shell脚本中利用之前积累的命令，来简化脚本的编写呢。\n场景 我使用hugo静态网页框架搭建了个人博客，部署到github-Page。博客中的图片是占用了大部分宝贵的空间，为了瘦身，编写一个一键部署的脚本deploy.sh，旨在自动编译，图片压缩，然后再发布到托管服务器上。\n实践 压缩图片压缩图片是工作中常有的需求，之前已经有封装好的快捷命令： Python获取当前文件路径 - 简书\n1 ~/.../pngquant/compresspng.py imgDir #默认目录路径 为了简化命令，借助alias别名工具，并在.zshrc 加载:\n1 alias pngTo=\u0026#34;$hsgToolDir/pngquant/compresspng.py \u0026#34; 重新打开终端，就可以找pngTo命令\n1 2 where pngTo pngTo imgDir #压缩imgDir目录下的图片 在deploy.sh使用pngTo命令开始想当然的直接在deploy.sh中直接调用：\n1 2 #压缩图片 pngTo `pwd`/static/ox-hugo 执行过程提示:找不到 pngTo 命令.\n原因是，想使用环境，还必须需要source名加载环境文件.zshrc.\n1 2 3 #压缩图片 source ~/.zshrc pngTo `pwd`/static/ox-hugo 完整脚本 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 #!/bin/zsh # deploy.sh # hugo # # Created by admin on 2019/8/8. # echo -e \u0026#34;Deploying updates to Github...\u0026#34; source ~/.zshrc # 压缩图片 where pngTo pngTo `pwd`/static/ox-hugo pngTo `pwd`/../iPics/images # build the project hugo -t even deploy() { git remote -v git add . msg=\u0026#34;rebuilding site `date`\u0026#34; if [ $# -eq 1 ] then msg=\u0026#34;$1\u0026#34; fi git commit -m \u0026#34;$msg\u0026#34; # push source to github git push origin HEAD:master # come back to blog root cd .. } cd public deploy ### echo \u0026#34;输入commit msg：\u0026#34; read msg deploy $msg ","date":"2019-08-09T15:22:00+08:00","permalink":"https://it-boyer.github.io/post/old/%E5%80%9F%E5%8A%A9%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%AE%80%E5%8C%96shell%E8%84%9A%E6%9C%AC/","section":"post","tags":["shell"],"title":"借助环境变量简化shell脚本"},{"categories":["博客站务"],"contents":"给文章添加访问权限,为自己知识产权多一份保障. 本文章基于even主题,添加文章密码.\n修改主题even的header.html 1 vi themes/even/layouts/partials/head.html 在head.html底部添加js脚本:\n1 2 3 4 5 6 7 8 9 10 \u0026lt;script\u0026gt; (function(){ if(\u0026#39;{{ .Params.password }}\u0026#39;){ if (prompt(\u0026#39;请输入文章密码\u0026#39;) !== \u0026#39;{{ .Params.password }}\u0026#39;){ alert(\u0026#39;密码错误！\u0026#39;); history.back(); } } })(); \u0026lt;/script\u0026gt; 配置文章默认密码值 需要通过对post.org头设置,新增自定义字段password\n1 2 #+password: #+hugo_custom_front_matter: :author \u0026#34;iTBoyer\u0026#34; :password \u0026#34;0000\u0026#34; 这样,在org转md之后,会在md文章头部自动添加:\n1 2 3 4 ... author = \u0026#34;iTBoyer\u0026#34; password = 0000 +++ 运行: hugo server 访问该文章就会提示,输入密码弹出框了.\n","date":"2019-08-09T14:00:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/hugo%E6%96%87%E7%AB%A0%E6%94%AF%E6%8C%81%E5%AF%86%E7%A0%81%E8%AE%BF%E9%97%AE%E7%9A%84%E5%B0%8F%E6%8A%80%E5%B7%A7/","section":"post","tags":["hugo"],"title":"hugo文章支持密码访问的小技巧"},{"categories":["解决方案"],"contents":"\u0026mdash;\u0026ndash;BEGIN PGP MESSAGE\u0026mdash;\u0026ndash;\njA0EBwMCUlTuBCTI8Rbk0ukBersHDQQnHsO5+FaUQKR/ZYY6m1lxq+gbwYyCaV0y rDRbuteR30Hqyipc72CjIUWnE1DdqbSsiy7GZdh+oWUPb/cxZUFvZ0tOXStliAHC wGsqab2ewbfstgM9vfHv2dMmfUvbFIFBED0z8Oo7psXyjvUv/06yMLM07Ap9C7jD kARn3Q88hdeHTorDGKPF4sPteAyCA/h0kdgglUSlpAOZP+KqDyz8kj4gGPp/zW3t zJHuYjS8ZrtWjhr0UifLAmgOjIS7glKX2clOTVGv7nyUCfK3ctWOxjtA1Rbf6cKA LTgVrwwLps7E8oe8ATgi4H+0FyQ0gwpt/y6fDzmoelEzHD1MhFkNWAlZJn5USaGI 2E425Zv4MgzfmwAYbr65JUmyNuZAq2JlkvSFFDNZPQ1N2edmpyZf8ZB2LQf9bOcy 836RjOmebZca5ARuFHcUAG/5SjoXf5vL2hPusWhHhPlK9oJNr15rwNt5tFQVv0zL YQUGUtzSAe5iN08sgb7Vj5ZeRDqcIfAm+QbTGSSe5jFIIt3zR4lfaATz7f6g797h vPm11zneE6wu90ltmdZQVkwE2Mq3zGpN5NUwoDDpehoGReZszLfPr+in0khzxgYj bNjeT95BDAHqMdQp/g6YJItGsdlcJzMrcU1JoQkVu4t1pBsz4JSpxqu2VbJCQqDq OsEVNzys/TACtP35rqD3HVPpCypp79gjb+/vTcUlESYRQvHUlemGAJTMGqiu6GUu VwhGvW2+Xii1UJtlN1h0XqKddb6cNJXnjSMaGQOH1mnSVxn5OZxrVm9UCqm8pN1G 9WMEzB8lcJo5nS5DdzbsD/X7hydnARX//Ge/aTQ8Cruw7CTILwqnBaw529HMP8Q4 iFBJcacVfnYz4AEeevvIGXSavzrUkTQGViaoHh/t5rHRLnW7V4EYmykUrbqVKohs pmy77RuQfMA3r37qVKqmKE7Qxy04EGyh/JDhYXCZWmoDW6C1amJfmHzJcKENo22P 577ldYhgZ5GUQ9IEWN/RqxT4sD+2RY+YTf+Ja1jRisN7ocdg7JOLo776MsohS99C XHUv+NhaZC0rWoqX3ge652TmZJp9cDEeE6PxgWPRHKRPHTQeDdErSQSTjfQCUnGT szvB7XFJh/SEf4PjyeWqV5t9d+lLlW37EwuB+ovzFd94GU8tnNlTNnkjPpqobsWy JaljzhDDQXomL+EDaGePIBKB9/fi6CChFNNnGtuuSPCpK6c7/XlUNIRVsI1pOWcs FU29dsxewXfclRW7jl3hs1+FVwErKHwpPVXYTGkIaCSkBUpiDo11Yg== =2Zpw \u0026mdash;\u0026ndash;END PGP MESSAGE\u0026mdash;\u0026ndash;\n","date":"2019-08-09T11:47:00+08:00","permalink":"https://it-boyer.github.io/post/old/%E4%BC%98%E5%8C%96%E7%BD%91%E7%BB%9C%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F-%E9%87%8D%E6%9E%84sdimage%E7%BB%84%E4%BB%B6%E8%B0%83%E7%94%A8%E6%8E%A5%E5%8F%A3/","section":"post","tags":["文档"],"title":"优化网络实现方式,重构SDImage组件调用接口"},{"categories":["博客站务"],"contents":" 使用 mermaidjs\n引入 js 文件:mermaid.min.js\n1 2 3 4 5 6 7 vi themes/even/layouts/partials/footer.html #添加下面代码 \u0026lt;!-- mermaid JS --\u0026gt; \u0026lt;script src=\u0026#34;https://cdn.jsdelivr.net/npm/mermaid/dist/mermaid.min.js\u0026#34;\u0026gt;\u0026lt;/script\u0026gt; \u0026lt;script\u0026gt; mermaid.initialize({ startOnLoad: true }); \u0026lt;/script\u0026gt; 在 md 文件中添加代码块\n1 2 3 4 5 6 \u0026lt;div class=\u0026#34;mermaid\u0026#34;\u0026gt; graph LR A --- B B--\u0026gt;C[fa:fa-ban forbidden] B--\u0026gt;D(fa:fa-spinner); \u0026lt;/div\u0026gt; ","date":"2019-08-08T20:39:00+08:00","permalink":"https://it-boyer.github.io/post/%E5%8D%9A%E5%AE%A2%E7%AB%99%E5%8A%A1/hugo-%E4%B8%AD%E5%AE%9E%E7%8E%B0%E6%94%AF%E6%8C%81-uml-%E7%9A%84%E6%96%B9%E5%BC%8F/","section":"post","tags":["UML","hugo"],"title":"hugo 中实现支持 uml 的方式"},{"categories":["学习笔记"],"contents":"工具总结 ","date":"2019-07-30T12:12:32+08:00","permalink":"https://it-boyer.github.io/post/old/ADR%E5%92%8Corgmode%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","section":"post","tags":[],"title":"ADR和orgmode工具使用"},{"categories":["学习笔记"],"contents":"类图 流程图 ","date":"2019-07-25T19:27:00+08:00","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/VIPER%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/","section":"post","tags":[],"title":"VIPER设计模式"},{"categories":["项目总结"],"contents":"类图 流程图 ","date":"2019-07-22T19:35:47+08:00","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E4%BA%8C%E7%BA%A7%E5%B8%83%E5%B1%80%E5%99%A8%E6%B5%81%E7%A8%8B/","section":"post","tags":[],"title":"二级布局器流程"},{"categories":["项目总结"],"contents":" 扫码登录业务,登录功能新增跳转申请加入业务 .5 配置管理入口:在个人主页添加“用户组管理”(支持修改名入口名)和隐藏显示逻辑 .5 分享二维码:分享组件调用 .5 添加人员:通过网页调用原生界面添加成员功能 .5 用户组管理页: 2 显示默认分组,支持分页 删除管理员用户条件(最后一个管理页不可删除) 三个菜单入口: 创建分组/编辑分组入口跳转逻辑 收到申请加入个数及跳转逻辑 bug联调 1.5天 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 title 用户组管理工期 创建时间：2019-07-05 08:26:09+0800 endtitle left header 通过甘特图梳理工作进度安排 endheader project starts 2019-07-03 Sunday are closed Saturday are closed --依赖组件模块-- [扫码邀请] as [scan] on {hsg} lasts 1 days then [用户组管理入口] as [groupMenu] on {hsg} lasts 1 days then [分享组件] on {hsg} lasts 1 days then [人员选择器] as [selecter] on {hsg} lasts 1 days [依赖结束] happens at [selecter]\u0026#39;s end --用户组管理组件-- then [默认组逻辑] as [defaultGroup] on {hsg} lasts 1 days then [删除业务] as [deleteAction] on {hsg} lasts 1 days then [三个菜单] on {hsg:100%} lasts 1 days then [待审核业务] as [verfy] on {hsg:100%} lasts 1 days [迭代结束] happens at [verfy]\u0026#39;s end 业务流程 活动图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 title 用户组管理功能流程梳理 创建时间：2019-07-09 07:17:54+0800 endtitle left header 入口控制逻辑，列表展示，导航条菜单，组菜单，待审核业务 endheader start :用户组; if (管理员) then (YES) :组列表; if (多个组) then (YES) :分组菜单; else(NO) :默认组; endif :当前组; fork :组菜单; if (管理员) then (YES) if () then :邀请加入; :分享组件; detach elseif() :编辑分组; else :创建分组; endif else(NO) if () then :编辑分组; else :邀请加入; :分享组件; detach endif endif fork again :待审核入口; end fork :web页; else(NO) :隐藏入口; stop endif stop 用户组管理类图结构 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 title 梳理H5调用原生人员选择器 创建时间：2019-07-09 20:28:33+0800 endtitle left header 问题: 1. `GetDeptAndUserInfo`问题: 组织架构的API的数据结构和域名绑定,当域名不同返回的json结构不同 2. 原生选择器多版本: 1. setGroupAdmini :用户组管理中,web拦截器监听的方法 2. JHSelectCCPPeople: 旧版本选择人员的监听器 endheader page 2x2 \u0026#39;package，node，folder，frame，cloud，database\u0026#39; package \u0026#34;JinherCCP\u0026#34; as CCP { class \u0026#34;H5UseSelectPeopleViewController\u0026#34; as h5VC { --属性组 -- + var :String=\u0026#34;\u0026#34;\t__ js回调方法__ - (IBAction)clcikOKButton:(id)sender } class \u0026#34;OrganizationSelectViewController\u0026#34; as origin { --属性组 -- + var :String=\u0026#34;\u0026#34;\t__ 函数组__ } note bottom of h5VC 用于h5调用原生的界面 end note note bottom of origin 通讯录原生界面的调用方法 end note } \u0026#39;package，node，folder，frame，cloud，database\u0026#39; package \u0026#34;JHWebCore\u0026#34; as web { class \u0026#34;WVDispatcher\u0026#34; as wvd { --属性组 -- + var :String=\u0026#34;\u0026#34;\t__拦截jsURL__ - (BOOL)webView:shouldStartLoadWithRequest:navigationType: } class \u0026#34;WVH5SelectCCPPeople\u0026#34; as ccph5 { __ 函数组__ - (BOOL)webViewShouldStartLoadRequest; } class \u0026#34;WVUGMCCPPeople\u0026#34; as ugmWeb { __ 函数组__ - (BOOL)webViewShouldStartLoadRequest; } note left of wvd 用于注册监听接口的类 end note note bottom of ugmWeb 实现web拦截器中跳转到人员选择器的方法 end note wvd --\u0026gt; ugmWeb ugmWeb ----\u0026gt; h5VC wvd --\u0026gt; ccph5 ccph5 ----\u0026gt; h5VC } \u0026#39;package，node，folder，frame，cloud，database\u0026#39; package \u0026#34;RichScanLib\u0026#34; as scan { class \u0026#34;JNQRViewController\u0026#34; as qr { __ 函数组__ - (BOOL)shouldMoveToSuperController -(NSDictionary *) parameterWithURL:(NSString *) url } note top of qr 扫描二维码的组件,直接在反射类中分发定制业务 end note } \u0026#39;package，node，folder，frame，cloud，database\u0026#39; package \u0026#34;HPPersonalPagelib\u0026#34; as person { class \u0026#34;JHPersonalViewController\u0026#34; as personVC { --属性组 -- -BOOL isUGMAdmin __ 函数组__ //网络获取用户信息：用户心情、头像、昵称 - (void)getUserInfoFromServer //接口GetIsShowMyAppGroup - (void)loadUGMIsAdmin } note top of personVC 解析personalNewPage.plist菜单配置信息,加载功能 动态加载菜单 end note } \u0026#39;package，node，folder，frame，cloud，database\u0026#39; package \u0026#34;JHUGManagerSDK\u0026#34; as ugm { class \u0026#34;JHUGMViewController\u0026#34; as ugmVC { --属性组 -- - UIView *numView; - UITableView *tableView; --数据模型属性组-- - ReqUGMPageModel *reqUGM; - OrgAdminModel *adminModel; - NSMutableArray\u0026lt;JHUGManModel *\u0026gt; *dataArray; - NSArray *groupArray; --分组列表属性-- - NSString *curGroupId; - UIButton *navBut; - UGMGroupLView *groupView; - UGMGroupModel *defaultGroup; - UIImageView *arrowImgView; __分组管理菜单属性组__ - UIView *moreView; - UIButton *moreBut; - UIButton *createGroupBut; - UIView *firstGroupline; - MASConstraint *createButHeight; - MASConstraint *editButTop; --分享组件属性组-- - JHUGMOrgItemModel *myOrg; __ 函数组__ + func (:,:) -(void)loadGroupList -(void)loadUserList -(void)loadVerifyCount -(void)loadOrgAdmin -(void)loadRemoveUser:(JHUGManModel *)user } \u0026#39;package，node，folder，frame，cloud，database\u0026#39; cloud \u0026#34;服务器\u0026#34; { class \u0026#34;UGManagerServer\u0026#34; as ugmserver { --属性组 -- + (id)shared; + JHURLRequest * request; __ 函数组__ -(void)reqGetVerifyCount:handler: -(void)requestGroupListHandler: -(void)requestUGMList:handler: -(void)reqGetIsUGMAdmin:handler: -(void)reqRemoveUserFromGroup:userId:handler: } ugmVC ..\u0026gt; ugmserver } \u0026#39;package，node，folder，frame，cloud，database\u0026#39; folder \u0026#34;用户组列表\u0026#34; as UI { class \u0026#34;UGMGroupLView\u0026#34; as groupview { --属性组 -- + NSArray *dataArray; __ 函数组__ - (instancetype)initWithHandler: } class \u0026#34;UGMGroupLCell\u0026#34; as groupcell { --属性组 -- UGMGroupModel *model; } class \u0026#34;UGMGroupModel\u0026#34; as cellmodel { --属性组 -- + NSString *Id; + NSString *Name; + NSString *AppId; + NSNumber *IsVerify; + NSString *QrCodeSource; + NSString *QrCodeImage; + BOOL isGSeleced; } groupview *-up-\u0026gt; ugmVC groupview ..\u0026gt; groupcell groupcell ..\u0026gt; cellmodel } } APP ---down-\u0026gt; personVC APP ---down-\u0026gt; scan personVC --\u0026gt; ugmVC ugm -down-\u0026gt; web 添加消息的脑图 替换接口域名 替换以下相关接口的域名:将sns.iuoooo.com替换为api.iuoooo.com/ugm.api\n1 2 3 4 5 Jinher.AMP.SNS.SV.AppGroupUserQuerySV.svc/GetExistGroupsOfUser Jinher.AMP.SNS.SV.AppGroupUserQuerySV.svc/GetGroupsOfUser Jinher.AMP.SNS.SV.AppGroupUserQuerySV.svc/GetExistTypesOfUser Jinher.AMP.SNS.SV.AppGroupUserQuerySV.svc/UpdateUserGroup Jinher.AMP.SNS.SV.AppGroupUserQuerySV.svc/IsUserInGroup 域名获取三种方式 配置文件方式iPFile.plist 无需编译 宏定义方式 需要编译相关组件 主工程源码方式 无需编译 通过配置文件iPFile.plist获取:api_host_GroupChat 1 2 [[HttpIpFileService shareInstance] getIpFile:@\u0026#34;api_host_GroupQuery\u0026#34;];//服务器地址 经排查分析,接口Jinher.AMP.SNS.SV.AppSceneUserQuerySV.svc/ExistSceneUser用到了上述方式: 所以不能修改iPfile.plist的api_host_GroupChat的值.\n采用替换方式解决问题: JHLayoutParser组件中的文件LPUpdateView读取plist文件:api_host_GroupQuery获取域名 在iPfile.plist新增一个字段\n1 api_host_GroupQuery:api.iuoooo.com/ugm.api 依赖JHAcrossNetEngin组件的头文件NetEngin.h定义的宏方式 1 2 /AppGroupUser #define AppGroupUserHttpHead [NSString stringWithFormat:@\u0026#34;%@%@api.iuoooo.com/ugm.api/Jinher.AMP.SNS.SV.AppGroupUserQuerySV.svc\u0026#34;, JHTWREQUESTPROTOCOL, NetFormat] 只需替换JHAcrossNetEngin组件NetEngin.h的宏定义,将sns.iuoooo.com替换为api.iuoooo.com/ugm.api 然后,重新编译JHAcrossNetEngin组件库,并提交到主工程中.\n图文组件组件中的接口GetExistTypesOfUser引用AppGroupUserHttpHead,需要重新编译库,并提交到主工程中.\n主工程相关的域名替换 无需编译,直接替换,提交源码即可\n涉及到的相关文件:commitID c0a320ec86bf612260028fec2e8b7b19646c83c7\n1 2 3 4 5 6 modified: JHUniversalApp/JHUniversalApp/Categories/AccessRelevantLayoutData.m modified: JHUniversalApp/JHUniversalApp/Components/Libs/JH/AcrossNetEngin/NetEngine.h modified: JHUniversalApp/JHUniversalApp/Components/Libs/JH/JinherUniversalStaticLib/ipFile.plist modified: JHUniversalApp/JHUniversalApp/ViewControllers/HomePage/Controller/HomeChannelController.m modified: JHUniversalApp/JHUniversalApp/ViewControllers/LayoutEngine/LayoutEngineViewController.m modified: JHUniversalApp/JHUniversalApp/ViewControllers/LayoutEngine/LayoutSecondEngineViewController.m ","date":"2019-07-05T08:26:09+08:00","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E7%94%A8%E6%88%B7%E7%BB%84%E7%AE%A1%E7%90%86/","section":"post","tags":["iOS"],"title":"用户组管理"},{"categories":["项目总结"],"contents":"定制图片编辑器 关于Other Link Flag的有关说明\n1 other link 添加-ObjC 替换为github代理 时序图 ","date":"2019-06-13T22:19:57+08:00","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E5%AE%9A%E5%88%B6%E5%BC%80%E6%BA%90%E7%9A%84CLImageEditor%E5%9B%BE%E7%89%87%E7%BC%96%E8%BE%91%E5%B7%A5%E5%85%B7/","section":"post","tags":null,"title":"定制开源的CLImageEditor图片编辑工具"},{"categories":["项目总结"],"contents":" 工期预估 整改 录入 用例 时序图 类图 活动图 工期预估 整改 二级布局器入口配置/电子巡查底部详情 1 复用旧版电子整改管理列表(新增过滤器)待定页 1 电子巡查记录(列表/过滤器) 1 复用/详情页(数据源变更,新增视频类型) 1天\n录入 电子巡查录入: 重构录入界面UI/详情页UI(待定问题图片布局) 2天 图片编辑器 1天 检查 1 联调接口串联业务层 1天\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 scale 2 title 电子巡查工期估算 center header 通过需求评审,分解需求按照原型图划分任务模块 endheader project starts 2019-06-11 Sunday are closed Saturday are closed --电子巡查录入-- [电子巡查录入] as [onlinePatrol] on {hsg} lasts 5 days [重构录入界面] as [resetlr] lasts 1 days [录入详情页] as [lrdetail] lasts 1 days [图片编辑器] as [picediter] lasts 1 days [检查项选择器] as [optionSelecter] lasts 1 days [串联业务联调接口] as [lrother] on {wf} lasts 1 days then [录入结束] happens at [onlinePatrol]\u0026#39;s end --开始整改列表-- [整改及列表] as [fixPlist] on {pk} lasts 4 days [整改管理列表] as [fixlist] lasts 1 days [电子巡查列表] as [patrollist] lasts 1 days [复用整改页] as [fixP] lasts 1 days [联调接口串联业务] as [zhgother] on {wf} lasts 1 days then [整改结束] happens at [fixPlist]\u0026#39;s end [resetlr] -\u0026gt; [lrdetail] [lrdetail] -\u0026gt; [picediter] [picediter] -\u0026gt; [optionSelecter] [optionSelecter] -\u0026gt; [lrother] [fixlist] -\u0026gt; [patrollist] [patrollist] -\u0026gt; [fixP] [fixP] -\u0026gt; [zhgother] 用例 用例图 截屏\u0026ndash;标记\u0026ndash;分组到检项\u0026ndash;更新电子巡查\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 title 电子巡查录入业务用例图 center header 分两个模块来实现用例的描述 1. 图片标记分组 2. 提交业务 endheader usecase jt as \u0026#34;截图:通过远程后厨摄像头，实时抓取现场图片 \u0026#34; usecase mark as \u0026#34; **图片批注** --id-- 1 ==基础操作流程== 在现场图片上 1. 选画笔工具 标重点,支持颜色切换 2. 选文本工具 批改备注,支持拖放放大,旋转,切换颜色 ..可选操作流程.. 画笔粗细/文本字体样式布局 \u0026#34; usecase check as \u0026#34; **检查项分组** --id-- 2 ==基础操作流程== 对检查的内容进行分组 完成批准之后，进入检查项分组 1. 二级目录结构,参考原型图 2. **支持多选（跨分类中的多选）** ..可选操作流程.. \u0026#34; usecase update as \u0026#34; ==**更新UI:图片检查项分组**== 3 --基础操作流程-- 检查图片完成后,更新电子巡查录入页中的图片模块UI 1. 刷新检查项个数 2. 刷新检查项图片的个数 3. 点击检查项大图预览 4. --\u0026lt;font color=red\u0026gt;上传图片成功失败问题\u0026lt;/font\u0026gt;-- ..可选操作流程.. \u0026#34; :巡查人: as ren usecase result as \u0026#34; ==**检查结果/处理方式**== 设置检查结果和处理方式 --基础操作流程-- 默认设置:通过图片检查项的个数判断默认结果 手动设置: 检查人人为设置 ..可选操作流程.. --**不支持动态判断结果**--. \u0026#34; usecase commit as \u0026#34; ==**提交巡查结果**== 搜集电子巡查的基本数据,提交服务器 --基础操作流程-- 校验检查结果,录屏视频上传成功 提交数据 ..可选操作流程.. \u0026#34; usecase chul as \u0026#34; ==**处理巡查记录**== 提交巡查信息之后,开始处理是否整改/发布任务 --基础操作流程-- 根据结果判断是否弹出处理菜单 1. 发起整改,跳转至整改页面 2. 发布任务,跳转分配任务中 ..可选操作流程.. \u0026#34; ren --\u0026gt; jt: 抓取实时图像 jt --\u0026gt; mark : 在检查图片上做批注 mark --\u0026gt; check:对检查内容分组 check --\u0026gt; update:更新录入页面UI update -right-\u0026gt; result :处理结果 result --\u0026gt; commit :校验数据提交操作 commit --\u0026gt; chul :发起其他事物 chul --\u0026gt; (发起整改):执法人开始整改 chul --\u0026gt; (发布任务):管理员发布任务 时序图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 title 电子巡查录入时序图 center header 了解参与参与者的生命周期,消息发送的动态机制的体现 endheader autonumber 0 actor 截图 as jt control 标记工具 as mark actor 画笔 as drawer actor 文本 as texter control 上传器 as uploader boundary 检查器 as checker entity 录入 as list activate jt jt --\u0026gt; mark:标记检查环境的图片 deactivate jt ===批注图片== activate mark mark --\u0026gt; drawer:批注 activate drawer drawer --\u0026gt; mark:保存 deactivate drawer mark --\u0026gt; texter:文字备注 activate texter texter --\u0026gt; mark:保存 deactivate texter deactivate mark ===上传图片== mark --\u0026gt; uploader:保存--开始上传 activate uploader uploader --\u0026gt; uploader:失败重传 uploader --\u0026gt; checker:上传成功--分类处理 deactivate uploader activate checker checker --\u0026gt; list : 更新UI deactivate checker 类图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 title 录入界面类图设计 left header 在原有功能的基础上进行迭代设计 新增功能: 1. 检查图模块变更:涂鸦/布局优化 2. 提交业务:新增发起整改/发布任务功能菜单 endheader class \u0026#34;PatrolOnlineViewController\u0026#34; as online { --属性组 -- From fromVC; NSString *storeId\tNSString *shopName UITableView *tableView __ 函数组__ -(void)clickPaizhaoAction -(void)clickLuxiangAction - (void)clickCamera:(ILiveinfos *)liveInfo } class tableView { } class \u0026#34;OnlineCell\u0026#34; as cell { --属性组 -- BOOL isDetail NSInteger cellType MHLazyCollectionImages *lazyImages; UICollectionView *ibPhotoCollectionView; NSMutableArray\u0026lt;OnlineModel *\u0026gt;*itemsArray; __ 函数组__ - (IBAction)ibaUploadAction:(id)sender __block__ void(^handlerUpLoadData)(void) } class \u0026#34;OnlinePatrolCell\u0026#34; as PatrolCell { --属性-- } note top of PatrolCell 复用巡查模块的cell样式，及相关操作逻辑 end note class \u0026#34;OnlineModel\u0026#34; as cellmodel { --属性组 -- //1:厨房 2:图片 3: 视频 NSInteger cellType; NSString *title; //cell图像 UIImage *image; //签名路径 NSString *photoPath; //远程路径 NSString *imageUrl; LazyImgStatus isUploaded; NSString *gid; //直播model ILiveinfos *liveinfos; } class \u0026#34;ILiveinfos\u0026#34; as livemod { --属性组 -- NSString *liveImgUrl } class \u0026#34;YGPatrolServer\u0026#34; as server { --属性组 -- + var request:JHURLRequest __ 函数组__ +(id)shared -(void)reqElectronicSave:handler: } class \u0026#34;ElectronicInspectModel\u0026#34; as reqmodel { --属性组 -- NSString *AppId; NSString *EnforceUserId; NSString *EnforceUserName; NSString *StoreId; NSString *StoreName; NSString *Location; NSString *Longitude; NSString *Latitude; NSString *Pics; NSString *Videos; } interface \u0026#34;OnlineCellDelegate\u0026#34; as celldel { __ 函数组__ - (void)clickCamera: - (void)addCollectionCell: - (void)delCollectionCell: } enum \u0026#34;From\u0026#34; as from { FromDefault = 0,//默认 FromMap,//来自地图 FromSeach,//来自搜索 FromList//来自列表 } tableView *--\u0026gt; online from *--\u0026gt; online server *--\u0026gt; online cell *--\u0026gt; tableView: OnlinePhotoCell \\n OnlineInfoCell \\n OnlineUploadCell livemod \u0026lt;.. cellmodel:celltype = 1 \\n delBtnHidden = YES cellmodel \u0026lt;.. cell :OnlinePhotoCell:\\n1:厨房\\n2:图片\\n3:视频 reqmodel *--\u0026gt; server celldel o-- cell 活动图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 title 梳理批注流程 left header 抓住核心功能，梳理图片批注功能 endheader start :截图; :批注; if(批注) then if (批注) then (画笔) :批注; else(文本编辑器) :文本备注; endif :保存; elseif(保存) else(返回) stop endif :上传; :检查项分组; :添加到录入页; stop ","date":"2019-06-11T07:03:20+08:00","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5%E9%A1%B9%E7%9B%AE%E8%AE%BE%E8%AE%A1/","section":"post","tags":null,"title":"电子巡查项目设计"},{"categories":null,"contents":"github项目\nUML时序图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 title 时序图 center header 使用类的生命线来描述用例在代码中执行的具体流程 参与者：actor，boundary,control,entity,database 参与者支持as别名 生命线: --\u0026gt; \u0026lt;-- 消息 endheader \u0026#39;******* 类声明模块 *******\u0026#39; actor 巡查员 as patrol entity 检查记录 as record control 拍照 as paizhao database 图库 as imgdb control 上传器 as uploader database 请求库 as reqdb control 任务服务器 as server ==拍照服务== patrol --\u0026gt; record:五定拍照指令 record --\u0026gt; paizhao: 五定一 activate paizhao paizhao --\u0026gt; imgdb :图片1model数据 activate imgdb imgdb --\u0026gt; uploader:上传图片 activate uploader uploader --\u0026gt; imgdb:更新status=2 deactivate uploader deactivate paizhao deactivate imgdb ==提交服务== record --\u0026gt; reqdb:存储suRequest数据 activate record activate reqdb reqdb --\u0026gt; imgdb:查询检查项所有的图片状态 activate imgdb imgdb --\u0026gt; reqdb:更新请求记录 deactivate imgdb deactivate reqdb reqdb --\u0026gt; server:提交检查项 activate server server --\u0026gt; reqdb:清除请求记录 server --\u0026gt; imgdb:清空图片记录 deactivate server deactivate record center footer 完成 endfooter 活动图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 start :拍照; if (一景一张) then :拍照; :上传; if(wu) then (yes) :提交; elseif(dd) :tishi; else(失败) :退出; endif else if (一景多张) fork :拍照; :上传; fork again :拍照; :上传; end fork :commit; stop else if (多步多张) then (YES) if(第一步) then (yes) fork :拍照; :上传; fork again :拍照; :上传; end fork :commit; stop else if(第二步) then (yes) fork :拍照; :上传; fork again :拍照; :上传; end fork :commit; stop else if (第..) then (yes) fork :拍照; :上传; fork again :拍照; :上传; end fork :commit; stop endif endif stop ","date":"2019-05-30T18:46:15Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%94%B5%E5%AD%90%E5%B7%A1%E6%9F%A5/%E6%9A%82%E5%AD%98%E6%9C%BA%E5%88%B6%E6%97%B6%E5%BA%8F%E5%9B%BE/","section":"post","tags":null,"title":"iOS使用Realm和FMDB实现弱网下的暂存机制"},{"categories":["解决方案"],"contents":"写下这篇文章的目的是为了更清楚的讲解和展现ssh的用法和操作，避免网上庞杂的文章和材料影响新手的学习过程。所以如果你是为老手，可以略过这篇文章了。\nSSH介绍 安装使用 OpenSSH的安装 使用 配置和启动ssh服务 登录到远程主机 配置使用key登录ssh服务器ssh免密码登录 总结 本章总结 更多参考内容 SSH介绍 什么是ssh？ ssh是“Secure Shell”的简写，Secure Shell协议是国际互联网工程任务组（The Internet Engineering Task Force，简称 IETF）制定的一个标准。目的是为了创建一个工作在应用层和传输层基础上的安全协议。避免数据的的明文传输。 什么是OpenSSH？ 前边说了，ssh是网络协议，而OpenSSH就是其中的一个具体实现。OpenSSH是由OpenBSD管理的项目之一，不过Openssh是跨平台的，支持linux、unix*，甚至windows。 所以实际应用中，我们用到的ssh基本上都是Openssh。 OpenSSH有哪些功能？ Secure Shell 是一个通信协议，在这个协议之上可以实现很多种应用层协议。从OpenSSH官网来看，OpenSSH提供了以下几个应用： 1、ssh，登录远程服务器、在远程服务器上执行命令。 2、scp，在两台主机之间实现文件拷贝。 3、sftp，基于openssh实现的类似ftp程序。 除此之外，OpenSSH还提供了几个命令行工具，用来方便进行ssh操作： 1、ssh-add 2、ssh-keysign 3、ssh-keyscan 4、ssh-keygen\n安装使用 下文将讲述这些命令的实际用法。\nOpenSSH的安装 大部分linux发行版都默认包含了OpenSSH客户端和服务器端，一些linux桌面发行版没有安装openssh服务器端。 如果没有安装，我们可以通过linux发行版的软件包管理工具进行安装。简单来说就是： apt-get系列：\n1 sudo apt-get install openssh openssh-server yum系列：\n1 sudo yum install openssh openssh-server 其他系列：自己百度下。 备注：openssh是客户端、openssh-server是服务器端。不同的发行版名称可能不同，需要自己确认一下。 安装完毕之后，系统中就应该会有ssh命令了。这个时候就可以使用ssh来进行远程主机的管理了。\n使用 配置和启动ssh服务 在使用之前我们需要对ssh服务进行配置，在大多数linux系统中，ssh服务的配置文件为：/etc/ssh/sshd_config 使用vim进行编辑：\n1 vim /etc/ssh/sshd_config 以下地方根据实际情况进行修改（yes为允许、no为禁止）：\n1 2 3 4 PermitRootLogin yes #是否允许root账户登录 PasswordAuthentication yes #是否允许使用密码校验登录 RSAAuthentication yes PubkeyAuthentication yes #是否允许使用key登录 然后使用系统服务管理命令启动服务，在大部分linux系统下，命令为：service 或者 systemctl 启动ssh服务命令：\n1 ~# service sshd restart 或者\n1 ~# systemctl restart sshd 登录到远程主机 命令格式为：ssh 用户名@远程主机的ip地址:远程主机端口 示例：\n1 ssh root@192.168.0.1:22 或者：\n1 ssh -p 22 root@192.168.0.1 注：ssh默认端口为22，远程主机为默认端口时，可省略端口号。\n执行上述命令之后，首次登陆会询问是否保存秘钥，输入yes即可。然后会提示输入密码，输入该用户对应的远程主机密码即可。\n配置使用key登录ssh服务器ssh免密码登录 使用key登录，需三个步骤：\n修改ssh服务配置文件允许key登录： 1 ~# vim /etc/ssh/sshd_config 找到PubkeyAuthentication这一行，改成：\n1 PubkeyAuthentication yes 重启ssh服务： 1 ~# service sshd restart 或者\n1 ~# systemctl restart sshd 使用ssh-keygen命令在本地机器上生成Rsa公钥对： 1 ~# ssh-keygen -t rsa 执行上述命令后，会提示输入要保存的文件路径，默认为：~/.ssh/id_rsa.\n输入文件名，点回车，会提示输入秘钥的密码（会提示输入两遍），即可生成秘钥文件：\n查看秘钥文件\n将公钥文件上传到服务上： 1 2 ~# ssh-copy-id -i /home/zhao/.ssh/id_rsa_leilei.pub root@192.168.0.1 -i 是用来指定公钥文件，执行命令之后，按提示输入远程密码即可。 5. 然后即可使用私钥文件登录服务器：\n1 ~# ssh -i /home/zhao/.ssh/id_rsa_leilei root@192.168.0.1 注意：如果在第3步时为秘钥设置了密码，则使用秘钥登录服务器时，需要输入秘钥密码。\n总结 如果想实现免密登录，则只需要在第三步生成密钥对时不要设置秘钥密码。\n如果使用秘钥文件使用默认文件名（id_rsa），则在使用ssh的过程中就不需要再使用-i开关来指定秘钥文件了。\n拷贝文件到远程主机： ssh中提供了scp命令用来拷贝文件到远程主机，使用方式为：\n1 ~# scp -i /home/zhao/.ssh/id_rsa_miyao a.tar.gz root@192.168.0.1:/home/zhao/ 就能将文件 a.tar.gz 拷贝到远程主机/home/zhao/下\n5. 在远程服务器上执行命令： 直接将需要执行的命令追加到ssh命令后面即可，如：\n1 ~# ssh -i /home/zhao/.ssh/id_rsa_miyao root@192.168.0.1 \u0026#34;ls -l\u0026#34; 即可在远程服务器上执行“ls -l” 命令，结果将输出到本地控制台。 但是在执行一些命令时，远程主机会提示无法找到该命令，这说明需要设置远程主机的环境变量，可在发送给远程主机的命令中增加source指令，如：\n1 ~# ssh -i /home/zhao/.ssh/id_rsa_miyao root@192.168.0.1 \u0026#34;source ~/.bash_profile \u0026amp;\u0026amp; ls -l\u0026#34; 本章总结 本文的命令示例中，均使用了 -i 开关来指定秘钥文件，如果使用默认秘钥文件：~/.ssh/id_rsa 登录，则均可省略-i开关。 其他用法后续再补充吧。 更多参考内容 https://man.openbsd.org/ssh-add.1 https://man.openbsd.org/?query=ssh-keygen\u0026amp;sektion=1\n","date":"2019-02-26T18:16:23Z","permalink":"https://it-boyer.github.io/post/old/shell/SSH%E5%91%BD%E4%BB%A4%E5%AE%89%E8%A3%85%E5%8F%8A%E4%BD%BF%E7%94%A8/","section":"post","tags":["shell"],"title":"SSH命令安装及使用"},{"categories":["解决方案"],"contents":"简介 用于iOS的Blink Shell(为更多Shell util进行了编辑) Blink是第一个利用Mosh和SSH支持的专业桌面级iOS终端。因此，我们可以明确地保证稳定的连接、闪电般的速度和完整的配置。它可以而且应该是你一整天的工具。 我们没有创建另一个终端来修复您的网站的运行。Blink从一开始就被打造为专业级产品。 我们从分析什么是必须拥有的开始，我们最终基于以下三个概念:\n快速呈现 Unix服务器中的dmesg应该是即时的。我们等不及要渲染了。我们不需要重新发明轮子来实现这一点。我们只是简单地使用Chromium的HTerm来确保渲染是完美和快速的，即使是那些特殊的、复杂的编^码。\n始终在线 Mosh超越了SSH的可变性。Mosh克服了我们都与移动连接相关的不稳定和间歇性连接。您可以检查Safari，而不必担心重新启动SSH连接。感谢Mosh，你可以完美地从家里跳到火车上，然后跳到办公室。Blink是坚如磐石的连接方式。Mosh很容易获得，并且可以很容易地安装在服务器上。访问https://mosh.org。\n完全可配置 Blink热情拥抱蓝牙连接键盘。一些人喜欢在Vim上设置Esc，另一些人喜欢在Emacs上设置Ctrl。瞬目是它们的冠军。但还有更多，因为我们想要更多。您还可以添加自己的自定义主题和字体来闪烁。在你的日常工作中，你处于自己的状态。 但是，眨眼更重要。请阅读: 你应该命令你的终端，而不是导航它。Blink会把你直接跳到一个友好的shell中，这样你就可以清楚地看到如何滚动了。 界面很简单。我们抛弃了所有的菜单，为您的终端打开了全屏。 使用滑动在打开的连接之间移动，滑下来关闭它们，甚至捏来缩放! 通过添加您自己的主机和RSA加密密钥来配置Blink连接。一切看起来都很熟悉，你很快就可以开始工作了!\n使用 我们已经合并了SplitView，用于那些必要的谷歌搜索和与同事聊天。 更多信息，请访问Blink Shell。\n添加新功能 这个分支还包含一组shell实用程序，因此您可以添加/删除文件、列出它们等等。 目前可用的命令有:\n操作命令 cd, setenv, ls, touch, cp, rm, ln, mv, mkdir, rmdir, df, du, chksum, chmod, chflags, chgrp, stat, readlink, compress, uncompress, gzip, gunzip， 环境命令 pwd, env, printenv, date, uname, id, groups, whoami, uptime cat,grep, wc 访问命令 curl(包括http、https、scp、sftp…)、scp、sftp tar 第三方项目：使用外部项目:Python、Lua和TeX 您可以单独调用命令，或者使用python或lua使用script脚本。有重定向(“\u0026gt;”、“\u0026lt;”、“\u0026amp; \u0026gt;“…),但没有pipe工具。 所有这些命令都在ios_system.framework(预编译，用于工具)中。如果您想编辑源代码(以添加更多命令)，请参见:https://github.com/holzschu/ios_system。\n编辑脚本文件 我建议安装iVim (https://github.com/terrychou/iVim或https://itunes.apple.com/us/app/ivim/id1266544660?)mt=8)，使用ios11“edit-in-place”在Blink沙箱内编辑文件。\n密钥访问方式 curl可以打开与iPad之间的文件传输(ftp、http、scp、sftp…)。\n它使用了BLINKSHELL的密钥管理(即“config”创建密钥)。\n也可以指定键与路径: {% codeblock lang:swift %} curl scp://host.name.edu/filename -o filename—key $SHARED/id_rsa—pass MyPassword {% endcodeblock %} 你也可以使用scp和sftp命令:\nscp user@host.name.edu:文件名 sftp localFilename user@host.name.edu: ~ / scp和sftp是通过curl实现的，通过重写参数来遵循curl语法。 利:更轻的实现，更小的内存成本，更不可能有函数名冲突。 弊:有些开关可能没有完全相同的含义。\n第三方语言包 语言包(Python、Lua和TeX)只提供等价的二进制文件。您可以使用包(/usr/local/texlive或/usr/lib/python2.7)传输目录，并将它们放到Blink应用程序的Library文件夹中。这是命令，如ls, rm, tar, mv…将是有用的。 注意:所有框架(除了curl)都是动态框架，以减少应用程序内存占用。\n环境变量 在iOS中，由于沙箱限制，不能在**~**目录下写，只能在~/Documents/、~/Library/和~/tmp中写。大多数Unix程序假定配置文件位于$HOME中。因此，要么将$HOME重新定义为~/Documents/，要么将配置变量(使用setenv)设置为其他位置。 我用Blink在MCPSession.m文件。定义了以下变量:\n1 2 3 4 5 6 setenv PATH = $PATH:~/Library/bin:~/Documents/bin setenv PYTHONHOME = $HOME/Library/ setenv SSH_HOME = $HOME/Documents/ setenv CURL_HOME = $HOME/Documents/ setenv HGRCPATH = $HOME/Documents/.hgrc/ setenv SSL_CERT_FILE = $HOME/Documents/cacert.pem 如果你想永久地改变它们，最好是编辑MCPSession.m文件。\n使用Blink 我们的UI非常直观，并优化了触摸设备的体验，这是非常重要的部分，terminal终端。您将直接跳到一个非常简单的shell中，因此您将知道如何操作。 这里还有一些技巧: 键入help在shell中查找信息。 新建shell命令：用两个手指轻敲创建一个新的shell。 移动shell命令：通过用手指移动两行shell命令。 新建连接/重连/退出：您可以退出会话并回到shell打开一个新连接。 关闭session：两个手指向下拖动来关闭会话。 缩放文本：使用缩放手势来增加或减少文本的大小。您也可以使用Cmd+或Cmd-如果使用键盘。 复制和粘贴：通过选择文本点击屏幕。 运行“config”来设置密钥。通过ssh-copy-id将它们安装到服务器。 在SmartKeys栏上的Ctrl和Alt修改器允许连续按下，就像在真正的键盘上一样。\n支持python命令 holzschu/blink holzschu/pyhon_iOS\n配套使用的iVim工具 iVim readme介绍了，如何在真机上运行以及集成python环境。\n","date":"2019-02-26T18:11:37Z","permalink":"https://it-boyer.github.io/post/old/shell/iOS%E7%B3%BB%E7%BB%9F%E7%9A%84shell%E5%B7%A5%E5%85%B7blink/","section":"post","tags":["shell","iOS"],"title":"iOS系统的shell工具blink"},{"categories":["学习笔记"],"contents":" {% github nsomar Guaka 7d6135f width = 30% %}\nGuaka介绍 通过 Guaka Framework 来实现 CLI(command-line interface)。 该框架可以快速实现如下的效果：\n1 git checkout -v \u0026#34;url\u0026#34; git 就是一个 CLI，checkout是这个CLI的子命令，并接受一个 String 作为他的参数。\n对应上述的命令可以为分为：\ngit 主命令 checkout 子命令 -v/–v 命令所接收的 flag 1 2 3 4 └── git ├── checkout -v └── push -f └── ... 在 Guaka 中代码表现基本就是这样子的：\n1 2 3 4 5 let flag = Flag(longName: \u0026#34;v\u0026#34;, value: false, description: \u0026#34;Show verbose\u0026#34;) let command = Command(usage: \u0026#34;git\u0026#34;, flags: [flag]) { flags, args in let showVerbose = flags.getBool(name: \u0026#34;v\u0026#34;) // args the positional arguments passed to the command } 上面就是 git 的 -v 指令，是否打印过程.\nGuaka快速上手 安装 1 \u0026gt; brew install oarrabi/tap/guaka 新建工程 假设我们要建立一个 papa 的CLI指令 1 2 cd 到需要建立工程的目录 guaka create papa 会生成如下路径 ├── Package.swift └── Sources ├── main.swift ├── root.swift └── setup.swift\n增加指令 给 papa 增加个子命令叫做 check 1 guaka add check 增加 flag 增加 flag 就要去 Source 下面对应的 Swift 文件中修改。\n编译执行 Swift build 1 swift build // 会编译生成可执行文件 // .build/debug/papa \u0026ndash;help\n运行papa可执行文件 1 .build/debug/papa check 增加逻辑就在对应的 Swift 文件中增加.\n","date":"2018-11-18T19:10:49Z","permalink":"https://it-boyer.github.io/post/old/macOS/Guaka%E5%BF%AB%E9%80%9F%E5%88%9B%E5%BB%BAswift%E5%91%BD%E4%BB%A4%E8%A1%8CCLI%E7%9A%84%E5%B7%A5%E5%85%B7/","section":"post","tags":["swift"],"title":"Guaka快速创建swift命令行CLI的工具"},{"categories":["项目总结"],"contents":" {% github it-boyer WWDC-Subtitles 84878dc width = 30% %} 平时没有那么大段的时间能去看这些 session 的视频，想先通过字幕能了解到 session 中的内容，所以搜罗了网上大牛抓取WWDC字幕的相关实现。\n原理 WWDC客户端作者分享的一个开源项目jonyfive是把他WWDC项目中抓取字幕文件逻辑抽取出来，就是使用 swift 做的爬虫，可以结合项目做些有趣的东西。 这边我对该项目进行了一些修改，之前下载的直接就是 vtt 的文件，并没有对文本文件进行处理，我把vtt格式调整了正常阅读的模式，方便大家阅读。\n不支持2108下载\n安装 1 2 3 $ git clone https://github.com/Danny1451/WWDC-Subtitles.git $ cd WWDC-Subtitles $ swift build 抓取字幕 获取 2017 年 204 session 的字幕，保存到当前目录的 2017 文件夹\n1 ./wwwww subtitle -s 204 -v -y 2017 获取 2016 年 204 session 的 meta 信息，以 json 格式并且保存在当前目录的 sessions.json 文件中\n1 ./wwwww meta -s 204 -v -y 2016 如何下载中文 如何支持2018下载 WWDC 2017 字幕抓取 \u0026amp; Guaka 介绍\nWWDCHelper - 帮你更好下载 WWDC 中文字幕\n","date":"2018-11-18T19:10:49Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E4%BD%BF%E7%94%A8swift%E5%91%BD%E4%BB%A4%E8%A1%8C%E6%8A%93%E5%8F%96WWDC%E5%AD%97%E5%B9%95/","section":"post","tags":["swift"],"title":"使用swift命令行抓取WWDC字幕"},{"categories":["学习笔记"],"contents":"Foundation Foundation 框架实现了基于运行时一个特性的两个API：\n键值编码 (key-value-coding, KVC) 键值观察 (key-value observing, KVO) KVC 和 KVO 允许我们将 UI 和数据进行绑定，这也是 Rx 以及其他响应式框架实现的基础。 KVC KVC 的工作方式如下所示：\n1 2 3 4 @property (nonatomic, strong) NSNumber *number; [myClass valueForKey:@\u0026#34;number\u0026#34;]; [myClass setValue:@(4) forKey:@\u0026#34;number\u0026#34;]; 例如，假设我们有这个 number 属性，您可以将属性名称作为键，来获取属性值或者设置属性值。这个功能可以用在此前我们所看到的获取变量列表、协议列表，以及危险的混淆功能当中。\nKVO 通常所说的 Objective-C 「动态性」，往往都是指 KVO。虽然还有其余的函数，但是这些是最常见、最常用的。这也就是人们所说的，Swift 缺失的部分。\n使用KVO对状态的变化进行注册 1 2 3 4 5 6 7 8 9 10 11 [myClass addObserver:self forKeyPath:@\u0026#34;number\u0026#34; options:NSKeyValueObservingOptionInitial | NSKeyValueObservingOptionNew context:nil]; - (void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary\u0026lt;NSKeyValueChangeKey,id\u0026gt; *)change context:(void *)context{ // Respond to observation. } 在观察的值发生变更之后，KVO 会调用此方法立即通知观察者。通过这个方法，我们便可以按需更新 UI。 2. 弊端：难以调试 KVO这些操作都存有隐患。比方说 KVO，特别是当我们对某个不是自己所创建的类进行观察时，往往会发现有出乎意料的变化发生。通常而言，这些问题是非常难以调试的，也很难去理解为什么出错。在实际产品当中，我并不建议使用它们，尽管它们非常好用。但是在实际产品当中，我会很谨慎地去使用这些功能。\nApple 也是如此认为的，因此它们在视图控制器当中添加了这个私有方法，可以使用 class-dump 来查看。\n(void) attentionClassDumpUser: yesItsUsAgain: althoughSwizzlingAndOverridingPrivateMethodsIsFun: itWasntMuchFunWhenYourAppStoppedWorking: pleaseRefrainFromDoingSoInTheFutureOkayThanksBye: 的确，很让人抓狂。\nSwift Swift 是一种强类型语言。即默认类型是安全的静态类型。如果需要的话，不安全类型也是存在的，但是 Swift 仍然是尽力推动我们使用安全的静态类型。Swift 中的动态性可以通过 Objective-C 运行时来获得。\n本来这是很好的，但是 Swift 开源并迁移到 Linux 之后，由于 Linux 上的 Swift 并不提供 Objective-C 运行时，事情就大条了。社区的关键点在于，让 Swift 未来能够自己配备动态性，而不是依赖于 Apple。\nSwift中的两个动态修饰符 @objc: 将Swift API 暴露给 Objective-C 运行时，但是它仍然不能保证编译器会尝试对其进行优化。 @dynamic:动态功能修饰符，它隐含添加了 @objc功能。 Swift中运行时方法 回到我们的动态特性当中，让我们来看一看 Swift 当中这些动态特性是什么样的。假设我们需要使用内省机制、转发方法、替换和绑定方法。\n方法转发 1 2 3 4 5 6 7 8 9 10 11 12 13 // 1 override class func resolveInstanceMethod(_ sel: Selector!) -\u0026gt; Bool { // 添加实例方法并返回 true 的一次机会，它随后会再次尝试发送消息 } // 2 override func forwardingTarget(for aSelector: Selector!) -\u0026gt; Any? { // 返回可以处理 Selector 的对象 } // 3 - Swift 不支持 NSInvocation resolveInstanceMethod 同样会被调用，forwardingTarget 看起来似乎更贴近于 Swift 3 风格的 API。但是 NSInvocation 并不能在 Swift 当中使用。我们同样可以实现方法转发，因此看起来也不算太坏。\n方法混淆 load 在 Swift 不再会被调用，因此我们需要在 initialize 中进行混淆。在 Objective-C 当中使用的 dispatch_once，但是在 Swift 3 中被废弃。事情变得略为复杂。虽然对于特定类型的函数而言，我们仍然可以将其定义为动态函数，但是它会消除大部分混淆的功能。\n内省机制 1 2 3 4 5 6 7 8 9 10 11 if self is MyClass { // YAY } let myString = \u0026#34;myString\u0026#34;; let mirror = Mirror(reflecting: myString) print(mirror.subjectType) // “String\u0026#34; let string = String(reflecting: type(of: myString)) // Swift.String // No native method introspection is 替代了 isMemberOfClass，它同样也可以对 Swift 值类型:结构体、枚举以及其他 Swift 当中的新类型使用。此外还有一个新的映射 API，它主要针对于管道 (pipe) 和数据。\n单元测试 目前，我们没有原生的办法来实现内省。这也预示着这个功能未来可能会出现，但是目前我们还无法实现。这很令人沮丧，特别是当您想到我们此前所实现的 XCTestCase。如果您打算为 Linux 编写单元测试的时候，就无法自动遍历所有的函数。您必须实现 static var allTests，然后手动列出所有的测试函数。这很糟糕。\nKVC/KVO功能的削弱 KVO 的魅力在于，您可以在不是自己所创建的类当中使用它，也可以只对您想要监听变化的类使用。KVO 和 KVC 在 Swift 被极大地削弱了。 两点要求：\n被观察的对象必须要继承自 NSObject，并且使用一个 Objective-C 类型。 被观察的变量必须要声明为 @dynamic。您必须要对想要观察的事务了如指掌。 问题是 Swift 并没有很好的替代方案。您可以使用 Rx 或者基于协议来观察对象。但是语言自身是没有原生的解决方案的。 总结 总而言之，Objective-C 的动态性无疑是非常强大的、极其有用，虽然也存在危险性。Swift 目前没有足够的替代方案来解决这些问题，但是可以预见在不久的将来 Swift 的动态性将会出现，这是值得我们期待的。\n","date":"2018-11-10T09:14:55Z","permalink":"https://it-boyer.github.io/post/old/swift/Swift%E7%9A%84%E5%8A%A8%E6%80%81%E6%80%A7/","section":"post","tags":["swift"],"title":"Swift的动态性"},{"categories":["解决方案"],"contents":" {% github it-boyer chisel f331dc6 width = 30% %} 这个pull请求添加findinstances命令，该命令完成Add findinstances, and new support framework in Chisel.xcodeproj 和Add Makefile for installing framework的工作。 用户可以运行help findinstances获取findinstances的详细信息。简要总结一下，findinstances可以找到给定class类或protocol协议的所有实例，并使用谓词表达式过滤这些结果。 如果您有一个名为XXSocialUser的类，那么您可以通过运行findinstances XXSocialUser == 'curry'来找到一个特定的用户。\nChisel.xcodeproj为新建findinstance提供了凿子框架支持。 使用Chisel.xcodeproj支持新建chisel Framework通过本地代码实现command,findinstances等功能。也可以通过这种方式来实现更多chisel命令。\nfindinstance命令通过扫描iOS/macOSmalloc API。对于每个allocation分配，都会使用heuristics来识别可能的Objective-C实例。heuristics不调用对象上的method，而是依赖objc runtime运行时函数,基于class metadata类元数据来匹配到oc实例。这避免了在objc运行时机制下分配和有状态副作用。 在第一次传递之后，候选对象将通过第二次传递，检查它们是否与可选的NSPredicate匹配。如果没有谓词，则输出对象的信息最少。如果有谓词，并且对象传递谓词，那么对象将输出更多细节，特别是谓词中查询的细节。\n1 2 3 4 5 6 7 findinstances UIView findinstances *UIView findinstances UIScrollViewDelegate findinstances UIView window == nil || hidden == true || alpha == 0 || layer.bounds.#size.width == 0 || layer.bounds.#size.height == 0 findinstances UIView subviews.@count == 0 findinstances NSDictionary any @allKeys beginswith \u0026#39;perf_\u0026#39; findinstances NSArray @count \u0026gt; 100 开发使用 构建Xcode项目，并获得到Chisel Framework的路径。:\n1 /Users/\u0026lt;me\u0026gt;/Library/Developer/Xcode/DerivedData/Chisel-\u0026lt;stuff\u0026gt;/Build/Products/Debug-iphonesimulator/Chisel.framework/Chisel 在lldb环境下执行：\n1 2 3 $ lldb \u0026gt;\u0026gt;\u0026gt; expr -l objc -- (void*)dlopen(\u0026#34;/path/to/Chisel.framework/Chisel\u0026#34;, 2) script o=lldb.SBExpressionOptions(); o.SetLanguage(lldb.eLanguageTypeObjC); o.SetTrapExceptions(False); o.SetTryAllThreads(False); o.SetTimeoutInMicroSeconds(10*1000000); lldb.frame.EvaluateExpression(\u0026#39;(void)PrintInstances(\u0026#34;\u0026lt;classname\u0026gt;\u0026#34;, \u0026#34;\u0026lt;predicate\u0026gt;\u0026#34;)\u0026#39;, o) \u0026lt;classname\u0026gt;:可以是class类名或protocol协议名 \u0026lt;predicate\u0026gt;:是一个可由NSPredicate解析的字符串 可以使用regex command 命令: (注意，findinstance后面必须换行)\n1 2 command regex findinstances s/(\\S+) *(.*)/script o=lldb.SBExpressionOptions(); o.SetLanguage(lldb.eLanguageTypeObjC); o.SetTrapExceptions(False); o.SetTryAllThreads(False); o.SetTimeoutInMicroSeconds(10*1000000); lldb.frame.EvaluateExpression(\u0026#39;(void)PrintInstances(\u0026#34;%1\u0026#34;, \u0026#34;%2\u0026#34;)\u0026#39;, o)/ 或者，作为python命令，存储在path/to/findinstances.py中:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 import lldb def findinstances(debugger, command, exe_ctx, result, _): options = lldb.SBExpressionOptions() options.SetTrapExceptions(False) options.SetTryAllThreads(False) options.SetTimeoutInMicroSeconds(10*1000000) options.SetLanguage(lldb.eLanguageTypeObjC) frame = exe_ctx.frame if not exe_ctx.target.module[\u0026#39;Chisel\u0026#39;]: frame.EvaluateExpression(\u0026#39;(void*)dlopen(\u0026#34;/path/to/Chisel.framework/Chisel\u0026#34;, 2)\u0026#39;, options) args = command.split(\u0026#39; \u0026#39;, 1) typeName = args[0] predicate = args[1] if len(args) \u0026gt; 1 else \u0026#39;\u0026#39; frame.EvaluateExpression(\u0026#39;(void)PrintInstances(\u0026#34;{}\u0026#34;, \u0026#34;{}\u0026#34;)\u0026#39;.format(typeName, predicate), options) def __lldb_init_module(debugger, _): debugger.HandleCommand(\u0026#39;command script add -f findinstances.findinstances findinstances\u0026#39;) 安装 Add Makefile for installing framework This allows you to run make install with optional environment variables in order to build and install Chisel.framework.\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 PREFIX ?= /usr/local/lib export INSTALL_NAME = ifneq ($(LD_DYLIB_INSTALL_NAME),) INSTALL_NAME = \u0026#34;LD_DYLIB_INSTALL_NAME=$(LD_DYLIB_INSTALL_NAME)\u0026#34; endif install: xcodebuild \\ -scheme Chisel \\ -configuration Release \\ -sdk iphonesimulator \\ install \\ $(INSTALL_NAME) \\ DSTROOT=/ \\ INSTALL_PATH=\u0026#34;$(PREFIX)\u0026#34; ","date":"2018-11-09T13:05:46Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/Chisel-xcodeproj%E6%A1%86%E6%9E%B6%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"post","tags":["iOS","调试"],"title":"Chisel-xcodeproj框架的使用"},{"categories":["解决方案"],"contents":"make命令执行时，需要一个makefile文件，以告诉make命令需要怎么样的去编译和链接程序。\n首先，我们用一个示例来说明makefile的书写规则，以便给大家一个感性认识。这个示例来源于gnu 的make使用手册，在这个示例中，我们的工程有8个c文件，和3个头文件，我们要写一个makefile来告 诉make命令如何编译和链接这几个文件。我们的规则是：\n如果这个工程没有编译过，那么我们的所有c文件都要编译并被链接。 如果这个工程的某几个c文件被修改，那么我们只编译被修改的c文件，并链接目标程序。 如果这个工程的头文件被改变了，那么我们需要编译引用了这几个头文件的c文件，并链接目标程序。 只要我们的makefile写得够好，所有的这一切，我们只用一个make命令就可以完成，make命令会自动智能 地根据当前的文件修改的情况来确定哪些文件需要重编译，从而自动编译所需要的文件和链接目标程序。\nmakefile的规则\n在讲述这个makefile之前，还是让我们先来粗略地看一看makefile的规则。 跟我一起写Makefile\n","date":"2018-11-08T20:30:54Z","permalink":"https://it-boyer.github.io/post/old/shell/makefile%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BC%96%E8%AF%91%E5%B7%A5%E5%85%B7/","section":"post","tags":["shell"],"title":"makefile自动化编译工具"},{"categories":["博客站务"],"contents":" {% github it-boyer width = 30% %}\n使用 sphinx 制作简洁而又美观的文档\n安装 1 2 3 4 5 6 7 8 9 $ easy_install sphinx Searching for sphinx Reading http://pypi.python.org/simple/sphinx/ Reading http://sphinx.pocoo.org/ Best match: Sphinx 1.0.5 Downloading http://pypi.python.org/packages/[...] Processing Sphinx-1.0.5-py2.5.egg [...] Finished processing dependencies for sphinx 创建工程 1 2 3 4 5 6 $ sphinx-quickstart Welcome to the Sphinx 1.0.5 quickstart utility. Please enter values for the following settings (just press Enter to accept a default value, if one is given in brackets). [...] 工作目录的列表\n1 2 3 4 5 ├── Makefile ├── _build ├── _static ├── conf.py └── index.rst 让我们详细研究一下每个文件。\nMakefile：编译过代码的开发人员应该非常熟悉这个文件，如果不熟悉，那么可以将它看作是一个包含指令的文件，在使用 make 命令时，可以使用这些指令来构建文档输出。 _build：这是触发特定输出后用来存放所生成的文件的目录。 _static：所有不属于源代码（如图像）一部分的文件均存放于此处，稍后会在构建目录中将它们链接在一起。 conf.py：这是一个 Python 文件，用于存放 Sphinx 的配置值，包括在终端执行 sphinx-quickstart 时选中的那些值。 index.rst：文档项目的 root 目录。如果将文档划分为其他文件，该目录会连接这些文件。 make生成文档 以py-trello为例子\n1 2 3 4 5 6 7 $ git clone py-trello $ cd py-trello/docs $ make html \u0026gt; sphinx-build -b html -d _build/doctrees . _build/html 正在运行的是 Sphinx v1.8.1 创建输出目录… ","date":"2018-11-07T12:27:56Z","permalink":"https://it-boyer.github.io/post/old/hexo/%E4%BD%BF%E7%94%A8Sphinx%E5%88%B6%E4%BD%9C%E7%AE%80%E6%B4%81%E8%80%8C%E5%8F%88%E7%BE%8E%E8%A7%82%E7%9A%84%E6%96%87%E6%A1%A3/","section":"post","tags":["hexo"],"title":"使用Sphinx制作简洁而又美观的文档"},{"categories":["学习笔记"],"contents":"swift和OC混编 OC oc调用swift framework/swift静态库 oc静态库调用swift/oc的framework oc静态库调用swift/oc的静态库 swift swift调用oc/swift静态库 swift framework调用oc/swift静态库 swift静态库调用oc/swift静态库 ","date":"2018-10-31T21:19:06Z","permalink":"https://it-boyer.github.io/post/old/swift/swift%E6%B7%B7%E7%BC%96%E5%8F%8AFramework%E5%92%8C%E9%9D%99%E6%80%81%E5%BA%93%E7%9A%84%E6%94%AF%E6%8C%81/","section":"post","tags":["swift"],"title":"swift混编及Framework和静态库的支持"},{"categories":["学习笔记"],"contents":" {% github it-boyer width = 30% %}\n持续集成 在框架开发中，一个优秀的持续集成环境是至关重要的。CI 可以保证潜在的贡献者在有保障的情况下对代码进行修改，减小了框架的维护压力。大部分 CI 环境对于开源项目都是免费的，得益于此，我们可以利用这个星球上最优秀的 CI 来确保我们的代码正常工作。\n就 iOS 或者 OSX 开发来说，Travis CI, CircleCI, Coveralls，Codecov 等都是很好的选择。\n开发总是有趣的，但是发布一般都很无聊。因为发布流程每次都一样，非常机械。无非就是跑测试，打 tag，上传代码，写 release log，更新 podspec 等等。虽然简单，但是费时费力，容易出错。对于这种情景，自动化流程显然是最好的选择。而相比于自己写发布脚本，在 Cocoa 社区我们有更好的工具，那就是 fastlane。\nfastlane 是一系列 Cocoa 开发的工具的集合，包括跑测试，打包 app，自动截图，管理 iTunes Connect 等等。\n不单单是 app 开发，在框架开发中，我们也可以利用到 fastlane 里很多很方便的命令。\n使用 fastlane 做持续发布很简单，建立自己的合适的 Fastfile 文件，然后把你想做什么写进去就好了。比如这里是一个简单的 Fastfile 的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 # Fastfile desc \u0026#34;Release new version\u0026#34; lane :release do |options| target_version = options[:version] raise \u0026#34;The version is missed.\u0026#34; if target_version.nil? ensure_git_branch # 确认 master 分支 ensure_git_status_clean # 确认没有未提交的文件 scan # 运行测试 sync_build_number_to_git # 将 build 号设为 git commit 数 increment_version_number(version_number: target_version) # 设置版本号 version_bump_podspec(path: \u0026#34;Kingfisher.podspec\u0026#34;, version_number: target_version) # 更新 podspec git_commit_all(message: \u0026#34;Bump version to #{target_version}\u0026#34;) # 提交版本号修改 add_git_tag tag: target_version # 设置 tag push_to_git_remote # 推送到 git 仓库 pod_push # 提交到 CocoaPods end $ fastlane release version:1.8.4 AFNetworking 在 3.0 版本开始加入了 fastlane 做自动集成和发布，可以说把开源项目的 CI 做到了极致。在这里强烈推荐大家有空可以看一看这个项目，除了使用 fastlane 简化流程以外，这个项目里还介绍了一些发布框架时的最佳实践。\n","date":"2018-10-24T12:45:30Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E4%BD%BF%E7%94%A8Fastlane%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E5%BC%80%E5%8F%91/","section":"post","tags":["iOS","工具"],"title":"使用Fastlane持续集成开发"},{"categories":["学习笔记"],"contents":"通过介绍项目相关的属性配置，来了解cocoapods如何自动化管理项目依赖的。最后会通过自定义ruby脚本来演示。\ncocoapods偶现问题 pod install安装依赖，主要是对build settings中的新增依赖配置等， 当cocopad 集成失败时，可以通过以下几步排查 ，也可以尝试清除项目中pod相关的信息，重新pod install，了解以下步骤都是很重要的。\n添加宏Preprocessor Macros 1 2 Debug：$(inherited) COCOAPODS=1 Release：$(inherited) COCOAPODS=1 设置Other C Flags 1 2 Debug：$(inherited) -iquote \u0026#34;${PODS_CONFIGURATION_BUILD_DIR}/Small/Small.framework/Headers\u0026#34; -iquote \u0026#34;${PODS_CONFIGURATION_BUILD_DIR}/ZipArchive/ZipArchive.framework/Headers\u0026#34; Release：$(inherited) -iquote \u0026#34;${PODS_CONFIGURATION_BUILD_DIR}/Small/Small.framework/Headers\u0026#34; -iquote \u0026#34;${PODS_CONFIGURATION_BUILD_DIR}/ZipArchive/ZipArchive.framework/Headers\u0026#34; 设置Framework Search Paths 1 2 Debug：$(inherited) \u0026#34;${PODS_CONFIGURATION_BUILD_DIR}/Small\u0026#34; \u0026#34;${PODS_CONFIGURATION_BUILD_DIR}/ZipArchive\u0026#34; Release：$(inherited) \u0026#34;${PODS_CONFIGURATION_BUILD_DIR}/Small\u0026#34; \u0026#34;${PODS_CONFIGURATION_BUILD_DIR}/ZipArchive\u0026#34; Add User-Defined setting,新加三个参数 PODS_CONFIGURATION_BUILD_DIR Debug: ${PODS_BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME) Release: ${PODS_BUILD_DIR}/$(CONFIGURATION)$(EFFECTIVE_PLATFORM_NAME) PODS_PODFILE_DIR_PATH: ${SRCROOT}/../.. PODS_ROOT : ${SRCROOT}/../../Pods 使用脚本自动设置 Small-subprojects.rb编辑项目配置文件，动态设置插件库的Framework search path. 在项目中run shellScript添加ruby Small-subprojects.rb命令:\n当old_fsp为空时，会执行失败。 使用./Small-subprojects.rb，有时出现权限问题，替换为ruby Small-subprojects.rb。 编码问题：在头部添加# encoding: utf-8：如invalid byte sequence in US-ASCII (ArgumentError) 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 #!/usr/local/bin ruby # encoding: utf-8 require \u0026#39;xcodeproj\u0026#39; require \u0026#39;xcodeproj/project/object/target_dependency\u0026#39; project_path = \u0026#34;#{Dir.pwd}/#{Dir[\u0026#39;*.xcodeproj\u0026#39;][0]}\u0026#34; puts \u0026#34;项目位置：#{project_path}\u0026#34; project = Xcodeproj::Project.open(project_path) project.native_targets.each do |target| puts \u0026#34;项目target：#{target}\u0026#34; target.dependencies.each do |dep| puts \u0026#34;项目dep：#{dep}\u0026#34; if (dep.name != nil) changed = false sub_project = dep.target_proxy.proxied_object.project puts \u0026#34;sub_project：#{sub_project}\u0026#34; sub_project.native_targets.each do |sub_target| sub_target.build_configurations.each do |config| old_fsp = \u0026#34;ddd\u0026#34;#config.build_settings[\u0026#39;FRAMEWORK_SEARCH_PATHS\u0026#39;] puts \u0026#34;旧old_fsp：#{config.build_settings}\u0026#34; if (!(old_fsp.include? \u0026#34;$(CONFIGURATION_BUILD_DIR)/**\u0026#34;)) changed = true puts \u0026#34;更新-----\u0026#34; #config.build_settings[\u0026#39;FRAMEWORK_SEARCH_PATHS\u0026#39;] \u0026lt;\u0026lt; \u0026#34;$(CONFIGURATION_BUILD_DIR)/**\u0026#34; # puts \u0026#34;Small: Add framework search paths for \u0026#39;#{dep.name}\u0026#39;\u0026#34; end end end if (changed) sub_project.save end end end end 打印信息如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 Showing All Messages :-1: 项目位置：/Users/admin/hsg/hexo/XcodeTool/iSmallApp/iSmallApp.xcodeproj :-1: 项目target：iSmallApp :-1: 项目dep：IntelDecision :-1: sub_project：#\u0026lt;Xcodeproj::Project\u0026gt; path:`/Users/admin/hsg/hexo/XcodeTool/iSmallApp/bundles/IntelDecision/IntelDecision.xcodeproj` UUID:`84C839BA217F28A500541D4D` :-1: 旧old_fsp：{\u0026#34;CODE_SIGN_IDENTITY\u0026#34;=\u0026gt;\u0026#34;\u0026#34;, \u0026#34;CODE_SIGN_STYLE\u0026#34;=\u0026gt;\u0026#34;Automatic\u0026#34;, \u0026#34;DEFINES_MODULE\u0026#34;=\u0026gt;\u0026#34;YES\u0026#34;, \u0026#34;DEVELOPMENT_TEAM\u0026#34;=\u0026gt;\u0026#34;9CA5KUE8T7\u0026#34;, \u0026#34;DYLIB_COMPATIBILITY_VERSION\u0026#34;=\u0026gt;\u0026#34;1\u0026#34;, \u0026#34;DYLIB_CURRENT_VERSION\u0026#34;=\u0026gt;\u0026#34;1\u0026#34;, \u0026#34;DYLIB_INSTALL_NAME_BASE\u0026#34;=\u0026gt;\u0026#34;@rpath\u0026#34;, \u0026#34;INFOPLIST_FILE\u0026#34;=\u0026gt;\u0026#34;IntelDecision/Info.plist\u0026#34;, \u0026#34;INSTALL_PATH\u0026#34;=\u0026gt;\u0026#34;$(LOCAL_LIBRARY_DIR)/Frameworks\u0026#34;, \u0026#34;LD_RUNPATH_SEARCH_PATHS\u0026#34;=\u0026gt;[\u0026#34;$(inherited)\u0026#34;, \u0026#34;@executable_path/Frameworks\u0026#34;, \u0026#34;@loader_path/Frameworks\u0026#34;], \u0026#34;PRODUCT_BUNDLE_IDENTIFIER\u0026#34;=\u0026gt;\u0026#34;com.clcw.IntelDecision\u0026#34;, \u0026#34;PRODUCT_NAME\u0026#34;=\u0026gt;\u0026#34;$(TARGET_NAME:c99extidentifier)\u0026#34;, \u0026#34;SKIP_INSTALL\u0026#34;=\u0026gt;\u0026#34;YES\u0026#34;, \u0026#34;SWIFT_VERSION\u0026#34;=\u0026gt;\u0026#34;4.2\u0026#34;, \u0026#34;TARGETED_DEVICE_FAMILY\u0026#34;=\u0026gt;\u0026#34;1,2\u0026#34;} :-1: 更新----- :-1: 旧old_fsp：{\u0026#34;CODE_SIGN_IDENTITY\u0026#34;=\u0026gt;\u0026#34;\u0026#34;, \u0026#34;CODE_SIGN_STYLE\u0026#34;=\u0026gt;\u0026#34;Automatic\u0026#34;, \u0026#34;DEFINES_MODULE\u0026#34;=\u0026gt;\u0026#34;YES\u0026#34;, \u0026#34;DEVELOPMENT_TEAM\u0026#34;=\u0026gt;\u0026#34;9CA5KUE8T7\u0026#34;, \u0026#34;DYLIB_COMPATIBILITY_VERSION\u0026#34;=\u0026gt;\u0026#34;1\u0026#34;, \u0026#34;DYLIB_CURRENT_VERSION\u0026#34;=\u0026gt;\u0026#34;1\u0026#34;, \u0026#34;DYLIB_INSTALL_NAME_BASE\u0026#34;=\u0026gt;\u0026#34;@rpath\u0026#34;, \u0026#34;INFOPLIST_FILE\u0026#34;=\u0026gt;\u0026#34;IntelDecision/Info.plist\u0026#34;, \u0026#34;INSTALL_PATH\u0026#34;=\u0026gt;\u0026#34;$(LOCAL_LIBRARY_DIR)/Frameworks\u0026#34;, \u0026#34;LD_RUNPATH_SEARCH_PATHS\u0026#34;=\u0026gt;[\u0026#34;$(inherited)\u0026#34;, \u0026#34;@executable_path/Frameworks\u0026#34;, \u0026#34;@loader_path/Frameworks\u0026#34;], \u0026#34;PRODUCT_BUNDLE_IDENTIFIER\u0026#34;=\u0026gt;\u0026#34;com.clcw.IntelDecision\u0026#34;, \u0026#34;PRODUCT_NAME\u0026#34;=\u0026gt;\u0026#34;$(TARGET_NAME:c99extidentifier)\u0026#34;, \u0026#34;SKIP_INSTALL\u0026#34;=\u0026gt;\u0026#34;YES\u0026#34;, \u0026#34;SWIFT_VERSION\u0026#34;=\u0026gt;\u0026#34;4.2\u0026#34;, \u0026#34;TARGETED_DEVICE_FAMILY\u0026#34;=\u0026gt;\u0026#34;1,2\u0026#34;} :-1: 更新----- :-1: 项目target：iSmallAppTests :-1: 项目dep：TargetDependency :-1: 项目target：iSmallAppUITests :-1: 项目dep：TargetDependency ","date":"2018-10-23T20:29:21Z","permalink":"https://it-boyer.github.io/post/old/macOS/cocoapods%E5%A6%82%E4%BD%95%E8%87%AA%E5%8A%A8%E5%8C%96%E7%AE%A1%E7%90%86%E9%A1%B9%E7%9B%AE%E4%BE%9D%E8%B5%96/","section":"post","tags":[],"title":"cocoapods如何自动化管理项目依赖"},{"categories":["学习笔记"],"contents":"在Perfect项目中增加playground：\n新建Perfect.xcodeproj和PerfectPlayground 新建一个Xcode工程Perfect 1 swift package generate-xcodeproj 设置include路径 在Xcode工程的build settings中设置SWIFT_INCLUDE_PATH 路径为 ${PROJECT_DIR}并设置recursive（递归）选项。 在同一工程目录下创建一个PerfectPlayground。 新建Perfect.workspace 新建一个工作空间：Perfect.workspace,在工作空间中添加工程和操场：Perfect.xcodeproj和PerfectPlayground。 编译Perfect.xcodeproj，这样就激活了PerfectPlayground的PerfectLib函数库功能。 1 2 3 4 5 6 7 8 9 10 import PerfectLib let json = \u0026#34;{\\\u0026#34;name\\\u0026#34;: \\\u0026#34;tom\\\u0026#34;}\u0026#34; do { let name = try json.jsonDecode() print(name) }catch{ } let u = UUID() print(u.string) 原文Perfect-Playground\n","date":"2018-10-22T16:52:33Z","permalink":"https://it-boyer.github.io/post/old/swift/%E5%B0%86Playground%E4%BD%9C%E4%B8%BA%E9%A1%B9%E7%9B%AE%E7%9A%84%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","section":"post","tags":["swift"],"title":"将Playground作为项目的单元测试"},{"categories":["项目总结"],"contents":"新组件开发/发布的流程 原理：在build程序包之前，会根据平台提供的程序包的组件依赖信息，来other linker flags进行删减更新，仅保留依赖包的配置，这样以来，就可以针对打包平台提供的APP依赖，来生成相应的产品APP。 添加新组件的步骤\n在平台注册组件名称 在主工程配置other linker flags（支持静态库/Framework） 把组件包集成到主工程中，取消在项目的勾选 创建库组件 创建一个xcode工程项目，在工程中新建组件target 代码编写完成后，编译生成新库包\n集成库 将.a/.Framework库包拖入主项目，设置依赖类型：必需/可选 必需：默认类型，直接拖入主项目，Xcode默认会勾选中 可选： 拖入主项目中，取消默认的勾选即可 配置other linker flags 当是.a静态库时，新增-force_load和静态库路径相邻的两行 当framework时，新增 -framework和Framework名称相邻的两行 （测试有问题，预测需要填写framework项目路径） 加载库 API类的方式加载 需要运行时，反射的方式加载 资源包的方式加载 .a 静态库可以借助storyboard/xib来实现组件的装载。 .Framework可以直接作为bundle资源库装载，需要把库包拖入Copy bundle Resources 1 2 3 4 NSString *bundlePath = [[NSBundle mainBundle] pathForResource:@\u0026#34;jinher_app_IntelDecision\u0026#34; ofType:@\u0026#34;framework\u0026#34;]; NSBundle *resourceBundle = [NSBundle bundleWithPath:bundlePath]; UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@\u0026#34;IntelDecision\u0026#34; bundle:resourceBundle]; UIViewController *ygPatrolNav = [storyboard instantiateViewControllerWithIdentifier:@\u0026#34;RoomListViewController\u0026#34;]; 资源bundle包，主要配合.a静态库使用 选择macOS平台—\u0026gt;Framework\u0026amp;Library—\u0026gt;Bundle,创建之后，设置为iOS平台的支持：\n在build settings 配置:base SDK:lastest ios 建议删除plist: 删除资源库的plist文件，否则审核不通过 把资源包库包拖入Copy bundle Resources 加载资源包的方式案例： 1 2 NSBundle *bundle = [NSBundle bundleWithURL: [[NSBundle mainBundle] URLForResource:@\u0026#34;JHAudioPlayResources\u0026#34; withExtension:@\u0026#34;bundle\u0026#34;]]; NSArray *apparray= [bundle loadNibNamed:@\u0026#34;mycell\u0026#34; owner:nil options:nil]; 将组件注册到打包平台 组件配置文件ComponentInfomation.plst:在iMac编译服务器上的核心文件 结构\nComponent Infomation:组件清单字典，其中元素即为一个组件 库配置：\nios_payment: 组件名称，在打包平台创建功能组件时，保持一致。 libName :静态库名(可选) Resource: 静态库依赖的bundle资源库（可选） Framework: 配置framework（可选）最动态库的支持 Component Dependence 暂时没有用到 Filter List 所有组件名的列表清单，(组件索引，便于后台过滤组件)，就是在Component Infomation新增的组件名称，需要在这里同步配置。 平台打包证书配置 ","date":"2018-10-22T16:52:33Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%96%B0%E7%BB%84%E4%BB%B6%E5%BC%80%E5%8F%91%E6%B5%81%E7%A8%8B%E5%8F%8A%E6%89%93%E5%8C%85%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE/","section":"post","tags":[],"title":"新组件开发流程及打包证书配置"},{"categories":["学习笔记"],"contents":"(Swift) iOS Apps with REST APIs(一)https://www.jianshu.com/p/01ca73387481 ","date":"2018-10-22T08:30:26Z","permalink":"https://it-boyer.github.io/post/old/macOS/Swift%E8%AE%BF%E9%97%AEREST%E6%9C%8D%E5%8A%A1%E5%BC%80%E5%8F%91TrelloAPI/","section":"post","tags":["macOS","swift"],"title":"Swift访问REST服务开发TrelloAPI"},{"categories":["解决方案"],"contents":"screen 支持会话恢复 当我们开启screen后，只要screen进程没有终止，其内部运行的会话都可以恢复。网络连接中断临时，用户也可以进入开启的screen中，对中断的会话的进行控制(恢复或删除)。 通常的用法是在暂时离开的时候，让在screen中运行的会话保持正常运行并将Screen切换到后台。 支持多窗口 当使用screen时，可以开启多个窗口，让每个会话都独立运行到不同的窗口，并拥有各自的编号、名称等。用户可以通过这些编号及名称进入不同的窗口。 会话共享 Screen可以让一个或多个用户从不同终端登录一个会话，并共享会话。使用户登陆同一会话的用户看到同一会话内容。 同时它可以提供窗口访问权限的设置，对窗口进行密码保护。 screen参数 1 2 3 4 5 6 7 8 9 10 11 12 -A 将所有的视窗都调整为目前终端机的大小 -d 将指定的screen作业离线 -h 指定视窗的缓冲区行数 -m 即使目前已在作业中的screen作业，仍强制建立新的screen作业 -r 恢复离线的screen作业 -R 先试图恢复离线的作业。若找不到离线的作业，即建立新的screen作业 -s 指定建立新视窗时，所要执行的shell -S 指定screen作业的名称 -v 显示版本信息 -x 恢复之前离线的screen作业 -ls或-list 显示目前所有的screen作业 -wipe 检查目前所有的screen作业，并删除已经无法使用的screen作业 screen命令 自定义shell脚本启动一个进程 1 2 3 4 5 6 screen_name=\u0026#34;ngrok\u0026#34; # 创建了一个名为 my_screen 的窗 screen -dmS $screen_name cmd=\u0026#34;ngrok tcp 22\u0026#34;; screen -x -S $screen_name -p 0 -X stuff \u0026#34;$cmd\u0026#34; screen -x -S $screen_name -p 0 -X stuff \u0026#39;\\n\u0026#39; 退出进程 1 screen -S session_name -X quit 其他\n1 2 3 4 5 6 7 8 9 10 11 C-a ? 显示所有键绑定信息 C-a w 显示所有窗口列表 C-a C-a 切换到之前显示的窗口 C-a c 创建一个新的运行shell的窗口并切换到该窗口 C-a n 切换到下一个窗口 C-a p 切换到前一个窗口(与C-a n相对) C-a 0..9 切换到窗口0..9 C-a a 发送 C-a到当前窗口 C-a d 暂时断开screen会话 C-a k 杀掉当前窗口 C-a [ 进入拷贝/回滚模式 退出screen 退出screen的作业时，有两种方式：\n1 2 3 Crtl + a +d 保存进程并退出作业(程序在screen中继续运行，screen -ls 可查看) Crtl + alt + a + d 进入后台运行进程 exit 退出作业和进程(程序终止，screen -ls 不可查看) 什么是Mosh Mosh表示移动Shell(Mobile Shell)，是一个用于从客户端跨互联网连接远程服务器的命令行工具。它能用于SSH连接，但是比Secure Shell功能更多。它是一个类似于SSH而带有更多功能的应用。程序最初由Keith Winstein 编写，用于类Unix的操作系统中，发布于GNU GPL V3协议下。 Mosh最大的特点是基于UDP方式传输，支持在服务端创建一个临时的Key供客户端一次性连接，退出后失效；也支持通过SSH的配置进行认证，但数据传输本身还是自身的UDP方式。\n会话的中断不会导致当前正在前端执行的命令中断，相当于你所有的操作都是在screen命令中一样在后台执行。 会话在中断过后，不会立刻退出，而是启用一个计时器，当网络恢复后会自动重新连接，同时会延续之前的会话，不会重新开启一个。 ","date":"2018-10-21T22:42:59Z","permalink":"https://it-boyer.github.io/post/old/shell/%E4%BD%BF%E7%94%A8screen%E5%9C%A8%E5%90%8E%E5%8F%B0%E8%BF%90%E8%A1%8C%E8%BF%9B%E7%A8%8B/","section":"post","tags":["shell"],"title":"使用screen在后台运行进程"},{"categories":["解决方案"],"contents":" {% github it-boyer chisel 56d0e0d width = 30% %}\n管理.lldbinit .lldbinit每次启动Xcode 都会加载lldb环境，故当自定义命令写好之后，可以通过这里加载。\n1 script fblldb.loadCommandsInDirectory(\u0026#39;/magical/commands/\u0026#39;) 现在将lldbinit原文件放在自己便于管理的地方，便于导入python命令\n1 2 3 4 5 6 7 8 9 10 11 12 #!/bin/sh # installChisel.sh # HexoDeploy # # Created by admin on 2018/10/21. # Copyright © 2018年 boyer. All rights reserved. basepath=$(cd `dirname $0`; pwd) echo \u0026#34;当前cd的目录名：\u0026#34;`basename $(pwd)` echo \u0026#34;sh脚本文件的绝对路径：$basepath\u0026#34; ln -fs $basepath/lldbinit ~/.lldbinit echo \u0026#34;done\u0026#34; 创建加载自定义命令 无论是本地使用还是提交到Chisel贡献，工作流程都是一样的。\n在便于管理的目录下，新建python文件 vi example.py，在chisel会通过该目录路径来加载新命令： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 #!/usr/bin/python # Example file with custom commands, located at /magical/commands/example.py import lldb import fblldbbase as fb def lldbcommands(): return [ PrintKeyWindowLevel() ] class PrintKeyWindowLevel(fb.FBCommand): def name(self): return \u0026#39;pkeywinlevel\u0026#39; def description(self): return \u0026#39;An incredibly contrived command that prints the window level of the key window.\u0026#39; def run(self, arguments, options): # It\u0026#39;s a good habit to explicitly cast the type of all return # values and arguments. LLDB can\u0026#39;t always find them on its own. lldb.debugger.HandleCommand(\u0026#39;p (CGFloat)[(id)[(id)[UIApplication sharedApplication] keyWindow] windowLevel]\u0026#39;) 加载新建的命令 可以使用Chisel提供的函数loadCommandsInDirectory加载，在fblldb.py中声明的方法。 在~/.lldbinit新增如下： 1 2 3 4 # ~/.lldbinit ... command script import /path/to/fblldb.py script fblldb.loadCommandsInDirectory(\u0026#39;/magical/commands/\u0026#39;) 更方便的方式：命令文件直接放在chisel源码中的mcommands目录中，这样会自动加载，就不用在lldbinit中配置了。 因为内置的支持，新命令也可以轻松使用arguments参数和options选项的相关功能。请参阅border和pinvocation命令的用法。\n开发调试命令的流程 无论是本地使用还是提交到Chisel贡献，都是相同的工作流。\n启动LLDB 拦截断点(或者通过Xcode的调试栏中的pause按钮暂停执行，或者直接process interrupt进程中断) 执行命令source ~/.lldbinit，在LLDB中提供命令源 运行您正在执行的命令 修改命令 重新加载脚本script reload(modulename) 重复3-6步骤，直到自定义命令达到预期效果。 ","date":"2018-10-21T09:03:35Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/%E5%9F%BA%E4%BA%8EChisel%E8%87%AA%E5%AE%9A%E4%B9%89python%E8%B0%83%E8%AF%95%E5%91%BD%E4%BB%A4/","section":"post","tags":["iOS","调试"],"title":"基于Chisel自定义python调试命令"},{"categories":["学习笔记"],"contents":" {% github it-boyer evernote-sdk-mac fd5da70 width = 30% %}\n制作pod支持 fork 并clone代码 1 git clone https://github.com/evernote/evernote-sdk-mac.git 创建pod spec索引文件 1 2 $ cd evernote-sdk-mac $ pod spec create EvernoteSDK https://github.com/it-boyer/evernote-sdk-mac.git 编写配置文件 设置支持的平台，源码目录位置，指定忽略的文件等配置。 1 2 3 4 5 6 7 8 9 10 11 12 .... spec.osx.deployment_target = \u0026#34;10.7\u0026#34; ... # ――― Source Code ―――――――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # spec.source_files = \u0026#34;EvernoteSDK\u0026#34;, \u0026#34;EvernoteSDK/**/*.{h,m}\u0026#34; spec.exclude_files = \u0026#34;EvernoteSDK/internal/ENOAuthViewController*\u0026#34; # ――― Project Settings ――――――――――――――――――――――――――――――――――――――――――――――――――――――――― # #spec.requires_arc = true #spec.xcconfig = {\u0026#34;WARNING_CFLAGS\u0026#34; =\u0026gt; \u0026#39;-Wno-nullability-completeness\u0026#39;} # spec.xcconfig = { \u0026#34;HEADER_SEARCH_PATHS\u0026#34; =\u0026gt; \u0026#34;$(SDKROOT)/usr/include/libxml2\u0026#34; } end 验证EvernoteSDK.podspec 需要用参数：\u0026ndash;allow-warnings ，由于源码验证过程中的警告提示问题，导致验证失败 1 $ pod lib lint --allow-warnings 发布到私库中 先在本地添加私库 1 2 3 $ pod repo add PodRepo https://github.com/it-boyer/PodRepo.git #输出： \u0026gt; Cloning spec repo `PodRepo` from `https://github.com/it-boyer/PodRepo.git` 开始发布过程中，也会验证，出现警告问题，需要添加--allow-warnings\n1 $ pod repo push podRepo EvernoteSDK.podspec --allow-warnings 在项目中使用 编辑podfile文件 1 2 3 4 #加载私库 source \u0026#39;https://github.com/it-boyer/PodRepo.git\u0026#39; #依赖库 pod \u0026#39;EvernoteSDK\u0026#39;, \u0026#39;~\u0026gt; 1.2.0\u0026#39; 在执行pod install 即可。\nAPI调用 在objc中调用 直接引入#import \u0026lt;EvernoteSDK/EvernoteSDK.h\u0026gt;\n1 2 3 4 5 6 7 8 9 10 #import \u0026lt;EvernoteSDK/EvernoteSDK.h\u0026gt; @implementation hello -(void)test { NSString *EVERNOTE_HOST = BootstrapServerBaseURLStringSandbox; NSString *CONSUMER_KEY = @\u0026#34;your key\u0026#34;; NSString *CONSUMER_SECRET = @\u0026#34;your secret\u0026#34;; [EvernoteSession setSharedSessionHost:EVERNOTE_HOST consumerKey:CONSUMER_KEY consumerSecret:CONSUMER_SECRET]; } @end 在swift中调用 创建工程名-Bridging-Header.h 引入框架库 1 #import \u0026lt;EvernoteSDK/EvernoteSDK.h\u0026gt; 在main.swift 调用 1 2 3 4 5 import Foundation let EVERNOTE_HOST = BootstrapServerBaseURLStringSandbox let CONSUMER_KEY = \u0026#34;\u0026#34; let CONSUMER_SECRET = \u0026#34;\u0026#34; EvernoteSession.setSharedSessionHost(EVERNOTE_HOST, consumerKey: CONSUMER_KEY, consumerSecret: CONSUMER_SECRET) ","date":"2018-10-21T00:12:20Z","permalink":"https://it-boyer.github.io/post/old/macOS/fork%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0SDK%E6%94%AF%E6%8C%81pod%E5%AE%89%E8%A3%85/","section":"post","tags":["pod"],"title":"fork印象笔记SDK支持pod安装"},{"categories":["博客站务"],"contents":" {% github it-boyer blogDocs 978ed39 width = 30% %}\n忽略配置 文档库主要整理kindle读书笔记，jazzy文档相关html页面，放在hexo中不需要经过md转换html过程。故需要通过hexo的skip_render配置机制，来屏蔽一些目录/文件等。\n1 skip_render: [\u0026#34;*.html\u0026#34;,\u0026#34;docs/*/*\u0026#34;] 这样，在hexo g过程，跳过这些文件，目录的编辑过程，直接拷贝到public中发布。 skip_render参考\ndocs配置 位置考虑 docs放在在source目录下，目录结构： 1 2 3 4 5 6 7 ├── souce ├── _post //博客 ├── tags //标签 ├── categories //分类 ├── docs //文档库 ├── index.md └── kindle笔记 其他配置可以按照tag,categories相关配置，显示在网页中。 2. 版本控制 考虑docs文档库的容量递增，选择git submodule来管理docs文档库，集成到hexo主库中。\n","date":"2018-10-20T13:54:16Z","permalink":"https://it-boyer.github.io/post/old/hexo/config%E9%85%8D%E7%BD%AE%E4%B8%AA%E4%BA%BA%E6%96%87%E6%A1%A3%E5%BA%93%E4%B8%93%E6%A0%8F/","section":"post","tags":["hexo"],"title":"config配置个人文档库专栏"},{"categories":["解决方案"],"contents":" {% github postmodern ruby-install ea2b8bb width = 30% %}\n安装工具ruby-install 1 $ brew install ruby-install 安装指定 Ruby 版本 方式一：使用Homebrew安装\n1 2 $ ruby-install ruby 2.4.1 $ ruby-install --system ruby #覆盖系统版本 但Mac最新系统安装Xcode时已经没有Command Line工具，需要单独安装。安装命令行：xcode-select --install\n安装chruby管理工具 1 $ brew install chruby 管理ruby版本 预览安装的版本 1 2 3 4 $ chruby ruby-1.9.3-p392 jruby-1.7.0 rubinius-2.0.0-rc1 切换为使用版本 1 2 3 4 5 $ chruby 1.9.3 #切换操作 $ chruby * ruby-1.9.3-p392 #当前使用的版本 jruby-1.7.0 rubinius-2.0.0-rc1 智能切换支持 让chruby在cd不同项目目录时，自动切换Ruby的当前版本，load auto.sh in ~/.bashrc or ~/.zshrc: 1 2 source /usr/local/share/chruby/chruby.sh source /usr/local/share/chruby/auto.sh OSX does not automatically execute ~/.bashrc, instead try adding to /etc/bashrc.\n设置默认的ruby 通过设置启动项来设置默认的ruby版本，在 ~/.bash_profile or ~/.zprofile设置: 1 chruby ruby-1.9 如果终端已经设置自启动项切换 chruby.sh and/or auto.sh , 只需要在~/目录新建.ruby-version:\n1 echo \u0026#34;ruby-1.9\u0026#34; \u0026gt; ~/.ruby-version ","date":"2018-10-19T15:58:23Z","permalink":"https://it-boyer.github.io/post/old/shell/%E5%AE%89%E8%A3%85ruby%E5%8F%8Achruby%E7%89%88%E6%9C%AC%E7%AE%A1%E7%90%86/","section":"post","tags":["shell"],"title":"安装ruby及chruby版本管理"},{"categories":["博客站务"],"contents":"起始 知识是自己构建出来的，不是别人灌输的，也不是看了各种资料背住就完了。所谓构建，是指接受信息输入之后，通过信息整理加工，消化转变为自己理解的内容，并分类记录在脑部对应类别的不同层次区域。\n就像一个帝国的建立和发展过程，不断的累积资本，转化为力量。通过知识加工这个二次学习的过程，能让我们更加牢固的记住关键知识和产生更加深入的理解。\n一直希望寻找一种相对优雅、我比较喜欢的方式来做知识管理，帮助知识积累构建；经过尝试了手写笔记本、OneNote 、 Evernote 、为知笔记等之后，最终选择用 个人 Wiki 系统 来做自己的知识管理。然而天下 Wiki 千千万，选择困难症患者到底该选哪一种呢？\n我试了时下好几个流行的、推荐者比较多的 Wiki 系统，但是多少都有些小细节让我不是很满意。在我的 Wiki 首页 可以看到我对知识管理和这几个 Wiki 系统的一些简单的看法，以及为此自己开坑了个 Wiki 的轮子。\n轮子 先放上上我经过了这些使用之后，整理出自己对 个人 Wiki 系统的需求：\n界面简洁，排版整齐，有些留白，不要太满 （要求很宽泛） 部署简单，不需要后台与数据库 （最好静态页面） 支持多级分类 （满足知识的分类性） 分类目录可展开和收缩 展开分类时可直接看到该分类下所有条目 支持全文搜索 使用 Markdown 书写 适合单人的修改与更新内容 最好支持查看历史版本 嗯，所以以上这些也是我自己 Wiki 系统的特性了吧~~ 借用 Hexo 博客系统的框架，仿照 Wikitten 的样式，写了一个针对于个人 Wiki 的主题 hexo-theme-Wikitten。 先放上两个链接： 我的个人 Wiki 地址：https://wiki.zthxxx.me/ Wikitten 主题地址：https://github.com/zthxxx/hexo-theme-Wikitten 再放一个预览的截图： 嘛，样式是跟 victorstanciu 的 Wikitten 一样的（人家有 MIT LICENSE 的，并且我提到时也都有注明出处），之所以选择 Wikitten ，是因为我觉得这个 Wiki 系统最接近我自己对个人 Wiki 的需求，并且样式也很简洁。不过相比起来，代码就完全不一样了；人家是 PHP ，我这是 Hexo 的主题，不需要后台，可以直接挂在 Github Pages 上，省去了服务器；原本只支持搜索标题的，我也给改到支持全文搜索了。 转\n","date":"2018-10-18T20:51:48Z","permalink":"https://it-boyer.github.io/post/old/hexo/%E7%94%A8Hexo%E5%81%9A%E4%B8%AA%E4%BA%BAWiki%E7%9F%A5%E8%AF%86%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F/","section":"post","tags":["hexo"],"title":"用Hexo做个人Wiki知识管理系统"},{"categories":["博客站务"],"contents":" {% github everblogjs everblog-adaptor-hexo 3c081de width = 30% %} {% github everblogjs everblog b1832a6 width = 30% %} Everblog ——使用 Evernote 写博客 印象笔记+hexo搭建自己的个人博客 申请印象笔记token 邮件申请：\n1 2 3 欢迎使用印象笔记开发者Token功能，麻烦你回复这封邮件，在收到你的确认邮件后，我们会为你开启开发者Token权限，谢谢。 注：回复邮件的邮箱需要和帐户的注册邮箱地址保持一致，如果当前地址不是帐户注册邮箱，建议使用帐户注册邮箱直接发送邮件到 online-help@yinxiang.com ，并说明需要开启Token即可。 使用 Hexo 主题 图文步骤如下： 在印象笔记操作 创建 _config.yml 创建一些笔记\n在hexo中执行 运行 DEBUG=* everblog start 构建并打开构建成功后的主页\n使用 Hexo 主题完整步骤如下：\n1 2 3 4 5 6 7 8 9 $ npm i hexo-cli -g # 全局安装 hexo-cli $ hexo init myblog # 初始化一个 hexo 项目 $ cd myblog \u0026amp;\u0026amp; npm i # 安装依赖 $ npm i everblog -g # 全局安装 everblog $ npm i everblog-adaptor-hexo --save # 在当前 hexo 项目下安装 adaptor $ echo \u0026#34;module.exports = require(\u0026#39;everblog-adaptor-hexo\u0026#39;)\u0026#34; \u0026gt; index.js # 在当前 hexo 项目下创建 index.js ，引入 adaptor $ DEBUG=* everblog build # 使用 everblog 构建 hexo 所需文件 $ hexo server # 启动 hexo $ open http://localhost:4000/ # 浏览器打开博客主页 需要安装node8+ 详见issue-371806541\n","date":"2018-10-18T20:25:49Z","permalink":"https://it-boyer.github.io/post/old/hexo/%E5%90%8C%E6%AD%A5%E5%8D%B0%E8%B1%A1%E7%AC%94%E8%AE%B0%E5%88%B0hexo%E5%8D%9A%E5%AE%A2/","section":"post","tags":["hexo"],"title":"同步印象笔记到hexo博客"},{"categories":["项目总结"],"contents":"在我的中新增智慧决策菜单 先搜集菜单信息 name:菜单名称，必填，显示在我的页面的cell上。 componentId: 业务ID，必填项，通过该字段控制前端权限/业务 group.order: 设置菜单组在我的页面显示的位置 item.order: 设置菜单在自己组中的显示位置 icon:菜单图标的名称，前端需要在我的插件项目的资源包中添加同名的图片 show:设置菜单是否为默认被打包 重要项 contentType: 设置平台配置菜单的样式：如：单选/输入框 等 WebItemUrl: 仅当输入框样式时，前端解析该字段，访问网页。（兼容android问题，输入框必须时绝对路径，即：http开头） method: 待补充 event: 待补充 localURL: 待补充 部分样例如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 \u0026lt;group order=\u0026#34;5\u0026#34; show=\u0026#34;1\u0026#34; orientation=\u0026#34;0\u0026#34; contentType=\u0026#34;SafetyCaterOperate\u0026#34;\u0026gt; \u0026lt;item\u0026gt; \u0026lt;id\u0026gt;\u0026lt;/id\u0026gt; \u0026lt;componentId\u0026gt;SafetyCaterOperate\u0026lt;/componentId\u0026gt; \u0026lt;name\u0026gt;阳光餐饮运营\u0026lt;/name\u0026gt; \u0026lt;order\u0026gt;1\u0026lt;/order\u0026gt; \u0026lt;icon\u0026gt;icon_safetycateroperate\u0026lt;/icon\u0026gt; \u0026lt;event\u0026gt;JhItemId:\u0026lt;/event\u0026gt; \u0026lt;method\u0026gt;safetyCaterOperate\u0026lt;/method\u0026gt; \u0026lt;isArgs\u0026gt;flase\u0026lt;/isArgs\u0026gt; \u0026lt;isRed\u0026gt;false\u0026lt;/isRed\u0026gt; \u0026lt;show\u0026gt;0\u0026lt;/show\u0026gt; \u0026lt;/item\u0026gt; \u0026lt;/group\u0026gt; 信息搜集之后，交付平台人员部署到平台上。 特别注意contentType 输入框类型：\n手机端解析我的菜单 我的插件控制器JHPersonalViewController解析布局配置文件：personalNewPage.plist，根据菜单配置显示样式。\n业务权限解析 我的控制器初始化UI加载过程中，会先解析业务id，来控制菜单是否显示：\n1 2 3 4 5 6 7 8 9 10 11 12 13 #pragma mark 加载数据 -(void)loadData{ ... NSString * inforPath = [[NSBundle mainBundle] pathForResource:@\u0026#34;personalNewPage\u0026#34; ofType:@\u0026#34;plist\u0026#34;]; .... 通过解析 if ([detailRow.componentId isEqualToString:@\u0026#34;IntelligentDecision\u0026#34;]) ){ //如果是食品管理政府，且用户已登录，且允许添加，且是组织内用户，则添加 if ([[LoginAndRegister sharedLoginAndRegister] isUserOfficialLogin] \u0026amp;\u0026amp; [[LoginAndRegister sharedLoginAndRegister] IsOrganizationUser]) { [rows addObject:detailRow]; } } } 菜单类型 当有相应业务权限后，菜单列会显示在我的页面中\n举例介绍自定义路径菜单类型\n现在程序中找到点击菜单的事件代码即类PKHorizontalCell.m： 1 2 3 4 5 6 7 8 9 10 11 12 13 - (UIView *)containsView{ ... //菜单icon设置 [btn setImage:[PersonalHelper imageWithSuffixName:detail.icon] title:detail.name forState:UIControlStateNormal]; //菜单点击事件 [btn addTarget:self action:@selector(eachBtnAction:) forControlEvents:UIControlEventTouchUpInside]; ... } - (void)eachBtnAction:(id)sender{ ... [self.delegate clickBtnWith:detail]; ... } 菜单业务实现 定位到点击事件的实现片段： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 - (void)dealClickWhenSelectedCellWith:(DetailRows *)detail{ ... //解析到自定义的菜单路径 NSString * webColumnUrlString = detail.WebItemUrl; ... if (webColumnUrlString \u0026amp;\u0026amp; ![webColumnUrlString isEqualToString:@\u0026#34;\u0026#34;]) { //仅当菜单类型为自定义链接时，即输入框样式，前端解析url访问网页。（兼容android问题，输入框必须时绝对路径，即：`http`开头） if ([webColumnUrlString hasPrefix:@\u0026#34;http\u0026#34;] \u0026amp;\u0026amp; ![detail.icon isEqualToString:@\u0026#34;personalWork\u0026#34;]) {//兼容办公业务是http开头的但走本地www包 [JHWebviewManager pushWebViewControllerWithURL:webColumnUrlString isShowReturnButtonAndCloseButton:YES title:@\u0026#34;\u0026#34;]; return; } } } iOS部署产品线 目前平台部署仅支持测试环境。在正式环境使用./release.command -t\n测试环境部署图文产品线 1 ./release.command -t 2 如果部署失败\n临时解决办法： 通过普通方式部署./release.command -t 协调测试人员，包配置中去除产品线插件 这样会影响android端发布，慎重。\n找平台发布解决。经协调，已修复，可通过产品线部署。 详细介绍 部署命令 功能：将当前目录下的工程部署到对应环境 命令：release.command 参数1： 1 2 3 -d dev环境 -t test环境 -z 正式环境 参数2： 该参数与app后台网站上的 [功能页] -\u0026gt; [应用产品线] 设置中指定的产品线名称一一对应, 目前产品线名称有 电商 / 图文 / OA办公 / 企业经营, 参数对应关系如下:\n1 2 3 4 1 电商 2 图文 3 OA办公 4 企业经营 当app未打应用产品线时, 禁止填写该参数.\n","date":"2018-10-17T21:01:49Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%9C%A8%E6%88%91%E7%9A%84%E6%8F%92%E4%BB%B6%E4%B8%AD%E9%85%8D%E7%BD%AE%E5%A4%9A%E7%A7%8D%E7%B1%BB%E5%9E%8B%E8%8F%9C%E5%8D%95%E7%9A%84%E6%AD%A5%E9%AA%A4/","section":"post","tags":[],"title":"在我的插件中配置多种类型菜单的步骤"},{"categories":["解决方案"],"contents":"Xcode集成了LLDB，进一步简化了程序调试流程。虽然LLDB很强大，但是它的命令很有限。所幸的是，lldb包含了对python的支持，使得lldb的拓展成为可能。本人在开发过程中很喜欢使用image lookup 命令，但是苦于每次只能执行一条，相当耗时，因此一直想要找到一种批量执行的方法\n问题 批量执行image lookup -a optparse和shlex是用于解析参数的两个重要的库。通过optparse来生成解析器\n编写python脚本(layne_command.py)，代码如下： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 #coding=utf-8 #自定义lldb命令 import lldb import commands import optparse import shlex #批量执行`image lookup`命令的函数，也是自定义的新的lldb命令的名称 def layne_imagelookup(debugger, command, result, internal_dict): target = debugger.GetSelectedTarget() process = target.GetProcess() thread = process.GetSelectedThread() command_args = shlex.split(command) parser = create_custom_parser() try: (options, args) = parser.parse_args(command_args) except: result.SetError (\u0026#34;option parsing failed\u0026#34;) return if args: for address in args: print(\u0026#34;*************************************\u0026#34;) debugger.HandleCommand(\u0026#39;image lookup -a %s\u0026#39;%(address)) def create_custom_parser(): usage = \u0026#34;usage: %prog [options]\u0026#34; description = \u0026#39;\u0026#39;\u0026#39;Parse Symbols to Human-readable Format.\u0026#39;\u0026#39;\u0026#39; #生成解析器 parser = optparse.OptionParser(description=description, prog=\u0026#39;print_frame\u0026#39;,usage=usage) # parser.add_option(\u0026#39;-p\u0026#39;,\u0026#39;--parse\u0026#39;,type=\u0026#39;string\u0026#39;,dest = \u0026#39;parse\u0026#39;,help=\u0026#39;parse symbols.\u0026#39;); return parser #运行脚本入口 def __lldb_init_module(debugger, internal_dict): debugger.HandleCommand(\u0026#39;command script add -f layne_command.layne_imagelookup layne_imagelookup\u0026#39;) print(\u0026#39;The \u0026#34;layne_imagelookup\u0026#34; python command has been installed and is ready for use.\u0026#39;) 然后保存为文件layne_command.py,放到如下目录(自己指定)：~/Python/lldb/layne_command.py 说明: ①#coding=utf-8指定python脚本编码，否则运行时注释中的中文将会报错。 ②运行脚本时入口为 __lldb_init_module(debugger,internal_dict) 。debugger.HandleCommand是python中执行lldb命令的主要方式。 ③layne_imagelookup是批量执行image lookup命令的函数，也是自定义的新的lldb命令的名称。 ④optparse和shlex是用于解析参数的两个重要的库。通过optparse来生成解析器。\n","date":"2018-10-17T19:47:15Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/xcode%E8%B0%83%E8%AF%95%E4%B8%AD%E5%BC%95%E7%94%A8python%E8%84%9A%E6%9C%AC/","section":"post","tags":["调试","lldb"],"title":"xcode调试中引用python脚本"},{"categories":["学习笔记"],"contents":"问题 #3707\n1 dyld: Library not loaded: @rpath/FilesProvider.framework/Versions/A/FilesProvider 结论：cocoa pods不支持Command Line Tool项目\nCocoapods + Command Line Tool - dyld: Library not loaded: @rpath/Realm.framework/Versions/A/Realm cocoa pods不支持Command Line Tool项目 Command Line Tool + CocoaPods frameworks breaks\n采用SPM来管理依赖库 使用SPM创建可执行模版 1 2 $ mkdir SPMCmdLineTool $ swift package init --type=executable 配置Package.swift 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 import PackageDescription let package = Package( name: \u0026#34;SPMCmdLineTool\u0026#34;, dependencies: [ // Dependencies declare other packages that this package depends on. // .package(url: /* package url */, from: \u0026#34;1.0.0\u0026#34;), .package(path: \u0026#34;/Users/admin/hsg/FileProvider\u0026#34;) ], .target( name: \u0026#34;SPMCmdLineTool\u0026#34;, dependencies: [\u0026#34;FilesProvider\u0026#34;]), .testTarget( name: \u0026#34;SPMCmdLineToolTests\u0026#34;, dependencies: [\u0026#34;SPMCmdLineTool\u0026#34;]), ] ) 使用workspace管理 先生成一个Xcode工程文件：SPMCmdLineTool.xcodeproj 1 $ swift package generate-xcodeproj 再把SPMCmdLineTool.xcodeproj拖入现有的workspace中来管理。\n每次执行swift build ，须重新生成xcodeproj工程文件，再重新打开workspace即可。\n命令行的单元测试赏析 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 final class SPMCmdLineToolTests: XCTestCase { func testExample() throws { // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct // results. // Some of the APIs that we use below are available in macOS 10.13 and above. guard #available(macOS 10.13, *) else { return } // 运行可执行文件 let fooBinary = productsDirectory.appendingPathComponent(\u0026#34;SPMCmdLineTool\u0026#34;) let process = Process() // 指定可执行文件 process.executableURL = fooBinary let pipe = Pipe() process.standardOutput = pipe //开始运行 try process.run() process.waitUntilExit() let data = pipe.fileHandleForReading.readDataToEndOfFile() let output = String(data: data, encoding: .utf8) XCTAssertEqual(output, \u0026#34;Hello, world!\\n\u0026#34;) } /// Returns path to the built products directory. var productsDirectory: URL { #if os(macOS) for bundle in Bundle.allBundles where bundle.bundlePath.hasSuffix(\u0026#34;.xctest\u0026#34;) { return bundle.bundleURL.deletingLastPathComponent() } fatalError(\u0026#34;couldn\u0026#39;t find the products directory\u0026#34;) #else return Bundle.main.bundleURL #endif } static var allTests = [ (\u0026#34;testExample\u0026#34;, testExample), ] } ","date":"2018-10-16T17:08:15Z","permalink":"https://it-boyer.github.io/post/old/macOS/CommandLineTool%E4%BD%BF%E7%94%A8pod%E4%BE%9D%E8%B5%96%E5%BA%93%E5%BC%80%E5%8F%91/","section":"post","tags":[],"title":"CommandLineTool使用pod依赖库开发"},{"categories":["解决方案"],"contents":" {% github amosavian FileProvider b597244 width = 30% %}\n安装FilesProvider 使用FilesProvider来做文件处理，通过SPM管理库依赖\n配置Package.swift 1 2 3 4 5 6 7 8 9 dependencies: [ // Dependencies declare other packages that this package depends on. // .package(url: /* package url */, from: \u0026#34;1.0.0\u0026#34;), 指定版本。giturl .package(path: \u0026#34;/Users/admin/hsg/FileProvider\u0026#34;) //源码clone本地，指定路径 ], .target( name: \u0026#34;SPMCmdLineTool\u0026#34;, dependencies: [\u0026#34;FilesProvider\u0026#34;]), ] swift build 单元测试 FilesProvider异步处理：需要XCTestExpectation辅助测试 FilesProvider在处理文件（拷贝/重命名/删除）时，不能使用绝对路径，应采用文件相对于documentsProvider.baseURL的相对路径。否则，在当给定的路径包含root目录时，例如/Users/nam/file.png会提示失败。 在swift调用shell时，目前只能使用Process.launchedProcess类方法执行shell脚本命令。 有可能在单元测试环境，导致其他两种调用shell的失败。 测通可运行的代码片段 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 import FilesProvider var documentsProvider:LocalFileProvider! var pngexpectation: XCTestExpectation! = nil override func setUp() { // Put setup code here. This method is called before the invocation of each test method in the class. documentsProvider = LocalFileProvider(for: .userDirectory, in: .allDomainsMask) pngexpectation = self.expectation(description: \u0026#34;BLDownloadImageNotification\u0026#34;) } func testExample() { // This is an example of a functional test case. // Use XCTAssert and related functions to verify your tests produce the correct results. //创建文件夹 documentsProvider.create(folder: \u0026#34;testPng\u0026#34;, at: \u0026#34;admin/hsg/\u0026#34;) { (err) in print(\u0026#34;新建目录成功\u0026#34;) //拷贝图片到目录 self.documentsProvider.contentsOfDirectory(path: \u0026#34;admin/Desktop\u0026#34;, completionHandler: { (contents, error) in for file in contents { let png = file.path.hasSuffix(\u0026#34;png\u0026#34;) if png{ print(\u0026#34;文件路径:\\(file.path)\u0026#34;) let thePath:NSString = file.path as NSString let toFile = \u0026#34;admin/hsg/testPng/\\(thePath.lastPathComponent)\u0026#34; self.documentsProvider.copyItem(path: file.path, to: toFile, overwrite: true, completionHandler: { (err) in //调用shell工具压缩图片 self.testProcessRunShellScript(filePath: toFile) print(\u0026#34;Name: \\(file.name)\u0026#34;) print(\u0026#34;Size: \\(file.size)\u0026#34;) print(\u0026#34;路径: \\(file.path)\u0026#34;) }) } } }) } waitForExpectations(timeout: 40, handler: nil) } //可用 func testProcessRunShellScript(filePath:String) { let sub = \u0026#34;_temp.png\u0026#34; let pngquantFile = \u0026#34;/Users/\u0026#34;+filePath let tmpFilePath = filePath.replacingOccurrences(of: \u0026#34;.png\u0026#34;, with: sub) let exePath = \u0026#34;/Users/admin/hsg/hexo/GitSubmodules/hsgTool/pngquant/pngquant\u0026#34; Process.launchedProcess(launchPath: exePath, arguments: [\u0026#34;--ext\u0026#34;,sub,\u0026#34;--speed=3\u0026#34;,pngquantFile]) // 删除旧文件 // documentsProvider.removeItem(path: filePath) { (error) in // //重命名压缩过的tmp文件 // print(\u0026#34;ddddddderr:\\(error?.localizedDescription)\u0026#34;) // self.documentsProvider.moveItem(path: tmpFilePath, to: filePath, overwrite: true, completionHandler: { (error) in // self.pngexpectation.fulfill() // }) // } } ","date":"2018-10-15T20:51:45Z","permalink":"https://it-boyer.github.io/post/old/macOS/swift%E8%B0%83%E7%94%A8pngquant%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9%E5%9B%BE%E7%89%87/","section":"post","tags":["macOS","工具"],"title":"swift调用pngquant批量压缩图片"},{"categories":["学习笔记"],"contents":" {% github it-boyer Panagram_Final 8023350 width = 30% %} Command Line Programs on macOS Tutorial swift编写命令行工具\n更新7/21/17:macOS教程上的命令行程序已经更新为Xcode 9和Swift 4。 前言 典型的Mac用户使用图形用户界面(GUI)与计算机交互。gui，顾名思义，是基于用户通过输入设备(如鼠标)与计算机进行视觉交互，通过选择或操作屏幕元素(如菜单、按钮等)。 不久前，在GUI出现之前，命令行接口(CLI)还是与计算机交互的主要方法。CLIs是基于文本的接口，用户可以在其中输入要执行的程序名，后面跟着参数。 尽管gui很流行，命令行程序仍然在当今的计算世界中扮演着重要的角色。命令行程序(如ImageMagick或ffmpeg)在服务器世界中非常重要。事实上，大多数形成Internet的服务器只运行命令行程序。 甚至Xcode也使用命令行程序!当Xcode构建项目时，它调用xcodebuild，它执行实际的构建。如果构建过程被嵌入到Xcode产品中，持续集成解决方案将很难实现，如果不是不可能的话!\n开始 对于创建命令行程序来说，Swift似乎是一个奇怪的选择，因为C、Perl、Ruby或Java等语言是更传统的选择。但是，有一些很好的理由可以根据您的命令行需求选择Swift:\nSwift既可以用作解释脚本语言，也可以用作编译语言。这给了您脚本语言的优势，例如零编译时间和易于维护，以及选择编译应用程序以提高执行时间或将其捆绑销售。 你不需要学习其他语言。许多人说程序员应该每年学一门新语言。这不是一个坏主意，但是如果你已经习惯了Swift和它的标准库，你可以通过坚持使用Swift来减少时间投资。 样例介绍 在macOS教程中的命令行程序中，您将编写一个名为Panagram的命令行实用程序。根据传入的选项，它将检测给定输入是回文还是字谜。它可以从预定义的参数开始，或者在交互模式下运行，提示用户输入所需的值。 通常，命令行程序是从嵌入在工具应用程序(比如macOS中的Terminal)中的shell中启动的。为了简单易学，在本教程中，大部分时间您将使用Xcode来启动Panagram。在本教程的最后，您将学习如何从终端启动Panagram。 Open Xcode and go to File/New/Project. Find the macOS group, select Application/Command Line Tool and click Next: For Product Name, enter Panagram. Make sure that Language is set to Swift, then click Next. In the Project Navigator area you will now see the main.swift file that was created by the Xcode Command Line Tool template. Many C-like languages have a main function that serves as the entry point — i.e. the code that the operating system will call when the program is executed. This means the program execution starts with the first line of this function. Swift doesn’t have a main function; instead, it has a main file. When you run your project, the first line inside the main file that isn’t a method or class declaration is the first one to be executed. It’s a good idea to keep your main.swift file as clean as possible and put all your classes and structs in their own files. This keeps things streamlined and helps you to understand the main execution path.\nThe Output Stream Command-Line Arguments Anagrams and Palindromes Handle Input Interactively Xcode中测试 Launching Outside Xcode Normally, a command-line program is launched from a shell utility like Terminal (vs. launching it from an IDE like Xcode). The following section walks you through launching your app in Terminal. There are different ways to launch your program via Terminal. You could find the compiled binary using the Finder and start it directly via Terminal. Or, you could be lazy and tell Xcode to do this for you. First, you\u0026rsquo;ll learn the lazy way.\nLaunch your app in Terminal from Xcode Create a new scheme that will open Terminal and launch Panagram in the Terminal window. Click on the scheme named Panagram in the toolbar and select New Scheme: Name the new scheme Panagram on Terminal: Ensure the Panagram on Terminal scheme is selected as the active scheme. Click the scheme and select Edit Scheme\u0026hellip; in the popover. Ensure that the Info tab is selected and then click on the Executable drop down and select Other. Now, find the Terminal.app in your Applications/Utilities folder and click Choose. Now that Terminal is your executable, uncheck Debug executable. Your Panagram on Terminal scheme\u0026rsquo;s Info tab should look like this: Note: The downside is that you can\u0026rsquo;t debug your app in Xcode this way because now the executable that Xcode launches during a run is Terminal and not Panagram.\nNext, select the Arguments tab, then add one new argument: ${BUILT_PRODUCTS_DIR}/${FULL_PRODUCT_NAME} Finally, click Close. Now, make sure you have the scheme Panagram on Terminal selected, then build and run your project. Xcode will open Terminal and pass through the path to your program. Terminal will then launch your program as you\u0026rsquo;d expect. 终端启动命令行APP Open Terminal from your Applications/Utilities folder. In the Project Navigator select your product under the Products group. Copy your debug folder\u0026rsquo;s Full Path from Xcode\u0026rsquo;s Utility area as shown below (do not include \u0026ldquo;Panagram\u0026rdquo;): Open a Finder window and select the Go/Go to Folder\u0026hellip; menu item and paste the full path you copied in the previous step into the dialog\u0026rsquo;s text field: Click Go and Finder navigates to the folder containing the Panagram executable: Drag the Panagram executable from Finder to the Terminal window and drop it there. Switch to the Terminal window and hit Return on the keyboard. Terminal launches Panagram in interactive mode since no arguments were specified: ","date":"2018-10-15T19:30:26Z","permalink":"https://it-boyer.github.io/post/old/swift/%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91%E8%87%AA%E5%B7%B1%E7%9A%84%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/","section":"post","tags":["swift"],"title":"使用swift开发自己的命令行工具"},{"categories":["学习笔记"],"contents":"当想让自己的app支持播放，但有没有足够的时间来开发自己的播放器，可以先考虑用mpv播放器来实现相关功能，这是AppleScript作为互通的桥梁。\nNSTask调用AppleScript 用Process(原NStask)进行调用main.scpt脚本 swift两种方式 1 2 3 4 5 6 7 8 9 10 11 12 //方式一： let process = Process() process.launchPath = \u0026#34;/usr/bin/osascript\u0026#34; process.arguments = [\u0026#34;~/Desktop/main.scpt\u0026#34;] process.launch() //方式二 let bundle = NSBundle.mainBundle() if let scriptPath = bundle.pathForResource(\u0026#34;main\u0026#34;, ofType: \u0026#34;scpt\u0026#34;){ let paths = [scriptPath] Process.launchedProcess(launchPath: \u0026#34;/usr/bin/osascript\u0026#34;, arguments: paths) } NSAppleScript调用AppleScript NSAppleScript语法：do shell script \u0026quot;shell语句\u0026quot;，必须在on run {变量名称，逗号隔开} 以end run结束的闭包里运行。 调用APPleScript脚本片段样例：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 let bundle = NSBundle.mainBundle() let videoPath = bundle.pathForResource(\u0026#34;BigBuck\u0026#34;, ofType: \u0026#34;m4v\u0026#34;) //https://developer.apple.com/library/mac/technotes/tn2084/_index.html //open -na /Applications/mpv.app命令行必须是 -na 才能调用当前指定的播放器，否则会调用系统默认播发器 let myAppleScript = \u0026#34;on run\\ndo shell script \\\u0026#34;open -na /Applications/mpv.app \\(videoPath!)\\\u0026#34;\\ntell application \\\u0026#34;mpv\\\u0026#34; to activate\\n end run\u0026#34; print(myAppleScript) var error: NSDictionary? if let scriptObject = NSAppleScript(source: myAppleScript) { if let output: NSAppleEventDescriptor = scriptObject.executeAndReturnError(\u0026amp;error) { print(output.stringValue) } else if (error != nil) { print(\u0026#34;error: \\(error)\u0026#34;) } } oc调用AppleScript Can you execute an Applescript script from a Swift Application AppleScript调用shell 在NSAppleScript语法中调用shell语句\n1 do shell script \u0026#34;shell语句\u0026#34;` 例：运行shell命令open -na /Applications/mpv.app (videoPath!)\n1 2 3 4 5 on run do shell script \u0026#34;open -na /Applications/mpv.app (videoPath!)\u0026#34; tell application \u0026#34;mpv\u0026#34; to activate end run 终端osascript调用AppleScript 参考\n语法 {% codeblock lang:shell %} osascript -e \u0026lsquo;applescript command\u0026rsquo; #单引号 {% endcodeblock %}\n打开Finder窗口 {% codeblock lang:shell %} osascript -e \u0026rsquo;tell app \u0026ldquo;Finder\u0026rdquo; to make new Finder window\u0026rsquo; {% endcodeblock %}\n打开某个程序同时弹出\u0026quot;Hello World\u0026quot;提示框 {% codeblock lang:js %} osascript -e \u0026rsquo;tell app \u0026ldquo;applicationname\u0026rdquo; to display dialog \u0026ldquo;Hello World\u0026rdquo;' {% endcodeblock %}\n设置音量，音量大小范围（0-7） {% codeblock lang:js %} osascript -e \u0026ldquo;set volume number\u0026rdquo; {% endcodeblock %}\nc语言调用shell 可以用c语言的#include system 函数库：include\u0026lt;stdlib.h\u0026gt; 函数说明: system()会调用fork()产生子进程，由子进程来调用/bin/sh-c string来执行参数string字符串所代表的命令，此命\u0026gt;令执行完后随即返回原调用的进程。在调用system()期间SIGCHLD 信号会被暂时搁置，SIGINT和SIGQUIT 信号则会被忽略。 返回值:\n1 2 3 =-1:出现错误 =0:调用成功但是没有出现子进程 \u0026gt;0:成功退出的子进程的id 如果system()在调用/bin/sh时失败则返回127，其他失败原因返回-1。若参数string为空指针(NULL)，则返回非零值\u0026gt;。如果system()调用成功则最后会返回执行shell命令后的返回值，但是此返回值也有可能为 system()调用/bin/sh失败所返回的127，因此最好能再检查errno来确认执行成功。\n","date":"2018-10-15T17:22:37Z","permalink":"https://it-boyer.github.io/post/old/swift/Swift%E8%B0%83%E7%94%A8AppleScript%E8%84%9A%E6%9C%AC%E5%92%8CShell%E8%84%9A%E6%9C%AC/","section":"post","tags":["swift"],"title":"Swift调用AppleScript脚本和Shell脚本"},{"categories":["学习笔记"],"contents":" {% github PerfectlySoft Perfect-Python 63589be width = 30% %}\nPerfect - Python 本项目提供了在Swift服务器应用上直接引用Python 2.7函数库的简便方法。\n本项目采用Swift Package Manager 软件包管理器编译，是Perfect 项目的一部分，但是也可以独立运行\n在使用之前请准备好最新的Swift 4.1.2 工具链\nLinux 编译事项 首先请确保 libpython2.7-dev 已经在 Ubuntu 16.04 上正确安装：\n1 $ sudo apt-get install libpython2.7-dev MacOS 编译事项 请确定 Xcode 9.0 以上版本已经正确安装\n快速上手 首先在Package.swift中增加依存关系：\n1 2 3 4 5 6 7 .package(url: \u0026#34;https://github.com/PerfectlySoft/Perfect-Python.git\u0026#34;, from: \u0026#34;3.2.0\u0026#34;) // 注意在编译目标段落需要追加： .target( // name: \u0026#34;your project name\u0026#34;, dependencies: [\u0026#34;PerfectPython\u0026#34;, \u0026#34;PythonAPI\u0026#34;]), 然后将下列头文件导入Swift源代码：\n1 2 import PythonAPI import PerfectPython 请注意在任何程序调用之前，必须调用Py_Initialize()函数初始化python嵌入环境：\n1 Py_Initialize() 导入Python函数库模块 使用 PyObj 类对象用于导入python模块。下列参考范例中，一个名为/tmp/clstest.py的脚本被动态导入到当前Swift运行环境：\n1 let pymod = try PyObj(path: \u0026#34;/tmp\u0026#34;, import: \u0026#34;clstest\u0026#34;) 访问Python变量 导入模块后，您可以使用PyObj.load()函数加载任何一个变量；也可以反过来用 PyObj.save()命令保存当前变量为一个新的值。\n比如，以下python脚本中有个叫做 stringVar 的字符串变量：\n1 stringVar = \u0026#39;Hello, world\u0026#39; 那么要取得这个字符串的值只需要这样做：\n1 2 3 4 if let str = pymod.load(\u0026#34;stringVar\u0026#34;)?.value as? String { print(str) // 会打印变量的字符串值 \u0026#34;Hello, world!\u0026#34; } 此时您还可以为该变量直接写入新的字符串值：\n1 try pymod.save(\u0026#34;stringVar\u0026#34;, newValue: \u0026#34;Hola, 🇨🇳🇨🇦！\u0026#34;) 注意 目前，Perfect-Python仅支持如下Swift / Python数据类型自动转换：\nPython 类型 Swift 类型 备注 int Int float Double str String list [Any] 递归转换 dict [String:Any] 递归转换 比如，您可以把一个字符串 String 转换为 PyObj，通过 let pystr = \u0026quot;Hello\u0026quot;.python() 或者 let pystr = try PyObj(value:\u0026quot;Hello\u0026quot;) 完成转换。\n反过来，如果要把 PyObj 类转换为Swift数据类型，比如字符串，则仍然有两种方法：let str = pystr.value as? String 和 let str = String(python: pystr)。\n执行Python函数 方法 PyObj.call() 用于带参数执行某个python函数。以如下python脚本为例：\n1 2 def mymul(num1, num2): return num1 * num2 Perfect-Python 可以用下列方法封装并调用以上函数，您所需要注意的仅仅是其函数名称以及参数。其中函数名称用字符串代替，而参数用一个数组表达：\n1 2 3 4 if let res = pymod.call(\u0026#34;mymul\u0026#34;, args: [2,3])?.value as? Int { print(res) // 结果为 6 } Python类对象 请同样使用 PyObj.load() 函数用于家在Python类对象，但是注意后面一定要紧跟一个PyObj.construct() 用于初始化类对象实例。该方法同样支持用一个任意类型的数组作为参数进行对象构造。\n假设如下脚本的典型python类对象 Person，该类有两个属性姓名name 和年龄age，还有一个名为“自我介绍”的类对象方法intro():\n1 2 3 4 5 6 7 class Person: def __init__(self, name, age): self.name = name self.age = age def intro(self): return \u0026#39;Name: \u0026#39; + self.name + \u0026#39;, Age: \u0026#39; + str(self.age) 在Swift中初始化上述类对象的方法需要进行以下两步走：\n1 2 3 4 if let personClass = pymod.load(\u0026#34;Person\u0026#34;), let person = personClass.construct([\u0026#34;rocky\u0026#34;, 24]) { // person is now the object instance } 之后就可以访问类实例的属性变量和方法了，如同上文所提到的普通变量和函数调用的方法一样：\n1 2 3 4 5 if let name = person.load(\u0026#34;name\u0026#34;)?.value as? String, let age = person.load(\u0026#34;age\u0026#34;)?.value as? Int, let intro = person.call(\u0026#34;intro\u0026#34;, args: [])?.value as? String { print(name, age, intro) } 回调函数 参考以下python代码，此时如果执行 x = caller('Hello', callback) 则可以将函数作为参数进行回调:\n1 2 3 4 5 def callback(msg): return \u0026#39;callback: \u0026#39; + msg def caller(info, func): return func(info) 在Swift中等效的代码平淡无奇，只不过将待调函数作为参数而已：:\n1 2 3 4 5 6 if let fun = pymod.load(\u0026#34;callback\u0026#34;), let result = pymod.call(\u0026#34;caller\u0026#34;, args: [\u0026#34;Hello\u0026#34;, fun]), let v = result.value as? String { print(v) // 结果是 \u0026#34;callback: Hello\u0026#34; } 你没看错：Swift可以直接调用Python函数库\n","date":"2018-10-15T17:22:37Z","permalink":"https://it-boyer.github.io/post/old/swift/Swift%E7%9B%B4%E6%8E%A5%E8%B0%83%E7%94%A8Python%E5%87%BD%E6%95%B0%E5%BA%93/","section":"post","tags":["swift"],"title":"Swift直接调用Python函数库"},{"categories":["解决方案"],"contents":" {% github it-boyer width = 30% %}\npngquant 使用pngquant批量压缩png\n编写批量处理脚本 vi compresspng.py 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 import os import sys ## 参考https://www.jianshu.com/p/bfa29141437e # 执行文件路径: # os.path.realpath(__file__) # sys.argv[0] # 当前图片目录:os.getcwd() # 文件目录:sys.path[0] # 获取终端参数 # sys.argv[1] # 用法 # pngTo imgDir 默认目录路径 def GetFileFromThisRootDir(dir, ext = None): allfiles = [] needExtFilter = (ext != None) for root,dirs,files in os.walk(dir): for filespath in files: filepath = os.path.join(root, filespath) extension = os.path.splitext(filepath)[1][1:] if needExtFilter and extension == ext in ext: allfiles.append(filepath) return allfiles if __name__ == \u0026#39;__main__\u0026#39;: rootDir=sys.path[0] PngquantExe = rootDir + \u0026#34;/pngquant\u0026#34; print(len(sys.argv)) if len(sys.argv) == 1: #当没有传目录参数时,默认获取当前目录 srcDir = os.getcwd() else: srcDir=sys.argv[1] #获取用户指定的目录路径 print(srcDir) imgFiles=GetFileFromThisRootDir(srcDir, \u0026#39;png\u0026#39;) suffix=\u0026#34;_temp.png\u0026#34; for f in imgFiles: cmd = \u0026#34;\\\u0026#34;\u0026#34; + PngquantExe + \u0026#34;\\\u0026#34;\u0026#34; + \u0026#34; --ext \u0026#34; + suffix + \u0026#34; --force --speed=3 \u0026#34;+ f os.system(cmd) os.remove(f) newfile=f.replace(\u0026#34;.png\u0026#34;, suffix) os.rename(newfile, f) print(\u0026#34;压缩完成\u0026#34;) 用法\npngTo默认压缩当前目录的图片 pngTo imgDir imgDir用户指定的目录名 参考使用pngquant批量压缩png\ntinypng https://tinypng.com/developers python 脚本批量处理\n","date":"2018-10-15T15:21:53Z","permalink":"https://it-boyer.github.io/post/old/%E5%85%B6%E4%BB%96/%E6%89%B9%E9%87%8F%E5%8E%8B%E7%BC%A9png%E5%9B%BE%E7%89%87%E5%B7%A5%E5%85%B7/","section":"post","tags":["工具"],"title":"批量压缩png图片工具"},{"categories":["解决方案"],"contents":" {% github rickytan RTImageAssets cf0a641 width = 30% %}\n自动生成所有所需的应用程序图标 https://github.com/rickytan/RTImageAssets iOS开发工具：自动生成@2x,@3x图片\nIconMaker程序生成icon {% gist 816b7ef296219d14edac %} 通过原始1024X1024图片来生成各种iphone ios icon，包含Content.json\nIconMaker使用说明：\n默认生成到当前目录: 1 2 $ IconMaker 1024.png #默认放在当前目录 $ IconMaker 1024.png ~/Desktop/icon/ #生成在指定目录icon中 生成结果自动结构如下： |\u0026mdash;Images.xcassets/ |\u0026mdash;\u0026mdash;AppIcon.appiconset/ |\u0026mdash;\u0026mdash;\u0026mdash;Content.json |\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;con-60@3x.png 拖入xcode即可 ","date":"2018-10-15T15:21:53Z","permalink":"https://it-boyer.github.io/post/old/%E5%85%B6%E4%BB%96/%E8%87%AA%E5%8A%A8%E7%94%9F%E6%88%90icon@2x@1x/","section":"post","tags":["工具"],"title":"自动生成icon@2x@1x"},{"categories":["解决方案"],"contents":"github插件 This plugin supports working with GitHub from the command line. It provides a few things:\nSets up the hub wrapper and completions for the git command if you have hub installed. Completion for the github Ruby gem. Convenience functions for working with repos and URLs. Functions empty_gh - Creates a new empty repo (with a README.md) and pushes it to GitHub new_gh - Initializes an existing directory as a repo and pushes it to GitHub exist_gh - Takes an existing repo and pushes it to GitHub git.io - Shortens a URL using git.io ","date":"2018-10-15T08:26:32Z","permalink":"https://it-boyer.github.io/post/old/git/Zsh%E6%8F%92%E4%BB%B6%E4%B9%8Bgithub%E4%BD%BF%E7%94%A8/","section":"post","tags":["github","zsh"],"title":"Zsh插件之github使用"},{"categories":["解决方案"],"contents":"大家是否有过这样的经历，在命令行里输入adb shell，然后使用命令操作你的手机或模拟器，但是那些命令都是常见Linux命令的阉割缩水版，用起来很不爽。是否想过在Android上使用较完整的shell呢？用BusyBox吧。不论使用adb连接设备使用命令行还是在手机上直接用terminal emulator都可以。\n什么是BusyBox ？ BusyBox 是标准 Linux 工具的一个单个可执行实现。BusyBox 包含了一些简单的工具，例如 cat 和 echo，还包含了一些更大、更复杂的工具，例如 grep、find、mount 以及 telnet。有些人将 BusyBox 称为 Linux 工具里的瑞士军刀.简单的说BusyBox就好像是个大工具箱，它集成压缩了 Linux 的许多工具和命令。（摘自百度百科）\n在Android上安装BusyBox 准备：\n先要把手机给Root了，具体教程这里就不提供了，网上有很多。\n下载BusyBox的binary，打开这个地址 http://www.busybox.net/downloads/binaries ，选择最新版本，然后下载对应你的设备架构的版本，这里我下载了busybox-armv6l，下面将以这个文件名为示例。 [Android] 为Android安装BusyBox —— 完整的bash shell\n","date":"2018-10-15T08:10:09Z","permalink":"https://it-boyer.github.io/post/old/%E5%85%B6%E4%BB%96/Android%E5%AE%89%E8%A3%85BusyBox/","section":"post","tags":[],"title":"Android安装BusyBox"},{"categories":["学习笔记"],"contents":"Arm处理器，因为其低功耗和小尺寸而闻名，几乎所有的手机处理器都基于arm，其在嵌入式系统中的应用非常广泛，它的性能在同等功耗产品中也很出色。\nArmv6、armv7、armv7s、arm64都是arm处理器的指令集，所有指令集原则上都是向下兼容的，如iPhone4S的CPU默认指令集为armv7指令集，但它同时也兼容armv6指令集，只是使用armv6指令集时无法充分发挥其性能，即无法使用armv7指令集中的新特性，同理，iPhone5的处理器标配armv7s指令集，同时也支持armv7指令集，只是无法进行相关的性能优化，从而导致程序的执行效率没那么高。\niOS armv7, armv7s, arm64区别与应用32位、64位配置 为什么手机多用arm？\n","date":"2018-10-15T08:04:57Z","permalink":"https://it-boyer.github.io/post/old/%E5%85%B6%E4%BB%96/%E4%BA%86%E8%A7%A3%E6%89%8B%E6%9C%BA%E5%A4%84%E7%90%86%E5%99%A8ARM/","section":"post","tags":["iOS"],"title":"了解手机处理器ARM"},{"categories":["解决方案"],"contents":"Using Docker on Android - Stack Overflow Installing, running, using docker on armhf (ARMv7)devices\n","date":"2018-10-14T23:47:06Z","permalink":"https://it-boyer.github.io/post/old/%E5%85%B6%E4%BB%96/Docker%E5%AE%89%E8%A3%85%E5%9C%A8android%E7%B3%BB%E7%BB%9F/","section":"post","tags":["docker"],"title":"Docker安装在android系统"},{"categories":["解决方案"],"contents":"npm 与 package.json 快速入门教程 每个项目的根目录下一般都有一个package.json文件，定义项目所需要的各种模块，以及项目的配置信息。npm install则是根据这个配置文件，自动下载所需要的模块，也就是配置项目所需的运行和开发环境。 package.json文件可以手工编写，也可以用npm init命令自动生成，除了项目名称和项目版本是必填的，其他都是选填的。\n最简单的package.json 1 2 3 4 { \u0026#34;name\u0026#34;:\u0026#34;aaa\u0026#34;, //项目名称 \u0026#34;version\u0026#34;:\u0026#34;0.0.0\u0026#34; //项目版本(大版本.次要版本.小版本) } package是一个JSON对象，对象的每个成员就是当前项目的一项设置。\nscript字段 script指定运行脚本命令的npm命令行缩写。\n1 2 3 4 5 6 \u0026#34;script\u0026#34;:{ \u0026#34;start\u0026#34;:\u0026#34;node index.js\u0026#34;, \u0026#34;test\u0026#34;:\u0026#34;tap test/*.js\u0026#34; } //运行npm run start时，执行node index.js命令 //运行npm run test时，执行tap test/*.js命令 dependencies，devDependencies dependencies和devDependencies两项，分别指定了项目运行所依赖的模块、项目开发所需要的模块。它们都指向一个对象，该对象的各个成员，分别由模块名和对应的版本要去组成，表示依赖的模块及其版本范围\n\u0026ndash;save参数表示将该模块写入dependencies属性， \u0026ndash;save-dev表示将该模块写入devDependencies属性。\n1 2 3 4 5 6 7 { \u0026#34;devDependencies\u0026#34;:{ \u0026#34;browserify\u0026#34;:\u0026#34;~13.0.0\u0026#34;, \u0026#34;babel-core\u0026#34;:\u0026#34;^6.5.0\u0026#34; } } //模块名：对应的版本 对应的版本 指定版本: 比如1.2.2，安装时只安装指定版本1.2.2\n波浪号(tilde) + 指定版本：比如~1.2.2，表示安装不低于1.2.2的1.2.x最新版本，但是不会安装1.3.x，等于只会影响小版本的版本号。\n插入号(caret) + 指定版本 : 比如^1.2.2，表示安装不低于1.2.2的1.x.x最新版本，但是不会安装2.x.x，等于不会影响大版本号。如果大版本号为0，则插入号和波浪号效果一样，不会改变次要版本号。\nlatest:安装最新的版本\n如果一个模块不在package.json文件汇总，则可以单独安装这个模块，并使用相应的参数将其写入package.json中。\n1 2 $ npm install express --save $ npm install express --save-dev 例如安装上面的express模块，–save表示将模块写入dependencies属性，–save-dev表示将模块写入devDependencies属性。\n注释问题 package.json就是一个json文件，json本身只是一种数据格式，而不是程序语言，一般程序语言都会支持注释，但作为数据格式，它本身并不支持注释，所以只能通过其他方式绕过了。\n","date":"2018-10-14T23:47:05Z","permalink":"https://it-boyer.github.io/post/old/shell/package_json%E6%96%87%E4%BB%B6%E9%85%8D%E7%BD%AE%E8%AF%B4%E6%98%8E/","section":"post","tags":["shell"],"title":"package_json文件配置说明"},{"categories":["解决方案"],"contents":" {% github openwrt openwrt 759f111 width = 30% %} openwrt.io 小米路由器固件信息\n路由器read-only file system怎么改权限\n1 mount -o remount,rw / 新建配置 备份初始conf 1 mv /etc/opkg.conf /etc/opkg.conf.bak 开始配置 vim /etc/opkg.conf 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 src/gz attitude_adjustment_base http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base src/gz attitude_adjustment_packages http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/packages/ src/gz attitude_adjustment_luci http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/luci/ src/gz attitude_adjustment_management http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/management/ src/gz attitude_adjustment_oldpackages http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/oldpackages/ src/gz attitude_adjustment_routing http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/routing/ src/gz openwrt_dist http://openwrt-dist.sourceforge.net/releases/ramips/packages src/gz openwrt_dist_luci http://openwrt-dist.sourceforge.net/releases/luci/packages dest root /data dest ram /tmp lists_dir ext /data/var/opkg-lists option overlay_root /data arch all 100 arch ramips 200 arch ramips_24kec 300 更新库 1 2 3 $ opkg update Downloading http://downloads.openwrt.org/..../generic/packages/packages/Packages.gz. Updated list of available packages in /data/var/opkg-lists/attitude_adjustment. 注：如果下载失败，请确认是否是http而非https。另外如果链接失效可能是更新了包，可以到https://downloads.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base/搜索libc_找到最新下载地址。\n经过用上操作，opkg就可以正常使用了\nopkg安装命令 opkg install 软件包名:一律安装在/data/usr/bin目录中 opkg upgrade 软件包名: 升级软件包 opkg list-installed:查看已经安装的包 opkg list-upgradable:查看可以升级的包 opkg update 更新可以获取的软件包列表 opkg remove 软件包名 卸载已经安装的指定的软件包 opkg list 获取软件列表\n安装基础包libc* 安装其他库的时候，经常会提示错误，缺少libc*。这里他没办法直接安装，只能手工操作: 1 $ opkg install http://archive.openwrt.org/barrier_breaker/14.07/ramips/mt7620a/packages/base/libc_0.9.33.2-1_ramips_24kec.ipk 接下来就可以安装一些自己需求的软件包: 例如：安装git命令工具 1 $ opkg install git 配置系统环境 由于没有配置 /etc/profile,导致：运行命令时，提示no fond 例如：#python no fond 1 2 export PATH=/data/usr/bin:$PATH $ source /etc/profile //命令生效 OpenWRT基本知识整理\n","date":"2018-10-14T23:27:01Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/opkg%E5%9C%A8%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%99%A8%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"post","tags":["智能设备"],"title":"opkg在小米路由器的使用"},{"categories":["解决方案"],"contents":" 1 2 3 4 $ brew doctor $ brew install git $ brew link --overwrite git Linking /usr/local/Cellar/git/2.19.1... 216 symlinks created ","date":"2018-10-12T19:56:59Z","permalink":"https://it-boyer.github.io/post/old/git/brew%E5%8D%87%E7%BA%A7git%E7%89%88%E6%9C%AC/","section":"post","tags":["git"],"title":"brew升级git版本"},{"categories":["学习笔记"],"contents":" {% github asmallteapot cocoapods-playgrounds c54b492 width = 30% %} issues 62\n在playground中优雅的使用Pod\nThis Could Be Us But You Playing Generates a Swift Playground for any Pod.\nInstallation $ gem install cocoapods-playgrounds\nUsage CocoaPods To generate a Playground for a specific Pod:\n1 $ pod playgrounds Alamofire To generate a Playground for a local development Pod:\n1 $ pod playgrounds ../../../Sources/Alamofire/Alamofire.podspec To generate a Playground with multiple Pods:\n1 $ pod playgrounds RxSwift,RxCocoa Carthage To generate a Playground for a Carthage-enabled library:\n1 $ carthage-play Alamofire/Alamofire Note: This currently assumes that libraries are hosted on GitHub.\nCLI To generate an empty Playground from the commandline:\n1 2 $ playground --platform=ios YOLO $ open YOLO.playground ","date":"2018-10-12T19:56:59Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E4%B8%BAPod%E7%9A%84%E5%BA%93%E5%88%9B%E5%BB%BA%E6%BC%94%E7%A4%BA%E6%96%87%E4%BB%B6SwiftPlayground/","section":"post","tags":["swift","pod"],"title":"为Pod的库创建演示文件SwiftPlayground"},{"categories":["学习笔记"],"contents":"PLAYGROUND 延时运行引入 Playground 的XCPlayground扩展包框架,其中就包括使 Playground 能延时执行的黑魔法，needsIndefiniteExecution(需要无限期执行)使 Playground 具有延时运行的功能. 在实际使用和开发中，我们最经常面临的异步需求可能就是网络请求了，如果我们想要在 Playground 里验证某个 API 是否正确工作的话，使用 XCPlayground 的这个方法开启延时执行也是必要的：\n1 2 3 4 5 6 7 let url = NSURL(string: \u0026#34;http://httpbin.org/get\u0026#34;)! let getTask = URLSession.shared.dataTask(with: url as URL) { (data, response, error) -\u0026gt; Void in let dictionary = try! JSONSerialization.jsonObject(with: data!, options: []) print(dictionary) } getTask.resume() 之前有30s限制，目前可以无限执行。 ~~可以通过 Alt + Cmd + 回车 来打开辅助编辑器。在这里你会看到控制台输出和时间轴，将右下角的 30 改成你想要的数字，就可以对延时运行的最长时间进行设定了。 ~~\n","date":"2018-10-12T19:56:59Z","permalink":"https://it-boyer.github.io/post/old/swift/%E5%9C%A8playground%E4%B8%AD%E6%89%A7%E8%A1%8C%E5%BC%82%E6%AD%A5%E6%96%B9%E6%B3%95/","section":"post","tags":["swift"],"title":"在playground中执行异步方法"},{"categories":["博客站务"],"contents":"Hexo + Material + Github 搭建博客与配置\n{% github viosey hexo-theme-material d93c5a8 width = 30% %}\n注意！ 在主题的开发迭代过程中，主题的配置文件模板 可能会改动。为了避免使用 git pull 更新主题的用户出现冲突，我们将 主题配置文件模板 命名为 _config.template.yml。配置主题时，你应该拷贝一份 _config.template.yml 并将其重命名为 _config.yml。\n遇到的问题 issues/688 在主题文件夹下新建一个_config.yml文件，并将_config.template.yml里的配置复制到_config.yml文件。 修改layout/_widget/dnsprefetch.ejs文件。修改内容如下：\n1 2 3 \u0026lt;% } else if(theme.comment.use.startsWith(\u0026#34;disqus\u0026#34;)) { %\u0026gt; // to \u0026lt;% } else if(theme.comment.use \u0026amp;\u0026amp; theme.comment.use.startsWith(\u0026#34;disqus\u0026#34;)) { %\u0026gt; 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ERROR /Users/kai/Code/hexoBlog/themes/material/layout/layout.ejs:3 1| 2| \u0026lt;html style=\u0026#34;display: none;\u0026#34; \u0026lt;% if(config.language !== null) { %\u0026gt;lang=\u0026#34;\u0026lt;%- config.language.substring(0,2) %\u0026gt;\u0026#34;\u0026lt;% } %\u0026gt;\u0026gt; 3| \u0026lt;%- partial(\u0026#39;_partial/head\u0026#39;) %\u0026gt; 4| 5| \u0026lt;% if(page.layout === \u0026#39;gallery\u0026#39;) { %\u0026gt; 6| /Users/kai/Code/hexoBlog/themes/material/layout/_partial/head.ejs:22 20| 21| 22| \u0026lt;%- partial(\u0026#39;_widget/dnsprefetch\u0026#39;) %\u0026gt; 23| 24| 25| /Users/kai/Code/hexoBlog/themes/material/layout/_widget/dnsprefetch.ejs:2 1| 2| \u0026lt;% if(theme.vendors.materialcdn) { %\u0026gt; 3| 4| \u0026lt;% } %\u0026gt; 5| \u0026lt;% if( (theme.leancloud.enable === true) || (theme.comment.use == \u0026#34;valine\u0026#34;) ) { %\u0026gt; ","date":"2018-10-12T19:33:01Z","permalink":"https://it-boyer.github.io/post/old/hexo/%E5%AE%89%E8%A3%85Material%E4%B8%BB%E9%A2%98/","section":"post","tags":["hexo"],"title":"安装Material主题"},{"categories":["博客站务"],"contents":" 1 2 \u0026#34;hexo-filter-flowchart\u0026#34;: \u0026#34;^1.0.4\u0026#34;, \u0026#34;hexo-filter-sequence\u0026#34;: \u0026#34;^1.0.3\u0026#34;, 1 2 3 4 5 6 7 8 9 10 11 12 13 14 #作图插件 sequence: # webfont: https://cdnjs.cloudflare.com/ajax/libs/webfont/1.6.27/webfontloader.js # snap: https://cdnjs.cloudflare.com/ajax/libs/snap.svg/0.4.1/snap.svg-min.js # underscore: https://cdnjs.cloudflare.com/ajax/libs/underscore.js/1.8.3/underscore-min.js # sequence: https://cdnjs.cloudflare.com/ajax/libs/js-sequence-diagrams/1.0.6/sequence-diagram-min.js # css: # optional, the url for css, such as hand drawn theme options: theme: simple css_class: flowchart: # raphael: # optional, the source url of raphael.js # flowchart: # optional, the source url of flowchart.js options: # options used for `drawSVG` ","date":"2018-10-12T16:05:45Z","permalink":"https://it-boyer.github.io/post/old/hexo/hexo%E4%BD%9C%E5%9B%BE%E6%8F%92%E4%BB%B6/","section":"post","tags":["hexo"],"title":"hexo作图插件"},{"categories":["博客站务"],"contents":"hexo-generator-restful\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 ## API接口：以下为默认配置，属性值为 false 表示不生成。 restful: #http://npm.taobao.org/package/hexo-generator-restful # site 可配置为数组选择性生成某些属性 # site: [\u0026#39;title\u0026#39;, \u0026#39;subtitle\u0026#39;, \u0026#39;description\u0026#39;, \u0026#39;author\u0026#39;, \u0026#39;since\u0026#39;, email\u0026#39;, \u0026#39;favicon\u0026#39;, \u0026#39;avatar\u0026#39;] site: false # hexo.config mix theme.config posts_size: 10 # 文章列表分页，0 表示不分页 posts_props: # 文章列表项的需要生成的属性 title: false slug: false date: false updated: false comments: false path: false excerpt: false cover: false # 封面图，取文章第一张图片 content: false keywords: false categories: false tags: false categories: false # 分类数据 tags: false # 标签数据 post: false # 文章数据 pages: false # 额外的 Hexo 页面数据, 如 About ","date":"2018-10-12T15:36:18Z","permalink":"https://it-boyer.github.io/post/old/hexo/%E5%8D%9A%E5%AE%A2%E7%94%9F%E6%88%90restful%E9%A3%8E%E6%A0%BC%E7%9A%84json%E6%95%B0%E6%8D%AE%E6%BA%90/","section":"post","tags":["hexo"],"title":"博客生成restful风格的json数据源"},{"categories":["学习笔记"],"contents":" {% github git-lfs git-lfs 45c4568 width = 30% %} git-lfs官网 LFS其实是git的一个扩展，并没有改变git的工作方式，有点像耍了个小花招，把指定需要lfs管理的文件替换成了一个指针文件交给git进行版本管理； 在pull/push等这些操作中，lfs又通过lfs服务器把这些文件的真身给下载或上传回来； 通过这样的手段，使得本地仓库的体积大大减小，而不会出现随着这些文件的版本增多而体积剧烈膨胀的情况； 个人觉得这种把存储负担转移给了服务器的做法，是不是有违git去中心化的理念，毕竟lfs这样做其实算是强依赖于这个lfs服务器了，本地仓库并不是一个完整的仓库\n安装 1 brew install git-lfs 配置git库支持git-lfs Git命令行扩展工具git-lfs,您只需设置一次Git LFS。 1 2 3 4 #设置库支持 git lfs install #删除库支持 git lfs uninstall 当使用gitee时，push远程库：WARNING: Authentication error: Authentication required: not a enterprise project\n配置.gitattribute文件，添加需要Git LFS管理的文件类型。也可track命令添加其他类型 1 2 3 4 5 6 # 添加 git lfs track \u0026#34;*.psd\u0026#34; # 查看规则 git lfs track # 查看跟踪的文件清单 git lfs ls-files 确保跟踪.gitattributes 1 git add .gitattributes 像往常一样提交并推送到GitHub。 1 2 3 git add file.psd git commit -m \u0026#34;Add design file\u0026#34; git push origin master ","date":"2018-10-11T17:58:15Z","permalink":"https://it-boyer.github.io/post/old/git/git-lfs%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","section":"post","tags":["git"],"title":"git-lfs命令工具使用"},{"categories":["学习笔记"],"contents":" {% github defunkt gist 8d86604 width = 30% %} 按照gist\n安装gist 1 brew install gist 创建gist 上传a.rb中的代码段：\n1 gist a.rb 上传多个文件a.rb,b.rb,c.rb的代码段:\n1 2 gist a b c gist *.rb 作为文件上传：获取STDIN数据，并使用-f指定文件名test.rb上传：\n1 gist -f test.rb \u0026lt;a.rb 直接从剪切板上传文本:\n1 gist -P 设置隐私片段 -p:\n1 gist -p a.rb 添加片段描述信息-d:\n1 gist -d \u0026#34;Random rbx bug\u0026#34; a.rb 更新现有的片段 -u:\n1 2 3 gist -u GIST_ID FILE_NAME 例子： gist -u 42f2c239d2eb57299408 test.txt ‌If you\u0026rsquo;d like to copy the resulting URL to your clipboard, use -c.\n1 gist -c \u0026lt;a.rb ‌If you\u0026rsquo;d like to copy the resulting embeddable URL to your clipboard, use -e.\n1 gist -e \u0026lt;a.rb 打开浏览器访问片段 -o.\n1 gist -o \u0026lt;a.rb ‌To list (public gists or all gists for authed user) gists for user gist -l : all gists for authed user gist -l defunkt : list defunkt\u0026rsquo;s public gists To read a gist and print it to STDOUT\n1 2 3 gist -r GIST_ID 例子： gist -r 374130 ‌See gist --help for more detail.\n使用gist命令 使用gistit快捷工具 {% github jrbasso gistit 99fc659 width = 30% %}\n安装 1 brew install gistit 使用说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 # Creating a public gist from other app response ls | gistit # Creating a private gist from other app response ls | gistit -priv # Specifying the gist filename ls | gistit -i list.txt # Sending files gistit file.txt # Sending multiple files in a private gist gistit -priv file1.txt file2.c # Setting gist description gistit -d \u0026#34;This is just a sample\u0026#34; sample.txt # Setting gist description, private and with multiple files gistit -d \u0026#34;Sample\u0026#34; -priv file1.txt file2.txt file3.txt # Help gistit -h # Version gistit -v ","date":"2018-10-11T17:17:52Z","permalink":"https://it-boyer.github.io/post/old/git/gist%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7%E4%BD%BF%E7%94%A8/","section":"post","tags":["git"],"title":"gist命令工具使用"},{"categories":["学习笔记"],"contents":"Git 仓库拆拆拆\n拆分一个子目录为独立仓库 1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 这就是那个大仓库 big-project $ git clone git@github.com:tom/big-project.git $ cd big-project # 把所有 `codes-eiyo` 目录下的相关提交整理为一个新的分支 eiyo $ git subtree split -P codes-eiyo -b eiyo # 另建一个新目录并初始化为 git 仓库 $ mkdir ../eiyo $ cd ../eiyo $ git init # 拉取旧仓库的 eiyo 分支到当前的 master 分支 $ git pull ../big-project eiyo 清除一个子目录下所有内容和记录 这个还是要用万能的 filter-branch：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 # 还是那个大仓库 big-project $ git clone git@github.com:tom/big-project.git $ cd big-project # 清理 `master` 分支上所有跟 `codes-eiyo` 目录有关的痕迹 $ git filter-branch --index-filter \u0026#34;git rm -rf --cached --ignore-unmatch codes-eiyo\u0026#34; --prune-empty master # 另建一个新目录并初始化为 git 仓库 $ mkdir ../big-project-fresh $ cd ../big-project-fresh $ git init # 拉取 `big-project` 的 `master` 分支（到新仓库的 master 分支） $ git pull ../big-project master 推送给新的远端仓库 1 2 $ git remote add origin git://github.com:tom/fresh-project.git $ git push origin -u master git subtree 合并 git subtree：合并策略，通过git subtree命令能将依赖库某分支合并到主项目的分支中，在开发过程中，只需对主项目分支进行统一管理。\n创建合并subtree add命令 命令如下:\n1 2 \u0026#39;git subtree\u0026#39; add -P \u0026lt;prefix\u0026gt; \u0026lt;commit\u0026gt; \u0026#39;git subtree\u0026#39; add -P \u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;ref\u0026gt; 两步走 先fetch库再subtree add合并\n先将依赖库fetch到本地仓库中 1 2 3 4 // 创建lib的远程版本库: git init --bare lib-rep #-f：远端库添加后立即执行fetch操作 git remote add -f librepo ../lib-rep 通过git subtree命令将依赖库合并到主项目中 1 git subtree add -P lib librepo master squash合并法 --squash: 适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。\n1 git subtree add --prefix=themes/jacman --squash https://it-boyer@github.com/it-boyer/jacman.git master subtree其他命令 git subtree支持创建(add)之外,还支持更新(pull),推送(push),合并(merge),抽离(split)以下命令:\n1 2 3 4 \u0026#39;git subtree\u0026#39; pull -P \u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;ref\u0026gt; \u0026#39;git subtree\u0026#39; push -P \u0026lt;prefix\u0026gt; \u0026lt;repository\u0026gt; \u0026lt;ref\u0026gt; \u0026#39;git subtree\u0026#39; merge -P \u0026lt;prefix\u0026gt; \u0026lt;commit\u0026gt; \u0026#39;git subtree\u0026#39; split -P \u0026lt;prefix\u0026gt; [OPTIONS] [\u0026lt;commit\u0026gt;] 从子树库中拉取最新代码:\n1 git subtree pull --prefix=themes/jacman --squash https://it-boyer@github.com/it-boyer/jacman.git master 将自己的代码发布到子树库:\n1 git subtree push --prefix=themes/jacman --squash https://it-boyer@github.com/it-boyer/jacman.git master 相关参数：\n1 2 3 4 5 6 -q | --quiet -d | --debug -P \u0026lt;prefix\u0026gt; | --prefix=\u0026lt;prefix\u0026gt; 引用库对应的本地目录 -m \u0026lt;message\u0026gt; | --message=\u0026lt;message\u0026gt; 适用于add/pull/merge子命令。设置产生的合并提交的说明文本 --squash 适用于add/pull/merge子命令。先合并引用库的更新记录，将合并结果并到主项目中。 使用此选项时，subtree add/pull会产生两个提交版本：一个是子项目的历史记录，一个是Merge操作。好处是可以让主项目历史记录很规整，缺点是子项目更新时常常需要解决冲突。一个更好的解决方案是：单独建一个分支进行--no-squash的subtree更新，然后再--squash合并到主分支。每次在此分支做操作前都需要先把主分支合并进来。参考：http://www.fwolf.com/blog/post/246 split子命令选项：\n1 2 3 4 5 --annotate=\u0026lt;annotation\u0026gt; 创建合成历史时有可能形成内容不同但提交信息完全相同的提交版本，使用这个选项在每个提交消息前加上此前缀用来区分。 -b \u0026lt;branch\u0026gt; | --branch=\u0026lt;branch\u0026gt; 创建合成的提交历史时，创建此参数指定的新分支包含生成的合成历史。\u0026lt;branch\u0026gt;必须是还不存在的。 --onto=\u0026lt;onto\u0026gt; --rejoin --ignore-joins 使用sourcetree管理 配置 subtree 菜单：Repository -\u0026gt; Add/Link subtree\u0026hellip;(添加／链接子树\u0026hellip;) 在左边栏的SUBTREES(子树)中显示： 拉取依赖库的最新代码 在右边栏右击已存在的subtree，并选择 pull subtree\u0026hellip;菜单项： 第二步的功能代码如下: 1 git -c subtree pull -P themes/.jacman --squash https://it-boyer@github.com/it-boyer/jacman.git master ","date":"2018-10-09T12:07:55Z","permalink":"https://it-boyer.github.io/post/old/git/subtree%E6%8B%86%E5%88%86%E5%A4%A7%E7%9A%84git%E5%BA%93%E5%88%B0%E5%A4%9A%E4%B8%AA%E7%8B%AC%E7%AB%8Bgit%E5%BA%93/","section":"post","tags":["git"],"title":"subtree拆分大的git库到多个独立git库"},{"categories":["解决方案"],"contents":" {% github joeblau gitignore.io a09921d width = 30% %}\n配置zsh支持插件gi命令 先浏览oh-my-zsh/plugins目录下支持所有插件,找到gi命令的插件名称：gitignore,即目录名称。 把gitignore添加到zshrc.zsh-template的插件激活的清单中： 1 2 # 插件设置，如果添加太多启动速度会比较慢 plugins=(git gitignore ruby autojump osx mvn) gi清单命令使用 再次打开zsh窗口会激活gi命令\nlist命令 打印出gitignore.io官网支持语种的所有模版： 1 $ gi list 系统全局清单 在.gitignore_global文件中添加，忽略当前操作系统中某个IDE工具的忽略清单: 1 $ gi linux,eclipse \u0026gt;\u0026gt; ~/.gitignore_global Project项目忽略清单 在.gitignore文件中添加，配置项目中使用的源码语言的相关忽略清单: 1 $ gi java,python \u0026gt;\u0026gt; .gitignore ","date":"2018-10-09T12:04:55Z","permalink":"https://it-boyer.github.io/post/old/git/zsh%E6%8F%92%E4%BB%B6%E4%B9%8Bgi%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","section":"post","tags":["zsh"],"title":"zsh插件之gi使用说明"},{"categories":["学习笔记"],"contents":"pod支持问题 xcode-playground-with-cocoapods You could use ThisCouldBeUsButYouPlaying or add this to your Podfile xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库\nRxSwift资源案例 在项目中使用RxSwift.Resources.total，提供所有Rx资源分配的计数，这对于在开发期间检测泄漏非常有用。 在写入磁盘之前，修改一些工程的配置post_install hook:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 target \u0026#39;AppTarget\u0026#39; do pod \u0026#39;RxSwift\u0026#39; end post_install do |installer| installer.pods_project.targets.each do |target| if target.name == \u0026#39;RxSwift\u0026#39; target.build_configurations.each do |config| if config.name == \u0026#39;Debug\u0026#39; config.build_settings[\u0026#39;OTHER_SWIFT_FLAGS\u0026#39;] ||= [\u0026#39;-D\u0026#39;, \u0026#39;TRACE_RESOURCES\u0026#39;] end end end end end Run pod update. Build project (Product → Build).\npost_install 用法 podfile hook语法 post_install语法 把玩CocoaPods post_install 和 pre_install\n","date":"2018-10-06T14:50:12Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E9%85%8D%E7%BD%AEPodfile%E6%94%AF%E6%8C%81playground%E5%AF%BC%E5%85%A5%E5%BA%93/","section":"post","tags":["pod","playground"],"title":"配置Podfile支持playground导入库"},{"categories":["解决方案"],"contents":"升级cocopods 1 2 3 4 5 6 sudo gem update --system gem source -l pod setup pod repo update --verbose sudo gem install cocoapods --pre sudo gem cleanup gem source\n1 2 3 4 $ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ $ gem sources -l https://gems.ruby-china.com # 确保只有 gems.ruby-china.com 腾讯云： https://gems.ruby-china.com/ 淘宝：https://ruby.taobao.org/\n","date":"2018-10-06T14:50:12Z","permalink":"https://it-boyer.github.io/post/old/shell/%E4%BD%BF%E7%94%A8gem%E5%8D%87%E7%BA%A7pod%E6%96%B9%E6%B3%95/","section":"post","tags":["shell"],"title":"使用gem升级pod方法"},{"categories":["解决方案"],"contents":"profile文件 1.1 profile文件的作用 profile(/etc/profile)，用于设置系统级的环境变量和启动程序，在这个文件下配置会对所有用户生效。当用户登录(login)时，文件会被执行。 1.2 在profile中添加环境变量 一般不建议在/etc/profile文件中添加环境变量，因为在这个文件中添加的设置会对所有用户起作用。 当必须添加时，我们可以按以下方式添加： 如，添加一个HOST值为linuxprobe.com的环境变量：\n1 export HOST=linuxprobe.com 添加时，可以在行尾使用;号，也可以不使用。 一个变量名可以对应多个变量值，多个变量值需要使用:进行分隔。 添加环境变量后，需要重新登录才能生效，也可以使用source命令强制立即生效：\n1 source /etc/profile 查看是否生效可以使用echo命令：\n1 2 $ echo $HOST linuxprobe.com bashrc文件 bashrc文件用于配置函数或别名。 bashrc文件有两种级别：系统级的位于/etc/bashrc、用户级的位于~/.bashrc，两者分别会对所有用户和当前用户生效。 bashrc文件只会对指定的shell类型起作用，bashrc只会被bash shell调用。 Mac OS X上的终端bash不读取~/.bashrc，因为Mac OS X上的bash是通过login的方式运行的，而man bash中写着，通过login方式登录的bash不会读取~/.bashrc。 解决方法：把下面的代码 添加到 ~/.bash_profile中:\n1 2 \u0026lt;!-- lang: shell --\u0026gt; source ~/.bashrc bash_profile文件 bash_profile只对单一用户有效，文件存储位于~/.bash_profile，该文件是一个用户级的设置，可以理解为某一个用户目录下的profile。这个文件同样也可以用于配置环境变量和启动程序，但只针对单个用户有效。\n","date":"2018-10-05T09:32:44Z","permalink":"https://it-boyer.github.io/post/old/shell/%E8%AE%BE%E7%BD%AE%E7%8E%AF%E5%A2%83%E5%8F%98%E9%87%8F%E7%9A%84profile%E4%B8%8Ebash_profile%E5%8C%BA%E5%88%AB/","section":"post","tags":["shell"],"title":"设置环境变量的profile与bash_profile区别"},{"categories":["解决方案"],"contents":"/,?查找命令 /word 向下查找word字符串 ?word向上查找word字符串 组合查找 n: 代表重复前一个查找的操作 N:反向进行前一个查找操作 s/old/new/g替换命令 行间查找 在第n1和n2行查找word1比替换为word2 1 :n1,n2s/word1/word2/g 举例： ：100,200s/vbird/VBIRD/g\n全文查找并替换 1 :1,$s/word1/word2/g 从第一行到最后一行查找字符串word1字符串，并将字符串word1替换为word2\n用户确认替换提示 1 :1,$s/word1/word2/gc 从第一行到最后一行查找字符串word1，并将字符串word1替换为word2,在替换之前提示用户确认是否替换\n","date":"2018-10-04T23:48:08Z","permalink":"https://it-boyer.github.io/post/old/shell/vim%E4%B8%80%E8%88%AC%E6%A8%A1%E5%BC%8F%E4%B8%8B%E6%9F%A5%E6%89%BE%E5%92%8C%E6%9B%BF%E6%8D%A2%E5%91%BD%E4%BB%A4/","section":"post","tags":["shell"],"title":"vim一般模式下查找和替换命令"},{"categories":["解决方案"],"contents":"获取shell脚本文件的绝对路径 basepath=$(cd dirname $0; pwd) echo \u0026ldquo;sh脚本文件的绝对路径：$basepath\u0026rdquo;\n当前执行脚本的路径 echo \u0026ldquo;当前执行脚本的路径也是cd路径打印方法:\u0026quot;pwd echo \u0026ldquo;当前cd的目录名：\u0026quot;basename $(pwd)\n","date":"2018-10-04T13:52:19Z","permalink":"https://it-boyer.github.io/post/old/shell/shell%E8%84%9A%E6%9C%AC%E8%B7%AF%E5%BE%84%E5%92%8C%E6%89%A7%E8%A1%8C%E7%9A%84%E8%B7%AF%E5%BE%84%E5%8C%BA%E5%88%AB/","section":"post","tags":["shell"],"title":"shell脚本路径和执行的路径区别"},{"categories":["学习笔记"],"contents":" {% github it-boyer SimpleValidation fb7a58b width = 30% %}\n{% meting \u0026ldquo;0036mZ7Q1pk7st\u0026rdquo; \u0026ldquo;tencent\u0026rdquo; \u0026ldquo;song\u0026rdquo; %}\n使用RxSwift的优点 RxSwift的目的是让让数据/事件流和异步任务能够更方便的序列化处理，能够使用swift进行响应式编程\n这是一个模拟用户登录的程序。\n功能点 当用户输入用户名时，如果用户名不足 5 个字就给出红色提示语，并且无法输入密码，当用户名符合要求时才可以输入密码。 同样的当用户输入的密码不到 5 个字时也给出红色提示语。 当用户名和密码有一个不符合要求时底部的绿色按钮不可点击，只有当用户名和密码同时有效时按钮才可点击。 当点击绿色按钮后弹出一个提示框，这个提示框只是用来做演示而已。 share(replay: 1)是用来做什么的？ 我们用 usernameValid 来控制用户名提示语是否隐藏以及密码输入框是否可用。shareReplay 就是让他们共享这一个源，而不是为他们单独创建新的源。这样可以减少不必要的开支。\n第一个观察者passwordOutlet.rx_enabled订阅usernameValid时，调用map里的print函数，第二个观察者在订阅时(没有添加.shareReplay(1))时，又再次调用map里的print函数，以此类推，如果有很多观察者的话就要调用很多次，而从第二个观察者开始需要的只是map返回的一个序列，而不是让其徒劳地调用map里的函数，那么怎样解决在多个观察者订阅时多次重复调用执行的问题？ 使用shareReplay(bufferSize: Int)就ok了。 shareReplay会返回一个新的事件序列，它监听底层序列(这里指的是map返回的序列)的事件，并且通知自己的订阅者们。不过和传统的订阅不同的是，它是通过『重播』的方式通知自己的订阅者，因此在这里通过shareReplay订阅的map并不会调用多次。 // 参数bufferSize指的是重播的最大元素个数，因为usernameValid是一个只有一个元素的序列observable，因此shareReplay参数为1；假如对于一个有5个元素的序列，你只需要重复播报最后3个，那么就写成.shareReplay(3)，就酱紫。\ndisposed(by: disposeBag) 是用来做什么的？ 和我们所熟悉的对象一样，每一个绑定也是有生命周期的。并且这个绑定是可以被清除的。disposed(by: disposeBag)就是将绑定的生命周期交给 disposeBag 来管理。当 disposeBag 被释放的时候，那么里面尚未清除的绑定也就被清除了。这就相当于是在用 ARC 来管理绑定的生命周期。 这个内容会在 Disposable 章节详细介绍。\nbindTO 简单使用 我的理解就是将已经信号源去用一个UIBindingObserver去接受,当接收到的属性是true进行相应的操作 为登录按钮写一个rx_click的拓展\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 ///首先写一个UIBindingObserver var rx_click:AnyObserver\u0026lt;Bool\u0026gt; { return UIBindingObserver.init(UIElement: self, binding: { (lab, result) in lab.backgroundColor = result ? UIColor.blue:UIColor.gray }).asObserver() } //*bindto 信号合并处理 bindto发送信号 // combineLatest(合并信号) bind(订阅) // observer -----------------------\u0026gt;处理信号时间-------------\u0026gt;处理信号 ///然后手机号11位 验证码 6位就可以用这一行代码解决 let _ = Observable.combineLatest(phoneobser, passobserver, resultSelector: { $0 \u0026amp;\u0026amp; $1 }).bind(to: canclik.rx_click) ","date":"2018-10-04T09:04:35Z","permalink":"https://it-boyer.github.io/post/old/%E5%BC%80%E6%BA%90%E5%BA%93/RxSwift%E5%BA%94%E7%94%A8%E7%99%BB%E5%BD%95%E9%AA%8C%E8%AF%81/","section":"post","tags":["SDK"],"title":"RxSwift应用登录验证"},{"categories":["博客站务"],"contents":"Hexo添加Gitalk评论插件 自动初始化 Gitalk 和 Gitment 评论 Gitment/Gitalk自动初始化\n","date":"2018-10-03T16:16:25Z","permalink":"https://it-boyer.github.io/post/old/hexo/%E8%87%AA%E5%8A%A8%E5%88%9D%E5%A7%8B%E5%8C%96Gitalk%E5%92%8CGitment%E8%AF%84%E8%AE%BA/","section":"post","tags":["hexo"],"title":"自动初始化Gitalk和Gitment评论"},{"categories":["博客站务"],"contents":"安装Heroku CLI工具 Mac端\n1 brew install heroku/brew/heroku Heroku CLI 命令\n1 2 heroku -h heroku login Creating Apps from the CLI 1 2 3 4 5 6 7 $ mkdir example $ cd example $ git init $ heroku apps:create example Creating ⬢ example... done https://example.herokuapp.com/ | https://git.heroku.com/example.git Git remote heroku added 查看现有APP信息 1 2 heroku apps //所有应用列表 heroku apps:info //查看所有应用的详细信息 在浏览器中访问APP页面 1 2 3 4 5 6 7 8 9 10 11 12 13 USAGE $ heroku apps:open [PATH] OPTIONS -a, --app=app (required) app to run command against -r, --remote=remote git remote of app to use EXAMPLES $ heroku open -a myapp # opens https://myapp.herokuapp.com $ heroku open -a myapp /foo # opens https://myapp.herokuapp.com/foo 用例：在heroku上部署gh-oauth-server服务 issues:object ProgressEvent 下载服务器源代码gh-oauth-server ,由于是nodejs写的所以需要安装nodejs环境 如何安装自己Google; 然后git clone 该项目并进入目录, 执行npm install 安装依赖, 依赖安装成功后执行npm start, 如果输出start on port 300表示开启成功,;为了支持ssl 可以安装nginx代理, 这个可以自己百度, 有很多教程的.\n1 2 3 4 5 git clone https://github.com/imsun/gh-oauth-server cd gh-oauth-server heroku create gitment-hexo //创建herokua应用 git push heroku master //会自动安装package.json依赖库。 heroku open -a gitment-hexo //浏览器打开 进入heroku服务器命令行 1 2 3 4 5 6 $heroku run bash Running `bash` attached to terminal... up, run.3052 ~ $ ls Procfile README.md composer.json composer.lock vendor views web ~ $ exit exit 参考 Getting Started on Heroku with Node.js 把已经存在的应用部署到heroku上learn how to prepare it for Heroku deployment.\n","date":"2018-10-03T12:29:51Z","permalink":"https://it-boyer.github.io/post/old/hexo/Heroku%E9%83%A8%E7%BD%B2web%E6%9C%8D%E5%8A%A1%E5%99%A8/","section":"post","tags":["hexo"],"title":"Heroku部署web服务器"},{"categories":["博客站务"],"contents":"安装gitment 在package.json文件添加gitment依赖：\n1 \u0026#34;gitment\u0026#34;: \u0026#34;^0.0.3\u0026#34; 安装\n1 npm install 申请应用 首先去New OAuth App为你的博客应用一个密钥:\n1 2 3 4 Application name:随便写 Homepage URL:这个也可以随意写,就写你的博客地址就行 Application description:描述,也可以随意写 Authorization callback URL:这个必须写你的博客地址 申请好之后点注册,然后就可以看到两个东西ClientID和Client Secret,后面会用到.\n配置 下面就是配置Gitment,主要编辑在themes/next/_config.yml:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 # Gitment # Introduction: https://imsun.net/posts/gitment-introduction/ gitment: enable: true mint: true # RECOMMEND, A mint on Gitment, to support count, language and proxy_gateway count: true # Show comments count in post meta area lazy: false # Comments lazy loading with a button cleanly: false # Hide \u0026#39;Powered by ...\u0026#39; on footer, and more language: # Force language, or auto switch by theme github_user: {you github user id} github_repo: 随便写一个你的公开的git仓库就行,到时候评论会作为那个项目的issue client_id: {刚才申请的ClientID} client_secret: {刚才申请的Client Secret} proxy_gateway: # Address of api proxy, See: https://github.com/aimingoo/intersect redirect_protocol: # Protocol of redirect_uri with force_redirect_protocol when mint enabled 开通评论 注意到这里基本上已经OK了,再看你的博客应该可以显示评论了.不过每篇博客都需要你手动初始化评论功能(如果你的历史博客很多那就一篇一篇去点吧，不过貌似有人写了批量处理脚本,没试过哈).\n问题 object ProgressEvent 由于引入的 gitment.js 中有这样的一段代码：\n1 2 3 4 5 6 7 8 9 10 11 _utils.http.post(\u0026#39;https://gh-oauth.imsun.net\u0026#39;, { code: code, client_id: client_id, client_secret: client_secret }, \u0026#39;\u0026#39;).then(function (data) { _this.accessToken = data.access_token; _this.update(); }).catch(function (e) { _this.state.user.isLoggingIn = false; alert(e); }); 请求了一个服务接口，由于这个跨域服务接口是作者自己搭建的，已经停止了。 有博主 fork 源作者的 repo ，在这个基础上改的，修改了一些地方接入自己通用的服务CORS-Proxy-Server. 现在直接把这个文件 https://imsun.github.io/gitment/dist/gitment.browser.js 替换为 https://www.wenjunjiang.win/js/gitment.js 就可以了. 原理： hexo 这个评论接了一个自己写的一个通用的跨域服务 https://cors.wenjunjiang.win/ github地址为：https://github.com/jjeejj/CORS-Proxy-Server ，代替作者的 https://gh-oauth.imsun.net 这个接口地址，去请求 github的接口。 可以自己搭建，可以转发所有的前端跨域服务。要注意的是： 在向 github 请求 access_token时 需要带上Accept: application/json 或者Accept: application/xml请求头， 否则回报 406 的错误.\n参考 gitment评论模块接入hexo hexo博客配置-添加评论系统-gitment和valine-需注册 Gitment：使用 GitHub Issues 搭建评论系统\n","date":"2018-10-03T00:54:35Z","permalink":"https://it-boyer.github.io/post/old/hexo/hexo%E9%9B%86%E6%88%90gitment%E8%AF%84%E8%AE%BA%E7%B3%BB%E7%BB%9F/","section":"post","tags":["hexo"],"title":"hexo集成gitment评论系统"},{"categories":["解决方案"],"contents":"引言 性能是实现卓越的用户体验的关键之一。当应用或者游戏表现的运行迅速，反应灵敏时，用户会更喜欢。但是软件是很复杂的，当你的应用视图做某事时，例如只是点了一个按钮，但程序也有可能做了很多的事情，这就意味着你可以在一些看似不太可能的地方找到一些优化点。但这样做，挖掘性能的优化点，有时就需要深入理解你的程序正在做些什么。它需要您知道代码什么时候执行的，以及特定的操作需要多长时间。所以这就体验出来了有一个好的测试工具是多么的重要。\n我们知道开发更好的工具，并让开发者使用这些工具，是我们帮助您成为更高效的开发人员的方法之一。所以今天我们要谈谈其中的一个工具——Signposts（路标）。\n介绍Signposts及历史 Signposts是OSLog家族的新成员，我们正准备让它支持iOS和macOs。您可以在swift和C中使用它们，但最酷的是我们把它和Instruments集成在了一起。这就意味着Instruments可以获取Signposts所产生的数据，并且让深入你理解你的程序正在做什么。\n首先要介绍一点历史，几年前我们介绍了OSLog。这是我们现代化的呈现日志记录的工具。这是我们从系统中获取调试信息的方法。它是在我们“效率”、“隐私”的目标下完成的。具体了解，请查看WWDC 2016 Unified Logging and Activity Tracing。\n这里你可以看到一个OSLog的例子，创建一个简单的日志句柄，并且像它发送了一个Hello world。\n1 2 let logHandle = OSLog(subsystem: \u0026#34;com.example.widget\u0026#34;, category: \u0026#34;Setup\u0026#34;) os_log(.info, log: logHandle, \u0026#34;Hello, %{public}s!\u0026#34;, world) Signposts扩展了OSLogAPI，但它们是为性能用例而做的。这意味着它们正在传达与性能相关的信息，并且它们与我们的开发工具集成在一起，您可以使用Signposts对代码进行标注，然后启动Instruments查看类似的内容。因此，Instruments向您展示了您的程序正在做的事情的可视化时间轴，以及Signposts展示在上面。然后底部有个表，统计汇总和分析Signposts数据，数据分成一块一块的，可以让您看到程序到底做了些什么。 在文章中，我将谈谈如何在您的代码中使用Signposts，以及展示一下他们的作用。然后展示Instruments中Signposts的可视化界面，让您了解Instruments和Signpost是如何协同工作的。\n使用Signposts Siginposts的两个函数:os_signpost(.begin, ...)和os_signpost(.end, ...). 日志句柄:日志句柄需要两个参数一个是子系统，一个是类别. 让我们从一个非常基础的例子开始。想象一下这是你的应用。 你要研究的就是一个接口特定部分刷新所需要的时间。你知道你需要加载一些图片并在屏幕上展示。所以，在这个简单、抽象的视图中，可能你需要做的就是获取图片资源。 所有操作完成后，界面会刷新。Signposts允许我们在一系列工作的开始和结尾进行标记，然后将这两个时间点关联起来，同时这两个日志事件也会互相关联。这就需要调用Siginposts的两个函数。os_signpost(.begin, ...)和os_signpost(.end, ...)。图中b箭头代表开始，e箭头代表结束。然后我们将这两个时间点互相关联，让您了解这一段经过的时间。 在代码中，有一个简单的算法实现，对于我们接口中的每个元素，我们将获取该资源，这正是我们想要去测量的。 1 2 3 for element in panel.elements { fetchAsset(for: element) } 因此，为了将Signposts代码加入到基本的代码中，我们需要导入import os模块，然后由于Siginposts是OSLog的一部分，所以我们需要创建一个日志句柄。这个日志句柄需要两个参数一个是子系统，一个是类别。\n子系统: 在整个项目中可能都是相同的，它看起来很像您的app的包名。它代表了组件或者软件，或者是您正在使用的框架。 类别: 用于关联，将相关的操作或者Signposts绑定在一起。之后我们会讲到这么做的好处。 当我们拥有了日志句柄，我们只需要调用Siginposts的.begin和.end两个函数即可。参数中，我们将日志句柄传递过去，然后再传递一个Signpost的名字。名字是一个字符串，用来标识我们感兴趣的操作的时间间隔。\n1 2 3 4 5 6 7 8 9 import os.signpost let refreshLog = OSLog(subsystem: \u0026#34;com.example.your-app\u0026#34;, category: \u0026#34;RefreshOperations\u0026#34;) for element in panel.elements { os_signpost(.begin, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;) fetchAsset(for: element) os_signpost(.end, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;) } 所以返回之前的时间轴，它就变成了这个样子。在每次开始、结束获取资源时，我们都添加了一个路标。因为在开始和结束的路标的标识一样，所以我们可以将他们两者匹配在一起。但是，如果我们还想要测试整个操作的全部时间，整个刷新过程是怎样的，该如何去做呢？我们在代码中，只需要再添加一对新路标即可（新的名字）。\n1 2 3 4 5 6 7 8 9 10 11 import os.signpost let refreshLog = OSLog(subsystem: \u0026#34;com.example.your-app\u0026#34;, category: \u0026#34;RefreshOperations\u0026#34;) os_signpost(.begin, log: refreshLog, name: \u0026#34;Refresh Panel\u0026#34;) for element in panel.elements { os_signpost(.begin, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;) fetchAsset(for: element) os_signpost(.end, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;) } os_signpost(.end, log: refreshLog, name: \u0026#34;Refresh Panel\u0026#34;) 这时，我们的时间轴又发生了变化。 异步用例：测量异步任务的时间 Signpost IDs路标ID:区分重叠时间间隔的方法，将告诉系统哪些是相同类型的操作，但每个操作彼此不同。 上面是一个很简单的例子。如果你的应用顺序执行第一步、第二步、第三步等等，那么这样测量是非常有效的。但是我们会经常用到一些异步的工作，他们可能同时发生，他们之间也可能会有重叠或者交叉。 在这种情况下，我们需要向系统提供一些额外的信息，以便系统可以将这些路标彼此区分开来。到现在为止，我们在调用方法的时候只用到了名字，通过名字将相同路标的绑定在一起。名字已经确定了时间间隔，但是没有给我们一种区分重叠时间间隔的方法，所以在这里引入了Signpost IDs。路标ID将告诉系统哪些是相同类型的操作，但每个操作彼此不同。在路标开始和结尾传递相同的id，则系统知道这两个是关联的。你可以通过日志句柄来得到一个路标ID。\n1 2 3 4 let spid = OSSignpostID(log: refreshLog) os_signpost(.begin, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;, signpostID: spid) // some code or even async... os_signpost(.end, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;, signpostID: spid) 同样你也可以通过一个对象来得到日志句柄。如果你有一些对象代表您正在尝试的工作，只要您使用该对象实例就会生成相同的路标ID。这就意味着您不用去存放路标ID，只需要通过对象去管理ID就好了。\n1 let spid = OSSignpostID(log: refreshLog, object: element) 在视觉上，您可以将路标ID视为允许我们向每一个路标调用传递一些额外的上下文，这可以将特定操作的开始和结束标记互相关联。 这很重要，因为这些操作不仅仅可以重叠，而且通常他们需要的时间也不同。 我们现在把示例中的fetchAsset从同步调用改为异步调用。并且由于是异步的，这些时间间隔可能会相互重叠，所以我们还要在创建路标时加上路标ID。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 let refreshLog = OSLog(subsystem: \u0026#34;com.example.your-app\u0026#34;, category: \u0026#34;RefreshOperations\u0026#34;) let spidForRefresh = OSSignpostID(log: refreshLog) os_signpost(.begin, log: refreshLog, name: \u0026#34;Refresh Panel\u0026#34;, signpostID: spidForRefresh) for element in panel.elements { //通过对象去创建路标ID let spid = OSSignpostID(log: refreshLog, object: element) //通过ID去记录一个路标 os_signpost(.begin, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;, signpostID:spid) fetchAssetAsync(for: element) { //每一个完成之后的回调 os_signpost(.end, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;, signpostID: spid) } } // 全部完成完成的回调 notifyWhenDone { os_signpost(.end, log: refreshLog, name: \u0026#34;Refresh Panel\u0026#34;, signpostID: spidForRefresh) } 这样就完成了，您可以将Signposts视为一种分类或等级制度。所有的操作都通过日志句柄相关联，这意味着日志分类。然后对我们感兴趣的每个操作，我们给它一个路标名字，如果可能有重叠，我们在给他们路标ID，告诉系统虽然名字相同了，但是我希望通过ID区分。\n这个接口设计的特别灵活，所以你可以控制起始点和结束点的所有参数，日志句柄，路标名字及ID。只要传递的参数是一致的，起始点与结束点就可以对应上，即便他们写在了不同的方法或者文件中。我们之所以这样做是因为希望您能够将它应用到实际开发中。\n在Signposts中添加元数据 您可能希望在路标中传达一些额外的信息，额外的性能相关的信息。很巧，我们有一个方法来为路标添加元数据。下面是一个基本的路标。\n1 os_signpost(.begin, log: log, name: \u0026#34;Compute Physics\u0026#34;) 我们可以添加一个额外的字符串（OSLog格式化的）参数。这允许您向开始点与结束点添加一些上下文。我们可以通过%d来传递整数。当然也可以传递其他的格式化类型的参数。\n1 2 os_signpost(.begin, log: log, name: \u0026#34;Compute Physics\u0026#34;, \u0026#34;%d %d %d %d\u0026#34;,x1, y1, x2, y2) os_signpost(.begin, log: log, name: \u0026#34;Compute Physics\u0026#34;,\u0026#34;%{public}s %.1f %.1f %.2f %.1f %.1f\u0026#34;, description, x1, y1, m, x2, y2) 至于字符串的长度，不用担心，您可以自由、随意的使用。该字符串也会全部渲染到Instruments的界面中，或者仍然可以在程序中访问附加的数据。\n添加独立事件 除了元数据之外，您可能还希望及时添加单独的时间点。这就表示，除了开始的路标以及结尾的路标外，你可能还有一个路标，该路标没有连接到特定的时间间隔，而是一些固定的时刻。为此，我们提供了一个带有事件类型的路标。 用法与设置开始、结束的路标类似，只不过它标识一个单一的时间点。\n1 2 os_signpost(.event, log: log, name: \u0026#34;Fetch Asset\u0026#34;, \u0026#34;Fetched first chunk, size %u\u0026#34;, size) os_signpost(.event, log: log, name: \u0026#34;Swipe\u0026#34;, \u0026#34;For action 0x%x\u0026#34;, actionCode) 您可以在间隔的上下文中使用该方法，或者一些您想追踪的与用户交互无关等时间间隔无关的内容。如果您真的在调查一个性能上的问题，您可能会大量使用它。 有条件启动Signposts 路标通常默认是开启 如果你启用了一些路标，那么他们通常默认是开启的，但我想谈谈有条件的打开和关闭它们。首先我要强调一下，路标是轻量级的。这说明我们已经做了很多优化。我们通过编译器优化来完成这些工作，这些优化在编译时就做了，而不是在运行时完成的。我们还推迟了很多工作，以便他们在Instruments后端完成。这意味着路标应该占用很少的系统资源。我们之所有这样做是因为我们希望尽量减少对您代码的影响。我们也做到了这一点，因为我们确保即使您的时间跨度非常小，也可以发出许多路标来获取一些细粒度的测量结果。 关闭路标 但您可能希望能够关闭路标。要做到一这点，我们将利用OSLog的功能，即禁用的日志句柄。禁用的日志句柄也是一个简单的句柄。它的作用是针对该句柄进行的每个OSLog和os_signpost调用都会几乎会变为无操作。事实上，如果你在C中采用这个，我们甚至会对你进行检查，然后我们甚至不会评估其余的参数。所以你可以在运行时更改这个句柄。 举个例子，让我们回到第一个示例的代码上。我以一个环境变量作为条件，来初始化。如果包含该变量，那么使用普通的os日志构造函数；如果不包含，那么将使用禁用的日志句柄。\n1 2 3 4 5 6 7 8 9 10 11 12 13 let refreshLog: OSLog if ProcessInfo.processInfo.environment.keys.contains(\u0026#34;SIGNPOSTS_FOR_REFRESH\u0026#34;) { refreshLog = OSLog(subsystem: \u0026#34;com.example.your-app\u0026#34;, category: \u0026#34;RefreshOperations\u0026#34;) } else { refreshLog = .disabled } os_signpost(.begin, log: refreshLog, name: \u0026#34;Refresh Panel\u0026#34;) for element in panel.elements { os_signpost(.begin, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;) fetchAsset(for: element) os_signpost(.end, log: refreshLog, name: \u0026#34;Fetch Asset\u0026#34;) } os_signpost(.end, log: refreshLog, name: \u0026#34;Refresh Panel\u0026#34;) 环境变量是您在调试程序时可以在Xcode scheme中设置的内容。现在我说你不必在调用中进行更改，但这种方式相当昂贵并且只适用于调试时。因此如果您有一些基于Instruments的特定的功能，你可以检查特定的日志句柄，查看它是否打开了siginposts enabled属性。然后试用该属性来控制添加该附加操作。\n1 2 3 if refreshLog.signpostsEnabled { let information = copyDescription() os_signpost(..., information) } C语言中的Signposts 上面我们所有示例都是swift的，但是C语言中也提供了路标。到目前为止，上述功能都是可用的：长句柄、使用不用的路标、以及管理路标标识符。 那些对C语言中使用路标感兴趣的人，推荐你们阅读头文件中的文档。文档中包含了所有信息，都是从C语言开发人员的角度考虑的。\nInstruments中使用路标 现在介绍完如何在代码中应用路标，接下来很开心为大家介绍路标和Instruments是如何在一起工作的。向大家展示Instruments 10中三个重要的新功能，来帮助您使用路标数据。\n路标工具:该工具允许您记录、查看和分析应用程序中所有的路标活动。 兴趣点:谈谈什么是兴趣点，以及何时您要设置一个兴趣点 自定义工具: 介绍新的自定义工具，以及如何将它与路标一起使用，以获得更精致的路标展示。 路标 接下来就看下例子吧。示例的app名叫开拓者，主要是展示一些风景。 当我们滚动时，最初展示一个白色的背景，当图片下载完之后，会填充到白色背景区域。这是一种常见的设计，尽管这样设计可以提升一些用户体验，但很难分析它的性能，因为在这个过程中进行了很多异步的活动。如果用户快速滚动，那么有可能出现某个单元格还没有下载完毕之前，就已经要被重用了，那么就必须取消下载。如果不取消的话，可能会有几个并行下载，而展示出来的图也不一定是我们想要的（图和标题不对应）。接下来看看如何通过路标来分析这个应用吧。 首先，在每个单元格中，有一个startImageDownload方法。当我们需要下载图片时会调用它，并传递要下载图片的名字。方法内部，有一个图片下载类，我们通过图片名字和设置自己为委托来初始化该类。在这种情况下，由于downloader对象代表正在进行的并发活动，因为下载是异步的，所以可以通过downloader来创建一个路标ID。接着在下载开始之前，调用os_signpost(.begin，...)方法，设置日志句柄、名称、ID、以及一些元数据。然后开始下载图片，并且将downloader设置为当前单元格正在运行的下载器。 图片下载完毕的回调中将图片展示到屏幕上，然后调用os_siginpost(.end, ...方法，设置日志句柄、名称、ID、以及一些元数据。您会注意到，我们用xcode:size-in-bytes注释了这个参数。它的作用是告诉Xcode和Instruments这个参数应该被视为展示和分析字节大小。这种被称作为工程类型。可以Instruments开发人员帮助文档中找到他们的详细介绍。最后，我们下载完毕了，将下载器设置为空。 当然下载除了成功以外，还有失败的情况，在单元格准备重用时，进行相关的路标设置。 设置完之后，就可以来进行分析了。打开Instruments后，可以选择一个空白的文档。 然后从右侧添加中选择os_signpost工具，并推动到轨迹中。 接下来就可以在app中操作了，一阵操作猛如虎之后，我们回到Instruments来看一下。 通过选择某一段时间，可以查看这段时间内的情况。我们可以看到左侧的路标名称Background Image，以及右侧的一些使用元数据来注释的时间段。 现在再缩小然后看看其他未知的追踪，我们注意到我们最多只有五个并行下载图片的任务，这是一件好事，证明我们取消了。 查看底部间隔的摘要，我们看到是按照类别、路标的名字、开始的消息和结束的消息来区分的。我们来看一共触发了93次的图片下载请求。其中location1触发了12次，7次取消，5次下载成功，下载成功时间共计3.04秒，3.31MB。并且可以查看每次请求时间的最小值、最大值和平均值。如果对某类数据感兴趣，可以点击进入查看详细内容。 如果要查看元数据相关的内容，可以进行筛选，然后查看数据。 这是一种很好的方式来查看您通过元数据传达的值的统计分析.\n兴趣点 接下里，我们看看兴趣点。回到应用，我们我们在主页点击一个单元格，就会进入详情页面。\n如果现在我们每次都能追踪这些详情页面出现的时间就太好了，因为这样我们就可以知道用户正在做什么，并且我们知道用户在app中的哪个页面。当然可以通过路标完成这件事，但是你需要在Instruments中把它拖到轨迹中，并且记录所有的活动。这样有点淡化了导航事件的重要性。所以我们提供了兴趣点。\n点在我们在详情页面的代码中查看viewDidAppear方法，我们通过os_signpost(.event, ...来创建一个路标事件。这个事件要发送到我们创建的称之为兴趣点的日志句柄中。类别设置为兴趣点，这正是Instruments寻找的一个特殊类别。 我们回到再次打开Instruments选择时间分析，会发现自动有了兴趣点这一项。 然后开始录制，从首页进入详情页，选择不同的单元格反复执行，然后返回Instruments，就可以看到这些兴趣点了。 因此您可以在看到用户在哪个页面，并且将其与其他性能数据相关联。\n自定义Instruments 视频中，具体没有讲如何创建，如果想了解如何创建的话，可以参考一下WWDC 2018 Creating Custom Instruments。 WWDC 2018 session 405 转自使用日志记录来衡量性能\n","date":"2018-10-02T23:19:55Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/Instrument%E4%BD%BF%E7%94%A8Signposts%E5%B7%A5%E5%85%B7/","section":"post","tags":["iOS","调试"],"title":"Instrument使用Signposts工具"},{"categories":["学习笔记"],"contents":"Xcode 10 Xcode 10在macOS Mojave的黑暗模式下看起来非常棒，也让你很容易在macOS应用程序中采用新的外观。Xcode 10测试版包括Swift 4.2和beta sdk，适用于iOS 12、watchOS 5、tvOS 12和macOS Mojave。\nDark模式界面和Mac程序支持 全新的dark外观贯穿Xcode和Instruments 在终端中输入命令，Xcode10开启dark mode: 1 defaults write com.apple.dt.Xcode NSWindowDarkChocolate -bool true 使用低版本的macOS,使用此命令可能会造成Xcode interface损坏(测试系统 macOS High Sierra 10.13.4),只能使用macOS Mojave 10.14+才能使用暗黑模式 Asset catalogs为自定义colors assets 和 image assets 添加了深色和浅色变体，支持不同的图像与颜色assets的亮暗与高对比度表现。 支持CarPlay assets. 支持ARKit 3D ARReferenceObject assets. Asset目录与视图调试器(view debugger)的背景可以被明确设定成亮或暗，这样前景的元素就会明显看出来。 Interface Builder支持dark和light预览之间切换 调试您的Mac应用程序在黑暗或光明的变种，而不改变OS设置 Source Control 在共享服务器上的本地存储库或上游的更改直接在编辑器中突出显示。乍一看，你会发现: 修改代码。 更改尚未推入共享存储库。 其他人已经做出了上游的改变。源编辑器(source editor)会显示出某个开发者做出的改变并展示其他开发者做出的还未添加到项目中的改变。 在承诺之前，你应该解决冲突。 支持Atlassian Bitbucket提供的云托管和自托管Git服务器，以及与现有GitHub支持一起使用的GitLab。 Xcode提供了在从存储库中提取最新版本的代码时重新设置更改的基础。 如果需要，将生成SSH密钥，并将其上载到服务提供者。 编辑器的改进 在代码编辑器中放置多个游标，以便同时进行许多更改。 Xcode 10 Source Editor现在支持多光标编辑，允许你快速同时编辑多范围的代码。你可以通过多种方式放置额外的光标，包括鼠标点击方式⌃+⇧+Click，或通过选择列⌥+Click+Drag，或通过键盘的⌃+⇧+Up选择上一列，或⌃+⇧+Down选择下一列。 代码折叠带现在可以隐藏任何被大括号包围的代码块。 Over-scroll功能可以方便地将屏幕中间的最后几行代码居中。 库(Library)内容从Inspector区的底部移动到了一个重叠窗口中，这个窗口可以移动或调整大小，就像Spotlight search一样。在拖动物品时它会解除，但在拖动前按住Option键，它就会为一个额外的拖动保持开启。 Playgrounds支持机器学习 REPL-like model 立即重新运行您现有的playground代码。 代码运行到指定的行，或键入shift-return来运行刚刚添加的代码。 importCreate ML Framework以交互式地培训新模型，然后在playground上编写代码的测试模型。完成后，将模型拖放到应用程序中。 测试和调试 Debugging symbols从新设备下载的速度比以前快了五倍。 Xcode将生成一组完全相同的模拟器，以充分利用多核Mac的优势，并通过风扇测试并行运行，以更快的速度完成测试套件。 以随机或线性顺序运行测试。 Instruments工具会自动显示添加到代码中的OSLog路标。 构建并共享您自己的定制instruments package，为您自己的代码提供独特的数据可视化和分析。 Memory内存调试器使用紧凑的布局，以便更容易地研究内存图。 Metal shader调试器允许您轻松地检查顶点、片段、计算和平铺着色器代码的执行。 Metal dependency viewer可以预览在你的Metal-based应用程序中如何使用资源的详细图表。 Xcode的视图调试器添加了一个选项，可以选择亮暗canvas背景色。 你可以改变你macOS应用运行时的外观，通过使用Debug \u0026gt; View Debugging \u0026gt; Appearance menu，或调试栏中的Override Appearance菜单，或接触栏(touch bar) 检查器(inspector)中展示的已命名颜色在调试时会显示它们的名字以及它们是否为系统颜色。 构建性能 默认情况下启用New build system，改进了整个系统的性能。 Xcode 10使用了一个新的创建系统。新创建系统提供了更好的可靠性与创建性能，它可以获取项目配置问题，而legacy创建系统则不能。 Legacy创建系统在Xcode 10中依旧可用。要想使用的话，在File \u0026gt; Project/Workspace Settings页选择它。为legacy创建系统配置过的项目会在Activity View显示一个橘黄锤子标签\nSwift编译器构建每个单独的文件要快得多。\n使用incremental build setting增量构建设置时，用于调试的大型Swift项目的构建速度要快得多。 《WWDC》Xcode 10也有暗黑模式，現在整合GitLab程式碼託管服務 Xcode10新功能新内容（Beta版下载链接）\n","date":"2018-10-02T13:18:21Z","permalink":"https://it-boyer.github.io/post/old/xcode/Xcode10%E6%96%B0%E7%89%B9%E6%80%A7/","section":"post","tags":[],"title":"Xcode10新特性"},{"categories":["学习笔记"],"contents":"Perfect简介 {% github PerfectlySoft Perfect 60e44e4 width = 30% %} 目前比较流行服务端框架主要有Vapor、Perfect、Kitura和Zewo，他们各有长短，本人这次主要是使用Perfect来写的，因为Perfect的功能比较完善，在GitHub上具有1W+的星，而且有一个非常重要的原因提供了Perfect 中文文档。\nPerfect 包括了您所期待的所有基本功能，包括路由、websockets 基于 HTTP 的网络套接字、TLS（SSL）通信加密、Mustache 模板和 Markdown 模板、JSON 结构化数据等等，以及全部其他所有 Swift 后台框架加在一起才有的 XML 结构化数据、苹果推送消息 APNS、MqTT 消息队列和 SMTP 邮件发送，甚至大数据也支持。Perfect 的数据库支持非常广泛，其原生SQL驱动包括 MySQL、SQLite、PostgreSQL 和 MariaDB，还支持 MongoDB、Redis、CouchDB 甚至还包括 FileMaker（苹果自己的数据库 Swift 都不支持，Perfect 反过来支持——译者注）。Perfect 据说还部分支持微软的 ODBC，即多种数据库的底层兼容界面——有点像 ORM，但是以 C 函数库为基础。提到 ORM 数据库对象关系自动化管理，Perfect有 StORM 并完整实现了 PostgreSQL、MySQL、CouchDB 和 SQLite。\nPerfect文档生成器\n搭建HTTP服务器 {% github it-boyer PerfectTemplate 20294e56 width = 30% %} 本章将引导您使用Swift和Perfect软件框架逐步设置一个简单的HTTP服务器。\n创建Web应用 原文\n新建一个文件夹保存项目文件： 1 2 $ mkdir iPerfect $ cd iPerfect 初始化项目，用SPM软件包管理器： 1 2 3 4 5 6 7 8 $ swift package init --type=executable Creating executable package: iPerfect Creating Package.swift Creating README.md Creating .gitignore Creating Sources/ Creating Sources/iPerfect/main.swift Creating Tests/ 配置依赖 打开Package.swift文件进行编辑： 该文件在要求Swift编译的最低版本为3.0.0，设置target编译依存库PerfectHTTPServer 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 // swift-tools-version:4.0 // The swift-tools-version declares the minimum version of Swift required to build this package. import PackageDescription let package = Package( name: \u0026#34;iPerfect\u0026#34;, dependencies: [ .package(url: \u0026#34;https://github.com/PerfectlySoft/Perfect-HTTPServer.git\u0026#34;, from: \u0026#34;3.0.0\u0026#34;) ], targets: [ .target( name: \u0026#34;iPerfect\u0026#34;, dependencies: [\u0026#34;PerfectHTTPServer\u0026#34;]), ] ) 编码 1 2 mkdir Sources echo \u0026#39;print(\u0026#34;您好！\u0026#34;)\u0026#39; \u0026gt;\u0026gt; Sources/iPerfect/main.swift 编译和运行 现在项目就已经准备好，可以通过以下两个命令编译和运行： 1 2 swift build .build/debug/iPerfect 成功之后，会打印：\n1 你好！！！ 设置Perfect HTTPServer服务器 注册路由和请求／响应句柄 打开Sources/iPerfect/main.swift文件，把内容替换为以下程序：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 import PerfectHTTP import PerfectHTTPServer // 注册路由和请求／响应句柄 var routes = Routes() routes.add(method: .get, uri: \u0026#34;/\u0026#34;) { request, response in response.setHeader(.contentType, value: \u0026#34;text/html\u0026#34;) response.appendBody(string: \u0026#34;\u0026lt;html\u0026gt;\u0026lt;title\u0026gt;Hello, world!\u0026lt;/title\u0026gt;\u0026lt;body\u0026gt;Hello, world!\u0026lt;/body\u0026gt;\u0026lt;/html\u0026gt;\u0026#34;) .completed() } do { // 启动HTTP服务器 try HTTPServer.launch(.server(name: \u0026#34;www.example.ca\u0026#34;, port: 8181, routes: routes)) } catch { fatalError(\u0026#34;\\(error)\u0026#34;) // fatal error launching one of the servers } 编译运行 1 2 3 4 $ swift build $ .build/debug/iPerfect \u0026gt;\u0026gt; [INFO] Starting HTTP server www.example.ca on :::8181 在浏览器上打开http://127.0.0.1:8181/ 终止服务器：在终端控制台上用组合键control-c可以随时停止服务器。\n使用Xcode调试服务器 生成iPerfect.xcodeproj Swift软件包管理器（SPM）能够为您的项目iPerfect生成Xcode工程：\n1 swift package generate-xcodeproj 递归编译设置 设置递归编译项目目录中的所有target 打开iPerfect.xcodeproj，在检索项目软件库Library Search Paths字典中新增路径：$(PROJECT_DIR) ，路径属性修改为recursive。 recursive：遍历该目录，non-recursive：默认路径设置；不遍历该目录。 如果路径的属性为recursive，那么编译的时候在找库的路径的时候，会遍历该目录下的所有子目录的库文件。 PS：在搭建项目的时候，可以创建一个专门放库文件的文件夹并且设置其属性为recursive:即为$(PROJECT_DIR)/**，相当于遍历项目文件同级下的所有路径(不推荐使用，项目大的话，影响编译的速度)。\nscheme运行在My Mac 在Xcode打开项目之后，选择可执行目标为 My Mac，并选择正确的Swift工具链。 设置服务器的资源目录 为了使服务器能够访问您工程文件夹下的目录，比如html静态网页。 进入菜单命令 Product \u0026gt; Scheme \u0026gt; Edit Scheme…，设置工作目录 Use Custom Working Directory 为项目文件夹。 现在您就可以在Xcode中运行调试您的服务器了.\n","date":"2018-10-02T11:13:35Z","permalink":"https://it-boyer.github.io/post/old/macOS/SPM%E6%90%AD%E5%BB%BAPerfect%E6%A8%A1%E7%89%88%E6%9C%8D%E5%8A%A1%E5%99%A8/","section":"post","tags":["SPM","swift"],"title":"SPM搭建Perfect模版服务器"},{"categories":["学习笔记"],"contents":"概念概述 Package Manager {% github it-boyer PerfectTemplate 20294e56 width = 30% %}\nModules模块 在 Swift 中我们使用模块来管理代码，每个模块指定一个命名空间并强制指定模块外哪些部分的代码是可以被访问控制的。\n一个程序可以将它所有代码聚合在一个模块中，也可以将它作为依赖关系导入到其他模块。除了少量系统提供的模块，像 OS X 中的 Darwin 或者 Linux 中的 Glibc 等的大多数依赖需要代码被下载或者内置才能被使用。\n当你将编写的解决特定问题的代码独立成一个模块时，这段代码可以在其他情况下被重新利用。例如，一个模块提供了发起网络请求的功能，在一个照片分享的 app 或者 一个天气的 app 里它都是可以使用的。使用模块可以让你的代码建立在其他开发者的代码之上，而不是你自己去重复实现相同的功能。\nPackages包 一个包由 Swift 源文件和一个清单文件组成。这个清单文件称为 Package.swift，定义包名或者它的内容使用PackageDescription 模块。 一个包有一个或者多个目标，每个目标指定一个产品并且可能声明一个或者多个依赖。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 import PackageDescription let package = Package( name: \u0026#34;DeckOfPlayingCards\u0026#34;, products: [ .library(name: \u0026#34;DeckOfPlayingCards\u0026#34;, targets: [\u0026#34;DeckOfPlayingCards\u0026#34;]), .executable(name: \u0026#34;Dealer\u0026#34;, targets: [\u0026#34;Dealer\u0026#34;]), ], dependencies: [ .package(url: \u0026#34;https://github.com/apple/example-package-fisheryates.git\u0026#34;, from: \u0026#34;2.0.0\u0026#34;), .package(url: \u0026#34;https://github.com/apple/example-package-playingcard.git\u0026#34;, from: \u0026#34;3.0.0\u0026#34;), ], targets: [ .target( name: \u0026#34;DeckOfPlayingCards\u0026#34;, dependencies: [\u0026#34;FisherYates\u0026#34;, \u0026#34;PlayingCard\u0026#34;]), .testTarget( name: \u0026#34;DeckOfPlayingCardsTests\u0026#34;, dependencies: [\u0026#34;DeckOfPlayingCards\u0026#34;]), ] ) Products产品 一个target可能构建一个.library()库或者一个.executable()可执行文件作为其产品。 .library(name: \u0026quot;\u0026quot;, targets: [])库:是包含用于其他Swift 代码导入该模块 .executable(name: \u0026quot;\u0026quot;, targets: [])可执行文件:是一段可以被操作系统运行的程序。\nDependencies依赖 Dependencies依赖是指Package中代码必须添加的Modules块。Dependencies由.package资源的绝对路径或相对 URL 和包的版本组成。 包管理器的作用是通过自动为工程下载和编译所有依赖的过程中，减少协调的成本。这是一个递归的过程：依赖能有自己的依赖，其中每一个也可以具有依赖，形成了一个依赖相关图。\n用例 创建依赖库lib Package 建一个target表示标准的52张扑克牌的PlayingCard： 1 2 3 mkdir PlayingCard cd PlayingCard swift package init 创建公共实现类 PlayingCard定义PlayingCard类型，它由Suit枚举值(梅花、方块、红心、黑桃)和Rank枚举值(Ace、2、3、…、Jack、Queen、King)组成。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 public enum Rank : Int { case Ace = 1 case Two, Three, Four, Five, Six, Seven, Eight, Nine, Ten case Jack, Queen, King } public enum Suit: String { case Spades, Hearts, Diamonds, Clubs } public struct PlayingCard { let rank: Rank let suit: Suit } 按照约定，一个target所有的源文件都存在相应的Sources/\u0026lt;target-name\u0026gt;目录下，默认情况下，库模块使用public来声明类型和方法，这些类型和方法位于Sources/\u0026lt;target-name\u0026gt;中：\n1 2 3 4 5 6 7 example-package-playingcard ├── Sources │ └── PlayingCard │ ├── PlayingCard.swift │ ├── Rank.swift │ └── Suit.swift └── Package.swift PlayingCard因为不生成executable可执行文件，这种类型的target成为库，当构建一个模块可以被依赖导入使用。\n运行swift build命令，将编译生成PlayingCard模块。 使用 #if #else #endif构建配置语句 创建fisher模块 1 2 3 mkdir fisher cd fisher swift package init fisher与PlayingCard不同，此模块不定义任何新类型。相反，它扩展了现有的类型(特别是CollectionType和MutableCollectionType协议)，以添加shuffle()方法和它的变体副本shuffleInPlace()。 2. 使用构建配置语句 #if #else #endif shuffleInPlace()的实现使用Fisher-Yates算法随机排列集合中的元素。因为Swift标准库不提供随机数生成器，所以该方法必须调用从系统模块导入的函数。为了使该函数与macOS和Linux兼容，代码使用构建配置语句。 在macOS中，系统模块是Darwin，它提供了arc4random_uniform(_:)函数。 在Linux中，系统模块为Glibc，它提供了random()函数:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 #if os(Linux) import Glibc #else import Darwin.C #endif public extension MutableCollectionType where Index == Int { mutating func shuffleInPlace() { if count \u0026lt;= 1 { return } for i in 0..\u0026lt;count - 1 { #if os(Linux) let j = Int(random() % (count - i)))) + i #else let j = Int(arc4random_uniform(UInt32(count - i))) + i #endif if i == j { continue } swap(\u0026amp;self[i], \u0026amp;self[j]) } } } 依赖库导入及使用 DeckOfPlayingCards包将前两个包组合在一起:它定义了一种桥牌类型，该类型在一个PlayingCard值数组上使用fisher()方法。 要使用fisher和PlayingCards模块，必须在DeckOfPlayingCards模块的清单文件Package.swift中声明为它们package依赖项。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 // swift-tools-version:4.0 import PackageDescription let package = Package( name: \u0026#34;DeckOfPlayingCards\u0026#34;, products: [ .library(name: \u0026#34;DeckOfPlayingCards\u0026#34;, targets: [\u0026#34;DeckOfPlayingCards\u0026#34;]), ], dependencies: [ .package(url: \u0026#34;https://github.com/apple/example-package-fisheryates.git\u0026#34;, from: \u0026#34;2.0.0\u0026#34;), .package(url: \u0026#34;https://github.com/apple/example-package-playingcard.git\u0026#34;, from: \u0026#34;3.0.0\u0026#34;), ], targets: [ .target( name: \u0026#34;DeckOfPlayingCards\u0026#34;, dependencies: [\u0026#34;FisherYates\u0026#34;, \u0026#34;PlayingCard\u0026#34;]), .testTarget( name: \u0026#34;DeckOfPlayingCardsTests\u0026#34;, dependencies: [\u0026#34;DeckOfPlayingCards\u0026#34;]), ] ) 每个依赖项指定源URL和from:版本号。 源URL是解析到Git存储库的当前用户可以访问的URL。版本需求遵循语义版本控制(SemVer)约定，用于确定签出哪个Git标签并使用它来构建依赖关系。对于依赖项FisherYates ，将使用最新版本主版本为2(例如，2.0.4)。类似地，PlayingCard依赖项将使用最新版本主版本为3。 当运行swift build命令时，包管理器下载所有依赖项，编译、并链接到包模块。这样DeckOfPlayingCards使用import语句来访问依赖模块中public类型的属性和方法。 您可以在项目根目录下的.build/checkouts目录中看到下载的源代码，在项目根目录下的.build目录中看到中间的构建产品。\n解决依赖传递关系 构建Dealer模块,它依赖于DeckOfPlayingCards包，而DeckOfPlayingCards包又依赖于PlayingCard和fisher包。然而，由于Swift包管理器自动解析传递依赖项，您只需将DeckOfPlayingCards包声明为依赖项即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 // swift-tools-version:4.0 import PackageDescription let package = Package( name: \u0026#34;dealer\u0026#34;, products: [ .executable(name: \u0026#34;Dealer\u0026#34;, targets: [\u0026#34;Dealer\u0026#34;]), ], dependencies: [ .package(url: \u0026#34;https://github.com/apple/example-package-deckofplayingcards.git\u0026#34;, from: \u0026#34;3.0.0\u0026#34;), ], targets: [ .target( name: \u0026#34;Dealer\u0026#34;, dependencies: [\u0026#34;DeckOfPlayingCards\u0026#34;]), ] ) 依赖传递关系也体现在Swift源文件代码import导入一个模块，就可以使用该某块下所有依赖库的类型。例如Dealer模块的main.swift 文件。在DeckOfPlayingCards中的Deck类型和PlayingCard中的PlayingCard类型。尽管Deck类型的shuffle()方法在内部使用了fisher模块，但该模块不需要在main.swift中导入。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 import PlayingCard import DeckOfPlayingCards let numberOfCards = 10 var deck = Deck.standard52CardDeck() deck.shuffle() for _ in 1...numberOfCards { guard let card = deck.deal() else { print(\u0026#34;No More Cards!\u0026#34;) break } print(card) } 构建并运行可执行文件 根据约定，一个target的根目录中包含一个名为main.swift文件，可以构建成一个可执行文件。 运行swift build命令，然后运行.build/debug目录下的Dealer可执行文件。\n1 2 3 4 5 6 7 8 9 10 11 12 $ swift build $ ./.build/debug/Dealer ♠︎6 ♢K ♢2 ♡8 ♠︎7 ♣︎10 ♣︎5 ♢A ♡Q ♡7 两个坑 1 swift package generate-xcodeproj 每次更新或添加库或框架，xcodeproj就需要重新创建一次，不然无法引用到新库或新框架； 在source文件夹如果发生任何改动，库或框架的更新就会失败。 这就是为什么我要专门建一个工程来管理这些框架或者库（这是我踩的最恶心的坑）。为了解决这个大坑，就再创建一个项目工程，然后使用workspace来管理 今天开始用swift写服务器(一) ","date":"2018-10-01T23:57:27Z","permalink":"https://it-boyer.github.io/post/old/swift/%E4%BD%BF%E7%94%A8SPM%E7%AE%A1%E7%90%86%E4%BE%9D%E8%B5%96%E5%BA%93/","section":"post","tags":["swift"],"title":"使用SPM管理依赖库"},{"categories":["学习笔记"],"contents":"直接用 swift 命令执行 xcrun swift可以直接将一个 .swift文件作为命令行工具的输入，这样里面的代码也会被自动地编译和执行。我们甚至还可以在 .swift 文件最上面加上命令行工具的路径，然后将文件权限改为可执行，之后就可以直接执行这个 .swift 文件了：\nhello.swift 1 2 #!/usr/bin/env xcrun swift println(\u0026#34;hello\u0026#34;) 终端设置为可执行权限，并运行打印： 1 2 3 4 \u0026gt; chmod 755 hello.swift \u0026gt; ./hello.swift // 输出： hello 这些特性与其他的解释性语言表现得完全一样\nswiftc 相对于直接用 swift 命令执行，Swift 命令行工具的另一个常用的地方是直接脱离 Xcode 环境进行编译和生成可执行的二进制文件。我们可以使用 swiftc 来进行编译，比如下面的例子：\nMyClass.swift 1 2 3 4 5 6 class MyClass { let name = \u0026#34;XiaoMing\u0026#34; func hello() { println(\u0026#34;Hello \\(name)\u0026#34;) } } main.swift 1 2 let object = MyClass() object.hello() 终端编译运行，将生成一个名叫 main 的可执行文件： 1 2 \u0026gt; xcrun swiftc MyClass.swift main.swift \u0026gt; ./main //运行main文件 利用这个方法，我们就可以用 Swift 写出一些命令行的程序了。\n最后想说明的一个 Swift 命令行工具的使用案例是生成汇编级别的代码。有时候我们想要确认经过优化后的汇编代码实际上做了些什么。swiftc 提供了参数来生成 asm 级别的汇编代码：\n1 swiftc -O hello.swift \u0026gt; hello.asm Swift 的命令行工具还有不少强大的功能，对此感兴趣的读者不妨使用 xcrun swift --help 以及 xcrun swiftc --help 来查看具体还有哪些参数可以使用。\nswiftc -g支持lldb调试 ","date":"2018-10-01T21:02:49Z","permalink":"https://it-boyer.github.io/post/old/swift/Swift%E5%8D%95%E6%96%87%E4%BB%B6%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%B7%A5%E5%85%B7/","section":"post","tags":["swift"],"title":"Swift单文件相关命令行工具"},{"categories":["学习笔记"],"contents":"Using the LLDB Debugger 使用LLDB调试器一步一步地运行Swift程序，通过设置断点调试运行状态。\n创建一个名Factorial.swift，定义了一个factorial(n:)函数，并打印调用该函数的结果: 1 2 3 4 5 6 7 func factorial(n: Int) -\u0026gt; Int { if n \u0026lt;= 1 { return n } return n * factorial(n: n - 1) } let number = 4 print(\u0026#34;\\(number)! is equal to \\(factorial(n: number))\u0026#34;) swiftc命令 运行swiftc命令-g选项生成swift调试信息,在目录中生存可执行的Factorial文件： 1 2 3 4 5 $ swiftc -g Factorial.swift $ ls Factorial.dSYM Factorial.swift Factorial* 使用lldb启动Factorial文件 通过LLDB调试器命令lldb运行: 1 2 3 $ lldb Factorial (lldb) target create \u0026#34;Factorial\u0026#34; Current executable set to \u0026#39;Factorial\u0026#39; (x86_64). 设置断点 使用breakpoint set (b) 命令在factorial(n:)函数的第2行中设置一个断点，每次执行函数时中断进程: 1 2 (lldb) b 2 Breakpoint 1: where = Factorial`Factorial.factorial (Swift.Int) -\u0026gt; Swift.Int + 12 运行调试 使用run (r)命令运行进程。进程在factorial(n:)函数的调用位置停止。 1 2 3 4 5 6 7 8 9 10 11 12 (lldb) r Process 40246 resuming Process 40246 stopped * thread #1: tid = 0x14dfdf, 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -\u0026gt; Swift.Int + 12 at Factorial.swift:2, queue = \u0026#39;com.apple.main-thread\u0026#39;, stop reason = breakpoint 1.1 frame #0: 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -\u0026gt; Swift.Int + 12 at Factorial.swift:2 1 func factorial(n: Int) -\u0026gt; Int { -\u0026gt; 2 if n \u0026lt;= 1 { return n } 3 return n * factorial(n: n - 1) 4 } 5 6 let number = 4 7 print(\u0026#34;\\(number)! is equal to \\(factorial(n: number))\u0026#34;) Use the print (p) command to inspect the value of the n parameter.\n1 2 (lldb) p n (Int) $R0 = 4 The print command can evaluate Swift expressions as well.\n1 2 (lldb) p n * n (Int) $R1 = 16 Use the backtrace (bt) command to show the frames leading to factorial(n:) being called.\n1 2 3 4 5 6 (lldb) bt * thread #1: tid = 0x14e393, 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -\u0026gt; Swift.Int + 12 at Factorial.swift:2, queue = \u0026#39;com.apple.main-thread\u0026#39;, stop reason = breakpoint 1.1 * frame #0: 0x0000000100000e7c Factorial`Factorial.factorial (n=4) -\u0026gt; Swift.Int + 12 at Factorial.swift:2 frame #1: 0x0000000100000daf Factorial`main + 287 at Factorial.swift:7 frame #2: 0x00007fff890be5ad libdyld.dylib`start + 1 frame #3: 0x00007fff890be5ad libdyld.dylib`start + 1 Use the continue (c) command to resume the process until the breakpoint is hit again.\n1 2 3 4 5 6 7 8 9 10 11 12 (lldb) c Process 40246 resuming Process 40246 stopped * thread #1: tid = 0x14e393, 0x0000000100000e7c Factorial`Factorial.factorial (n=3) -\u0026gt; Swift.Int + 12 at Factorial.swift:2, queue = \u0026#39;com.apple.main-thread\u0026#39;, stop reason = breakpoint 1.1 frame #0: 0x0000000100000e7c Factorial`Factorial.factorial (n=3) -\u0026gt; Swift.Int + 12 at Factorial.swift:2 1 func factorial(n: Int) -\u0026gt; Int { -\u0026gt; 2 if n \u0026lt;= 1 { return n } 3 return n * factorial(n: n - 1) 4 } 5 6 let number = 4 7 print(\u0026#34;\\(number)! is equal to \\(factorial(n: number))\u0026#34;) Use the print (p) command again to inspect the value of the n parameter for the second call to factorial(n:).\n1 2 (lldb) p n (Int) $R2 = 3 取消断点 Use the breakpoint disable (br di) command to disable all breakpoints and the continue (c) command to have the process run until it exits. 1 2 3 4 5 6 (lldb) br di All breakpoints disabled. (1 breakpoints) (lldb) c Process 40246 resuming 4! is equal to 24 Process 40246 exited with status = 0 (0x00000000) ","date":"2018-10-01T21:02:49Z","permalink":"https://it-boyer.github.io/post/old/swift/swift%E5%9C%A8%E7%BB%88%E7%AB%AF%E4%BD%BF%E7%94%A8LLDB%E8%B0%83%E8%AF%95/","section":"post","tags":["swift"],"title":"swift在终端使用LLDB调试"},{"categories":["学习笔记"],"contents":"概念概述 getting-started {% github it-boyer PerfectTemplate 20294e56 width = 30% %}\n使用Swift编译系统 Swift 编译系统为编译库、可执行文件和在不同工程之间共享代码提供了基本的约定。\nswift 工具 swift package swift package generate-xcodeproj swift run swift build swift test swift package创建一个HelloSPM 创建Hello目录，目录名会作为SPM名称： 1 2 $ mkdir Hello $ cd Hello swift package初始化为SPM工程 1 2 3 4 5 6 7 8 9 10 $ swift package init ├── Package.swift // 依赖清单文件 ├── README.md ├── Sources // 源码目录 │ └── Hello │ └── Hello.swift └── Tests ├── HelloTests │ └── HelloTests.swift └── LinuxMain.swift 每个包在其根目录下都必须拥有一个命名为Package.swift清单文件。如果清单文件为空，那包管理器将会使用常规默认的方式来编译包。 3. swift build编译SPM 编译会先解析Package.swift项目配置和下载依赖库等环境，然后编译源码\n1 2 $ swift build #编译可执行文件 Compile Swift Module \u0026#39;Hello\u0026#39; (1 sources) swift test运行SPM的单元测试 1 2 3 4 5 6 7 8 9 10 11 12 13 14 $ swift test Compile Swift Module \u0026#39;HelloTests\u0026#39; (1 sources) Linking ./.build/x86_64-apple-macosx10.10/debug/HelloPackageTests.xctest/Contents/MacOS/HelloPackageTests Test Suite \u0026#39;All tests\u0026#39; started at 2016-08-29 08:00:31.453 Test Suite \u0026#39;HelloPackageTests.xctest\u0026#39; started at 2016-08-29 08:00:31.454 Test Suite \u0026#39;HelloTests\u0026#39; started at 2016-08-29 08:00:31.454 Test Case \u0026#39;-[HelloTests.HelloTests testExample]\u0026#39; started. Test Case \u0026#39;-[HelloTests.HelloTests testExample]\u0026#39; passed (0.001 seconds). Test Suite \u0026#39;HelloTests\u0026#39; passed at 2016-08-29 08:00:31.455. Executed 1 test, with 0 failures (0 unexpected) in 0.001 (0.001) seconds Test Suite \u0026#39;HelloPackageTests.xctest\u0026#39; passed at 2016-08-29 08:00:31.455. Executed 1 test, with 0 failures (0 unexpected) in 0.001 (0.001) seconds Test Suite \u0026#39;All tests\u0026#39; passed at 2016-08-29 08:00:31.455. Executed 1 test, with 0 failures (0 unexpected) in 0.001 (0.002) seconds 创建一个可执行的SPM 可运行的SPM必须包含main.swift文件。SPM会把main.swift编译成可执行文件的二进制文件。 在本例中，SPM将生成一个名为Hello的可执行文件，输出“Hello, world!”\n创建 1 2 3 $ mkdir Hello $ cd Hello $ swift package init --type executable 两种运行方式 2.1 先编译在运行 1 2 3 4 5 6 $ swift build Compile Swift Module \u0026#39;Hello\u0026#39; (1 sources) Linking ./.build/x86_64-apple-macosx10.10/debug/Hello $ .build/x86_64-apple-macosx10.10/debug/Hello Hello, world! 2.2 swift run直接运行\n1 2 3 4 $ swift run Hello Compile Swift Module \u0026#39;Hello\u0026#39; (1 sources) Linking ./.build/x86_64-apple-macosx10.10/debug/Hello Hello, world! 多个源文件协作 下一步，让我们在新的资源文件里定义一个新的方法 sayHello(_:) 然后直接用 print(_:) 替换执行调用的内容。 在 Sources/ 目录下创建一个新文件命名为 Greeter.swift 然后输入如下代码： 1 2 3 func sayHello(name: String) { print(\u0026#34;Hello, \\(name)!\u0026#34;) } sayHello(_:) 方法带一个单一的字符串参数，然后在前面打印一个 “Hello”，后面跟着函数参数单词 “World”。\n现在打开 main.swift， 然后替换原来的内容为下面代码：\n1 2 3 4 5 6 if Process.arguments.count != 2 { print(\u0026#34;Usage: hello NAME\u0026#34;) } else { let name = Process.arguments[1] sayHello(name) } 跟之前的硬编码不同，main.swift 现在从命令行参数中读取。替代之前直接调用 print(_:)， main.swift 现在调用 sayHello(_:) 方法。因为这个方法是 Hello 模块的一部分，所以不需要使用到 import 语句。\n运行 swift build 并尝试 Hello 的新版本：\n1 2 $ swift build $ .build/debug/Hello \u0026#39;whoami\u0026#39; 目前为止，你已经能够运用开源 Swift 来运行一些你想要的程序了 。 要了解Swift包管理器，包括如何构建模块、导入依赖项和映射系统库，请参阅网站的Swift包管理器部分。\n","date":"2018-10-01T14:52:23Z","permalink":"https://it-boyer.github.io/post/old/swift/SPM%E7%9B%B8%E5%85%B3%E5%91%BD%E4%BB%A4%E5%B7%A5%E5%85%B7/","section":"post","tags":["swift"],"title":"SPM相关命令工具"},{"categories":["学习笔记"],"contents":"利用JavaScript构建OSX应用 Example OS X applications written in JavaScript. JavaScript for Automation Cookbook 廖雪峰的JavaScript教程 W3Cschool javascript教程 JavaScript快速入门\n使用场景 UIAutomation的简单使用方法 如何使用UIAutomation进行iOS 自动化测试（Part I） JavaScript for OS X Automation by Example JavaScript For Automation iOS 程序员效率提升利器之 AppleScript Numbers入门 \u0026mdash; 附录：脚本 AppleScript 与 Numbers\n","date":"2018-09-29T18:35:50Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E5%88%A9%E7%94%A8JavaScript%E6%9E%84%E5%BB%BAOSX%E5%8E%9F%E7%94%9F%E5%BA%94%E7%94%A8/","section":"post","tags":["JS"],"title":"利用JavaScript构建OSX原生应用"},{"categories":["解决方案"],"contents":"出现的问题主要有两点 数据恢复问题 1）修改用户名后，mac系统认为是创建了一个新的用户，这时候，之前管理员账号的数据在当前用户的finder里是看不到的。这时候可以去到桌面，点击又上角的“前往” 。 管理员权限问题 虽然数据问题恢复了，但是另外一个更严重的问题又出现了。新的用户名账号只是一个普通用户账号，没有管理员权限没有管理员权限了。在需要管理员权限的操作中输入具有管理员权限的前用户名和密码也不认了。 解决办法： 创建一个新的具有管理员权限的用户 第一步：重启电脑，并长按组合键：command+s进入Single User Model模式，出现像DOS一样的提示符 。 第二步：在命令行顺序输入命令： 1 2 3 4 fsck -y mount -uaw / rm /var/db/.AppleSetupDone reboot 苹果电脑会重启，并且在开机后出现新装机时的欢迎界面。重新建立一个新的管理员账号。\n","date":"2018-09-25T19:16:53Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E4%BF%AE%E6%94%B9Mac%E7%94%A8%E6%88%B7%E5%90%8D%E5%AF%BC%E8%87%B4%E4%B8%A2%E5%A4%B1%E7%AE%A1%E7%90%86%E5%91%98%E6%9D%83%E9%99%90%E9%97%AE%E9%A2%98%E4%BF%AE%E5%A4%8D/","section":"post","tags":["macOS"],"title":"修改Mac用户名导致丢失管理员权限问题修复"},{"categories":["学习笔记"],"contents":"使用了Vim之后，被其强大的文本编辑能力吸引, 于是每天都在寻找 Vim 插件, 试图用 Vim 代替 Xcode 进行日常开发. 直到有一天突然发现, 我想要的就是一个拥有强大文本编辑能力的 Xcode. 分享一个自定义快捷键完整版\n常用操作 Xcode虽然没有 Vim 的模式切换, 但是也可以使用大部分文本操作, 这里主要用到的是:\n删除: 完全删除单行, 删除单行到行首, 删除词组, 删除单词, 删除段落 替换: 替换单行, 替换词组 复制: 复制行尾词组, 复制词组, 复制单行. 另外还有向前删除单行, 向后删除单行, 全局替换, 剪切单行, 格式化粘贴单行等. 系统自带快捷操作 首先 Xcode 原生自带的快捷键就非常实用了, CMD+, 打开Preferences-\u0026gt;Code Binding-\u0026gt;Text 可以看到常用的选择, 删除, 搜索等快捷操作, 如 Move Word Right =\u0026gt; ⌥+→ : 光标向右按单词移动.\n自定义快捷操作 实际使用时发现系统提供的删除只可以删除单词或词组某一方向的字符: 系统快捷键演示： 自定义快捷键 所以, 决定自行添加快捷操作, 而 Xcode 本身就是一个OSX 应用程序, 所以我们可以找到相关文件去配置快捷操作。\n了解并编辑IDETextKeyBindingSet.plist Application-\u0026gt;Xcode.app-\u0026gt;Contents-\u0026gt;Frameworks-\u0026gt;IDEKit.framework-\u0026gt;Resources-\u0026gt;IDETextKeyBindingSet.plist 使用编辑器打开IDETextKeyBindingSet.plist, 自行添加快捷操作: 1 2 \u0026lt;key\u0026gt;Delete Current Word\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;moveLeft:, moveWordRight:, deleteWordBackward:\u0026lt;/string\u0026gt; 自定义快捷键演示 其中Cut Current Line 是显示在 Xcode 偏好设置内的快捷操作.moveToEndOfLine 是编辑器的文本操作相关的 编辑器API, 可以组合类似的 API 自定义操作. 2. 更新到xcode设置快捷键 编辑完成后, 重新打开 Xcode-\u0026gt;Preferences-\u0026gt;Key Bindings-\u0026gt;Customized, 为自定义的快捷操作添加快捷键. 分享一个自定义快捷键完整版\n","date":"2018-09-20T21:12:51Z","permalink":"https://it-boyer.github.io/post/old/xcode/%E8%87%AA%E5%AE%9A%E4%B9%89Xcode%E6%94%AF%E6%8C%81Vim%E5%BF%AB%E6%8D%B7%E9%94%AE/","section":"post","tags":["xcode"],"title":"自定义Xcode支持Vim快捷键"},{"categories":["项目总结"],"contents":"\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 title 巡查及处理整合迭代 center header 巡查执法及处理整合设计实现图 endheader \u0026#39;******* 类声明模块 *******\u0026#39; \u0026#39;类型:class,abstract,interface,annotation,enum\u0026#39; \u0026#39;访问域:(-)私有,(#)保护,(~)包私有,(+)公有\u0026#39; class TagCenter{ -- 私有属性-- \u0026#39;分隔符--,..,==,__\u0026#39; IBOutlet UIScrollView *titleScrollView; IBOutlet UIScrollView *contentScrollView; NSMutableArray *titleLabels; IBOutlet PatrolSearchBar *ibSearchBar; IBOutlet UIView *ibErrorView; ReqFilterStoreModel *filterModel; __初始化 滚动标题方法__ // 初始化UIScrollView - (void)setUpScrollView // 添加所有子控制器对应标题 - (void)setUpTitleLabel // 添加所有子控制器 - (void)setUpChildViewController } package 过滤工具 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ class JHTagListView{ --动画属性-- IBOutlet NSLayoutConstraint *ibTableViewToLeftViewConut; IBOutlet NSLayoutConstraint *ibShadeToFilterViewConut; --方法-- -(void)setupFilterView:(NSArray *)dataArray; -(void)loadDataList:(dispatch_group_t)group; -(void)showListView; } JHTagListView *-- JHFilterStoreTypeCell UICollectionView ()- JHFilterStoreTypeCell class JHFilterStoreTypeCell{ --接口属性-- NSString *typeName; NSArray *tagArr; } JHTagListView *-- JHFilterPatrolTimeCell class JHFilterPatrolTimeCell{ } JHFilterPatrolTimeCell *-- DateAlertPickerController class DateAlertPickerController{ } note left of DateAlertPickerController 时间选择器的封装 end note note right of JHFilterPatrolTimeCell 定义时间cell样式 end note note top of JHFilterStoreTypeCell 定义业态类型样式 end note } \u0026#39;显示/隐藏类,类方法属性等 关键字支持class,interface,enum\u0026#39; \u0026#39;---- 声明类关系线备注,可以当做用例来参与到关系连接中 ---\u0026#39; note \u0026#34;实现过滤UI及业务的类\u0026#34; as filterClassnote \u0026#39;###### 类备注模块 类声明末尾使用:note 位置: 备注#########\u0026#39; note left of TagCenter #red 整个框架的主体：包括搜索框/过滤条件列表/滚动标签 end note \u0026#39;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; 类组合模块 类模块 \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026#39; \u0026#39;六种组合样式:Node,Rectangle,Folder,Frame,Cloud,Database\u0026#39; package tagList \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ class tagBase{ -- 属性-- \u0026#39;分隔符--,..,==,__\u0026#39; TagListType curTagType; //标签类型 NSMutableArray *dataArray; //列表数据源 __ getter/setter方法__ -(NSMutableArray *)dataArray //通过标签类型过滤出当前列表的数据源 } package 基础类 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt; { class JHTagBanLiModel{ ddd } class JHTagBanliCell{ ddd } } package 巡查执法 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ tagBase \u0026lt;|-- DaiBan class DaiBan{ --属性-- tagtype redhot //红点显示 --方法-- tableView } tagBase \u0026lt;|-- YiBanVC package YiBan \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ class YiBanVC{ dddd } YiBanVC *-- YiBanCellView JHTagBanliCell \u0026lt;|-- YiBanCellView tagBase \u0026lt;|-- Guanli class Guanli{ --属性-- tagtype --方法-- tableView } } } package 自检自查 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ tagBase \u0026lt;|-- YiZCha class YiZCha{ --属性-- tagtype --方法-- tableView } tagBase \u0026lt;|-- WeiZCha class WeiZCha{ --属性-- tagtype --方法-- tableView } } } \u0026#39;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 类关系图及连接备注模块 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#39; \u0026#39;关系节点符:(|\u0026gt;)继承,(*)合成 ,(o)聚合, 其他#,x,},+,^ 连线符:(--)实线 ，(..)虚线\u0026#39; TagCenter \u0026#34;1\u0026#34; *-down[#red]- \u0026#34;3+2\u0026#34;tagBase:列表基类 \u0026gt; note left on link #green 解偶列表与搜索功能相关的UI和业务 end note TagCenter \u0026#34;1\u0026#34; *-down[#red]- \u0026#34;1\u0026#34;JHTagListView:过滤条件列表 \u0026gt; center footer 类图实现设计图 endfooter ","date":"2018-09-13T19:22:55Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%B7%A1%E6%9F%A5%E8%87%AA%E6%9F%A5%E6%95%B4%E5%90%88%E7%B1%BB%E5%9B%BE/","section":"post","tags":[],"title":"巡查自查整合类图"},{"categories":["解决方案"],"contents":"检查是否安装： 1 chsh 打印：\n安装 Debian / Ubuntu 安装：\n1 $ sudo apt-get install zsh zsh直接启动：\n1 zsh 安装oh-my-zsh样式工具 在hexoDeploy项目根目录执行：\n1 sh Util/oh-my-zsh/installTemplate.sh 会提示sed文件修改失败的错误：\n1 sed: can\u0026#39;t read s#export ZSH=.*#export ZSH=\u0026#39;/home/cabox/workspace/it-boyer.github.io/Util/oh-my-zsh\u0026#39;#g: No such file or directory 暂时通过手动来修改：\n1 vi ../oh-my-zsh/templates/zshrc.zsh-template 修改如下：\n1 export ZSH=\u0026#39;/home/cabox/workspace/it-boyer.github.io/Util/oh-my-zsh\u0026#39; 安装space-vim工具 执行 1 sh Util/space-vim/Manualinstall.sh 创建替身失败的提示：\n1 2 3 /home/cabox/workspace/it-boyer.github.io 已经存在 Util/space-vim/Manualinstall.sh: 18: Util/space-vim/Manualinstall.sh: Syntax error: \u0026#34;(\u0026#34; unexpected 手动解决创建替身的：\n1 2 $ ln -fs /home/cabox/workspace/it-boyer.github.io/Util/space-vim/init.vim ~/.vimrc $ ln -fs /home/cabox/workspace/it-boyer.github.io/Util/space-vim/init.spacevim ~/.spacevim 安装vim插件 启动vim工具，终端自动安装相关插件。\n","date":"2018-09-13T11:25:14Z","permalink":"https://it-boyer.github.io/post/old/shell/%E5%9C%A8Codeanywhere%E4%B8%8A%E4%BD%BF%E7%94%A8zsh%E7%BB%88%E7%AB%AF%E5%8F%8A%E9%AB%98%E4%BA%AE%E6%A0%B7%E5%BC%8F/","section":"post","tags":["shell"],"title":"在Codeanywhere上使用zsh终端及高亮样式"},{"categories":["博客站务"],"contents":" {% github hexojs site e1839be width = 30% %}\nHexo 有强大的插件系统，使您能轻松扩展功能而不用修改核心模块的源码。在 Hexo 中有两种形式的插件：\n脚本（Scripts） 如果您的代码很简单，建议您编写脚本，您只需要把 JavaScript 文件放到 scripts 文件夹，在启动时就会自动载入。\n插件（Packages） 如果您的代码较复杂，或是您想要发布到 NPM 上，建议您编写插件。首先，在 node_modules 文件夹中建立文件夹，文件夹名称开头必须为 hexo-，如此一来 Hexo 才会在启动时载入否则 Hexo 将会忽略它。\n文件夹内至少要包含 2 个文件：一个是主程序，另一个是 package.json，描述插件的用途和所依赖的插件。\n1 2 3 . ├── index.js └── package.json package.json 中至少要包含 name, version, main 属性，例如：\n1 2 3 4 5 6 package.json { \u0026#34;name\u0026#34;: \u0026#34;hexo-my-plugin\u0026#34;, \u0026#34;version\u0026#34;: \u0026#34;0.0.1\u0026#34;, \u0026#34;main\u0026#34;: \u0026#34;index\u0026#34; } 工具 您可以使用 Hexo 提供的官方工具插件来加速开发： hexo-fs：文件 IO hexo-util：工具程式 hexo-i18n：本地化（i18n） hexo-pagination：生成分页资料\n发布 当您完成插件后，可以考虑将它发布到 插件列表，让更多人能够使用您的插件。发布插件的步骤和 更新文件 非常类似。\nFork hexojs/site 把库（repository）复制到电脑上，并安装所依赖的插件： 1 2 3 $ git clone https://github.com/\u0026lt;username\u0026gt;/site.git $ cd site $ npm install 编辑 source/_data/plugins.yml，在档案中新增您的插件，例如： 1 2 3 4 5 6 7 - name: hexo-server description: Server module for Hexo. link: https://github.com/hexojs/hexo-server tags: - official - server - console 推送（push）分支. 建立一个新的合并申请（pull request）并描述改动。 ","date":"2018-09-07T15:08:22Z","permalink":"https://it-boyer.github.io/post/old/hexo/Hexo%E6%8F%92%E4%BB%B6%E5%BC%80%E5%8F%91/","section":"post","tags":["hexo"],"title":"Hexo插件开发"},{"categories":["博客站务"],"contents":" {% github hexojs hexo 0b26940 width = 30% %}\n开始之前 请遵守以下准则：\n遵守 Google JavaScript 代码风格。 使用 2 个空格缩排。 不要把逗号放在最前面。 工作流程 Fork hexojs/hexo 把库（repository）复制到电脑上，并安装所依赖的插件: 1 2 3 4 $ git clone https://github.com/\u0026lt;username\u0026gt;/hexo.git $ cd hexo $ npm install $ git submodule update --init 新增一个功能分支: 1 $ git checkout -b new_feature 开始开发。 推送（push）分支: 1 $ git push origin new_feature 建立一个新的合并申请（pull request）并描述变动. 注意事项 不要修改 package.json 的版本号。 只有在测试通过的情况下您的合并申请才会被批准，在提交前别忘了进行测试。\n1 $ npm test ","date":"2018-09-07T15:08:22Z","permalink":"https://it-boyer.github.io/post/old/hexo/Hexo%E5%BC%80%E5%8F%91%E6%96%87%E6%A1%A3%E5%8F%8A%E4%BD%BF%E7%94%A8%E6%95%99%E7%A8%8B/","section":"post","tags":["hexo"],"title":"Hexo开发文档及使用教程"},{"categories":["解决方案"],"contents":"zeroTier内网穿透 ","date":"2018-09-05T18:29:50Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/zeroTier%E5%86%85%E7%BD%91%E7%A9%BF%E9%80%8F/","section":"post","tags":["智能设备"],"title":"zeroTier内网穿透"},{"categories":["学习笔记"],"contents":"trello 卡片 git log使用 查看提交历史 来看一个实际的例子，如果要查看 Git 仓库中，2008 年 10 月期间，Junio Hamano 提交的但未合并的测试脚本（位于项目的 t/ 目录下的文件），可以用下面的查询命令：\n1 2 3 4 5 6 7 8 $ git log --pretty=\u0026#34;%h - %s\u0026#34; --author=gitster --since=\u0026#34;2008-10-01\u0026#34; \\ --before=\u0026#34;2008-11-01\u0026#34; --no-merges -- t/ 5610e3b - Fix testcase failure when extended attribute acd3b9e - Enhance hold_lock_file_for_{update,append}() f563754 - demonstrate breakage of detached checkout wi d1a43f2 - reset --hard/read-tree --reset -u: remove un 51a94af - Fix \u0026#34;checkout --track -b newbranch\u0026#34; on detac b0ad11e - pull: allow \u0026#34;git pull origin $something:$cur Git 项目有 20,000 多条提交，但我们给出搜索选项后，仅列出了其中满足条件的 6 条。\ngitk图形工具 ","date":"2018-09-05T15:52:33Z","permalink":"https://it-boyer.github.io/post/old/git/git-log%E7%9A%84%E4%BD%BF%E7%94%A8/","section":"post","tags":["git"],"title":"git-log的使用"},{"categories":["学习笔记"],"contents":" {% github realm jazzy 6932e5e width = 30% %}\ndemo {% github appcoda SwiftDocSample 24c1649 width = 30% %}\n使用 Jazzy 产生代码文档 Jazzy 是一款可以为 Swift 和 Objective-C 代码产生具有 Apple 风格的代码文档工具。事实上，Jazzy 会为你创建一个链接所有代码文档的独立网页。它是一款命令行工具，但还是很容易使用的。 在 Xcode 中使用 Markdown 生成 Swift 代码文档\n安装 1 $ sudo gem install jazzy gem source不稳定常会导致无法找到jazzy\n1 2 3 4 $ gem sources --add https://gems.ruby-china.com/ --remove https://rubygems.org/ $ gem sources -l https://gems.ruby-china.com # 确保只有 gems.ruby-china.com 腾讯云： https://gems.ruby-china.com/ 淘宝：https://ruby.taobao.org/\n使用 使用 cd 命令将目录切换到工程对应的目录：\n1 2 cd path_to_project_folder Jazzy 输入 Jazzy 之后敲回车,会将标注为 public 的结构写入代码文档。 如果你想要包含所有的实体，就输入一下：\n1 jazzy --min-acl internal 默认输出的文件夹位于工程的根目录（你也可以更改输出路径），叫 docs。 当jazzy不支持swift版本时，会导致错误：\n1 2 Could not parse compiler arguments from `xcodebuild` output. Please confirm that `xcodebuild` is building a Swift module. 这是就需要在build settings中设置swift Language Version版本号。\n生成指定的swift版本 如果不是 Swift 的最新版本，发现使用 Jazzy 后没有效果的话，需要先指定 Xcode 支持的 Swift 版本：\n1 jazzy --swift-version 2.1.1 --min-acl internal 帮助 jazzy -help查看使用 Jazzy 时可能使用到的参数。当然，你完全可以根据自己的喜好来得到最终的结果。\n集成Xcode 在项目中添加运行脚本，或创建 其他\u0026ndash;\u0026gt;Aggregate在build phases下添加New run script phase\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 author=\u0026#34;iTBoyer\u0026#34;; author_url=\u0026#34;http://it-boyer.github.io\u0026#34;; github_url=\u0026#34;https://github.com/it-boyer\u0026#34;; sdk=\u0026#34;iphone\u0026#34;; output=\u0026#34;docs/swift_output\u0026#34;; #生成的文档地址 docSetDir=\u0026#34;/Users/admin/Library/Developer/Shared/Documentation/DocSets/\u0026#34; jazzy \\ --objc \\ --clean \\ --author \u0026#34;${author}\u0026#34;\\ --author_url \u0026#34;${author_url}\u0026#34; \\ --github_url \u0026#34;${github_url}\u0026#34; \\ --module-version 0.96.2 \\ --xcodebuild-arguments -scheme,\u0026#34;${PROJECT_NAME}\u0026#34; \\ --module \u0026#34;${PROJECT_NAME}\u0026#34; \\ --sdk \u0026#34;${sdk}\u0026#34; \\ --output \u0026#34;${output}\u0026#34; \\ #拷贝到xcode文档目录中 echo \u0026#34;${output}/docsets/${PROJECT_NAME}.docset\u0026#34; pwd cp -r \u0026#34;${output}/docsets/${PROJECT_NAME}.docset\u0026#34; \u0026#34;${docSetDir}\u0026#34; 安装到Xcode，在编写代码时，可以快速查看帮助。\n1 2 3 4 #拷贝到xcode文档目录中 echo \u0026#34;${output}/docsets/${PROJECT_NAME}.docset\u0026#34; pwd cp -r \u0026#34;${output}/docsets/${PROJECT_NAME}.docset\u0026#34; \u0026#34;${docSetDir}\u0026#34; 工具推荐 appledoc工具install 方法和更新方法相同 1 2 3 git clone git://github.com/tomaz/appledoc.git cd ./appledoc sudo sh install-appledoc.sh dash插件的使用 下载 ","date":"2018-09-05T15:52:33Z","permalink":"https://it-boyer.github.io/post/old/macOS/Jazzy%E7%94%9F%E6%88%90Swift%E6%96%87%E6%A1%A3%E5%B7%A5%E5%85%B7/","section":"post","tags":["工具"],"title":"Jazzy生成Swift文档工具"},{"categories":["解决方案"],"contents":"trello卡片 LaunchPad学习 第二期：Chain的选择与设置/页数的映射\n分轨和音频采样\n音频轨道 拖拽音频文件或视频文件到Simple采样轨道中，视频格式会生成asd格式的新文件文件，加载到轨道中。\nMIDI轨道可以为Lights 1.1 灯光轨道 1.2 鼓点设置\n鼓点音色映射设置，来输出不同的音乐片段 拖动IB控件到MIDI模块 鼓点灯光映射设置 拖进MIDI Effects rack控件 1.1 点击黄色选项：展开Key:vel:chain:Hide页面 1.2 右击蓝色条，选择map selecter 1.3 选中右上角的MIDI切换到设置MIDI映射键模式。 1.4 选中第一个表盘，选中LauchPad上的 A—B，来映射页数的设置 1.5 新建八个chain，错位蓝色条，完成页数映射的设置 1.6 逐个选中不同的chain，在每一个chain中嵌套MIDI Effect Rock控件 第三期：关于分轨和音频采样 reddit.com beatport.com splice.com 选中页数1的chain ，展开drum rack模块，点击launchpad上键盘，会高亮显示映射的鼓点位置，这时将采样的音色拖拽到改鼓点位置，再次点击launchpad键垫就可以播放音色片段。\n第四期：基础灯光效果制作\nArpeggiator （A效果器） 设置纵横方向的属性变化 效果：垫子灯光会从左到右，从下向上的走马灯式的移动。通过arpeggiator设置移动速度，范围\nrate速度：1/1一拍移动一下最慢，1/128最快。\nGate范围：1—200：依据灯光速率的亮度百分率率来看，1%:亮度不高，200%：可以在一个键上激活两个相邻的灯光\nstyle：纵向变化的方向：up/down/upDown/DownUp\u0026hellip;\nHold激活不用长按，即可厂量\nrepeats：设置走马灯的循环次数\nA效果器在灯光效果包中，放置的位置不同起到不同效果，例如一个灯光效果在A效果器之后，则会将A效果器的属性应用到后续其他的灯光效果上。\nChord （和弦） 拖拽到Key列表中的一个垫子的灯光效果包上。 chord提供六个属性shift1，shift2\u0026hellip;.shift6，来设置和弦灯光错位，融合等效果 第一个旋钮设置1 ：说明灯光向右边移动一个单位。即当点击当前垫子时，右边相邻的垫子的灯光也会一起亮 第二个按钮shift2设置+2：灯光向右联动两个单位，右边相邻的两个垫子的灯光都点亮。 以此类推 一个key上可以添加多个chord：根据偏移量来激活周边的垫子灯光。+4亮起四分之一，+16：亮起半屏，-16：四分之三亮起 -32：整个lPD全亮 MIDI Effect Rack 在主MIDI effect Rack中的chain中映射出的页数中，再嵌套子MIDI effect Rack这样每一页都可以设置自己的灯光效果。 设置灯光效果包\n选中嵌套的子MIDIeffect rack，展开chain模块 ，右击新建一个chain，即代表着一个灯光效果 选中key，点击lauchpad垫子，在钢琴键位为标红显示，即可定位将要设置灯光效果的键。即：绿色区域定位点击的键垫位置 新建Velocity（力度感应） 新建chord（和弦） 新建Arpeggiator（A效果器） Note Length Pitch Random Scale\nVelocity：力度感应 拖到刚才的chain上，即在该键上添加力度感应属性设置。 设置灯光颜色：Out Hi的表盘参数，参考MIni支持的灯光色值 ","date":"2018-09-05T15:52:33Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/LaunchPad%E6%89%93%E5%87%BB%E5%9E%AB%E5%AD%A6%E4%B9%A0/","section":"post","tags":["智能设备"],"title":"LaunchPad打击垫学习"},{"categories":["学习笔记"],"contents":"swift支持的正则（textKit） 正则表达式语法 iOS开发之详解正则表达式原文：NSRegularExpression Tutorial: Getting Started nshipster文章NSPredicate iOS中的谓词（NSPredicate）使用\n谓词和正则表达式的区别及适用场景 谓词的对象可以是字符串，集合，同时支持sql语法和正则表达式 正则表达式，对字符串 正则表达式 简短的定义：正则表达式提供了一种在指定文本文档中按指定模式进行搜索，并能基于匹配模式进行修改文本的一种方式。 正则表达式的通用用例：\n执行搜索：高亮显示搜索和替换 UITextView的NSAttributedString属性来高亮显示搜索的结果 用text kit来实现高亮的功能 验证用户输入 ","date":"2018-09-05T15:52:33Z","permalink":"https://it-boyer.github.io/post/old/swift/swift%E6%94%AF%E6%8C%81%E7%9A%84%E6%AD%A3%E5%88%99textKit/","section":"post","tags":["swift"],"title":"swift支持的正则（textKit）"},{"categories":["博客站务"],"contents":"启动heroku 终端 Heroku Exec (SSH Tunneling) 每个Heroku exec连接最多持续一个小时。一小时后，您可能需要重新连接。Heroku exec在对Shield Private Spaces是不限制的。\n先在该目录初始化环境\n1 heroku create myhexo 创建 1 heroku ps:exec bash 1 2 3 4 heroku run bash // Heroku ps:stop run #停止所有的dynos 再执行heroku run bash 查看正在运行的bash 1 Heroku run:detached ls 退出 1 Heroku dyno:kill dyno 重启 1 Heroku dyno:restart [dyno] ","date":"2018-09-05T14:03:39Z","permalink":"https://it-boyer.github.io/post/old/hexo/heroku%E7%9A%84SSH%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4/","section":"post","tags":["hexo"],"title":"heroku的SSH终端命令"},{"categories":["解决方案"],"contents":"参考 lldb官方文档 苹果文档 LLDB调试器使用简介 南峰子译 调试：案例学习 系统翻译文章 Debugging iOS binaries with LLDB 高级LLDB调试 LLDB中使用python概览\n善用LLDB 如果想断点到某种场景，不是先随意打个断点然后一直单步到出问题的那行代码，最佳的做法是充分利用LLDB的特性以一次性定位到你所感兴趣的代码。\n自定义数据类型 因为LLDB默认是只输出系统类型的，而并不认识自定义的数据类型，所以需要告诉LLDB你所关注的自定义数据类型及其数据，实现对数据的查看。 合理开销 为了避免重新构建所带来的时间开销，你需要学会编写调试代码，以改变应用的执行路径，并修改数据，比如初始化还未初始代的数据。你所输入并执行的表达式会改变应用原本的执行路径，所以对此所带来的副作用你需要有清晰的把控。 正确的调试过程 想通过LLDB获取什么信息？ 断点到可疑的代码块 在正在执行的代码中一步步执行 观察数据并验证猜想 LLDB的使用时机和作用 什么时候用LLDB,LLDB能在调试的时候怎样帮助你\ndebug-Only assertion 它能帮助你知道应用中的运行异常，以及各组件之间传递的参数是否与约定的一致。但是不要在assertion中做对应用逻辑有影响的操作，因为一旦构建发布版本，这些assertion都会被屏幕，你在其中执行的操作也就不会进行了。 所以，当发现bug时，LLDB并不是你的第一选择，而应该是debug-Only assertion。 log apple system log(ASL) 而对于在运行中各处都看起来很正常，最终却呈现了错误的结果的情况，log会是一个非常有用的工具。而此处的log指的并不是NSLog，而是apple system log(ASL)，其可以通过console观察到。 level ASL可以通过log的level来区分log的严重程序，比如ASL_LEVEL_EMERG和ASL_LEVEL_DEBUG。 tag 同时还可以附带使用hash tag以方便log的查找，比如为特定的业务添加特定的业务字符串等。而鉴于log可能被滥用，所以ASL可以通过开关提供某些log是否应该进行。 正常的开关方式可以是可以使用NSUserDefaults等，或者也可以在shell中设置一个变量，程序在运行的时候读取此值以决定是否进行log。 Xcode 静态代码分析器 Xcode可以为程序做的，-Weverything和静态代码分析器可以在代码运行前的编译阶段即发现可能存在的问题。可以在之前的session： What\u0026rsquo;s New In LLVM和What\u0026rsquo;s New In the LLVM Compiler中找到相关内容。而在运行期间可以通过Guard Malloc发现堆上缓存overrun的问题，通过zombie objects获取对释放了的对象进行方法调用的问题。具体可以参见Advanced Memory Analysis with Instruments LLDB的正确打开方式 两种启模式：一种是通过Xcode上的按钮，另一种是通过console中的lldb调试语言。 三种命令表达式：discoverable,abbreviated及alias形式， discoverable格式: expression \u0026ndash;object-description \u0026ndash; foo abbreviated格式: e -0 \u0026ndash; foo alias格式: po foo 同一个命令三种方式，书写繁琐程度递减，而且可以定义自己的alias 形式的命令。 设置断点 行号断点：b MyCode.m:4（breakpoint set --file MyCode.m --line 4） 方法断点：b \u0026quot;-[MyClass method:]\u0026quot;（breakpoint set --name \u0026quot;-MyClass method:]\u0026quot;） selector断点: b method:（breakpoint set --selector method:） 省时的命令 鉴于在app及Xcode之间因为多次中断而进行的多次切换，可以在断点发生之后执行特定的命令，比如希望查看的数据之后再立即恢复执行\n1 2 3 4 5 6 b \u0026#34;-[MyClass method:]\u0026#34; br co a/breakpoint command add \u0026gt;p rect/expression rect \u0026gt;bt/thread backtrace \u0026gt;c/process continue \u0026gt;DONE 这些命令也可以在Xcode面板中通过点击及输入完成同样的功能。\n条件断点 如果不希望断点频繁触发，可以通过条件断点来达到此目的，比如想在某个特定对象析构的消息处断点，可以这样：\n1 2 3 p id $myModel = self/expression id $myModel = self b \u0026#34;-[MyClass dealloc]\u0026#34;/breakpoint set \u0026#34;-[MyClass dealloc]\u0026#34; br m -c \u0026#34;self == $myModel\u0026#34;/breakpoint modify --condition \u0026#34;self == $myModel\u0026#34; 通过watchpoint监控特定内存空间 watchpoint的应用场景在于有人会修改某个变量值，你对此很关心但只知道变量的地址，其行为方式是如果变量被访问则watchpoint会暂停app的运行，设置watchpoint的方式是\n1 w s v self-\u0026gt;_needsSynchronization/watchpoint set variable self-\u0026gt;_needsSynchronization 受限于CPU的支持程度，在intel平台上，提供了4个slot供watchpoint使用，所以同时只可设置最多4个watchpoint，arm上是2个 watchpoint也可以在Xcode的控制面板中进行操作，只需要在变量区域中右击某变量选择菜单中的watchpoint选项即可\n避免不断单步的高招 LLDB可以在两种场景下暂停程序的执行：\n执行到程序的具体某行代码的时候 这种场景的实用命令是thread until linenum，避免一步步单步执行到希望的行，在xcode中这个功能对应的操作是右击代码行选择continue to this line。 函数返回之后 LLDB中手动执行代码 很多时候你可能会发现，要想让你希望执行的代码执行一遍会很困难，比如单元测试的时候某个用例就是无法进行测试，这种情况下你需要用Clang([\u0026lsquo;kl^n])直接调用这份代码，调用方式是直接在命令行表达式中输入你希望执行的代码并执行，比如\n1 2 b \u0026#34;-[ModelDerived removeDuplicates]\u0026#34; e -i false -- [self removeDuplicates]/expression --ignore-breakpoints false -- [self removeDuplicates] 先在方法上打断点，然后在LLDB中执行此函数，选择不要忽略断点，你会发现执行此expression之后会断点到removeDuplicates，接着即可对其进行执行。 然而有一点需要特别注意的是，通过LLDB执行的表达式代码是在你的进程中执行的，所以需要对此所带来的后果有自己的认知。\n检查数据以找寻事情的缘由 在上述的操作之后，我们已经可以断点到我们希望断点的位置了，接着就是检查数据寻找事情发生的原因了，这部分有3方面内容：\n在LLDB命令行中检查数据 查看局部变量： frame variable 执行任意代码： expression (x+35) 其会通过app使用的编译器进行编译并在你的app中执行 p @\u0026quot;hello\u0026quot; 兼容expression的语法，执行表达式并输出结果 po @\u0026quot;hello\u0026quot; 执行任意代码并输出结果的description\nLLDB实用数据格式 需要先搞清楚raw data和data的区别， raw data:是内存中所存储的数据，但它并不易读，对你来说可能太复杂，或者并不是你理解的数据类型，又或者它的数据量很大。 解析：如果想对raw data有个直观的印象，只需要在Xcode的变量区域选择show raw values就可以在观察任意一个栈帧的时候看到raw data了，而此时切换到show types就可以看到规整而有意义的数据呈现形式了，这就是 LLDB 数据格式所要达到的目的。 对于内置的系统库STL,CoreFoundation,Foundation，其中的数据都已经添加了Data formatter，在调试的时候显示都很规整 对于程序员自定义的数据类型的data formatter，苹果构建了可扩展的data formatter子系统，这意味着程序员也可以为自定义的类型添加data formatter。\n自定义data formatter 数据类型的data formatter包括两部分：综述summary，用于呈现数据的关键描述；所组成的子数据即synthetic children 以使用python定义summary为例，summary会将一种数据类型与一个python函数映射起来，基础的映射是通过类型名，更多其它规则可以参见 这个python函数会在此类型的数据在展示的时候被调用，LLDB会将一个SBValue传递给它，SBValue是LLDB对象模型的一部分，可以将其简单地想象成为一个变量，这个python函数最终会返回一个字符串，这个字符串即会被当做summary\nSBValue 之前提到SBValue可以当做一个变量来对待，可以询问其name,data type,summary(如果有的话),是否有children,有多少children,是否可以详述每个child的信息,每个child的信息其实也是一个SBvalue，所以整个是一个递归的过程。如果值是一个比如数字这样的标量，整数，浮点数等，也可以询问其value。 对自定义类进行summary\n1 2 3 4 5 6 7 8 def MyClass_Summary(value,unused)://其中value是一个SBValue //由于是自己定义的数据，可先获取其中的成员变量，成员变量也是SBValue member1 = value.GetChildMemberWithName(\u0026#34;_member1\u0026#34;) member2 = value.GetChildMemeberWithName(\u0026#34;_member2\u0026#34;) member1Summary = member1.GetSummary() member2Summary = member2.GetSummary() #当然也可以做任何你想做的事情，这里仅仅只是简单地组合两个成员的summary return member1Summary + \u0026#34; \u0026#34; + member2Summary 完成了这个python函数之后，变量区域中仍然不能正确显示MyClass的自定义数据类型，因为你还需要在LLDB中执行：\n1 ty su a MyClass -F MyClass_Summary/type summary add MyClass --python-function MyClass_Summary 审视不透明的数据 先介绍下用于数据分析的expression，可以通过如下形式定义一个持久有效的结构体：\n1 expression struct $NotOpaque{int item1;float item2;char* item3;} 对于第3方库提供的对象，你可能连其数据类型都不知道，更不会知道其中成员变量的定义，可能通过google之后，可以发现其具体的定义，这时候，就需要使用上述expression再结合summary，即可以在展示的时候使用自定义的data formatter了. 扩展LLDB 自定义LLDB命令 通过python脚本，可以为调试器添加新特性，实现自定义的操作/自动化的操作过程 比如计算递归的层数，想想LLDB怎么也算是个强大的程序，数数对它来说应该不是什么难事，更加说相比于你手工一个栈帧一个栈帧地数了。\nLLDB 对象模型 LLDB的强大在于它所使用的LLDB对象模型，我们称其为\u0026quot;SB\u0026quot;(scripting bridge)，这是个python API，xcode用其来构建debugger的UI，这意味着对你可以完全地通过LLDB脚本使用SB的所有功能，同时其也有一套对调试session的描述： 对于上述调试界面相信大家都比较熟悉，LLDB对象模型对其的描述是这样：SBTarget即是调试中的target，接着在点击了xcode中的运行按钮之后，这个target成为了一个活着的实体，对这个实体，你可以输入，点哪，点哪，点，这即是在机器底层上运行的进程称为SBProcess，进程有着很多用来完成任务的thread，即SBThread，而SBThread会不停地执行function，每个function都会而每次function调用都会对应栈上的一帧，即SBFrame，现在我们已经了解到了描述程序运行中的所有对象，接下来看看怎样完成我们想完成的任务。 首先需要知道的是python命令是如何执行的呢，python函数是与LLDB中的命令一一对应的，LLDB看到这个命令的时候即会调用相应的python命令，python命令的原型是这样:\n1 def MyCommand_Impl(debugger,user_input,result,unused): debugger:是一个SBDebugger user_input:是用户输入的python字符串 result:是SBCommandReturnObject，是用来反馈给LLDB的，反馈执行成功与否等信息 添加自定义的命令的方式如下：\n1 co sc a foo -f foo/command script add foo --python-function foo 断点操作 断点的痛点在于它会不停在中断程序的执行，条件断点会好一点，有了断点action，我们可以只在自己关注的场景停下来 断点action是将断点与一个python函数联系起来，断点命中的时候会调用此python函数，而其可以返回false以勾选断点编辑界面中的continue选择框以让LLDB继续运行 此python函数的原型是\n1 def break_on_deep_traversal(frame,bp_loc,unused): frame类型:为SBFrame bp_loc类型:为SBBreakpointLocation 绑定python函数的命令是\n1 br co a -s p -F foo 1 /breakpoint command add --script python --python-function foo 1 首先需要注意的是WWDC中python代码样例的函数function中常看到unused作为结尾参数，在实际使用python函数时如果未理解其深意，可能会不知其所以然。 断点中的全局变量frame和bp_loc分别是断点栈帧的指针及断点处的代码描述信息，bp_loc打印出来类似于这样：\n1 2.1: where = YourApp`-[SomeViewController onDynamicMethod:paraList:] + 117 at SomeViewController.m:109, address = 0x000000010f9cf3d5, resolved, hit count = 4 在将function作为python命令添加时，命中断点之后lldb会为指定的断点命令函数传入3个参数即frame,bp_loc和internal_dict。\nLLDB在设计之初即提供了两种范畴的脚本化方式： 即可以在Unix环境的python应用中使用LLDB开启并进行一段不能进行交互的调试session； 在LLDB中使用python脚本进行诸如监视数据，遍历容器或者决定断点是该暂停程序执行还是继续程序的执行。\n在python中操作程序中的变量 在实现这个目标之前，需要解决的一个问题是，程序中的变量需要转换成python可以访问的形式，这个时候就需要用到LLDB API，它是作为python的LLDB模块提供的。 在LLDB中运行python时，LLDB会自动将当前帧对象通过lldb.frame这个python变量提供出来，其类型是SBFrame，可以通过FindVariable方法向帧对象询问其本地变量，通过此方法获得的对象是SBValue对象，可以通过SBValue.h中的方法，比如 GetChildMemberWithName(), GetSummary(), 及GetValue()等方法获取具体的信息。 程序中的变量值最终是如何转换成python中任意取用的信息的呢？ 原来LLDB在捕获到程序作用域中的变量之后都是将其封装在SBValue对象中，通过SBValue的API即可获取到封装在其中的变量值的具体信息，对于对象类型的变量，可以通过GetChildMemberWithName获取其成员变量的值，若原本是一个字符串，则使用GetSummary获取字符串，通过GetValue获取数值相关的值等。\n用断点命令script完成最终的临门一脚 有了操作局部变量的神技，实战操作的时候就可以这么玩了，在可疑处打断点，读取临时变量的值检查与预期是否相符，此处的一个小tip是: 将python脚本操作编写在一个python文件里面的function里面，通过import的形式导入并调用其中的function，以免在lldb中输入起来繁琐。 断点命令script的奥义 如果在lldb命令行中为某断点添加python脚本，比如通常是这样breakpoint command add -s python breakpointnum ，输入一到数行python脚本，则LLDB会自行将这数行代码封装成一个python函数并传递两个参数，即frame和bp_loc，断点命中时，即会调用此函数，并传入断点时当前帧对象frame及断点位置信息对象bp_loc。 由此可知，在实际编写断点命令的时候，需要注意这样两点：\n如果想访问你脚本之外创建的python变量，需要将其声明为global，否则其会被当做局部变量，即需要在断点命令脚本中显式声明，比如global variable 所有python断点命令脚本都能够访问到frame和bp_loc 举例在断点处的当前栈帧位于特定帧中时命中断点 第一步通过import导入本地的脚本文件\n1 command script import ~/lldb/inGivenFrame.py 第二步通过codeline添加断点， 第三步添加断点命令\n1 br comm add --script-type python -o \u0026#34;inGivenFrame.inGivenFrame(frame,location,\u0026#39;-[NSObjec givenfuncname]\u0026#39;)\u0026#34; 1 如果不需要传入第三个参数，则也可以使用-F选项，此时命令形式\n1 br comm add --script-type python -F inGivenFrame.inGivenFrameF 1 此时在断点命中时，lldb传给inGivenFrameF函数的第三个参数的意义也有所变更，此时传入的是名为internal_dict的变量，包含额外的信息 使用inGivenFrameF作为断点命令的操作步骤及执行结果如下： 问题 现在想通过lldb来调试自己的iOS项目，官方提供了\n1 2 $ lldb /Projects/Sketch/build/Debug/Sketch.app (lldb) process launch 当按照这种方式指定到路径iOS项目时,打印：\n(lldb) target create \u0026ldquo;/Users/admin/Desktop/Recommend.app\u0026rdquo;\nCurrent executable set to \u0026lsquo;/Users/admin/Desktop/Recommend.app\u0026rsquo; (arm64).\n但是启动时出现问题：\n1 2 (lldb) run error: the platform is not currently connected 大神，有没有解决办法？\n","date":"2018-09-05T14:03:39Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8LLDB%E7%8B%AC%E7%AB%8B%E8%B0%83%E8%AF%95APP/","section":"post","tags":["调试","lldb"],"title":"使用LLDB独立调试APP"},{"categories":["解决方案"],"contents":" {% github it-boyer WCShadowrocket f101e23 width = 30% %} 一次讲透：IOS翻墙利器“小火箭（Shadowrocket）”上手、进阶、配合Workflow获取免费节点攻略\niOS版Shadowrocket 完美重签 无需付费 无需越狱~ 越狱手机砸壳工具 详见https://github.com/AloneMonkey/frida-ios-dump 砸壳教程https://github.com/we11cheng/WCStudy/blob/master/frida-ios-dump.md dumpdecrypted砸壳https://github.com/we11cheng/WCStudy/blob/master/dumpdecrypted%20%E5%AF%BC%E5%87%BA%E5%A4%B4%E6%96%87%E4%BB%B6.md Clutch砸壳https://github.com/we11cheng/WCStudy/blob/master/Clutch%E7%A0%B8%E5%A3%B3(%E8%8F%9C%E9%B8%A1%E7%89%88).md 其他砸壳收集请戳https://github.com/we11cheng/WCCrackedCollect 本repo使用方法如下: 1、安装MonkeyDev(如已安装，跳过) 安装最新的theos 1 sudo git clone --recursive https://github.com/theos/theos.git /opt/theos 安装ldid(如安装theos过程安装了ldid，跳过) 1 brew install ldid 指定的Xcode 1 sudo xcode-select -s /Applications/Xcode.app 执行安装命令 1 sudo /bin/sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-install)\u0026#34; 更新 1 sudo /bin/sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-update)\u0026#34; 卸载 1 sudo /bin/sh -c \u0026#34;$(curl -fsSL https://raw.githubusercontent.com/AloneMonkey/MonkeyDev/master/bin/md-uninstall)\u0026#34; 2、运行工程 打开工程 WCShadowrocket.xcodeproj 选择证书：自动配置证书即可（相信大家都是没有问题的）。 选择设备(不可选择模拟器，且仅支持64位设备)运行。 本次测试机iphone6s 10.3.3 xcode 9.3（iOS11测试过可以运行,其他机型应该也没啥问题）。 版权及免责声明 iOS逆向实践，不可使用于商业和个人其他意图。一切问题均由个人承担，与本人无关。 感谢MonkeyDev的作者庆总https://github.com/AloneMonkey/MonkeyDev。 如内容对您的权利造成了影响，请issues, 我会在第一时间进行删除。 效果截图 华丽的分割线 点右上角的 Star 可以领红包，不信你试试。重签付费应用就是这么容易，感谢MonkeyDev作者。\n福利 提供免费付费软件砸壳，理论上支持越狱手机上所有软件砸壳，砸壳以后拖入MonkeyDev开始逆向之旅吧~。应用列表：Shu Thor Detour Kitsunebi Pythonista HyperApp JSBOx Surge Quantumult PPHub Tik Tok Mume Mume Red \u0026hellip; 2018-5-29 添加自建vps ssr\u0026amp;ss节点信息。虽然延迟有点高，但还是能用的。完全自己搭建，(有限制流量，不够再加)放心使用~ SS 链接 : ss://YWVzLTI1Ni1jdHI6Z3djcGF_f0AxOTguMTgxLjM1LjIzOjEwMDAx SS 二维码 : http://doub.pw/qr/qr.php?text=ss://YWVzLTI1Ni1jdHI6Z3djcGF_f0AxOTguMTgxLjM1LjIzOjEwMDAx SSR 链接 : ssr://MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw SSR 二维码 : http://doub.pw/qr/qr.php?text=ssr://MTk4LjE4MS4zNS4yMzoxMDAwMTpvcmlnaW46YWVzLTI1Ni1jdHI6cGxhaW46WjNkamNHRl9mdw 规则详见https://github.com/lhie1/Rules，自行选择使用，更多规则https://github.com/h2y/Shadowrocket-ADBlock-Rules 2018-6-26 新增ssr节点订阅模式(免费)。 参考https://tool.ssrshare.xyz/tool/free_ssr 如何订阅 打开shadowrocket 首页，点击右上角+号。模式选择Subscribe URL部分输入以下三个地址（一个或多选，多选表示订阅多个） 1 2 3 4 5 6 实时订阅链接,为防止滥用，24小时自动更改一次密码(key) 所有(golbal)可用订阅: https://tool.ssrshare.xyz/tool/api/getGolSub?key=1529942400_8_xuo 实时订阅链接,为防止滥用，24小时自动更改一次密码(key) 中国(CN)可用订阅: https://tool.ssrshare.xyz/tool/api/getCnSub?key=1529942400_8_xuo 非实时订阅链接（无密码）: https://raw.githubusercontent.com/ImLaoD/sub/master/ssrshare.com 点击完成，就能发现节点列表新增了我们订阅节点信息。选择一个可以的连接即可。 最后一个订阅地址是开源的(托管在git)。查看作者repo 2018-7-17 更新 添加了Capabilities下Person VPN Network Extensions 帮助https://github.com/we11cheng/WCStudy/blob/master/iOS%20Widget%20Extensions%E8%AF%81%E4%B9%A6%E9%85%8D%E7%BD%AE.md 添加节点的时候，遇到问题，还没解决..求大佬们一起解决它.. 1 2 CoreData: annotation: Failed to load optimized model at path \u0026#39;/var/containers/Bundle/Application/9D19C752-5139-426B-815E-2A68B632352F/WCShadowrocket.app/Shadowrocket.momd/Shadowrocket 7.omo\u0026#39; *** Terminating app due to uncaught exception \u0026#39;NSFileHandleOperationException\u0026#39;, reason: \u0026#39;*** -[NSConcreteFileHandle seekToFileOffset:]: Bad file descriptor\u0026#39; 最新福利，谷歌云上搭建了一个App Engine 爬取ssr/ss节点，拿去不谢 https://sspy-210307.appspot.com/（已失效） 2018-7-26 更新几个ssr订阅 逗比根据地 http://ss-ssshare.7e14.starter-us-west-2.openshiftapps.com/subscribe 香港节点 https://wepn.hk/link/idFgpbMYQQxvHjuK?mu=0 loremwalker https://prom-php.herokuapp.com/cloudfra_ssr.txt App Engine https://sspy-210307.appspot.com/subscribe,update可能需要科学上网。（已失效） 他人共享https://raw.githubusercontent.com/forpw2009/lpss2009/master/ssr/lpssr 作者github主页https://github.com/forpw2009 Heroku https://isspy.herokuapp.com/subscribe 2018-8-21 App Engine欠费关闭，改用Heroku部署，项目主页地址 https://isspy.herokuapp.com/ ss/ssr订阅地址 https://isspy.herokuapp.com/subscribe ","date":"2018-09-05T12:11:58Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/shadowrocket%E6%97%A0%E9%9C%80%E8%B6%8A%E7%8B%B1%E9%87%8D%E7%AD%BE%E7%BF%BB%E5%A2%99/","section":"post","tags":["翻墙"],"title":"shadowrocket无需越狱重签翻墙"},{"categories":["学习笔记"],"contents":"在升级xcode之后，出现playground无法运行的情况，live view 不显示等问题。 ","date":"2018-09-05T11:46:05Z","permalink":"https://it-boyer.github.io/post/old/swift/playground%E8%BF%90%E8%A1%8C%E6%85%A2%E9%97%AE%E9%A2%98%E8%A7%A3%E5%86%B3%E5%8A%9E%E6%B3%95/","section":"post","tags":["swift"],"title":"playground运行慢问题解决办法"},{"categories":["学习笔记"],"contents":"七个习惯资源 {% github it-boyer 7HabitFiles ab2502a width = 30% %}\n下载习惯的评估矫正.pages 下载七个习惯综合评估.numbers\n生成markdown表格工具\n你的生活中心 配偶 家庭 金钱 工作 财富 享乐 朋友 敌人 宗教 自我 原则 配偶 *满足需求的主要来源 *维持现状 *不太重要 *有夫妻共同维护 *让配偶衣食无忧所必须的 *挣钱养活配偶所必须的 *关爱、打动或支配配偶的手段 *一起活动或无足轻重 *配偶是最好或唯一的朋友 *只有“我们的”朋友才是朋友 *配偶捍卫我的利益或者共同的敌人令我们的婚姻稳固 *共同的享受乐趣的生活 *仅次于婚姻关系 *由配偶决定自我价值 *极易受到配偶态度和行为的影响 *与配偶建立并维持关系的理念 家庭 *家庭的一部分 *重中之重 *家庭经济的支柱 *达到某个目的的手段 *带给家庭安逸和机遇 *家庭活动或相对次要 *家庭的朋友否则会引起斗争 *稳固家庭生活的威胁 *由家庭决定 *家庭团结稳固的根源 *可能对家庭团结构成威胁 *求助的对象 *家庭的重要部分但地位次于家庭 *保持家庭团结稳固的规则 *次于家庭 金钱 *赚钱的资本或负担 *经济负担 *安全感和满足感的来源 *赚钱所必须的 *经济成功的证据 *经济负担或者经济压力的标志 *由于经济地位或者影响力而结交 *经济上的竞争者 *经济稳定的威胁 *税金减免 *花钱的地方 *自我价值 *由净资产决定 *赚取和管理钱财的有效方法 工作 *工作的助力或阻力 *帮助或者干扰工作 *培养家人的敬业精神 *次要 *辛勤工作的证据 *满足感和成就感的主要来源 *重中之重 *提高工作效率的手段 *工作的成果和证明 *浪费时间 *干扰工作 *由于工作环境或者志趣相投而结交 *基本不必要 *工作的效率障碍 *对企业形象至关重要 *占用时间 *建立职业关系网的机会 *由工作中的作用决定 *让你在工作中获取成功的理念 *适应工作环境所必须的 财富 *主要财富 *获取财富的帮手 *可供使用、利用、支配、压制和控制的财富 *炫耀 *增加财富的关键 *可供炫耀的财富 *获取地位、权势和承认的机会 *地位标志 *逛街、购物、加入俱乐部 *个人所有 *可供利用 *掠夺者、强盗 *拥有更多财富或者更高的声望的人 *“我的”教堂地位的象征 *不公正批判和生活美好事物的根源 *由我拥有的财产决定 *由社会地位和声望决定 *让你获取和增加财富的观念 享乐 *享受乐趣的同伴或阻碍 *载体或干扰 *增加享乐机会的手段 *达到目的的手段 *愿意从事有趣的工作 *乐趣的客体 *获取更多乐趣的手段 *生活中至高无上的目标 *满足感的主要来源 *共享乐趣的伙伴 *过于认真的看待生活 *带来罪恶感的人，破坏者 *麻烦，娱乐的障碍 *带来罪恶感 *享乐的工具 *必须得到满足的固有冲动的本能 朋友 *可能是朋友可能是对手 *社会地位的象征 *朋友建立友谊的障碍 *社会地位的象征 *良好经济和社会状况的根源 *社会机遇 *收买友谊的手段 *消遣或提供社交娱乐的手段 *与朋友一起总是很快乐 *以社交活动为主 *对个人的快乐至关重要 *归属感、得到接纳和受欢迎至关重要 *社交圈以外 *共同的敌人和巩固或缔结友谊 *社交聚会的场所 *由社会决定 *害怕尴尬或遭到排斥 *让你与别人和睦相处的基本法则 敌人 *同情替罪羊 *避难所（情感支持）或替罪羊 *对抗或证明高人一等的手段 *逃避方式或者发泄情绪的机会 *斗争工具 *争取盟友的手段 *逃避、寻找逃难所 *下一次战斗前的休息放松时间 *情感上的支持者和同情者 *可能由于共同的敌人而结下友谊 *仇恨的对象 *个人烦恼的根源 *自我保护和自我辩白的原因 *自我辩护的根源 *受害 *受制于敌人 *指责敌人的理由 *敌人错误的根源 宗教 *为教堂服务的同伴或帮手 *信仰的考验 *贯彻宗教教义的榜样 *信仰的考验 *支持教会和家庭的手段 *如果比为教会教义服务更重要，则是罪恶 *维持世俗生活所必须的 *世俗财富毫不重要 *名誉和形象极其可贵 *“无害”的乐趣，是与其他教友聚会的机会 *其他娱乐是有害的是浪费时间，应该禁止 *其他教友 *无信仰的人；不赞同宗教教义的人或者生活方式完全违背教义的人 *生活方向的最重要指引 *自我价值由宗教活动，对教会的贡献或按教义行事的表现决定 *宗教信条 *比宗教次要 自我 *财富 *令自己满足和快乐 *财富 *满足需求 *满足需求的来源 *“自行其是”的机会 *自我界定保护和提高的来源 *应得的感官享受 *我的权力 *我的需求 *我的支持者和供应者 *自我界定自我辩白的根源 *服务私利的手段 *比别人优秀、聪明、正确 *集中一起资源满足个人需求 *辩白的根源 *最能为我的利益服务的理念；可以根据需求不同作出调整 原则 在互利互赖的关系中的平等伙伴 *朋友 *服务、贡献和成就的机会 *改写几代人的行为模式和变革的机会 *完成要务和重要目标的资源 *以富有成效的方式运用才华和能力的机会 *获取经济资源的手段 *与其他时间投入相均衡的时间投入，与生活中的要务和价值观相一致 *可供利用的资源 *得到适当照顾的责任 *与人相比是次要的 *目标明确的生活中几乎所有活动产生的乐趣 *真正的娱乐是平衡而全面的生活方式的重要组成部分 *相互依赖生活中的同伴 *知心人\u0026mdash;能倾吐心声，能提供服务和支持 *没有真正意义上的敌人；知识思维定势和考虑事项不同应该予以理解和关心 *真正的原则的载体 *服务和贡献的机会 *是诸多独特、有才华、富有创造力的个体当中的一个。 这些个体独立和互赖的工作能完成伟业 *永恒的自然法则，一旦违反必受惩罚 *得到遵守时，则能维护尊严，从而实现真正的成长和幸福 ","date":"2018-09-04T19:39:50Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E9%99%84%E5%BD%95%E4%B8%80/","section":"post","tags":["图书"],"title":"七个习惯附录一"},{"categories":["学习笔记"],"contents":"1）我的时间是怎样度过的 1.很不同意2.不同意3.略不同意4.略微同意5.同意6.很同意\n问题 态度 1.我花了很多时间在重要而且需要立刻关注的活动上，例如危机、紧迫问题、截止日期即将到期的项目。 打分 2.我觉得总是到处救火，不断处理危机 打分 3.我觉得自己浪费了好多时间。 打分 4.我花了很多时间在虽然紧迫但与我的最高优先毫无关系的事情上（诸如无端的干扰、不重要的会议，、非紧急的电话和电子邮件） 打分 5.我花了很多时间在重要但不紧迫的事务上，例如做计划、准备、防范、改善人际关系、恢复和休整 打分 6.我花了很多时间在繁忙的工作、强制性习惯、垃圾邮件、过多的电视节目、琐事和玩游戏上。 打分 7.我觉得由于防范得当、精心准备和周密计划，一切由我掌控。 打分 8.我觉得自己总是在处理对他人重要、但却对自己不重要的事情。 打分 以上表格的设计，是用来帮你快速评估自己花费在时间矩阵的每个象限中的时间和精力各有多少。对于上面的8个问题圈出你的反应，从1到6. 得分操作指南：\n对于这8个问题圈出相应于你的反应的数字，从1到6. 把你在每个象限中的得分相加。 在每个象限中用阴影涂画出四分之一圆，其中半径等于你在该象限的得分。 ","date":"2018-09-03T15:01:52Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E4%B9%A0%E6%83%AF%E4%B8%89%E8%A6%81%E4%BA%8B%E7%AC%AC%E4%B8%80%E8%87%AA%E6%88%91%E7%AE%A1%E7%90%86%E5%8E%9F%E5%88%99/","section":"post","tags":["图书"],"title":"习惯三要事第一自我管理原则"},{"categories":["学习笔记"],"contents":"1）检查你的愿景 现在是时候了，让我们对自己的愿景作一次检查。花一分钟思考下述问题，写下你的想法。 2）制定一份个人使命宣言 为了帮你制定自己的使命宣言，下面列出制定过程的六个步骤。 步骤1：开动脑筋畅想 将你对下面三个问题的回答一口气写下来，不要停顿。这是自由发挥。如果你想到了一个观点，别太在意用词和语法，只管不停地写下去。记住，你只是在畅想，不是定稿，目的是把自己的想法写在纸上。在每个问题上花2-3分钟。\n步骤2：放松一下 现在深呼吸一下，然后放松下来。把你写的放在一边，走开几分钟。 步骤3：整理你的思绪 回顾你所写的，圈出你想列入自己使命宣言的关键想法、语句和词语\n步骤4：写出初稿 现在是写出你的初稿的时候了。前文已经列举了几个使命宣言的范本，以助于你思考。一周内随身带着这个初稿，每天写下备注或根据需要加以增删。也许每天或每两天你都想重写一份初稿。这是一个不断进行的过程。你的使命宣言将随着时间而不断修改。现在，花一点时间写出你的使命宣言初稿。\n步骤5：完成你的使命宣言 周末写出你的使命宣言的定稿，放在一个便于随时翻阅的地方。 步骤6：定期检查并加以评估\n把你做本章开篇的参加葬礼心灵演练时的新的列表整理下来。\n1）检查你的愿景 现在是时候了，让我们对自己的愿景作一次检查。花一分钟思考下述问题，写下你的想法。我现在的生活状况如何？它是否让我快乐？我是否有成就感？\n是什么在一直吸引着我？它是否与我目前正在做的事情有所不同？\n我少年时想做的是什么？这些事情仍然给我带来满足感吗？我目前是在做着其中的一些事情吗？\n目前最让我感兴趣的是什么？\n最让我的灵魂感到满足的是什么？\n我做什么事情最擅长？我的显著特点和优势是什么？\n2）制定一份个人使命宣言 为了帮你制定自己的使命宣言，下面列出制定过程的六个步骤。\n步骤1：开动脑筋畅想 将你对下面三个问题的回答一口气写下来，不要停顿。这是自由发挥。如果你想到了一个观点，别太在意用词和语法，只管不停地写下去。记住，你只是在畅想，不是定稿，目的是把自己的想法写在纸上。在每个问题上花2-3分钟。 1．标识一个对你有影响的人。确定一个对你的生活有积极影响的人。你最赞赏这个人的什么品质？你从这个人那里学到了什么品质？\n2．详细说明你想成为怎样的人。 设想现在已是20年后，你已经达成了自己所希望的所有成就。你的成就清单是什么？你想拥有什么？你想成为怎样的人？你想成就怎样的事业？\n3．请确定，目前对你最重要的是什么？\n步骤2：放松一下 现在深呼吸一下，然后放松下来。把你写的放在一边，走开几分钟。\n步骤3：整理你的思绪 回顾你所写的，圈出你想列入自己使命宣言的关键想法、语句和词语。\n步骤4：写出初稿 现在是写出你的初稿的时候了。前文已经列举了几个使命宣言的范本，以助于你思考。一周内随身带着这个初稿，每天写下备注或根据需要加以增删。也许每天或每两天你都想重写一份初稿。这是一个不断进行的过程。你的使命宣言将随着时间而不断修改。现在，花一点时间写出你的使命宣言初稿。\n使命宣言初稿\n步骤5：完成你的使命宣言 周末写出你的使命宣言的定稿，放在一个便于随时翻阅的地方。\n我的使命宣言\n步骤6：定期检查并加以评估 每个月问自己下列问题： ●我是否觉得这个使命宣言代表了最佳的自我？ ●当我回顾这个使命宣言的时候是否感到有了方向、目标、挑战和动力？ ●我的生活是否遵从了这个使命宣言中的理想和价值观？\n3）你的角色 既然你已有了逐步进展中的个人使命宣言初稿，重要的是考虑你在生活中的角色和目标，以及它们与你的使命宣言有着怎样的关系。\n在下页的空白处写下你的各个角色。别太在意一次把它们弄正确。只要写下你觉得正确的就行。尝试把列出的角色限制在七个以内。如果超过了七个，可以把若干职能归并为一个。在写下的角色旁边描述一下，你认为自己可能在该角色领域做出的最理想的业绩。 例如： 艺术家、护理者、同伴、指导者、激励者、朋友、祖父母、发明家、邻居、调解者、儿子、教师、训练员、志愿者、作家\n角色 在角色领域的最理想的业绩 志愿者 在儿童中心服务两个小时 4）你的生活中心 阅读本书附录一所列的各种生活中心，看看你的行为符合其中哪个类型？他们是否让你的日常行为有一定依据？你是否满意？\n5）告诉你自己怎么做 设想近期内可能会从事的某个项目，用智力创造的原则，写下你的希望获得的结果与应采取的步骤。\n向家人或者同事讲述本章的精华，并建议大家共同拟定家庭或者团队的使用宣言。\n","date":"2018-09-03T14:26:21Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E4%B9%A0%E6%83%AF%E4%BA%8C%E4%BB%A5%E7%BB%88%E4%B8%BA%E5%A7%8B%E8%87%AA%E6%88%91%E9%A2%86%E5%AF%BC%E5%8E%9F%E5%88%99/","section":"post","tags":["图书"],"title":"习惯二以终为始自我领导原则"},{"categories":["学习笔记"],"contents":"怎么在影响圈内,做到积极主动?\n行动建议 花一整天，听听你自己和周围人的语言，你使用“但愿”、“我办不到”、“我不得不”等消极回答的频率有多高？ 根据以往的经历，想象一下将来遇到什么会让你变得消极。假如你关注的是影响圈，再考虑一下这个场景，你能怎样积极回应？用几分钟时间，在头脑里鲜活地描绘那个场景，设想你用一种积极方式进行回应。你只需要随时提醒自己被动刺激和主动回应之间的区别，不要忘记有自由选择的权利。 1）多培养积极主动性 积极的人使用积极的语言：“我能”、“我要”、“我宁愿”等等。消极的人使用消极的语言：“但愿”、“我办不到”、“我不得不”、“要是”。 2）你的圈子有多大 挑战/问题 圈子 回应 列出本周内所面临的各种挑战和问题。设法让自己的影响圈逐步扩大，选一个打算在下周改变应对方式以克服的挑战。 3）采取积极主动 找出一个在工作或生活中令你备感挫折的问题，判断它属于直接控制、间接控制还是无法控制的问题，然后在影响圈内找出解决问题的第一个步骤，并付诸行动。 4）试行“积极主动”原则30天，写下自己的影像圈有和变化。\n1）多培养积极主动性 积极的人使用积极的语言：“我能”、“我要”、“我宁愿”等等。消极的人使用消极的语言：“但愿”、“我办不到”、“我不得不”、“要是”。 想想过去几周内自己以消极方式做出回应的两三件事情。 描述一下自己是怎么说的。\n1 2 3 1．____________________________ 2．____________________________ 3．____________________________ 现在，想想在同样情况下自己可以采取的几种积极的回应。请写在下面。\n1 2 3 1．____________________________ 2．____________________________ 3．____________________________ 请记住，在下周仔细倾听自己使用的语言，你的语言是更积极了，还是更消极了？\n1 ______________________________ 2）你的圈子有多大 写下你在本周内所面临的各种挑战和问题。它们分别归入哪个圈子？你的瞬间回应又是什么？\n挑战/问题 圈子 回应 _交通拥堵 关注圈 愤怒、咒骂 _ _ _ _ _ _ 你需要设法让自己的影响圈逐步扩大。这两个圈子中，从每个圈子选一个你本来打算在下周做出应对的挑战。你将怎样改变自己的回应以更有效地应对该挑战？ 1．影响圈\n1 _________________________________ 2．关注圈\n3）采取主动 找出一个在工作或生活中令你备感挫折的问题，判断它属于直接控制、间接控制还是无法控制的问题，然后在影响圈内找出解决问题的第一个步骤，并付诸行动。\n试行“积极主动”的原则30天，写下自己的影响圈有何变化？\n你是否有什么事情一直想做，但又觉得缺乏天赋、时间或能力？为了克服自己的弱点，你应当做些什么呢？作为一周伊始，你又能在本周做一件什么事呢？\n如果你能开发自己的一项新的才能，你想要什么？\n如果你能到世界任何一个地方去旅行，你想去哪里？\n如果你能改变自己生活中的某件事情，你想改变哪一件？\n制定让你实现上面三个愿望（对三个问题的回答）的计划，把它写下来。\n","date":"2018-09-03T13:53:19Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E4%B9%A0%E6%83%AF%E4%B8%80%E7%A7%AF%E6%9E%81%E4%B8%BB%E5%8A%A8%E4%B8%AA%E4%BA%BA%E6%84%BF%E6%99%AF%E5%8E%9F%E5%88%99/","section":"post","tags":["图书"],"title":"习惯一积极主动个人愿景原则"},{"categories":["学习笔记"],"contents":"七个习惯概论 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @startsalt {# 高效能人士 | 低效能人士 习惯一 积极主动。积极主动的人绝不浅尝辄止。他们知道要为自己的抉择负责，|消极被动。消极的人不愿为自己的抉择负责， 做出的选择总是基于原则和价值观，而不是基于情绪或受限于周围条件。积极的人是变化的催生者。 | 他们总是觉得自己是受害者—受到周围环境、自己的过去和他人的拖累。他们不把自己看作是生活的主人。 .|. 习惯二 Row header 2 | A long cell } @endsalt 高效能人士 低效能人士 习惯一：积极主动 积极主动\n积极主动的人绝不浅尝辄止。他们知道要为自己的抉择负责，做出的选择总是基于原则和价值观，而不是基于情绪或受限于周围条件。积极的人是变化的催生者。 消极被动\n消极的人不愿为自己的抉择负责，他们总是觉得自己是受害者—受到周围环境、自己的过去和他人的拖累。他们不把自己看作是生活的主人。 习惯二：以终为始 以终为始（先定目标后有行动）\n个人、家庭、团队、组织通过创造性的构思来设计自己的未来，他们对于任何项目，无论大小，也不管是个人的还是团队的，都下决心完成。他们标识并献身于自己生活中最重要的原则、人际关系和目标。 不定目标就行动\n他们缺乏个人愿景，没有目标。他们不思考生活的意义，也不愿制定使命宣言。他们的生活总是遵循社会流行的、而不是自己选择的价值观。 习惯三：要事第一 要事第一 以要事为先的人总是按照事务重要性的顺序来安排生活并付诸实践。无论情势如何，他们的生活总是遵循自己最珍视的原则。 不重要的事先做\n他们总是在应付各种危机。他们之所以无法关注最重要的事务，是因为他们总是纠缠于周围环境、过去的事情或人间是非。他们陷入成堆的琐事，被紧迫的事务弄得团团转。 习惯四：双赢思维 双赢思维\n有双赢思维的人能在交往中寻求双方获利、互相尊重。他们基于到处是机遇和富足的心态，基于“我们”而不是“我”，来进行思考。他们总是通过向感情账户存款来建立与他人的互信关系。 非赢即输\n他们抱的是匮乏心态，把生活看作是一场零和游戏。他们不善与他人沟通，总是从感情账户提款，结果是时时提防他人，陷入对抗的心理。 习惯五：知彼解己 知彼解己（先理解别人，再争取别人的理解） 当我们怀着理解对方的想法，而不是为了回答对方的问题去聆听时，我们就能进行真正的沟通并建立友谊。这时再坦述己见、争取理解就很自然，也容易多了。理解别人需要的是体谅，而争取别人理解需要的是勇气。效能在于这二者的平衡或适当的结合。 先寻求别人的理解 他们并未理解对方就先讲述自己的观点，完全基于自己的经验或动机。他们不先对问题做出诊断就盲目开出处方。 习惯六：统合综效 统合综效\n统合综效的人与对方合作，寻求第三变通方案。不是我的，也不是你的，而是第三种更好的解决方案。统合综效的基础是尊重、赞赏甚至庆贺彼此间的差异。它是某种创造性的合作，1＋1＝3，11，111，或者更多。 妥协、争斗或逃避 低效能人士相信总体小于部分之和。他们试图在自己的形象中克隆他人。他们把自己与他人的差异看作威胁。 习惯七：不断更新 不断更新（磨刀不误砍柴工） 高效能人士不断在生活的四个方面（身体、社会／情感、智力、精神）更新自己。这将增加他们实践其他有效习惯的能力。 把自己累得筋疲力尽\n低效能人士没有自我更新、自我改善的规划，最终失去了过去所拥有的锋利刀刃（竞争力）。 1）在七个习惯上给自己评分 这个评估能帮你了解自己在实践七个习惯方面的现状。为了了解自己的进步，你可以在读完本书后重新进行一次评估。 仔细阅读下列表格中的每句话，利用自己的最佳判断，圈出标识自己在每个习惯方面做得如何的数字（1表示极差，而6表示杰出）。\n七个习惯上的评分 感情账户 1. 待人和蔼，体谅对方\n2.我信守诺言\n3. 我不在别人背后说他坏话。 评分：\n评分：\n评分： 产出/产能平衡 4. 我能在生活的各个方面（家庭、朋友、工作等）保持适当的平衡\n5.当我致力于某个项目时，总是想着业主的需求和厉害关系。\n6. 我努力工作，但绝不把自己累的精疲力尽。 评分：\n评分：\n评分： 习惯一：积极主动 7. 我能掌控自己的生活\n8. 我把关注集中于我能有所作为的事情上，而不是集中在我无法控制的事件上。\n9. 我敢于为自己的情绪负责，而不是埋怨环境、责备他人。 评分：\n评分：\n评分： 习惯二：以终为始 10. 我明白自己在生活中的追求什么。\n11. 我的生活和工作井然有序，很少陷入危急态势。\n12.我每周都有一个清晰的计划，注明我想完成的事情 评分：\n评分：\n评分： 习惯三：要事第一 13.我致力于完成自己的计划（避免延误、浪费时间等等）。\n14. 我不让日常琐事埋没了真正重要的事务。\n15. 我每天做的事情都是有意义的，有助于实现我的生活目标。 评分：\n评分：\n评分： 习惯四：双赢思维 16. 我关心别人的成功，就像关心自己的成功一样。\n17. 我能与别人合作。\n18. 遇到矛盾时，我努力寻求有利于各方的解决方案。 评分：\n评分：\n评分： 习惯五：知彼知己 19. 我对他人的感觉也很敏感。\n20. 我尽力理解对方的观点。\n21. 倾听时，我试图从对方的角度，而不仅从自己的角度来观察问题。 评分：\n评分：\n评分： 习惯六：统合综效 22. 我赞赏并力图了解他人的见解。\n23. 我竭力寻求新的、更好的想法和解决方案。\n24. 我鼓励他人表达他们的观点 评分：\n评分：\n评分： 习惯七：不断更新 25.我真系自己的身体和健康。\n26.我努力建立并改善与他人的关系。\n27. 我肯花时间追求生活的意义和乐趣。 评分：\n评分：\n评分： 你的习惯 习惯是知识、技巧和意愿的交叉点。 知识是做什么和为何做，技巧是如何做，而意愿是动力——想做。所有这三者必须集合在一起才能形成一个习惯。 请列出你的两个习惯，一个好习惯，一个坏习惯。并写出关联于这两个习惯的知识、技巧和意愿。\n习惯有巨大的引力——比大多数人认识到的或愿意承认的还要大。打破一个根深蒂固的习惯需要做出极大的努力，而且一般还会涉及生活的重大变化。 看看你写下的坏习惯。你愿意为了打破这个坏习惯做出一切必要的努力吗？若是，请写下三件为了打破这个习惯你将着手做的事情。请记录下你的进步过程。\n1 2 3 1． 2． 3． 看一下图2-2七个习惯模型，你位于何处？花几分钟记录下你的现状及其原因。你的什么行为和态度让你处于目前这种状况？你开始看到自己最需要在哪方面做出努力了吗？\n","date":"2018-09-03T10:11:38Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E6%A6%82%E8%AE%BA/","section":"post","tags":["图书"],"title":"七个习惯概论"},{"categories":["学习笔记"],"contents":"由内而外全面造就自己 你是否有过这种经验，做出推测时发现自己的判断过于匆忙？请对这种经验加以描述。\n1 答: 你当时做出的推测是什么？\n1 答: 想一下你做过的其他推测。本周你将对其中某一项采取什么行动？\n1 答: 1）检验你的思维定式 你曾经到过其他国家，或本国其他地区吗？你觉得哪些事情是陌生的或奇怪的？\n1 答: 人们的行为是否如你预期？你对他们的行为有何看法？\n1 答: 回想你的旅游经验，你认为当地人对你的看法如何？你是否认为他们对你的看法与你对他们的看法可能很类似？\n1 答: 如果你有机会在旅途中认识当地人，你对他们的看法或推测会有什么改变？\n1 答: 2）转换你的思维定式 回想一下通往你的工作场所或你的家的不同途径。是否有些途径比其他的更复杂？是否有时其中一条比其他的更方便？为什么方便，为什么不方便？\n1 答: 你是否发现过一条你以前不知道的新途径？走不同途径的新鲜感又是什么？\n1 答: 现在想一下你与他人打交道的方式。与他们打交道是否有好几种途径？你还有可能会尝试哪些新的方式？\n1 答: 3）影响你生活的五个原则 请列出影响你的日常生活的五个原则。它们以怎样的方式影响你？它们是以积极的，还是消极的方式影响你的生活？\n","date":"2018-09-03T10:11:38Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF%E9%A2%98%E7%94%B1%E5%86%85%E8%80%8C%E5%A4%96%E5%85%A8%E9%9D%A2%E9%80%A0%E5%B0%B1%E8%87%AA%E5%B7%B1/","section":"post","tags":["图书"],"title":"七个习惯题由内而外全面造就自己"},{"categories":["项目总结"],"contents":"问题 [MPMoviePlayerController播放过程中自动暂停的问题] 在使用系统播放器MPMoviePlayerController的过程中，会出现播放器自动暂停的情况，有两种解决办法：参看 1.1 在播放开始的时候，设置useApplicationAudioSession ＝ NO; 1.2 重启手机，也可以恢复 why does MPMovieLoadState have state 5? 1 2 3 4 5 6 7 The playState is a bitmask. Any number of bits can be set, such as MPMovieLoadStatePlaythroughOK | MPMovieLoadStatePlayable Check for states like this: MPMovieLoadState state = [playerController loadState]; if( state \u0026amp; MPMovieLoadStatePlaythroughOK ) { NSLog(@\u0026#34;State is Playthrough OK\u0026#34;); } 问题2 投影不全屏 现象：投影仪页面未同步现象，全屏查看视频，横屏全屏显示，但投影在大屏的画面没有同步\n隔离业务代码，编写demo复现投影问题。ALMoviePlayerControllerGit库 demo问题 解决办法： 注释掉：- (id)initWithContentURL:(NSURL *)url方法。demo正常播放 小插曲：遇到Setting device discovery mode to DiscoveryMode_None，排查之后不影响播放。故没有继续研究。。。\n教训：必须深入代码联调测试中，本可以通过断点排查，查处url为nil导致demo无法的播放的原因。却长时间纠结在不必要的日志中。\n通过在投影仪上联调测试不影响播放 1 VAALMoviePlayerController[7438:3348866] [] \u0026lt;\u0026lt;\u0026lt;\u0026lt; AVOutputDeviceDiscoverySession (FigRouteDiscoverer) \u0026gt;\u0026gt;\u0026gt;\u0026gt; -[AVFigRouteDiscovererOutputDeviceDiscoverySessionImpl outputDeviceDiscoverySessionDidChangeDiscoveryMode:]: Setting device discovery mode to DiscoveryMode_None (client: VAALMoviePlayerController) 通过百度有两种方式： 1.在viewwillapear中添加player=nil AVPlayer is not playing in iOS 11 AVPlayerViewController black screen when swiping on iOS 11\n2.将工程设置为arc=YES\nMP4音频不同步 现象：视频播放到待定的时间点，画面卡顿，拖动进度条，声音画面不同步，复现：《视频美国儿童思维导图特训营》第一课：21:00时长复现\n","date":"2018-08-31T16:58:22Z","permalink":"https://it-boyer.github.io/post/old/MPMoviePlayerController%E9%81%87%E5%88%B0%E7%9A%84%E5%9D%91/","section":"post","tags":[],"title":"MPMoviePlayerController遇到的坑"},{"categories":["解决方案"],"contents":"参考\nyou can restart your device! then connect your device to your mac-\u0026gt;open Xcode-\u0026gt;press command + i I\u0026rsquo;ve encountered this issue today. The record button is disabled and the tooltip says \u0026ldquo;This device is not currently online\u0026rdquo;. However my iPhone is connecting with my Mac and can be debugged with Xcode without any problem.\n","date":"2018-08-31T16:58:22Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/Thisdeviceisnotcurrentlyonline/","section":"post","tags":["iOS","调试"],"title":"Thisdeviceisnotcurrentlyonline"},{"categories":["解决方案"],"contents":"检测app内存爆增代码，优化性能 Instruments工具使用办法 整理Demo，列出几种常用instrument的场景。来熟悉具体操作 demo\n集成归档模块代码，测试内存上升问题 ","date":"2018-08-31T16:58:22Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8Instruments%E7%9A%84%E5%B7%A5%E5%85%B7/","section":"post","tags":["iOS","调试"],"title":"使用Instruments的工具"},{"categories":["解决方案"],"contents":" {% github facebook chisel 56d0e0d width = 30% %}\nLLDB 是一个有着 REPL 的特性和 C++ ,Python 插件的开源调试器。LLDB 绑定在 Xcode 内部，存在于主窗口底部的控制台中。调试器允许你在程序运行的特定时暂停它，你可以查看变量的值，执行自定的指令，并且按照你所认为合适的步骤来操作程序的进展。(这里有一个关于调试器如何工作的总体的解释。)\nChisel 为lldb提供了新增的便捷命令，是非常实用的命令。\npviews 这个命令可以递归打印所有的view，并能标示层级，相当于 UIView 的私有辅助方法 [view recursiveDescription] 。 善用使用这个功能会让你在调试定位问题时省去很多麻烦。\n1 2 3 4 5 6 7 8 9 (lldb) pviews view \u0026lt;TestView: 0x18df8070; baseClass = UIControl; frame = (144 9; 126 167); layer = \u0026lt;CALayer: 0x18df8150\u0026gt;\u0026gt; | \u0026lt;UIView: 0x18df81d0; frame = (0 0; 126 126); userInteractionEnabled = NO; layer = \u0026lt;CALayer: 0x18df8240\u0026gt;\u0026gt; | \u0026lt;UIImageView: 0x18df8330; frame = (0 0; 126 126); clipsToBounds = YES; opaque = NO; userInteractionEnabled = NO; layer = \u0026lt;CALayer: 0x18df83b0\u0026gt;\u0026gt; | \u0026lt;UILabel: 0x18df8460; frame = (0 135; 126 14); text = \u0026#39;haha\u0026#39;; userInteractionEnabled = NO; layer = \u0026lt;_UILabelLayer: 0x18df7fb0\u0026gt;\u0026gt; | | \u0026lt;_UILabelContentLayer: 0x131a3d50\u0026gt; (layer) | \u0026lt;UILabel: 0x18df8670; frame = (0 155; 126 12); text = \u0026#39;hahaha\u0026#39;; userInteractionEnabled = NO; layer = \u0026lt;_UILabelLayer: 0x18df8730\u0026gt;\u0026gt; | | \u0026lt;_UILabelContentLayer: 0x131bea10\u0026gt; (layer) | \u0026lt;UIImageView: 0x18df88d0; frame = (0 9; 28 27); hidden = YES; opaque = NO; userInteractionEnabled = NO; layer = \u0026lt;CALayer: 0x18df8ba0\u0026gt;\u0026gt; pvc 这个命令也是递归打印层级，但是不是view，而是viewController。利用它我们可以对viewController的结构一目了然。 其实苹果在IOS8也默默的添加了 UIViewController 的一个私有辅助方法 [UIViewController _printHierarchy] 同样的效果。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 (lldb) pvc \u0026lt;TabBarController: 0x13772fd0; view = \u0026lt;UILayoutContainerView; 0x151b3a30\u0026gt;; frame = (0, 0; 414, 736)\u0026gt; | \u0026lt;UINavigationController: 0x1602b800; view = \u0026lt;UILayoutContainerView; 0x1b00aca0\u0026gt;; frame = (0, 0; 414, 736)\u0026gt; | | \u0026lt;FirstViewController: 0x16029c00; view = \u0026lt;UIView; 0x1b01e1c0\u0026gt;; frame = (0, 0; 414, 736)\u0026gt; | \u0026lt;UINavigationController: 0x138c5200; view = \u0026lt;UILayoutContainerView; 0x1316a080\u0026gt;; frame = (0, 0; 414, 736)\u0026gt; | | \u0026lt;SecondViewController: 0x16030400; view = \u0026lt;UIView; 0x2094b370\u0026gt;; frame = (0, 0; 414, 736)\u0026gt; | | | \u0026lt;SecondChildViewController: 0x15af6000; view = \u0026lt;UIView; 0x18d4e650\u0026gt;; frame = (0, 64; 414, 628)\u0026gt; | \u0026lt;UINavigationController: 0x1383ca00; view = \u0026lt;UILayoutContainerView; 0x13180070\u0026gt;; frame = (0, 0; 414, 736)\u0026gt; | | \u0026lt;ThirdViewController: 0x138ddc00; view = \u0026lt;UIView; 0x18df6650\u0026gt;; frame = (0, 0; 414, 736)\u0026gt; | | | \u0026lt;ThirdChild1ViewController: 0x1393fe00; view = \u0026lt;UIView; 0x131ec000\u0026gt;; frame = (0, 0; 414, 672)\u0026gt; | | | \u0026lt;ThirdChild2ViewController: 0x138dce00; view = \u0026lt;UIView; 0x204075a0\u0026gt;; frame = (414, 0; 414, 672)\u0026gt; | | | \u0026lt;ThirdChild3ViewController: 0x138a8e00; view = \u0026lt;UIView; 0x20426250\u0026gt;; frame = (828, 0; 414, 672)\u0026gt; | \u0026lt;UINavigationController: 0x160eca00; view = \u0026lt;UILayoutContainerView; 0x152f7d90\u0026gt;; frame = (0, 0; 414, 736)\u0026gt; | | \u0026lt;FourViewController: 0x13157cc0; view not loaded\u0026gt; visualize 这是个很有意思的功能，它可以让你使用Mac的预览打开一个 UIImage, CGImageRef, UIView, 或 CALayer。 这个功能或许可以帮我们用来截图、用来定位一个view的具体内容。 但是在我试用了一下，发现暂时还是只能在模拟器时使用，真机还不行。\n1 (lldb) visualize imageView fv \u0026amp; fvc fv 和 fvc 这两个命令是用来通过类名搜索当前内存中存在的view和viewController实例的命令，支持正则搜索。\n1 2 3 4 5 6 7 8 9 (lldb) fv scrollView 0x18d3b8c0 UIScrollView 0x137d0c50 UIScrollView 0x131b1580 UIScrollView 0x131b2070 UIScrollView (lldb) fvc Home 0x1393fe00 HomeFeedsViewController 0x138a8e00 HomeFeedsViewController (lldb) show \u0026amp; hide 这两个命令用来显示和隐藏一个指定的 UIView . 你甚至不需要Continue Progress. 就可以看到效果。\nmask/umask border/unborder 这两组命令用来标识一个view或layer的位置时用， mask用来在view上覆盖一个半透明的矩形， border可以给view添加边框。\n但是在我实际使用的过程中mask总是会报错，估计是有bug， 那么mask/unmask 一般不要用好了，用border命令是一样的效果，反正二者的用途都是找到一个对应的view.\ncaflush 这个命令会重新渲染，即可以重新绘制界面， 相当于执行了 [CATransaction flush] 方法，要注意如果在动画过程中执行这个命令，就直接渲染出动画结束的效果。 当你想在调试界面颜色、坐标之类的时候，可以直接在控制台修改属性，然后caflush就可以看到效果啦，是不是要比改代码，然后重新build省事多了呢。 例, 其中 $122 即是目标UIView：\n1 2 3 4 (lldb) p view (long) $122 = 140718754142192 (lldb) e (void)[$122 setBackgroundColor:[UIColor greenColor]] (lldb) caflush bmessage 使用场景：我们想在 [MyViewController viewWillAppear:] 里面打断点，但是 MyViewController并没有实现 viewWillAppear: 方法， 以往的作法可能就是在子类中实现下viewWillAppear:，然后打断点，然后rebuild。 那么幸好有了 bmessage命令。我们可以不用这样就可以打这个效果的断点： (lldb) bmessage -[MyViewController viewWillAppear:] 上面命令会在其父类的 viewWillAppear: 方法中打断点，并添加上了条件：[self isKindOfClass:[MyViewController class]].\nChisel-LLDB命令插件，让调试更Easy\n","date":"2018-08-31T16:20:20Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/Chisel-LLDB%E5%91%BD%E4%BB%A4%E6%8F%92%E4%BB%B6/","section":"post","tags":["调试","lldb"],"title":"Chisel-LLDB命令插件"},{"categories":["解决方案"],"contents":" {% github it-boyer width = 30% %}\nhelp 最简单命令是 help，它会列举出所有的命令。如果你忘记了一个命令是做什么的，或者想知道更多的话，你可以通过 help 来了解更多细节，例如 help print 或者 help thread。如果你甚至忘记了 help 命令是做什么的，你可以试试 help help。不过你如果知道这么做，那就说明你大概还没有忘光这个命令。\n打印变量 可以给 print 指定不同的打印格式。它们都是以 print/\u0026lt;fmt\u0026gt; 或者简化的 p/\u0026lt;fmt\u0026gt; 格式书写。 下面是一些例子： 默认的格式:\n1 2 (lldb) p 16 16 十六进制:\n1 2 (lldb) p/x 16 0x10 二进制 (t 代表 two)：\n1 2 3 4 (lldb) p/t 16 0b00000000000000000000000000010000 (lldb) p/t (char)16 0b00010000 你也可以使用 p/c 打印字符，或者 p/s 打印以空终止的字符串 (译者注：以 \u0026lsquo;\\0\u0026rsquo; 结尾的字符串)。 这里是格式的完整清单。\n完全在调试器内运行 在开始舞蹈之前，还有一件事要看一看。实际上你可以在调试器中执行任何 C/Objective-C/C++/Swift 的命令。唯一的缺点就是不能创建新函数\u0026hellip; 这意味着不能创建新的类，block，函数，有虚拟函数的 C++ 类等等。除此之外，它都可以做。\n","date":"2018-08-31T16:20:20Z","permalink":"https://it-boyer.github.io/post/%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/LLDB%E5%91%BD%E4%BB%A4%E4%BD%BF%E7%94%A8/","section":"post","tags":["调试","lldb"],"title":"LLDB命令使用"},{"categories":["解决方案"],"contents":"方法一 打开失效的项目，选择菜单：Xcode-\u0026gt;File-\u0026gt;Project Settings -\u0026gt; Advanced..， 删除图上所示的位置目录，重启xcode。 方式二 cd进入~/Library/Developer/Xcode/DerivedData 找到你的项目所用的目录（一般以你的项目名开头） cd 目录名 rm -r Index 删除掉你的项目所用的索引文件夹 方法三 退出 Xcode 重启电脑 找到 这个 DerivedData 文件夹 删除 (路径: ~/Library/Developer/Xcode/DerivedData) 删除这个 com.apple.dt.Xcode 文件 (路径: ~/Library/Caches/com.apple.dt.Xcode) 运行 Xcode 就好了~~ (1) 原文表示删除 ~/Library/Developer/Xcode/DerivedData下所有的文件，我尝试发现只需要删除当前项目相关的索引文件即可 (2) DerivedData从字面上理解应该是收集到的数据，应该是Xcode针对这个项目缓存的一些数据，不会影响项目本身的完整性\n","date":"2018-08-31T16:20:20Z","permalink":"https://it-boyer.github.io/post/old/xcode/%E8%A7%A3%E5%86%B3Xcode%E4%BB%A3%E7%A0%81%E9%AB%98%E4%BA%AE%E6%8F%90%E7%A4%BA%E5%8A%9F%E8%83%BD%E5%A4%B1%E6%95%88/","section":"post","tags":["xcode"],"title":"解决Xcode代码高亮提示功能失效"},{"categories":["项目总结"],"contents":" {% github it-boyer ReptileTool 60cac75 width = 30% %}\n目的 实践大话设计模式/swift基础语法/函数响应式开发 正则表达式语法 iOS开发之详解正则表达式原文：NSRegularExpression Tutorial: Getting Started nshipster文章NSPredicate iOS中的谓词（NSPredicate）使用\n简短的定义：正则表达式提供了一种在指定文本文档中按指定模式进行搜索，并能基于匹配模式进行修改文本的一种方式。 正则表达式的通用用例：\n执行搜索：高亮显示搜索和替换 UITextView的NSAttributedString属性来高亮显示搜索的结果 用text kit来实现高亮的功能 验证用户输入 先来看看网络爬虫的基本原理：\n一个通用的网络爬虫的框架如图所示：\n网络爬虫的基本工作流程如下：\n首先选取一部分精心挑选的种子URL； 将这些URL放入待抓取URL队列； 从待抓取URL队列中取出待抓取在URL，解析DNS，并且得到主机的ip，并将URL对应的网页下载下来，存储进已下载网页库中。此外，将这些URL放进已抓取URL队列。 分析已抓取URL队列中的URL，分析其中的其他URL，并且将URL放入待抓取URL队列，从而进入下一个循环。 网络数据抓取 概念：网络数据抓取，也叫网络爬虫。是在我们iOS程序中，获取要抓取到的网页上的数据。\n用处：如果要用到某网站的一些数据，这个时候我们就要用到抓取数据技术。\n建议：建议抓取过程中，多利用分类，多写一些分类方法，有助于提高程序可读性，也可提高效率。\n今天先来介绍一下第一种：正则表达式\n","date":"2018-08-28T12:03:26Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/RxSwift%E7%88%AC%E8%99%AB%E5%B7%A5%E5%85%B7/","section":"post","tags":[],"title":"RxSwift爬虫工具"},{"categories":["解决方案"],"contents":" {% github it-boyer width = 30% %}\n使用RxSwift开发爬虫工具 设置真机 首先打开模拟器或者真机设置中\u0026quot;Safari浏览器\u0026quot;→\u0026ldquo;高级\u0026rdquo;→\u0026ldquo;Web检查器\u0026quot;的开关。 然后我们打开Mac电脑的Safari浏览器,打开系统偏好设置(快捷键 commond + ,)，点击菜单中的\u0026quot;高级\u0026rdquo;,然后勾选\u0026quot;在菜单栏中显示\u0026quot;开发\u0026quot;菜单\u0026quot;.方便我们进行快速的调试。 这时候真机连接上数据线.或者开启模拟器就能在菜单栏\u0026quot;开发\u0026quot;选项中找到我们的设备或者是模拟器. 接下来我们只需要跑起我们的工程进入对应的WebView页面即可进行调试. ","date":"2018-08-23T13:34:25Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/%E4%BD%BF%E7%94%A8Safari%E6%B5%8F%E8%A7%88%E5%99%A8%E8%B0%83%E8%AF%95WebView/","section":"post","tags":["iOS","调试"],"title":"使用Safari浏览器调试WebView"},{"categories":["学习笔记"],"contents":" {% github beeth0ven RxSwift-Chinese-Documentation cbbc87e width = 30% %}\nRxSwift学习 RxSwift 中文文档\n更多示例 RxExample 中包含许多具有代表性的示例。它们都是很好的学习材料。这里我们取出其中几个示例来展示如何应用 RxSwift ： 演示RxExample的两种方式\nclone库，在根目录执行： 1 open Rx.xcworkspace 然后，选择想要演示的schemes (RxExample-iOS, RxExample-OSX) and hit Run。 2. 使用pod工具创建RxExample项目\n1 pod try RxSwift ImagePicker - 图片选择器\nTableViewSectionedViewController - 多层级的列表页\nCalculator - 计算器\n有兴趣的同学还可以研究一下 RxExample 中其他的示例。\n","date":"2018-08-23T09:56:38Z","permalink":"https://it-boyer.github.io/post/old/%E5%BC%80%E6%BA%90%E5%BA%93/RxSwift%E5%87%BD%E6%95%B0%E5%93%8D%E5%BA%94%E5%BC%8F%E5%BC%80%E5%8F%91/","section":"post","tags":["SDK"],"title":"RxSwift函数响应式开发"},{"categories":["博客站务"],"contents":" {% github GitbookIO gitbook 6efbb70 width = 30% %}\nGitBook Editor 个人中心\n制作书籍 在github找到文档库，fork为自己的库 登录GitBook个人中心，点击+ New新建book 在建库页面，选择导入git hub现有库 Import and sync an existing GitHub repository. 进入Personal settings，进入github设置面板 点击Configure按钮，进入github授权gitbook页面 GitBook does not have the permissions to access every GitHub repositories linked to your books. Please add them to your configuration to continue editing your books. github中设置 Repository access All repositories This applies to all current and future repositories. Only select repositories gitbook终端命令行 命令行文档 GitBook 制作 Kindle 电子书详细教程（命令行版）\n安装 1 $ npm install gitbook-cli -g 创建电子书项目 新建一个目录，并进入该目录使用 gitbook 命令初始化电子书项目。举个例子，现在要创建一个名为“MyFirstBook”的空白电子书项目，如下所示： 1 2 3 $ mkdir MyFirstBook $ cd MyFirstBook $ gitbook init 预览电子书内容 电子书内容编写完毕后可以使用浏览器预览一下。先输入下面的命令据 .md 文件生成 HTML 文档： 1 $ gitbook build Error: Couldn\u0026rsquo;t locate plugins \u0026ldquo;jsbin, anchors, video, ga, toggle-chapters, editlink, include-codeblock, splitter, github-buttons, chart, todo, quiz, include-highlight, tonic\u0026rdquo;, Run \u0026lsquo;gitbook install\u0026rsquo; to install plugins from registry. 执行安装插件命令：\n1 gitbook install 生成完毕后，会在电子书项目目录中出现一个名为“_book”的文件夹。进入该文件夹，直接用浏览器打开“index.html”，或先输入下面的命令：\n1 $ gitbook serve 然后在浏览器中输入“http://localhost:4000”即可预览电子书内容，预览完毕后按 Ctrl + C 结束。\n生成电子书文件 确定电子书没有问题后，可以通过输入以下命令生成 mobi 电子书： 1 $ gitbook mobi ./ ./MyFirstBook.mobi error: error while generating page \u0026ldquo;introduction.md\u0026rdquo;: InstallRequiredError:\u0026ldquo;svgexport\u0026rdquo; is not installed. Install it using: \u0026ldquo;npm install svgexport -g\u0026rdquo; 执行安装命令：\n1 npm install svgexport -g 如果出现以下错误提示，说明您还未安装 Calibre。由于 GitBook 生成 mobi 格式电子书依赖 Calibre 的 ebook-convert，所以请先点击这里下载安装 Calibre。\n1 2 3 Error: Need to install ebook-convert from Calibre //或者使用命令安装 brew install homebrew/cask/calibre Calibre 安装完毕后，对于 Mac OS X 系统，还需要先设置一下软链接：\n1 $ ln -s /Applications/calibre.app/Contents/MacOS/ebook-convert /usr/local/bin 再次运行转换命令，即可生成 mobi 格式电子书。\n","date":"2018-08-22T19:51:19Z","permalink":"https://it-boyer.github.io/post/old/hexo/GitBook%E7%BC%96%E8%BE%91%E5%99%A8%E4%BD%BF%E7%94%A8/","section":"post","tags":["hexo"],"title":"GitBook编辑器使用"},{"categories":["解决方案"],"contents":" {% github realm SwiftLint 8deb453 width = 30% %}\n安装配置swiftlint语法矫正工具 安装包方式 brew install swiftlint 或下载[swiftlint.pkg][https://github.com/realm/SwiftLint/releases/latest] 2. Xcode项目支持 在Xcode build Phase新增 \u0026ldquo;Run Script Phase\u0026rdquo;:\n1 2 3 4 5 if which swiftlint \u0026gt;/dev/null; then swiftlint else echo \u0026#34;warning: SwiftLint not installed, download from https://github.com/realm/SwiftLint\u0026#34; fi 单个项目安装swiftlint 通过cocoapods对单个项目安装swiftlint 1 pod \u0026#39;SwiftLint\u0026#39; 项目中添加支持 1 \u0026#34;${PODS_ROOT}/SwiftLint/swiftlint\u0026#34; 注意：pod服务器上有时并不是最新版本，尝试:=\u0026gt; githuburl无用。这种情况智能使用安装包方式。\n规则配置文件.swiftlint.yml 让 SwiftLint 在做代码规范检查时，不想检查某些源码，可以隔离规则，来自动忽略，例如： CocoaPods、Carthage、SPM 引入的第三方库文件。 在项目中新建 .swiftlint.yml 的配置文件：\n1 2 3 4 5 $ cd your-project $ vi .swiftlint.yml excluded: - Pods excluded： 配置项用来设置忽略代码规范检查的路径，可以指定整个文件夹，也可以指定精确路径下的文件。 支持嵌套： .swiftlint.yml 配置文件支持嵌套，可以给每个文件夹下的代码单独指定不同的规则，每个文件会匹配距离自己层级最近的父文件夹中的配置文件 嵌套的配置文件中的 excluded 和 included 配置会被忽略。\n终端插件集成swiftLint 支持vim编辑器： keith/swift.vim\n安装 syntastic 使用vim-pathogen安装syntastic，\n第一步安装 pathogen.vim 1 2 mkdir -p ~/.vim/autoload ~/.vim/bundle \u0026amp;\u0026amp; \\ curl -LSso ~/.vim/autoload/pathogen.vim https://tpo.pe/pathogen.vim 设置~/.vimrc配置项：\n1 execute pathogen#infect() 第二步将syntastic 作为 Pathogen bundle的资源方式安装 1 2 cd ~/.vim/bundle \u0026amp;\u0026amp; \\ git clone --depth=1 https://github.com/vim-syntastic/syntastic.git 终端集成使用 在vimrc中添加配置，当启动vim即可使用：\n1 let g:syntastic_swift_checkers = [\u0026#39;swiftpm\u0026#39;, \u0026#39;swiftlint\u0026#39;] 终端支持Package.swift 当存在Package.swift的swift目录中启动vim，swiftpm将自动可用。 终端支持.swiftlint.yml 当存在.swiftlint.yml的swift目录中启动vim，且SwiftLint已安装，自动启用swiftlint。 ","date":"2018-08-21T17:02:47Z","permalink":"https://it-boyer.github.io/post/old/shell/SwiftLint%E6%A3%80%E6%9F%A5%E4%BB%A3%E7%A0%81%E4%BD%BF%E7%94%A8/","section":"post","tags":["shell"],"title":"SwiftLint检查代码使用"},{"categories":["解决方案"],"contents":"终端支持swift自动补齐 keith/sourcekittendaemon.vim：这个插件提供了Vim集成SourceKittenDaemon。这意味着你可以在vim中开发swift项目\n需要两步：安装sourcekitten,\n第一步安装sourcekitten 安装\n方式一：brew install sourcekitten\n方式二：clone源码 ,运行swift build\n方式三：clone 源码，运行 make install\n方式三：pkg安装包 执行sourcekitten help验证安装成功。 第二步安装:SourceKittenDaemon 安装SourceKittenDaemon环境\n安装并设置SourceKittenDaemon\n方式一：pkg安装包\n方式二: 1. Clone the repository 2. 安装 make install 执行SourceKittenDaemon help验证安装成功。 使用 启动后台驻守服务HTTP：参考Protocol.org\n1 SourceKittenDaemon start --port 44876 --project /private/tmp/abcde/abcde.xcodeproj --port: 服务使用的端口号，默认为8081，vim目前不支持指定SourceKittenDaemon端口，使用默认的8081。 --project=: 指定服务将要加载的.xcodeproj文件路径，不支持指定.xcworkspaces文件路径\n使用get方法请求后驻服务：\n1 2 3 4 5 /complete # X-Offset|X-Path|X-File /stop # 停止后驻服务. 一般用于为其他target提供服务时，重新启动服务。 /ping # ping后驻服务，运行正常 return OK /project # 打印当前加载的project文件路径。 /files # 打印一个当前加载的project中包含的所有swift文件列表 ","date":"2018-08-21T15:48:24Z","permalink":"https://it-boyer.github.io/post/old/shell/%E7%BB%88%E7%AB%AF%E6%94%AF%E6%8C%81swift%E8%87%AA%E5%8A%A8%E8%A1%A5%E9%BD%90/","section":"post","tags":["shell"],"title":"终端支持swift自动补齐"},{"categories":["解决方案"],"contents":" {% github iamcco markdown-preview.vim c09a1ca width = 30% %} nisha\n命令行使用 1 2 3 4 5 MarkdownPreview \u0026#34; open preview window in markdown buffer MarkdownPreviewStop \u0026#34; close the preview window and server 插件运行效果预览 ","date":"2018-08-21T10:40:31Z","permalink":"https://it-boyer.github.io/post/old/shell/markdown-preview%E5%AE%9E%E7%8E%B0md%E9%A2%84%E8%A7%88/","section":"post","tags":["shell"],"title":"markdown-preview实现md预览"},{"categories":["项目总结"],"contents":"\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 126 127 128 129 130 131 132 133 134 135 136 137 138 139 140 141 142 143 144 145 146 147 148 149 150 151 152 153 154 155 156 157 158 159 160 161 162 163 164 165 166 167 168 169 170 171 172 173 174 175 176 177 178 179 180 181 182 183 184 185 186 187 188 189 190 191 192 193 194 195 196 197 198 199 200 201 202 203 204 205 206 207 208 209 210 211 212 213 214 215 216 217 218 219 220 221 222 223 224 225 226 227 228 229 230 231 232 233 234 235 236 237 238 239 240 241 242 243 244 245 246 247 248 249 250 251 252 253 254 255 256 257 258 259 260 261 262 263 264 265 266 267 268 269 270 271 272 273 274 275 276 277 278 279 280 281 282 283 284 285 286 287 288 289 290 291 292 293 294 295 296 297 298 299 300 301 302 303 304 305 306 307 308 309 310 311 312 313 314 315 316 317 318 319 320 321 322 323 324 325 326 327 328 329 330 331 332 333 334 335 336 337 338 339 340 341 342 343 344 345 346 347 348 349 350 351 352 353 354 355 356 357 358 359 360 361 362 363 364 365 366 367 368 369 370 371 372 373 374 375 376 377 378 379 380 381 382 383 384 385 386 387 388 389 390 391 392 393 394 395 396 397 398 399 400 401 402 403 404 405 406 407 408 409 410 411 412 413 414 415 416 417 418 419 420 421 title 智能培训类图 center header 梳理图文组件类关系图，实现在图文列表中实现智能培训样式 endheader \u0026#39;******* 类声明模块 *******\u0026#39; \u0026#39;类型:class,abstract,interface,annotation,enum\u0026#39; \u0026#39;访问域:(-)私有,(#)保护,(~)包私有,(+)公有\u0026#39; class LayoutEngineViewController{ -- 方法组 -- -(void)widgetImageViewClickWithData: } package 图文框架 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ class CenterViewController{ +Part *parentPart --二级目录数据源-- -NSMutableArray*arrParts --初始化二级目录方法-- -(void)queryTwoPartsWithParentForEnterpriseStyle:(Part *)parent --方法组 -- -(void)queryTwoPartsWithParent:(Part *)parent --初始化二级目录新闻视图页面body-- -(void)createNewsRootScrollView --通过二级目录信息，获取主体body数据方法-- -(void)addEveryNewsParts:(NSArray *)arrNewParts -(void)addParts:(NSArray *)arrNewParts } note right of CenterViewController 初始化多媒体 初始化图文列表 end note class Part { /** 父节点Id */ @property(nonatomic, copy) NSString *parentId /** 栏目Id */ @property(nonatomic, copy) NSString *partId; ///智能培训：storeId @property(nonatomic, assign) NSString *storeId; } } package 数据库 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ class DatabaseOperation{ --持久化二级目录-- + (BOOL)insertParts:withParentId: --查询二级目录数据-- + (NSMutableArray *)allpartsWithParentId: --持久化列表数据-- + (BOOL)insertNews:withPartID: --读取数据库数据-- + (NSMutableArray *)allNewsWithPartId: } CenterViewController *-- DatabaseOperation:持久化 \u0026lt; } LayoutEngineViewController *-- CenterViewController:Part \u0026gt; package 智能培训 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ LayoutEngineViewController *-- JHBaseViewController:布局映射入口 \u0026gt; JHBaseViewController \u0026lt;|-- SmartLearnViewController:反射类 \u0026gt; SmartLearnViewController *-- LearnStoreListViewController: 门店列表 \u0026gt; LearnStoreListViewController *-- CenterViewController:Part \u0026gt; class LearnStoreListViewController{ --方法组--- -(void)loadUserStores 门店列表 -(void)loadTLNewsCenterView 获取一级目录id -(void)pushTLNewCenterView:(Part *)part初始化图文 } LearnStoreListViewController *-left- ReqLearnStoreServer class ReqLearnStoreServer{ +(id)shared; @property (nonatomic, strong) JHURLRequest * request; -(void)reqGetUserStore:(void(^)(NSArray *))handler -(void)reqGetParentPart:(void(^)(KnowledgePaper *))handler } } CenterViewController *-- CenterNewsViewController: storeId (part.orderStatus == 0)左对齐图文样式\u0026gt; note right on link 通过\u0026lt;b\u0026gt;storeid\u0026lt;/b\u0026gt;来指定新接口, 加载智能培训数据源 end note CenterViewController *-- JHAudioVideoList:VAStoryCategory (part.orderStatus == 6)多媒体板式 note right on link 通过\u0026lt;b\u0026gt;storeid\u0026lt;/b\u0026gt;来指定新接口, 加载智能培训数据源 end note package JHAudioVideoList \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ class APListViewController{ --接口属性-- +VAStoryCategory *parentStoryCategory --TODO: tableView数据源模型-- VAStoryVersion：添加智能培训学习进度相关属性 --TODO: 网络接口方法-- -(void)getStoryVersionsWithCatId:LastId:count:sortBy: --block回调方法-- -getStoryVersionsCallback:(VABSAPIResponse *)res -- 暂存方法 -- -updateCacheData() -loadCacheData() --交互方法-- - (void)tableView:didSelectRowAtIndexPath: } APListViewController2 *-up- VAStoryCategory:构造参数 \u0026lt; note top on link 构造剧集列表的参数 end note APListViewController *-up- VAStoryCategory:构造参数 \u0026lt; note top on link 构造列表的参数 end note APListViewController *-- VAStoryVersion:单元格数据 \u0026lt; note top on link 单元格学习进度等 样式/数据的源 end note APListViewController *-- VADatabaseOperation:暂存 \u0026gt; note top on link 根据catid 更新持久化 table数据源数组 end note APListViewController *-left- VAMediaBaseCell:单元格 \u0026lt; class VAMediaBaseCell{ --// 发布时间|阅读时间-- @property (nonatomic, strong) UILabel *timeLabel; --// 播放次数|阅读进度-- @property (nonatomic, strong) UILabel *numLabel; } class VAStoryCategory{ +NSString *catId @property(nonatomic, copy) NSString * parentId @property (strong, nonatomic) NSString *storeId } class VAStoryVersion{ --TODO: 新增参数-- @property (assign, nonatomic) NSString *storeId; --///学习时长-- @property (strong, nonatomic) NSString *StudySec; --///预估总时长-- @property (strong, nonatomic) NSString *EstimateSec; --///学习进度-- @property (strong, nonatomic) NSString *StudySchedule; } note bottom of VAStoryVersion 解析列表数据的模型， 在此类中添加智力培训相关属性 end note VADatabaseOperation *-up- VAStoryVersion:持久化对象 \u0026lt; class VADatabaseOperation{ --TODO:当初始化时，持久化table数据源-- -(BOOL)writeStoryVersionCacheToDB:withCatId --当查看视频详情时，更新数据库-- + (BOOL) updateStoryVersion:(VAStoryVersion *)newStory +(BOOL)updatePlayListWithStoysVersion:(NSArray *)StoryVersions } note bottom of VADatabaseOperation 暂存列表中的数据模型， 映射到数据库中 end note class APListViewController2{ } note top of APListViewController2 (VideoDisplayType \u0026amp;\u0026amp; part.showType == 1) 当满足这个条件时初始化该实例 end note } package JHVideoRecording剧集版 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ APListViewController *-- VACMoviePlayerViewController:VAStoryVersion *sv \u0026gt; note top on link 当点击cell初始化剧集版播放器详情页 VideoDisplayType:// 判断用新的还是旧的播放界面 end note class VACMoviePlayerViewController{ 多媒体剧集版详情 --视频播放器启动方法-- - (void)playContentURL:(NSURL *)url } class VACGlodalManager{ +(VACGlodalManager*)SharedObj -VAALMoviePlayerController *pALMoviePlayerController; } VACMoviePlayerViewController *-- VACGlodalManager VACGlodalManager *-- VAALMoviePlayerController class VAALMoviePlayerController{ VAALMoviePlayerControls *controls; --播放控制方法组-- ---//切换屏幕--- - (void)fullscreenOrEmbedded:(NSString *)strMode; --//播放还是暂停-- - (void)playOrPause; } VAALMoviePlayerController *- VAALMoviePlayerControls:播放控制UI \u0026lt; class VAALMoviePlayerControls{ VAALButton *fullscreenButton; VAStoryVersion *story; VAALMoviePlayerController *moviePlayer; --TODO: 五定图按钮-- UIButton *showSevenImgButton; -(void)showSevenImgListAction; } VACMoviePlayerViewController .|\u0026gt; ALMoviePlayerControllerDelegate:代理 \u0026gt; interface ALMoviePlayerControllerDelegate{ --//上一曲-- - (void)beforePlayingVideo; --//下一曲-- - (void)afterPlayingVideo; --//切换屏幕-- - (void)fullscreenOrEmbedded:(NSString *)strMode; --//播放还是暂停-- - (void)playOrPause; } } package JHVideoRecording列表版 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ APListViewController *-- VACVideoPlayerDetailViewController:多媒体详情列表版 \u0026lt; note top on link 当选择cell初始化操作 VAStoryVersion * sv多媒体详情列表 end note VACVideoPlayerDetailViewController *-- JHTWVideoPlayer:播放器 \u0026lt; VACVideoPlayerDetailViewController *-- VAStoryVersion VACVideoPlayerDetailViewController .|\u0026gt; VideoPlayDetailProtocol:代理 \u0026lt; VACVideoPlayerDetailViewController *-- VideoPlayDetailBIZ:播放器辅助类 \u0026lt; JHTWVideoPlayer *-- VAStoryVersion:构造参数 \u0026lt; APListViewController2 *-- VACMoviePlayerViewController:多媒体详情剧集版 \u0026gt; class VACVideoPlayerDetailViewController{ --基础属性-- +VAStoryVersion *storyVersion -VideoPlayDetailBIZ *vpdBIZ --播放器浮动框显示五定图相关控件-- -UIView *sevenView --构造方法-- -initWithModel:(VAStoryVersion *)sv --点击按钮显示五定图预览列表-- -(void)showSevenImgList } class JHTWVideoPlayer{ --私有属性-- -VAStoryVersion *sv --构造器-- + (id)initWithFrame:model:(VAStoryVersion *)sv --加载新视频-- + (void)loadVideo:(VAStoryVersion *)sv } class VideoPlayDetailBIZ{ --接口参数-- +VAStoryVersion *currentStoryVersion } interface VideoPlayDetailProtocol{ --加载视频-- - (void)loadVideo:(VAStoryVersion *)sv; } } package 公共组件 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ APListViewController *-- VANetEngine:网络工具 \u0026lt; class VANetEngine{ --TODO: 图文网络接口方法-- -(void)v5newsQueryPartsWithPartId:parentId:count:dateTime:lastMeters:lon:lat:newOrOld:modifyTime:partModifiedtimeForPart:orderType:type:del:sel --TODO: 视频列表接口方法-- -(void)getStoryVersionsWithCatId:LastId:count:sortBy:asc:del: --block回调方法-- -getStoryVersionsCallback:(VABSAPIResponse *)res } VideoPlayDetailProtocol \u0026lt;-- SevenImgCapture:启用五定图 \u0026lt; class SevenImgCapture { --类方法-- +(SevenImgCapture *)shared --五定信息搜集方法-- -(void)threeInfo --文字图片合成方法-- - (UIImage *)complexText } note right of VANetEngine 网络工具 end note } package 图文列表模块 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ class BaseTableViewController{ --数据源-- +dataArray --加载网络数据-- - (void)loadMoreData } BaseTableViewController \u0026lt;|-- PartBaseViewController:继承 \u0026gt; PartBaseViewController \u0026lt;|-- CenterNewsViewController:继承data数据 \u0026gt; class PartBaseViewController{ --重载网络数据接口-- - (void)loadMoreData } PartBaseViewController *- DatabaseOperation:持久化 \u0026lt; class CenterNewsViewController{ --继承父类数据源-- +dataArray -- 智能培训标示-- open storeId:String __ 初始化cell代理方法 __ - (UITableViewCell *)tableView:cellForRowAtIndexPath: - (id)getCellDataWith: 获取cell数据 // 根据新闻取得对应的图集cell类 - (Class)getCellInfoByNews:CellId: --图文支持视频列表显示的方法-- #pragma mark - 进入阅读跳转 - (void)tableView:didSelectRowAtIndexPath: //不收费，且无权限要求时,进入阅读跳转 -(void)expush_mothed:(NSIndexPath *)indexPath } } package JHAcrossNetEngin图文访问网络模块 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ class NetEngine{ --新增图文列表接口-- -(void)v5newsQueryPartsWithPartId:parentId:storeId:count:dateTime:lastMeters:lon:lat:newOrOld:modifyTime:partModifiedtimeForPart:orderType:type:del:sel } PartBaseViewController \u0026lt;-down- NetEngine: 获取列表信息 \u0026lt; } package 图文详情模块 \u0026lt;\u0026lt;Rectangle\u0026gt;\u0026gt;{ class JHTWAtlasBaseCell{ +News *currentNews +fillDataWithModel:(New *):celldata 填充数据 } class JHTWMixedLARListCell{ -- 方法 -- [super fillDataWithModel:] TODO:适配智能培训UI布局 } class New{ __ 智能培训相关属性 __ @property (strong, nonatomic) NSString *StudySec; @property (strong, nonatomic) NSString *EstimateSec; @property (strong, nonatomic) NSString *StudySchedule; } note right of New 在替换新接口中，复用这个数据模型，添加智能培训相关属性 1. 添加属性： 2. 复用解析 3. 复用暂存 end note class ListAndCardNewDetailViewController{ } } CenterNewsViewController o-- JHTWAtlasBaseCell:初始化图文cell数据 \u0026lt; JHTWAtlasBaseCell \u0026lt;|-- JHTWMixedLARListCell JHTWMixedLARListCell o--New: picCount=1 \u0026lt; note right on link 当picCount=1时，图文列表会使用单个图片样式 end note package 多媒体 \u0026lt;\u0026lt;Rectangle\u0026gt;\u0026gt;{ class JHTWMixedMediaCell{ } class TLNewsHomepage{ --播放器初始化方法-- -(void)playMediaNews:clickedNews playList: } class JHTWMediaVideoPlayerDetailViewController{ } } JHTWMediaVideoPlayerDetailViewController *-- VANetEngine:五定图相关数据接口 \u0026lt; JHTWMediaVideoPlayerDetailViewController \u0026lt;-- SevenImgCapture: \u0026lt; CenterNewsViewController *-- TLNewsHomepage:多媒体详情 \u0026gt; note right on link 当点击cell调用 `expush_mothed`方法 [clickedNews isMediaNews]当点击多媒体cell时， 初始化视频播放器 end note CenterNewsViewController *-- JHTWMixedMediaCell:多媒体cell \u0026lt; note right on link 初始化图文列表时，显示多媒体cell样式 end note TLNewsHomepage *-- JHTWMediaVideoPlayerDetailViewController:播放器详情 \u0026gt; note right on link 初始化播放器页面 end note JHTWMediaVideoPlayerDetailViewController *-- New:构造参数 \u0026lt; JHTWMixedMediaCell o-- New:构造参数 \u0026lt; ListAndCardNewDetailViewController *-- New:构造参数 \u0026lt; CenterNewsViewController *-- ListAndCardNewDetailViewController:图文详情 \u0026gt; note right on link 当点击cell调用 `expush_mothed`方法 [clickedNews isMediaNews]当点击多媒体cell时， 初始化视频播放器 end note \u0026#39;JHTWAtlasBaseCell \u0026lt;|- JHTWMixedLARListCell \u0026#39;picCount == 1 \u0026#39;显示/隐藏类,类方法属性等 关键字支持class,interface,enum\u0026#39; \u0026#39;---- 声明类关系线备注,可以当做用例来参与到关系连接中 ---\u0026#39; \u0026#39;note \u0026#34;图文左列表样式，复用样式，实现智能培训相关内容的显示：学习进度时长等信息\u0026#34; as new \u0026#39;###### 类备注模块 类声明末尾使用:note 位置: 备注#########\u0026#39; note right of CenterNewsViewController 复用图文左列表样式 \u0026lt;b\u0026gt;实现智能培训相关属性显示：学习进度等。 end note center footer 梳理图文组件类关系图 endfooter ","date":"2018-08-18T14:36:18Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%9B%BE%E6%96%87%E7%BB%84%E4%BB%B6%E5%8F%8A%E5%A4%9A%E5%AA%92%E4%BD%93%E7%BB%84%E4%BB%B6%E7%B1%BB%E5%9B%BE/","section":"post","tags":[],"title":"图文组件及多媒体组件类图"},{"categories":["解决方案"],"contents":" {% github jerrymarino iCompleteMe ad0e1fe width = 30% %} iCompleteMe是基于YouCompleteMe。在花了一年多的时间试图实现对YouCompleteMe的快速支持之后，发现在YCM无法支持swift自动补齐。 iCompleteMe实现的行为对于Swift的补齐提示。iCompleteMe的核心子系统只与Swift一起工作。代码基占用的空间要小得多，这使得在CI上更容易安装、更容易理解和更稳定(理论上)。\n在space-vim中添加插件支持 1 Plugin \u0026#39;jerrymarino/iCompleteMe\u0026#39; 安装：\n1 2 3 cd ~/.vim/plugged/iCompleteMe/ brew install cmake ./install.py 然后 \u0026lt;Leader\u0026gt; f R 使配置生效，并执行 :PlugInstall进行安装.\n","date":"2018-08-10T16:40:19Z","permalink":"https://it-boyer.github.io/post/old/shell/iCompleteMe%E6%94%AF%E6%8C%81swift%E8%AF%AD%E6%B3%95%E6%8F%90%E7%A4%BA/","section":"post","tags":["shell"],"title":"iCompleteMe支持swift语法提示"},{"categories":["解决方案"],"contents":" {% github jerrymarino SwiftPlayground.vim f603700 width = 30% %}\n执行环境 在playgrounds后缀的目录中执行swift文件\n熟悉vim快捷键用法 空格 + fs 保存文件：此时插件会自动运行playgrounds，显示效果 shift + H ：行头 shift + L：行尾 :copen : AsyncRun显示运行日志 :AsyncRun shell命令\n支持结构 *.playgroud/Contents.swift 不支持包含：Pages页面的playground。\n","date":"2018-08-10T15:50:21Z","permalink":"https://it-boyer.github.io/post/old/shell/SwiftPlayground%E5%91%BD%E4%BB%A4%E6%93%8D%E4%BD%9C/","section":"post","tags":["shell"],"title":"SwiftPlayground命令操作"},{"categories":["学习笔记"],"contents":" {% github it-boyer FSCalendar 1a026a4c width = 30% %}\n自定义日历控件，日期图标 FSCalendar FSCalendar是一款开源iOS日历控件，支持横向、纵向滑动模式，全屏模式，带有子标题、事件设置等功能。以下是项目截图： Use Interface Builder 1、 Drag an UIView object to ViewController Scene 2、 Change the Custom Class to FSCalendar 3、 Link dataSource and delegate to the ViewController 4、 Finally, implement FSCalendarDataSource and FSCalendarDelegate in your ViewController 预览效果 ","date":"2018-07-17T17:59:05Z","permalink":"https://it-boyer.github.io/post/old/%E5%BC%80%E6%BA%90%E5%BA%93/FSCalendar%E6%94%AF%E6%8C%81%E8%87%AA%E5%AE%9A%E4%B9%89%E7%9A%84%E6%97%A5%E5%8E%86%E5%BC%80%E6%BA%90%E5%BA%93/","section":"post","tags":["SDK"],"title":"FSCalendar支持自定义的日历开源库"},{"categories":["学习笔记"],"contents":"豆瓣导图 豆瓣总结\n前言 如何善用本书 第一部分 重新探索自我 第一章 由内而外全面造就自己 第二章 七个习惯——概论 第二部分 个人的成功：从依赖到独立 第三章 习惯一：积极主动——个人愿景的原则 第四章 习惯二：以终为始——自我领导的原则 个人使命宣言 以终为始最有效的方法，就是撰写一份个人使命宣言，即人生哲学或基础信念。 宣言：主要说明自己想成为怎样的品行的人。成什么样的事业，及为此奠基的价值观和原则。 家庭第一 借重宗教的力量 在诚信问题上决不妥协 念及相关的每个人 未听取正反双方的意见，不妄下断语 征求他人意见 维护不在场的人 诚恳但立场坚定 每年掌握一种新技能 今天计划明天的工作 利用等待的空闲时间 态度积极 保持幽默感 生活与工作有条不紊 别怕犯错，怕的是不能吸取教训 协助属下成功 多请教别人 专注于当前的工作，不为下一次任务或提升操心\n定期储蓄或利用部分收入做投资\n一个人的应变能力取决于他对自己的本性，人生目标以及价值观的不变的信念。 只要心中秉持着恒久不变的真理，就能屹立于动荡的环境中。\n标记疗法的基础原理：许多心智或情感疾病，都是由于失落感或空虚感作祟，而标记疗法可以帮助病人找回生命的意义与使命感，以祛除这些感觉。\n第五章 习惯三：要事第一——自我管理的原则 豆瓣笔记\n第三部分 公众的成功：从独立到互赖 第六章 你不是一座孤岛 第七章 习惯四：双赢思维——人际领导的原则 第八章 习惯五：知彼知己——同理心交流的原则 第九章 习惯六：统合综效——创造性合作的原则 第四部分 全面观照生命 第十章 习惯七：不断更新——平衡的自我更新的原则 第十一章 再次由内而外造就自己 附录 一、你是哪种类型的人？——生活重心面面观 二、第四代时间管理——高效能人士的一天\n","date":"2018-07-03T12:30:31Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E9%AB%98%E6%95%88%E4%BA%BA%E5%A3%AB%E7%9A%84%E4%B8%83%E4%B8%AA%E4%B9%A0%E6%83%AF/","section":"post","tags":["图书"],"title":"高效人士的七个习惯"},{"categories":["学习笔记"],"contents":"","date":"2018-07-02T19:52:08Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E7%A8%8B%E5%BA%8F%E5%91%98%E8%B7%B3%E6%A7%BD%E5%85%A8%E6%94%BB%E7%95%A5/","section":"post","tags":["图书"],"title":"程序员跳槽全攻略"},{"categories":["学习笔记"],"contents":"处境 人到中年，职场受排挤降级，情场被抛弃不如意，怨天尤人，自怨自艾，却不思进取，死扛着压力勉强养家糊口残喘于世。\n心态转折 红皇后的故事：寓意为什么在现实生活中不进则退的境地，见贤思齐，善于发现同事优点，定位榜样学习实线。 读书习惯 100天33本书: 从量到质达到，培养读书习惯的目的。 ","date":"2018-07-02T13:59:35Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E4%B9%A6%E9%83%BD%E4%B8%8D%E4%BC%9A%E8%AF%BB%E8%BF%98%E6%83%B3%E6%88%90%E5%8A%9F/","section":"post","tags":["图书"],"title":"书都不会读还想成功"},{"categories":["学习笔记"],"contents":" {% github it-boyer JHHomeAPP 813e4b width = 30% %}\n在静态库组件中使用swift开发 基于静态库的开发，实现封装静态库/Framework并使用swiftOC混编开发\n创建三个角色 主项目：JHHomeAPP 静态库组件：FirstPlug SwiftInStaticLib(包含Swift源码实现的静态库) 动态库secondFramework 静态库：问题1 当静态库组件中存在swift源码时，依赖该组件的主工程会报错：\n1 2 3 4 5 6 7 8 ld: warning: Auto-Linking library not found for -lswiftDispatch ld: warning: Auto-Linking library not found for -lswiftCoreFoundation ld: warning: Auto-Linking library not found for -lswiftObjectiveC ld: warning: Auto-Linking library not found for -lswiftDarwin ld: warning: Auto-Linking library not found for -lswiftFoundation ld: warning: Auto-Linking library not found for -lswiftCoreGraphics ld: warning: Auto-Linking library not found for -lswiftCore ld: warning: Auto-Linking library not found for -lswiftSwiftOnoneSupport 联想方法： 设置 Always Embed Swift Standard Libraries: YES 结果无效。 适用的解决方法 在主工程中新建一个空的swift源文件，不需要自动新建$(SWIFT_MODULE_NAME)-Swift.h映射文件和JHHomeAPP/JHHomeAPP-Bridging-Header.h头文件。 使用方法2，问题1就不存在了，证明了在静态库中可以使用swift源码文件进行开发,同样证明了静态库可以封装包含swift源码的静态库。 Framework：问题2 在动态库中objc源码方法可以封装到静态库，并在可执行文件中调用。 当在Framework中新建swift源文件时，第一次编译运行出现崩溃问题： 1 2 3 dyld: Library not loaded: @rpath/libswiftCoreImage.dylib Referenced from: .../../Debug-iphonesimulator/SecondFramework.framework/SecondFramework Reason: image not found 解决办法：需要在ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES设置为YES.再次编译出现问题3。\nFramework: 问题3 当在oc源码文件中用引用-Swift.h头文件时，出现一下问题:\n1 2 3 \u0026#39;SecondFramework-Swift.h\u0026#39; file not found #import \u0026#34;SecondFramework-Swift.h\u0026#34; ^~~~~~~~~~~~~~~~~~~~~~~~~ 结果将：Install Objective-C Compatibility Header : NO可以正常调用swift方法了。\n验证：framework可以封装到静态库中，当有swift源码实现时需要设置ALWAYS_EMBED_SWIFT_STANDARD_LIBRARIES=YES\n总结 Product Module Name: 该项默认为项目名或自定义的名称 Defines Module: 设置为YES （framework默认为YES，静态库默认为NO） Embedded Content Contains Swift: 设置为YES Install Objective-C Compatibility Header：设置为YES （如上题说：在framework中设置为NO，才能正常运行，在静态库中似乎不影响） Objective-C Bridging Header: 自定义需要桥接到Swift中的OC头文件（EX：$(SRCROOT)/Swift-Bridging-Header.h） ","date":"2018-06-23T16:41:58Z","permalink":"https://it-boyer.github.io/post/old/swift/Framework%E5%AE%9E%E7%8E%B0%E4%BD%BF%E7%94%A8swift%E5%BC%80%E5%8F%91/","section":"post","tags":["swift"],"title":"Framework实现使用swift开发"},{"categories":["学习笔记"],"contents":"Cocoapods作为OS X和iOS开发平台的类库管理工具，已经非常完善和强大。通常我们用pod来管理第三方开源类库，但我们也极有可能会开发一个用pod管理依赖关系的静态类库给其他人使用，而又不愿意公开源代码，比如一些SDK，那么就需要打包成.a文件。本文将以一个依赖于ASIHTTPRequest的静态类库，来演示如何创建使用了CocoaPods的静态类库以及打包的过程。\n开发静态库（Static Library） 搭建pod静态库项目 不基于pod手动创建(deprecated) 在Xcode中创建一个Cocoa Touch Static Library； 创建Podfile文件； 执行pod install完成整个项目的搭建； 如果需要demo，手动创建示例程序，使用pod添加对私有静态库的依赖，重复执行pod install完成示例项目的搭建。 基于pod自动创建 只需要输入pod lib命令即可完成初始项目的搭建，下面详细说明具体步骤，以JHLib作为项目名演示。 1.执行命令pod lib create JHLib。在此期间需要确认下面4个问题。\n打包类库 需要使用一个cocoapods的插件cocoapods-packager来完成类库的打包。当然也可以手动编译打包，但是过程会相当繁琐。\n安装打包插件 终端执行以下命令 1 sudo gem install cocoapods-packager 打包 命令很简单，执行 1 pod package BZLib.podspec --library --force 其中--library指定打包成.a文件，如果不带上将会打包成.framework文件。--force是指强制覆盖。最终的目录结构如下\n1 2 3 |____BZLib.podspec |____ios | |____libBZLib.a 需要特别强调的是，该插件通过对引用的三方库进行重命名很好的解决了类库命名冲突的问题。 比如你的类库使用了ASI，然后打包成静态库.a文件。外部调用的项目也使用了ASI，那么不会造成冲突。因为在打包的时候，你的类库里的ASI被重命名为项目+ASI的前缀。\n如何打造一个让人愉快的框架 使用CocoaPods开发并打包静态库 iOS动态库,静态库以及framework\n","date":"2018-06-21T21:37:16Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E4%BD%BF%E7%94%A8CocoaPods%E5%BC%80%E5%8F%91%E9%9D%99%E6%80%81%E5%BA%93/","section":"post","tags":["pod"],"title":"使用CocoaPods开发静态库"},{"categories":["解决方案"],"contents":"tag标签自增新建脚本 1 2 3 4 5 6 #!/bin/sh tag=$(git describe --tags `git rev-list --tags --max-count=1`) version=${tag##*.} let \u0026#34;version+=1\u0026#34; newTag=${tag%.*}.${version} echo \u0026#39;Create New Tag \u0026#39;$newTag 修改tag版本号的方法 方法一：覆盖 已有v1.0.2.8要覆盖该版本 1 git tag -f v1.0.2.8 服务器已有v1.0.2.8，强制推到服务器 1 git push origin -f v1.0.2.8 同步服务器：获取服务器刚刚的v1.0.2.8 1 git fetch -–tag 方法：删除分支 删除本地版本 1 git tag -d v1.0.2.8 删除服务器上的分支(用空版本覆盖) 1 git push origin :v1.0.2.8 服务器获取刚刚的v1.0.2.8 1 git fetch –-tag ","date":"2018-06-20T17:22:37Z","permalink":"https://it-boyer.github.io/post/old/git/%E4%BD%BF%E7%94%A8tag%E7%AE%A1%E7%90%86%E5%A4%9A%E4%B8%AA%E7%9B%B8%E5%85%B3%E7%BB%84%E4%BB%B6%E7%9A%84%E7%89%88%E6%9C%AC%E5%8F%91%E5%B8%83/","section":"post","tags":["git"],"title":"使用tag管理多个相关组件的版本发布"},{"categories":["项目总结"],"contents":" {% github it-boyer ArcProgressUI 4b9bc85 width = 30% %}\nArcProgressUI Example To run the example project, clone the repo, and run pod install from the Example directory first.\nRequirements Installation ArcProgressUI is available through CocoaPods. To install it, simply add the following line to your Podfile:\n1 pod \u0026#39;ArcProgressUI\u0026#39; API使用 独立进度表盘加载 1 2 3 4 5 #import \u0026#34;ArcProgressView.h\u0026#34; NSArray *viewArr = [[NSBundle mainBundle] loadNibNamed:@\u0026#34;ArcProgressView\u0026#34; owner:nil options:nil]; UIView *arcView = viewArr.lastObject; arcView.backgroundColor = [UIColor redColor]; [self.view addSubview:arcView]; 完整控制器页面 1 2 3 4 5 6 7 8 9 10 #import \u0026#34;PatrolScoreViewController.h\u0026#34; +(PatrolScoreViewController *)withStoryboard:(PatrolScoreStyle)style{ NSBundle *podbundle = [NSBundle bundleForClass:[PatrolScoreViewController class]]; NSURL *bundleURL = [podbundle URLForResource:@\u0026#34;ArcProgressUI\u0026#34; withExtension:@\u0026#34;bundle\u0026#34;]; NSBundle *bundle = [NSBundle bundleWithURL:bundleURL]; UIStoryboard *story = [UIStoryboard storyboardWithName:@\u0026#34;PatrolScore\u0026#34; bundle:bundle]; PatrolScoreViewController *VC = [story instantiateViewControllerWithIdentifier:@\u0026#34;PatrolScoreViewController\u0026#34;]; VC.scoreViewStyle = style; return VC; } 静态库开发： 设想：通过cocoapod管理静态库的依赖关系。在项目调用静态库\n主工程：prj\n一级静态库: first.a ：组件\n二级静态库：组件依赖的静态库\nsec.a : 二级静态库.a pod.a ：包含二级静态库的集合\n其他经验：通过pod来开发一级静态库即组件。会生成组件的工作空间：workspace 将prj主工程拖入工作空间，来协作开发。\n坑：当再次切换prj主工程,关联.a组件依赖时，例如：libJHPatrol.a的other linker tag 路径一定要更新。\n结果：\n手动配置一级静态库组件，依赖的二级静态库可用 资源bundle文件直接添加到主工程资源拷贝列表中，在代码中会正常映射出IBoutlet相应的UI实例。参见 上述使用说明 -ObjC设置 在主工程build setting 配置的Other linker ： -ObjC：表示尽可能的加载所有依赖静态库中的objc源码资源。 解决的问题：可以解决通过资源（xib/storyboard）初始化实例式 1 this class is not key value coding-compliant for the key ibReviewLabel 解决在storyboard中使用源码自定义UI控件时，无效果的问题。\n在封装静态库中，storyboard/xib中的控件不要设置model属性。\n使用pod来一级静态库组件，管理依赖的二级静态库libpod.a无效\nAuthor huo3203@hotmail.com, 724987481\nLicense ArcProgressUI is available under the MIT license. See the LICENSE file for more info.\n","date":"2018-06-20T15:31:52Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E5%BC%A7%E5%BD%A2%E8%A1%A8%E7%9B%98%E8%BF%9B%E5%BA%A6%E4%BB%AA%E8%A1%A8/","section":"post","tags":[],"title":"弧形表盘进度仪表"},{"categories":["学习笔记"],"contents":"通过IB（xib/storyboard）创建View的周期方法 loadView：加载View方法，UI是通过代码绘制时，初始化控制器的视图时，会调用该方法。优先级高于IB视图，当重载时，会直接覆盖IB中的视图,因为无论nib也好，xib也好，最终在执行UIViewController生命周期函数loadView之前，都会转化成可执行的nib文件。 initWithNibName：是类的构造器方法，通过IB创建的类：简称IB类，IB类需要通过这个构造器来实例化对象。 initWithCoder：当IB类实例化时会调用该方法，即通过initWithNibName构造器实例化对象时，会调用该方法来分配IB对象的内存空间。 awakeFromNib：当实例化IB视图类时执行，即当IB文件被加载的时候，会发送一个awakeFromNib的消息到IB文件中的每个的对象，每个对象都可以定义自己的awakeFromNib函数来响应这个消息，执行一些必要的操作。 帮助记忆：一开始经过initWithCoder创建出来的控件是死的，然后通过awakeFromNib来唤醒，所以这会有一个先后的调用顺序\nviewDidLoad：当view对象被加载到内存后就会执行viewDidLoad，所以不管通过nib文件还是代码的方式创建对象都会执行viewDidLoad 。 加载xib方法 加载视图 方法一 1 2 3 4 5 6 NSArray* nibView = [[NSBundle mainBundle] loadNibNamed:@\u0026#34;xibfileName\u0026#34; owner:nil options:nil]; UIView *xibView = nibView.lastObject; //======= // 这里的bundle参数是nil,(这里nil默认就是mianBundle) UINib *nib = [UINib nibWithNibName:@\u0026#34;xib文件名\u0026#34; bundle:nil]; NSArray *views = [nib instantiateWithOwner:nil options:nil]; 方法二 owner:xib中的fileObject参数\n1 2 3 4 5 //加载所有xib文件 NSArray* objects = [[NSBundle mainBundle] loadNibNamed:nibName owner:self options:nil]; //加载指定xib文件 ContactsTableViewCell *cell = [[[NSBundle mainBundle]loadNibNamed:@\u0026#34;ContactsTableViewCell\u0026#34; owner:nil options:nil] objectAtIndex:0]; 加载控制器对象 1 self = [super initWithNibName:@\u0026#34;xibName\u0026#34; bundle:nibBundleOrNil]; 加载storyboard 加载控制器对象 1 2 3 4 5 6 7 8 9 10 // 加载storyboard UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@\u0026#34;Two\u0026#34; bundle:nil]; // 创建storyboard里面灰色的控制器 //找到shtoryboard里面设置的初始控制器 // UIViewController *vc = [storyboard instantiateInitialViewController]; // 从storyboard里面找出绑定标识的控制器 MJTwoViewController *vc = [storyboard instantiateViewControllerWithIdentifier:@\u0026#34;pink\u0026#34;]; self.window.rootViewController = vc; ","date":"2018-06-20T14:49:37Z","permalink":"https://it-boyer.github.io/post/old/iOS/UI/storyboard%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F/","section":"post","tags":["iOS"],"title":"storyboard的几种方式"},{"categories":["解决方案"],"contents":"使用curl命令管理远程github库\n新建远程仓库 在本地准备工作 进入一个目录，这个目录是本地仓库的目录； 在本地建立仓库 1 git init \u0026amp;\u0026amp; git add . \u0026amp;\u0026amp; git commit -m \u0026#39;some information\u0026#39; 新建一个API token 打开此链接，generate new token，写入description，选择scopes（设置此token持有者的权限）。记住personal access token（也就是那一串字符和数字）！这一串东西只出现一次，下次查看不到。 基础命令 这是最直接的一种形式，直接把参数写到命令行搞定：\n1 2 curl -u git账号 -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;新库名\u0026#34;,\u0026#34;description\u0026#34;:\u0026#34;库描述\u0026#34;}\u0026#39; https://api.github.com/user/repos curl -u \u0026#34;$username:$token\u0026#34; https://api.github.com/user/repos -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;\u0026#39;$repo_name\u0026#39;\u0026#34;}\u0026#39; 注：这里需要把$username和$token分别换成实际的用户名和刚才记住的personal access token，把$repo_name换成任何想要的repo name。\nbash 形式 我们可以把命令行写成bash脚本，下次只要执行里面的简单命令就可以执行以上整条命令。\n把username和token写入(apend或者修改)~/.gitconfig，形式如下： 1 2 3 [github] user = your user name token = the token you get 把如下 bash code写入（append）~/.bash_profile文件 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 github-create() { repo_name=$1 dir_name=`basename $(pwd)` if [ \u0026#34;$repo_name\u0026#34; = \u0026#34;\u0026#34; ]; then echo \u0026#34;Repo name (hit enter to use \u0026#39;$dir_name\u0026#39;)?\u0026#34; read repo_name fi if [ \u0026#34;$repo_name\u0026#34; = \u0026#34;\u0026#34; ]; then repo_name=$dir_name fi username=`git config github.user` if [ \u0026#34;$username\u0026#34; = \u0026#34;\u0026#34; ]; then echo \u0026#34;Could not find username, run \u0026#39;git config --global github.user \u0026lt;username\u0026gt;\u0026#39;\u0026#34; invalid_credentials=1 fi token=`git config github.token` if [ \u0026#34;$token\u0026#34; = \u0026#34;\u0026#34; ]; then echo \u0026#34;Could not find token, run \u0026#39;git config --global github.token \u0026lt;token\u0026gt;\u0026#39;\u0026#34; invalid_credentials=1 fi if [ \u0026#34;$invalid_credentials\u0026#34; == \u0026#34;1\u0026#34; ]; then return 1 fi echo -n \u0026#34;Creating Github repository \u0026#39;$repo_name\u0026#39; ...\u0026#34; curl -u \u0026#34;$username:$token\u0026#34; https://api.github.com/user/repos -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;\u0026#39;$repo_name\u0026#39;\u0026#34;}\u0026#39; \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 echo \u0026#34; done.\u0026#34; echo -n \u0026#34;Pushing local code to remote ...\u0026#34; git remote add origin git@github.com:$username/$repo_name.git \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 git push -u origin master \u0026gt; /dev/null 2\u0026gt;\u0026amp;1 echo \u0026#34; done.\u0026#34; } 也可以将脚本保存在github-create.sh文件中，让后在~/.bash_profile添加导入语句 1 . \u0026#34;$HOME/your path/github-create.sh\u0026#34; 也可以导入到oh-my-zsh配置文件zshrc.zsh-template中，每次创建myzsh窗口时，github-create方法会初始化在环境中： 1 . \u0026#34;$HOME/hsg/hexo/Util/tool/github-create.sh\u0026#34; 重新打开或新启动一个终端窗口，或者也可以在当前Terminal下运行如下命令 1 Source ~/.bash_profile 然后就可以用如下命令创建远程仓库了 1 github-create [repo name] 如果你不想用默认repo name（也就是当前目录名）创建repo可以重新输入另一个名字，否则直接按回车执行。\nbash形式\u0026ndash;简化版 把如下bash code写入（append）~/.bash_profile文件。第十行按照形式一处理一下。 1 2 3 4 5 6 7 8 9 10 11 12 13 simple-create() { if [ $1 ] then repo_name=$1 else echo \u0026#34;Repo name?\u0026#34; read repo_name fi curl -u \u0026#39;$username:$token\u0026#39; https://api.github.com/user/repos -d \u0026#39;{\u0026#34;name\u0026#34;:\u0026#34;\u0026#39;$repo_name\u0026#39;\u0026#34;}\u0026#39; git remote add origin git@github.com:efatsi/$repo_name.git git push -u origin master } 重新打开或新启动一个终端窗口，或者也可以在当前Terminal下运行如下命令 1 Source ~/.bash_profile 执行命令 1 simple-create [repo name] 查询现有库 1 curl -u git账号 https://api.github.com/repos/账号/库名 初始化远程仓库 找到仓库路径的字段clone_url或者\n1 2 3 4 git remote add origin clone_url //或者使用ssh,避免输入密码 //git remote add origin ssh_url git push origin master 删除远程仓库 1 2 3 4 5 6 7 githubDelRepo(){ if [[ $# != 2 ]] ; then echo \u0026#34;Needs username and repo-name as args 1 and 2 respectively.\u0026#34; else curl -X DELETE -u \u0026#34;${1}\u0026#34; https://api.github.com/repos/\u0026#34;${1}\u0026#34;/\u0026#34;${2}\u0026#34; fi } ","date":"2018-06-20T11:14:00Z","permalink":"https://it-boyer.github.io/post/old/git/%E4%BD%BF%E7%94%A8curl%E5%91%BD%E4%BB%A4%E7%AE%A1%E7%90%86%E8%BF%9C%E7%A8%8Bgithub%E5%BA%93/","section":"post","tags":["github"],"title":"使用curl命令管理远程github库"},{"categories":["解决方案"],"contents":"场景 例如，当急需在Mac系统上，安装abletonLive，涉及到破解机exe小程序，使用文中提到的两种方法，就解了燃眉之急。\n方法一 crossover\nWrappe[k]小应用 这款软件适用于一些小型exe程序，其他，推荐方法一 下载 密码: khqa 参看\n","date":"2018-06-19T18:09:18Z","permalink":"https://it-boyer.github.io/post/old/macOS/MacOS%E7%B3%BB%E7%BB%9F%E4%B8%8B%E8%BF%90%E8%A1%8Cexe%E5%B0%8F%E7%A8%8B%E5%BA%8F/","section":"post","tags":["macOS"],"title":"MacOS系统下运行exe小程序"},{"categories":["解决方案"],"contents":"Garageband不支持控件表面，因此无法使用Launchpad/LaunchKey的全部功能。\n在Garageband中，仅可以使用Launchpad来演奏虚拟乐器。 原因：Faders和Knobs将为输出MIDI CC消息(详细介绍)到支持手动操作的MIDI设备的插件。此外，打击垫还将发送固定的Note数据。 然而，Garageband本身没有传输、卷或Pan控件，不支持Launchpad的Volume or Pan Control。因此，只能在支持HUI Protocol的DAW的DAW，或者选择Ableton Live，Launchpad才能发挥最大的作用。 原文\n","date":"2018-06-19T15:39:56Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/%E5%9C%A8GarageBand%E4%B8%AD%E4%BD%BF%E7%94%A8LaunchPad/","section":"post","tags":["智能设备"],"title":"在GarageBand中使用LaunchPad"},{"categories":["解决方案"],"contents":"launchPad 设备官网\n官方教程资源 官方工程试听资源支持下载\nableton live 软件 官网下载 中国社区 ABLETON LIVE 10.0.1 SUITE 破解版下载 WINDOWS \u0026amp; MAC ABLETON LIVE10.0.1破解机下载\n下载 安装 {% post_path MacOS系统下运行exe小程序 %}\n灯光 第二期：Chain的选择与设置/页数的映射 音频轨道 拖拽音频文件或视频文件到Simple采样轨道中，视频格式会生成asd格式的新文件文件，加载到轨道中。\nMIDI轨道可以为Lights 1.1 灯光轨道 1.2 鼓点设置\n鼓点音色映射设置，来输出不同的音乐片段 拖动IB控件到MIDI模块 鼓点灯光映射设置 拖进MIDI Effects rack控件 1.1 点击黄色选项：展开Key:vel:chain:Hide页面 1.2 右击蓝色条，选择map selecter 1.3 选中右上角的MIDI切换到设置MIDI映射键模式。 1.4 选中第一个表盘，选中LauchPad上的 A—B，来映射页数的设置 1.5 新建八个chain，错位蓝色条，完成页数映射的设置 1.6 逐个选中不同的chain，在每一个chain中嵌套MIDI Effect Rock控件 第三期：关于分轨和音频采样 reddit.com beatport.com splice.com 选中页数1的chain ，展开drum rack模块，点击launchpad上键盘，会高亮显示映射的鼓点位置，这时将采样的音色拖拽到改鼓点位置，再次点击launchpad键垫就可以播放音色片段。\n第四期：基础灯光效果制作 Arpeggiator （A效果器） 设置纵横方向的属性变化 效果：垫子灯光会从左到右，从下向上的走马灯式的移动。通过arpeggiator设置移动速度，范围\nrate速度：1/1一拍移动一下最慢，1/128最快。\nGate范围：1—200：依据灯光速率的亮度百分率率来看，1%:亮度不高，200%：可以在一个键上激活两个相邻的灯光\nstyle：纵向变化的方向：up/down/upDown/DownUp\u0026hellip;\nHold激活不用长按，即可厂量\nrepeats：设置走马灯的循环次数\nA效果器在灯光效果包中，放置的位置不同起到不同效果，例如一个灯光效果在A效果器之后，则会将A效果器的属性应用到后续其他的灯光效果上。\nChord （和弦） 拖拽到Key列表中的一个垫子的灯光效果包上。 chord提供六个属性shift1，shift2\u0026hellip;.shift6，来设置和弦灯光错位，融合等效果 第一个旋钮设置1 ：说明灯光向右边移动一个单位。即当点击当前垫子时，右边相邻的垫子的灯光也会一起亮 第二个按钮shift2设置+2：灯光向右联动两个单位，右边相邻的两个垫子的灯光都点亮。 以此类推 一个key上可以添加多个chord：根据偏移量来激活周边的垫子灯光。+4亮起四分之一，+16：亮起半屏，-16：四分之三亮起 -32：整个lPD全亮 MIDI Effect Rack 在主MIDI effect Rack中的chain中映射出的页数中，再嵌套子MIDI effect Rack这样每一页都可以设置自己的灯光效果。 设置灯光效果包\n选中嵌套的子MIDIeffect rack，展开chain模块 ，右击新建一个chain，即代表着一个灯光效果 选中key，点击lauchpad垫子，在钢琴键位为标红显示，即可定位将要设置灯光效果的键。即：绿色区域定位点击的键垫位置 新建Velocity（力度感应） 新建chord（和弦） 新建Arpeggiator（A效果器） Note Length 延迟灯光时间 Pitch Random Scale\nVelocity：力度感应 拖到刚才的chain上，即在该键上添加力度感应属性设置。 设置灯光颜色：Out Hi的表盘参数，参考MIni支持的灯光色值 ","date":"2018-06-19T14:23:13Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/AbletonLive10%E5%AE%89%E8%A3%85%E4%BD%BF%E7%94%A8/","section":"post","tags":["智能设备"],"title":"AbletonLive10安装使用"},{"categories":["解决方案"],"contents":"工程demo 官方资源\nLaunchpad几种模式视频教程\n硬件设置 贴纸：确保标签与相应的按钮对齐。 使用USB连接线将你的Launchpad Mini连接到你的Mac或PC上的USB端口。Ableton Live支持最多6台同时连接的设备。 配置设备在Ableton Live中的配置 打开Live偏好设置,选中MIDI/Sync选项卡，在Input中选择Launchpad Mini所连接的端口 以及窗口顶部的Output选择器 在Control Surface控制面板中选择自己的设备。 在MIDI Ports下，开启 Track和Remote选项. PRODUCT OVERVIEW: ABLETON LIVE Session 模式 当选择Launchpad作为活动控制面时，会话视图上会出现一个圆环，用于指示当前由pad矩阵控制的哪个部分。按下一个剪辑启动板，就会在相应的剪辑插槽中触发该剪辑。在没有武装的轨道上点击一个空的剪辑槽将停止在这个轨道上播放的剪辑。如果跟踪是武装到记录，按下按钮记录一个新的剪辑。 方向箭头和会话按钮通过在场景和跟踪中导航会话视图，增加了8×8网格的范围。你也可以使用Launchpad Mini的右手边的按钮来触发水平的剪辑(场景)。\nSession概述 黄色:表示当前选定的剪辑块，它将被软件中的戒指所包围。 绿色:在那块剪辑中有一些剪辑在播放(虽然那可能不是被选中的剪辑块)。 红色:在这个范围内没有剪辑。 未激活色:在这个范围内没有音轨或场景。\nUSER 模式 User1模式:说明在Lives中的MIDI音轨中可以使用drum racks鼓架(如果没有分配的话) 制造)，或在lives的MIDI可分配参数中自由分配Launchpad Mini的按钮。 User2模式:说明可以作为一个方便的地方来访问Max for Live预设配置(如果没有学习任务的话)，或者自由地分配给Live中的任何参数。\nMixer混合器模式 底部的四行垫子提供了对每个轨道的直接访问控制，包括:停止、跟踪激活器、solo和跟踪臂。右下角的四个按钮为每个轨道提供额外的控制: •stop：停止按钮，将停止当前播放的所有剪辑(可通过重新分配功能来避免) •trk on：音轨激活器按钮，将打开所有轨道(非静音) •solo：“独奏”按钮，将不再独奏所有曲目。 •arm: “音轨操作臂”按钮,will un-arm all armed tracks\nTHE VOLUME / PAN / SNDA / SNDB PAGES 当Mixer模式激活时，按VOL/PAN/SNDA或SNDB按钮输入卷、PAN或发送页面，其中列的所有八个焊盘变成各自控制的连续轨迹“FADDER”。 VOLUME:音量 pan: sndA: sndB: {% pdf https://d2xhy469pqj8rc.cloudfront.net/sites/default/files/novation/downloads/7376/launchpadminiabletonguide_0.pdf %}\nlaunchPad APP for iOS键盘功能映射 iPad兼容（Low Power）vs全功率模式 手机端节能模式设置\n在连接USB过程中，同时按住按钮5, 6, 7和8,开启设置节能 选择一种电源模式（左为高，右为低），参考pdf图文 完成设置后，按下绿色按钮退出 在全功率模式下，Launchpad mini需要使用单独供电的USB集线器与iPad链接，否则无法正常工作。\n键位功能说明 F键位：Filters过滤器，8个垫子的每一列都变成一个滤光片:向上移动以除去低音，向下移动以除去高音。按D或E行的垫子重置Filter过滤器。 G键位：Volume音量，8个垫子的每一层都变成了一个音量调节器。按下B行垫子重置音量。 H键位：Trigger Sounds \u0026amp; FX {% pdf https://d2xhy469pqj8rc.cloudfront.net/sites/default/files/novation/downloads/6959/launchpad-mini-gsg-en_0.pdf %} ","date":"2018-06-19T14:23:13Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/LaunchPadMini%E8%AF%B4%E6%98%8E%E4%B9%A6/","section":"post","tags":["智能设备"],"title":"LaunchPadMini说明书"},{"categories":["解决方案"],"contents":"有些时候不小心上传了一些敏感文件(例如密码), 或者不想上传的文件(没及时或忘了加到.gitignore里的),\n而且上传的文件又特别大的时候, 这将导致别人clone你的代码或下载zip包的时候也必须更新或下载这些无用的文件,\n因此, 我们需要一个方法, 永久的删除这些文件(包括该文件的历史记录).\n首先, 可以参考 github帮助\n使用bfg工具 bfg官网\n创建bfg别名 下载bfg 到本地soft/bfg目录下。 创建别名 sudo vi ~/.bash_profile 添加如下： 1 alias bfg=\u0026#34;java -jar ~/Downloads/soft/bfg/bfg.jar\u0026#34; 常用命令 克隆仓库 1 git clone --mirror git@github.com:OpenFibers/openfibers.github.com.git 移除目标文件 然后就可以执行下面的任意一个或者多个操作。 从历史纪录中删除所有文件名是 id_rsa 或 id_dsa 的文件：\n1 $ bfg --delete-files id_{dsa,rsa} my-repo.git 从历史纪录中删除所有大于1M的二进制文件 :\n1 $ bfg --strip-blobs-bigger-than 1M my-repo.git 从文件中删除所有列出的密码：\n1 $ bfg --replace-text passwords.txt my-repo.git 删除目录及目录下文件: demo:删除的目录 --no-blob-protection命令，可以解除保护\n1 2 3 4 5 $ cd $ bfg --delete-folders demo --delete-files demo --no-blob-protection //上述命令将demo索引状态重置为`add`的状态，需要执行reset即可 $ git reset HEAD demo $ rm -fr demo 使用 filter-branch命令 步骤一: 从资料库中清除文件 1 $ git filter-branch --force --index-filter \u0026#39;git rm --cached --ignore-unmatch path-to-your-remove-file\u0026#39; --prune-empty --tag-name-filter cat -- --all 其中, path-to-your-remove-file 是要删除的文件的相对路径(相对于git仓库的跟目录), 替换成你要删除的文件即可.\n这里的文件或文件夹，都不能以 \u0026lsquo;/\u0026rsquo; 开头，否则文件或文件夹会被认为是从 git 的安装目录开始。\n删除文件夹 在 git rm --cached 命令后面添加 -r 命令，表示递归的删除（子）文件夹和文件夹下的文件，类似于 rm -rf 命令:\n1 $ git filter-branch --force --index-filter \u0026#39;git rm --cached -r --ignore-unmatch path-to-your-remove-folder\u0026#39; --prune-empty --tag-name-filter cat -- --all 支持通配符 如果当要删除的文件很多, 文件或路径里有中文, 由于MinGW或CygWin对中文路径设置比较麻烦, 你可以使用通配符*号, 例如: sound/music_*.mp3, 这样就把sound目录下以music_开头的mp3文件都删除了. 使用通配符*删除目录下的所有文件：\n1 $ git filter-branch --force --index-filter \u0026#39;git rm --cached -r --ignore-unmatch path-to-your-remove-folder/*\u0026#39; --prune-empty --tag-name-filter cat -- --all 成功的日志：\n1 2 3 4 5 Ref \u0026#39;refs/heads/master\u0026#39; was rewritten Ref \u0026#39;refs/remotes/origin/master\u0026#39; was rewritten WARNING: Ref \u0026#39;refs/remotes/origin/master\u0026#39; is unchanged WARNING: Ref \u0026#39;refs/tags/v0.9.0\u0026#39; is unchanged v0.9.0 -\u0026gt; v0.9.0 (2694a7834dada67cf8768ef27e2d7c3d777f5472 -\u0026gt; 2694a7834dada67cf8768ef27e2d7c3d777f5472) Ref 'refs/heads/master' was rewritten:表示成功； xxxxx unchanged: 说明在当前分支里没有找到该文件.\n步骤二: 推送我们修改后的repo 分支同步 通过步骤一，需要以强制覆盖的方式推送你的repo, 命令如下:\n1 $ git push --force origin master 这个过程其实是重新上传我们的repo, 比较耗时, 虽然跟删掉重新建一个repo有些类似, 但是好处是保留了原有的更新记录, 所以还是有些不同的. 如果你实在不在意这些更新记录, 也可以删掉重建, 两者也差不太多, 也许后者还更直观些.\ntag同步 为了能从打了 tag 的版本中也删除你所指定的文件或文件夹，您可以使用这样的命令来强制推送您的 Git tags：\n1 $ git push origin master --force --tags 步骤三: 清理和回收空间 虽然上面我们已经删除了文件, 但是我们的repo里面仍然保留了这些objects, 等待垃圾回收(GC), 所以我们要用命令彻底清除它, 并收回空间.\n执行命令，再查看.git目录空间会明显变小:\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 $ rm -rf .git/refs/original/ $ git reflog expire --expire=now --all $ git gc --prune=now Counting objects: 2437, done. # Delta compression using up to 4 threads. # Compressing objects: 100% (1378/1378), done. # Writing objects: 100% (2437/2437), done. # Total 2437 (delta 1461), reused 1802 (delta 1048) $ git gc --aggressive --prune=now Counting objects: 2437, done. # Delta compression using up to 4 threads. # Compressing objects: 100% (2426/2426), done. # Writing objects: 100% (2437/2437), done. # Total 2437 (delta 1483), reused 0 (delta 0) ","date":"2018-06-11T20:32:02Z","permalink":"https://it-boyer.github.io/post/old/git/Git%E5%A6%82%E4%BD%95%E6%B0%B8%E4%B9%85%E5%88%A0%E9%99%A4%E6%96%87%E4%BB%B6%E5%8C%85%E6%8B%AC%E5%8E%86%E5%8F%B2%E8%AE%B0%E5%BD%95/","section":"post","tags":["git"],"title":"Git如何永久删除文件(包括历史记录)"},{"categories":["学习笔记"],"contents":"导图 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 title 图表活用教学 left header 使用5种类型的图表 1. 掌握状况图解法 2. 检讨对策图解法 3. 掌握状况图解法 + 检讨对策图解法 树形图/图饼法/行列法/点图/流程图 endheader :5种图; note left # 树形图 # 图饼图 # 行列图 # 点图 # 流程图 end note split :掌握状况图解法; split again :检讨对策图解法; end split note right \u0026#39;\u0026lt;img:http://p27uwfdhv.bkt.clouddn.com/static/images/5%E7%A7%8D%E5%9B%BE.png\u0026gt; end note center footer 乐理基础 endfooter ","date":"2018-06-11T19:43:53Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/5%E4%B8%AA%E5%9B%BE%E8%A1%A8%E8%A7%A3%E5%86%B3%E5%B7%A5%E4%BD%9C%E4%B8%AD%E7%9A%8412%E5%A4%A7%E9%9A%BE%E9%A2%98/","section":"post","tags":["图书"],"title":"5个图表解决工作中的12大难题"},{"categories":["项目总结"],"contents":"UML状态图 使用状态图，查漏补觉，梳理相关业务流程。 建议：优化流程，使用流程图（活动图）/时序图来完善流程\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 title 工作计划逻辑状态图 left header 1. ~~扫描事件动画处理~~ 2. 巡查录入，执法权限验证进行执法 3. 筛选商业调试UI 4. 巡查年度列表 5. 配置平台组件 endheader scale 600 width [*]--\u0026gt;巡查录入 state 执法权限{ 巡查录入--\u0026gt;巡查结果:id 巡查录入--\u0026gt;巡查类型:执法种类集合（type=5） } 执法权限--\u0026gt;执法:可以执法 执法--\u0026gt;[*] [*]--\u0026gt;商家查询 商家查询:商家列表数据（分页） 商家查询:过滤条件（重置/确定） 商家查询:门店巡查状态页 商家查询--\u0026gt; Model:传递storeId state 门店巡查状态页{ state Model{ Model: 门店详情 Model: 门店巡查Model Model: 巡查状态Model } } 门店巡查状态页--\u0026gt;年度巡查页 [*]--\u0026gt;门店地图 门店地图--\u0026gt;扫描二维码 扫描二维码--\u0026gt; Model:传递storeId 扫描二维码: 1. 解析二维码地址获取storeId 扫描二维码: 2. 访问接口获取门店地图数据MapStoreModel 扫描二维码: 3. 定位门店位置动画之后，显示门店详情和大头针样式 年度巡查页--\u0026gt;[*] center footer 结束 endfooter ","date":"2018-06-05T10:18:33Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E6%89%A7%E6%B3%95%E5%B7%A1%E6%9F%A5%E5%BC%80%E5%8F%91%E7%8A%B6%E6%80%81%E6%80%BB%E7%BB%93/","section":"post","tags":[],"title":"执法巡查开发状态总结"},{"categories":["学习笔记"],"contents":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 start :ClickServlet.handleRequest(); :new page; if (Page.onSecurityCheck) then (true) :Page.onInit(); if (isForward?) then (no) :Process controls; if (continue processing?) then (no) stop endif if (isPost?) then (yes) :Page.onPost(); else (no) :Page.onGet(); endif :Page.onRender(); endif else (false) endif if (do redirect?) then (yes) :redirect process; else if (do forward?) then (yes) :Forward request; else (no) :Render page template; endif endif stop 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 start :ClickServlet.handleRequest(); :new page; if (Page.onSecurityCheck) then (true) :Page.onInit(); if (isForward?) then (no) :Process controls; if (continue processing?) then (no) stop endif if (isPost?) then (yes) :Page.onPost(); else (no) :Page.onGet(); endif :Page.onRender(); endif else (false) endif if (do redirect?) then (yes) :redirect process; else if (do forward?) then (yes) :Forward request; else (no) :Render page template; endif endif stop title uml模型图题目支持MD center header 在此处添加标头 endheader start \u0026lsquo;开始\u0026rsquo; \u0026lsquo;\u0026raquo;\u0026raquo;\u0026gt; 活动关系模块 支持嵌套，条件/循环/并行\u0026raquo;\u0026raquo;\u0026raquo;\u0026rsquo; if(环境条件) then (分流线名) :分支1活动; -[颜色]-\u0026gt; 线备注; note left 活动备注 end note elseif(分流线名) :分支2活动; else (分流线名) :分支3活动; endif\nrepeat :循环活动; repeat while (环境条件)\nwhile (环境条件) :循环活动; endwhile\nfork :并行活动; fork again :并行活动; end fork\n\u0026lsquo;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; 活动图组合模块 \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026rsquo; partition 活动组名{ :单元活动名称; }\n|#颜色 | 泳道名称| :当前泳道活动;\nstop \u0026lsquo;结束／end关键字\u0026rsquo; center footer 在此处添加脚注 endfooter\n","date":"2018-06-04T21:27:15Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/uml%E6%B4%BB%E5%8A%A8%E5%9B%BE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","section":"post","tags":["UML"],"title":"uml活动图常用语法"},{"categories":["学习笔记"],"contents":" 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :Main Admin: as Admin (Use the application) as (Use) User -\u0026gt; (Start) User --\u0026gt; (Use) Admin ---\u0026gt; (Use) note right of Admin : This is an example. note right of (Use) A note can also be on several lines end note note \u0026#34;This note is connected\\nto several objects.\u0026#34; as N2 (Start) .. N2 N2 .. (Use) 效果图\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 :Main Admin: as Admin (Use the application) as (Use) User -\u0026gt; (Start) User --\u0026gt; (Use) Admin ---\u0026gt; (Use) note right of Admin : This is an example. note right of (Use) A note can also be on several lines end note note \u0026#34;This note is connected\\nto several objects.\u0026#34; as N2 (Start) .. N2 N2 .. (Use) title uml模型图题目支持MD center header 在此处添加标头 endheader\n\u0026lsquo;******* 声明用例模块 usecase *******\u0026rsquo; (用例名称) as (别名) \u0026laquo;构造类型\u0026raquo;\nusecase 用例名称 as \u0026quot; 描述一 描述2 描述3 .. 描述标题 .. 描述4 \u0026quot; \u0026lsquo;******* 声明角色模块 actor *******\u0026rsquo; :角色名称: as 别名 actor 角色名称\n\u0026lsquo;\u0026mdash;- 声明备注:用例线备注可以当做用例来参与到关系连接中\u0026mdash;\u0026rsquo; note \u0026ldquo;备注内容\u0026rdquo; as 备注对象\n\u0026lsquo;##### 备注模块 位置：left/right/top/bottom #####\u0026rsquo; note 位置 of 用例/角色: 描述信息\n\u0026lsquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo; 关系模块 \u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026rsquo; left to right dirction \u0026lsquo;指定布局方向\u0026rsquo; 角色 \u0026ndash;\u0026gt; 用例:关系线描述\n\u0026lsquo;\u0026mdash;- 用例关系中的备注对象 \u0026mdash;-\u0026rsquo; 角色 \u0026ndash;\u0026gt;备注对象 备注对象 \u0026ndash;\u0026gt;用例\ncenter footer 在此处添加脚注 endfooter\n","date":"2018-06-04T21:20:41Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/uml%E7%94%A8%E4%BE%8B%E5%9B%BE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","section":"post","tags":["UML"],"title":"uml用例图常用语法"},{"categories":["学习笔记"],"contents":" 1 2 3 4 5 6 7 8 9 10 11 12 class BaseClass namespace net.dummy #DDDDDD { .BaseClass \u0026lt;|-- Person Meeting o-- Person .BaseClass \u0026lt;|- Meeting } namespace net.foo { net.dummy.Person \u0026lt;|- Person .BaseClass \u0026lt;|-- Person net.dummy.Meeting o-- Person } BaseClass \u0026lt;|-- net.unused.Person 效果图：\n1 2 3 4 5 6 7 8 9 10 11 12 class BaseClass namespace net.dummy #DDDDDD { .BaseClass \u0026lt;|-- Person Meeting o-- Person .BaseClass \u0026lt;|- Meeting } namespace net.foo { net.dummy.Person \u0026lt;|- Person .BaseClass \u0026lt;|-- Person net.dummy.Meeting o-- Person } BaseClass \u0026lt;|-- net.unused.Person title uml模型图题目支持MD center header 在此处添加标头 endheader\n\u0026lsquo;******* 类声明模块 *******\u0026rsquo; \u0026lsquo;类型:class,abstract,interface,annotation,enum\u0026rsquo; \u0026lsquo;访问域:(-)私有,(#)保护,(~)包私有,(+)公有\u0026rsquo;\nclass 类名\u0026lt;扩展对象\u0026gt; as 类别名{ \u0026ndash; 属性组名 \u0026ndash; \u0026lsquo;分隔符\u0026ndash;,..,==,__\u0026rsquo; 访问域修饰符 static/abstract 属性名称:类型 = 值1 __ 函数组名 __ 访问域修饰符 func 函数名称(参数1:类型,参数2:类型) } \u0026lsquo;显示/隐藏类,类方法属性等 关键字支持class,interface,enum\u0026rsquo; hide 类名/方法名\n\u0026lsquo;\u0026mdash;- 声明类关系线备注,可以当做用例来参与到关系连接中 \u0026mdash;\u0026rsquo; note \u0026ldquo;备注内容\u0026rdquo; as 备注对象\n\u0026lsquo;多行备注对象\u0026rsquo; note as 备注对象 \u0026ldquo;备注内容\u0026rdquo; end note\n\u0026lsquo;###### 类备注模块 类声明末尾使用:note 位置: 备注#########\u0026rsquo; note left/right/top/bottom of object #颜色 支持markdown语法加粗／斜体／删除线／下划线／波浪下划线 和HTML end note\n\u0026lsquo;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; 类组合模块 类模块 \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026rsquo; \u0026lsquo;六种组合样式:Node,Rectangle,Folder,Frame,Cloud,Database\u0026rsquo; scale 750 width/height package module名 \u0026laquo;模块样式\u0026raquo; #背景色{ class 类名\u0026lt;扩展对象\u0026gt; as 类别名{ \u0026ndash; 属性组名 \u0026ndash; \u0026lsquo;分隔符\u0026ndash;,..,==,__\u0026rsquo; 访问域修饰符 static/abstract 属性名称:类型 = 值1 __ 函数组名 __ 访问域修饰符 func 函数名称(参数1:类型,参数2:类型) } }\n\u0026lsquo;@@@@@@@ 命名空间模块 关系模块 @@@@@@@@\u0026rsquo; namespace com.cn #空间背景色{\n\u0026lsquo;关系节点符:(|\u0026gt;)继承,(*)合成 ,(o)聚合, 其他#,x,},+,^ 连线符:(\u0026ndash;)实线 ，(..)虚线\u0026rsquo; 类名/包名\u0026quot;基数\u0026quot; 节点符 left/right..``[#线色]-节点符 \u0026ldquo;基数\u0026quot;类名/包名:消息 \u0026gt; note left/right/top/bottom on link #颜色 连接注释体 end note}\n\u0026lsquo;\u0026raquo;\u0026raquo;\u0026raquo; 类关系图及连接备注模块 \u0026raquo;\u0026raquo;\u0026raquo;\u0026raquo;\u0026rsquo; \u0026lsquo;关系节点符:(|\u0026gt;)继承,(*)合成 ,(o)聚合, 其他#,x,},+,^ 连线符:(\u0026ndash;)实线 ，(..)虚线\u0026rsquo; 类名/包名\u0026quot;基数\u0026rdquo; 节点符 left/right..``[#线色]-节点符 \u0026ldquo;基数\u0026quot;类名/包名:消息 \u0026gt; note left/right/top/bottom on link #颜色 连接注释体 end note\ncenter footer 在此处添加脚注 endfooter\n","date":"2018-06-04T20:49:36Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/uml%E7%B1%BB%E5%9B%BE%E5%B8%B8%E7%94%A8%E8%AF%AD%E6%B3%95/","section":"post","tags":["UML"],"title":"uml类图常用语法"},{"categories":["解决方案"],"contents":"安装Mono Mac下需要使用.Net编译后的程序，首先需要用到跨平台的方案Mono(现阶段微软已推出跨平台的方案.Net Core，不过暂时只支持控制台程序)。 下载地址\n配置Mono环境 下载证书 从Mozilla LXR上下载所有受信任的root证书，存于Mono的证书库里。root证书能用于请求https地址： 1 2 $cd /Library/Frameworks/Mono.framework/Versions/\u0026lt;mono version\u0026gt;/bin/ $./mozroots --import --sync ./mozroots命令失效，./cert-sync新命令，暂时不知道怎么使用\n配置Mono环境变量 在.bash_profile中加入如下内容\n1 2 export MONO_HOME=/Library/Frameworks/Mono.framework/Versions/5.0.1 export PATH=$PATH:$MONO_HOME/bin Fiddler 官方文档\n安装 下载Fiddler-mac.zip压缩包，解压到非中文字符的路径下。\n运行 打开Terminal，进入到刚才解压的Fiddler路径，执行命令运行：\n1 sudo mono Fiddler.exe 参看\n","date":"2018-05-31T16:38:52Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E5%9C%A8Mac%E5%AE%89%E8%A3%85Fiddler/","section":"post","tags":["工具"],"title":"在Mac安装Fiddler"},{"categories":["博客站务"],"contents":"修改 hero-generator-index 插件，把文件：node_modules/hexo-generator-index/lib/generator.js 内的代码替换为：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 \u0026#39;use strict\u0026#39;; var pagination = require(\u0026#39;hexo-pagination\u0026#39;); module.exports = function(locals){ var config = this.config; var posts = locals.posts; posts.data = posts.data.sort(function(a, b) { if(a.top \u0026amp;\u0026amp; b.top) { // 两篇文章top都有定义 if(a.top == b.top) return b.date - a.date; // 若top值一样则按照文章日期降序排 else return b.top - a.top; // 否则按照top值降序排 } else if(a.top \u0026amp;\u0026amp; !b.top) { // 以下是只有一篇文章top有定义，那么将有top的排在前面（这里用异或操作居然不行233） return -1; } else if(!a.top \u0026amp;\u0026amp; b.top) { return 1; } else return b.date - a.date; // 都没定义按照文章日期降序排 }); var paginationDir = config.pagination_dir || \u0026#39;page\u0026#39;; return pagination(\u0026#39;\u0026#39;, posts, { perPage: config.index_generator.per_page, layout: [\u0026#39;index\u0026#39;, \u0026#39;archive\u0026#39;], format: paginationDir + \u0026#39;/%d/\u0026#39;, data: { __index: true } }); }; 在文章中添加 top 值，数值越大文章越靠前:\n1 2 3 4 5 6 title: 解决Charles乱码问题 date: 2017-05-22 22:45:48 tags: 技巧 categories: 技巧 copyright: true top: 100 转：hexo的next主题个性化配置教程\n","date":"2018-05-31T11:44:33Z","permalink":"https://it-boyer.github.io/post/old/hexo/hexo%E5%8D%9A%E6%96%87%E7%BD%AE%E9%A1%B6%E6%96%B9%E6%B3%95/","section":"post","tags":["hexo"],"title":"hexo博文置顶方法"},{"categories":["解决方案"],"contents":" 1 2 3 4 NSString *timstr = [resData objectForKey:@\u0026#34;Data\u0026#34;]; timstr = [timstr stringByReplacingOccurrencesOfString:@\u0026#34;/Date(\u0026#34; withString:@\u0026#34;\u0026#34;]; timstr = [timstr stringByReplacingOccurrencesOfString:@\u0026#34;+0800)/\u0026#34; withString:@\u0026#34;\u0026#34;]; model.time = [NSDate dateWithTimeIntervalSince1970:timstr.longLongValue/1000]; ","date":"2018-05-30T18:42:20Z","permalink":"https://it-boyer.github.io/post/old/iOS/+0800%E6%A0%BC%E5%BC%8F%E8%BD%ACNSDate/","section":"post","tags":["iOS"],"title":"+0800格式转NSDate"},{"categories":["学习笔记"],"contents":"引入头文件 1 2 #import \u0026lt;AMapFoundationKit/AMapFoundationKit.h\u0026gt; #import \u0026lt;AMapLocationKit/AMapLocationKit.h\u0026gt; 调用方法 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 NSString *strKey = @\u0026#34;2d8a96d668576584acebf2bab0ba0c08\u0026#34;;//默认值 //配置里面取值 NSString *strBundleKey = [[NSBundle mainBundle] infoDictionary][@\u0026#34;IOSPostionkey\u0026#34;]; if (strBundleKey) { strKey = strBundleKey; } [AMapServices sharedServices].apiKey = strKey; // 带逆地理信息的一次定位（返回坐标和地址信息） self.GaodelocationManager = [[AMapLocationManager alloc] init]; [self.GaodelocationManager setDesiredAccuracy:kCLLocationAccuracyHundredMeters]; // 定位超时时间，最低2s，此处设置为2s self.GaodelocationManager.locationTimeout =10; // 逆地理请求超时时间，最低2s，此处设置为2s self.GaodelocationManager.reGeocodeTimeout = 10; //设置不允许系统暂停定位 [self.GaodelocationManager setPausesLocationUpdatesAutomatically:NO]; // //设置允许在后台定位 // [locationManager setAllowsBackgroundLocationUpdates:YES]; //设置允许连续定位逆地理 [self.GaodelocationManager setLocatingWithReGeocode:YES]; // [locationManager setDelegate:self]; // [self.locationManager startUpdatingLocation]; // // 带逆地理（返回坐标和地址信息）。将下面代码中的 YES 改成 NO ，则不会返回地址信息。 [self.GaodelocationManager requestLocationWithReGeocode:YES completionBlock:^(CLLocation *gaodeLocation, AMapLocationReGeocode *regeocode, NSError *error) { if (gaodeLocation==nil) { NSLog(@\u0026#34;高德没有返回地理位置,使用苹果官方定位经纬度\u0026#34;); [self GetGISInfoByByLocationWithjingdu:jingdu AndWeidu:weidu]; return ; } if (error) { NSLog(@\u0026#34;locError:{%ld - %@};\u0026#34;, (long)error.code, error.localizedDescription); if (error.code == AMapLocationErrorLocateFailed) { NSLog(@\u0026#34;AMapLocationErrorLocateFailed高德没有返回地理位置,使用苹果官方定位经纬度\u0026#34;); [self GetGISInfoByByLocationWithjingdu:jingdu AndWeidu:weidu]; return; } } NSLog(@\u0026#34;使用高德location:%@\u0026#34;, gaodeLocation); NSString * gaodeWeidu = [NSString stringWithFormat:@\u0026#34;%.9f\u0026#34;,gaodeLocation.coordinate.latitude]; NSString * gaodeJingdu = [NSString stringWithFormat:@\u0026#34;%.9f\u0026#34;,gaodeLocation.coordinate.longitude]; if (regeocode) { NSLog(@\u0026#34;reGeocode:%@\u0026#34;, regeocode); self.theRealAdress = regeocode.formattedAddress; } [self GetGISInfoByByLocationWithjingdu:gaodeJingdu AndWeidu:gaodeWeidu]; }]; ","date":"2018-05-30T14:40:56Z","permalink":"https://it-boyer.github.io/post/old/iOS/%E9%AB%98%E5%BE%B7%E5%9C%B0%E5%9B%BEAPI%E4%BD%BF%E7%94%A8/","section":"post","tags":["iOS"],"title":"高德地图API使用"},{"categories":["解决方案"],"contents":"问题\n1 2 3 Fatal error in , line 0 # Check failed: !value_obj-\u0026gt;IsJSReceiver() || value_obj-\u0026gt;IsTemplateInfo(). #FailureMessage Object: 0x7ffeefbf25c0[1] 22749 illegal hardware instruction he 参考Fatal error in ../deps/v8/src/api.cc, line 1197 when gulp watch,需要降级node版本。\nnvm工具 nvm是node版本管理工具，参考官网nvm安装指南\n安装 1 $ brew install nvm 安装node 1 2 3 4 5 6 7 $ nvm install versionnum //安装 $ nvm use versionnum //使用指定版本 $ nvm ls //查看本地node -\u0026gt; v6.14.4 v8.12.0 system default -\u0026gt; 8 (-\u0026gt; v8.12.0) 使用npm nvm安装node之后，会安装对应版本npm工具，如：node 8 对应 npm v5，node 7 对应 npm v4 1 2 npm -v //查看当前node对应的npm版本号 npm version //查看当前目录使用的node详情，即node_modules安装时使用node版本号 注意：在hexo执行，npm install 之后，hexo g 失败时，需要降级npm版本，这是无论怎么使用nvm use 来设置当前node，都无效，必须删除node_modules目录，再使用nvm use切换低版本，重新安装package.json插件才行。\n工具包升级node issue-431242848 node有一个专门管理node.js的版本工具模块n 首先安装n模块：npm install -g n 升级node.js到最新稳定版\n1 n stable ","date":"2018-05-29T12:06:24Z","permalink":"https://it-boyer.github.io/post/old/shell/%E4%BD%BF%E7%94%A8nvm%E6%88%96n%E7%AE%A1%E7%90%86node%E5%92%8Cnpm%E7%89%88%E6%9C%AC/","section":"post","tags":["shell"],"title":"使用nvm或n管理node和npm版本"},{"categories":["解决方案"],"contents":"{% github weirongxu plantuml-previewer.vim bf4b3e5 width = 30% %}\n安装依赖 1 2 3 Plug \u0026#39;it-boyer/plantuml-syntax\u0026#39; \u0026#34;plantuml语法高亮 Plug \u0026#39;aklt/plantuml-syntax\u0026#39; Plug \u0026#39;tyru/open-browser.vim\u0026#39; Plug \u0026#39;weirongxu/plantuml-previewer.vim\u0026#39; \u0026#34;在线工具：http://sujoyu.github.io/plantuml-previewer/ Graphviz 下载地址\n1 brew install graphviz 打开浏览器safari插件工具 open-browser.vim\n语法高亮插件 aklt/plantuml-syntax (vim syntax file for plantuml)\n使用 创建uml文件 1 vi test.uml 预览uml图 通过命令打开浏览器预览界面\n1 :PlantumlOpen 在vi中执行保存命令:w,预览界面会自动刷新\n","date":"2018-05-29T11:32:04Z","permalink":"https://it-boyer.github.io/post/old/shell/%E7%BB%88%E7%AB%AF%E5%AE%9E%E7%8E%B0%E9%A2%84%E8%A7%88plantuml%E7%9A%84%E6%8F%92%E4%BB%B6/","section":"post","tags":["shell"],"title":"终端实现预览plantuml的插件"},{"categories":["博客站务"],"contents":"问题引入 在hexo 项目中使用npm 配置环境，出现错误：gyp ERR! configure error\npyenv是python的多版本管理包，实现互相独立、互不干扰的python环境配置。\n安装pyenv 安装电脑是mac，所以理所当然的使用神器：homebrew\n1 brew install pyenv 安装界面略过，安装结束后，系统提示如下：\n1 2 3 4 5 6 ==\u0026gt; Caveats To use Homebrew\u0026#39;s directories rather than ~/.pyenv add to your profile: export PYENV_ROOT=/usr/local/var/pyenv To enable shims and autocompletion add to your profile: if which pyenv \u0026gt; /dev/null; then eval \u0026#34;$(pyenv init -)\u0026#34;; fi 根据此提示，在bash的配置文件（由于我的bash是oh my zsh，所以我的配置文件为~/.zshrc）中添加以下两行代码：\n1 2 export PYENV_ROOT=/usr/local/var/pyenv if which pyenv \u0026gt; /dev/null; then eval \u0026#34;$(pyenv init -)\u0026#34;; fi 使用pyenv 安装指定版本的python 显示所有可以安装的python版本软件，如2.1.3\u0026hellip;3.5.1等。\n1 2 pyenv install -l pyenv install 2.7.11 -v -v表示在显示安装过程。 安装完成后，2.7.11版本在系统中的存放位置为： /usr/local/var/pyenv/versions/2.7.11\n为项目配置python环境 接下来进入开发项目的主文件夹，如~/Desktop/Python/TWD，输入如下命令：\n1 pyenv local 2.7.11 即在当前文件夹下配置完成python的开发环境。接下来可通过pip安装开发过程中的各种包。\n其他 1.显示所有安装的python版本 1 pyenv versions 2.切换python版本 要切换python 版本，可以使用如下命令：\n1 pyenv global \u0026lt;version\u0026gt; 比如，我使用以上命令pyenv global 2.7.11后，系统默认的python版本即为2.7.11，在命令行输入python后，进入的就是2.7.11的shell，不再是system的shell。\n3.切换python shell版本 若不使用pyenv global命令实现python shell版本切换，可以使用如下命令：\n1 pyenv shell \u0026lt;version\u0026gt; 比如，我使用pyenv shell 2.7.11后，在命令行输入python，进入的是2.7.11的shell。此时系统的默认python版本也变成了2.7.11，如下所示：\n转自\n","date":"2018-05-29T10:33:30Z","permalink":"https://it-boyer.github.io/post/old/hexo/pyenv%E5%88%87%E6%8D%A2python%E7%9A%84%E7%89%88%E6%9C%AC/","section":"post","tags":["hexo"],"title":"pyenv切换python的版本"},{"categories":["解决方案"],"contents":" {% github it-boyer sortChinese 2deab8b width = 30% %}\n方法一 实现模型对象排序，当万条数据时，出现卡顿问题。\n方法二 实现字符串数组的排序，暂时没有验证大量排序情况，尝试优化第一种方法的排序卡顿问题。\n","date":"2018-05-17T10:46:57Z","permalink":"https://it-boyer.github.io/post/old/iOS/%E6%B1%89%E5%AD%97%E6%8B%BC%E9%9F%B3%E6%8E%92%E5%BA%8F%E6%96%B9%E6%B3%95/","section":"post","tags":["iOS"],"title":"汉字拼音排序方法"},{"categories":["学习笔记"],"contents":"交互式暂存 Git 自带的一些脚本可以使在命令行下工作更容易。 本节的几个互交命令可以帮助你将文件的特定部分组合成提交。 当你修改一组文件后，希望这些改动能放到若干提交而不是混杂在一起成为一个提交时，这几个工具会非常有用。 通过这种方式，可以确保提交是逻辑上独立的变更集，同时也会使其他开发者在与你工作时很容易地审核。 如果运行 git add 时使用 -i 或者 \u0026ndash;interactive 选项，Git 将会进入一个交互式终端模式，显示类似下面的东西：\n1 2 3 4 5 6 7 8 9 10 $ git add -i staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now\u0026gt; 可以看到这个命令以非常不同的视图显示了暂存区 - 基本上与 git status 是相同的信息，但是更简明扼要一些。 它将暂存的修改列在左侧，未暂存的修改列在右侧。\n在这块区域后是命令区域。 在这里你可以做一些工作，包括暂存文件、取消暂存文件、暂存文件的一部分、添加未被追踪的文件、查看暂存内容的区别。\n暂存与取消暂存文件 如果在 What now\u0026gt; 提示符后键入 2 或 u，脚本将会提示想要暂存哪个文件：\n1 2 3 4 5 6 What now\u0026gt; 2 staged unstaged path 1: unchanged +0/-1 TODO 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb Update\u0026gt;\u0026gt; 要暂存 TODO 与 index.html 文件，可以输入数字：\n1 2 3 4 5 6 Update\u0026gt;\u0026gt; 1,2 staged unstaged path * 1: unchanged +0/-1 TODO * 2: unchanged +1/-1 index.html 3: unchanged +5/-1 lib/simplegit.rb Update\u0026gt;\u0026gt; 每个文件前面的 * 意味着选中的文件将会被暂存。 如果在 Update\u0026raquo; 提示符后不输入任何东西并直接按回车，Git 将会暂存之前选择的文件：\n1 2 3 4 5 6 7 8 9 10 11 Update\u0026gt;\u0026gt; updated 2 paths *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now\u0026gt; 1 staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb 现在可以看到 TODO 与 index.html 文件已经被暂存而 simplegit.rb 文件还未被暂存。 如果这时想要取消暂存 TODO 文件，使用 3 或 r（撤消）选项：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now\u0026gt; 3 staged unstaged path 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Revert\u0026gt;\u0026gt; 1 staged unstaged path * 1: +0/-1 nothing TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb Revert\u0026gt;\u0026gt; [enter] reverted one path 再次查看 Git 状态，可以看到已经取消暂存 TODO 文件：\n1 2 3 4 5 6 7 8 *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now\u0026gt; 1 staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: unchanged +5/-1 lib/simplegit.rb 如果想要查看已暂存内容的区别，可以使用 6 或 d（区别）命令。 它会显示暂存文件的一个列表，可以从中选择想要查看的暂存区别。 这跟你在命令行指定 git diff \u0026ndash;cached 非常相似：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 *** Commands *** 1: status 2: update 3: revert 4: add untracked 5: patch 6: diff 7: quit 8: help What now\u0026gt; 6 staged unstaged path 1: +1/-1 nothing index.html Review diff\u0026gt;\u0026gt; 1 diff --git a/index.html b/index.html index 4d07108..4335f49 100644 --- a/index.html +++ b/index.html @@ -16,7 +16,7 @@ Date Finder \u0026lt;p id=\u0026#34;out\u0026#34;\u0026gt;...\u0026lt;/p\u0026gt; -\u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt;contact : support@github.com\u0026lt;/div\u0026gt; +\u0026lt;div id=\u0026#34;footer\u0026#34;\u0026gt;contact : email.support@github.com\u0026lt;/div\u0026gt; \u0026lt;script type=\u0026#34;text/javascript\u0026#34;\u0026gt; 通过这些基本命令，可以使用交互式添加模式来轻松地处理暂存区。\n暂存补丁 Git 也可以暂存文件的特定部分。 例如，如果在 simplegit.rb 文件中做了两处修改，但只想要暂存其中的一个而不是另一个，Git 会帮你轻松地完成。 从交互式提示符中，输入 5 或 p（补丁）。 Git 会询问你想要部分暂存哪些文件；然后，对已选择文件的每一个部分，它都会一个个地显示文件区别并询问你是否想要暂存它们：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 diff --git a/lib/simplegit.rb b/lib/simplegit.rb index dd5ecc4..57399e0 100644 --- a/lib/simplegit.rb +++ b/lib/simplegit.rb @@ -22,7 +22,7 @@ class SimpleGit end def log(treeish = \u0026#39;master\u0026#39;) - command(\u0026#34;git log -n 25 #{treeish}\u0026#34;) + command(\u0026#34;git log -n 30 #{treeish}\u0026#34;) end def blame(path) Stage this hunk [y,n,a,d,/,j,J,g,e,?]? 这时有很多选项。 输入 ? 显示所有可以使用的命令列表：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 Stage this hunk [y,n,a,d,/,j,J,g,e,?]? ? y - stage this hunk n - do not stage this hunk a - stage this and all the remaining hunks in the file d - do not stage this hunk nor any of the remaining hunks in the file g - select a hunk to go to / - search for a hunk matching the given regex j - leave this hunk undecided, see next undecided hunk J - leave this hunk undecided, see next hunk k - leave this hunk undecided, see previous undecided hunk K - leave this hunk undecided, see previous hunk s - split the current hunk into smaller hunks e - manually edit the current hunk ? - print help 通常情况下可以输入 y 或 n 来选择是否要暂存每一个区块，当然，暂存特定文件中的所有部分或为之后的选择跳过一个区块也是非常有用的。 如果你只暂存文件的一部分，状态输出可能会像下面这样：\n1 2 3 4 5 What now\u0026gt; 1 staged unstaged path 1: unchanged +0/-1 TODO 2: +1/-1 nothing index.html 3: +1/-1 +4/-0 lib/simplegit.rb simplegit.rb 文件的状态很有趣。 它显示出若干行被暂存与若干行未被暂存。 已经部分地暂存了这个文件。 在这时，可以退出交互式添加脚本并且运行 git commit 来提交部分暂存的文件。\n也可以不必在交互式添加模式中做部分文件暂存 - 可以在命令行中使用 git add -p 或 git add \u0026ndash;patch 来启动同样的脚本。\n更进一步地，可以使用 reset \u0026ndash;patch 命令的补丁模式来部分重置文件，通过 checkout \u0026ndash;patch 命令来部分检出文件与 stash save \u0026ndash;patch 命令来部分暂存文件。 我们将会在接触这些命令的高级使用方法时了解更多详细信息。\n","date":"2018-04-12T19:41:46Z","permalink":"https://it-boyer.github.io/post/old/git/Git%E5%B7%A5%E5%85%B7%E4%BA%A4%E4%BA%92%E5%BC%8F%E6%9A%82%E5%AD%98/","section":"post","tags":["git"],"title":"Git工具交互式暂存"},{"categories":["解决方案"],"contents":"Other linker flags设置的值实际上就是ld命令执行时后面所加的参数。\n3个常用参数： -ObjC：加了这个参数后，链接器就会把静态库中所有的Objective-C类和分类都加载到最后的可执行文件中 -all_load：会让链接器把所有找到的目标文件都加载到可执行文件中，但是千万不要随便使用这个参数！假如你使用了不止一个静态库文件，然后又使用了这个参数，那么你很有可能会遇到ld: duplicate symbol错误，因为不同的库文件里面可能会有相同的目标文件，所以建议在遇到-ObjC失效的情况下使用-force_load参数。 -force_load：所做的事情跟-all_load其实是一样的，但是-force_load需要指定要进行全部加载的库文件的路径，这样的话，你就只是完全加载了一个库文件，不影响其余库文件的按需加载.\n加载FrameWork 加载静态库 ","date":"2018-04-11T16:42:57Z","permalink":"https://it-boyer.github.io/post/old/xcode/Otherlinkerflags%E8%AE%BE%E7%BD%AEld%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E7%9A%84%E5%8F%82%E6%95%B0/","section":"post","tags":["xcode"],"title":"Otherlinkerflags设置ld命令执行的参数"},{"categories":["学习笔记"],"contents":"{% github it-boyer SmallDemo 5931b43 width = 30% %}\n官网 small是android与iOS平台比较出名的轻巧的跨平台插件化框架，也正是被这一点吸引，决定将small应用到集团内部的应用引擎模块化方案中，本篇博文主要讲述本人基于small在iOS平台实现的定制化APP方案（运营自由配置、自由组合、自动打包）~ 特性与功能\n基于iOS组件化基础 iOS组件化基于Cocoa Touch Framework（以下简称CTF）通过NSBundle实现。\nCTF首次公开在WWDC2014，要求Xcode6 beta以上版本。 CTF官方表示支持8.0以上系统，但在6.0、7.0上测试正常。 如果你的App包含了CTF，但是Deployment Target \u0026lt; 8.0，上传二进制文件到App Store时会报警中断。 受苹果官方限制，如果你的CTF没有签名，将无法实现代码级别更新。 Framework 模式无法上传到App Store。只能应用到企业版\n使用Small模版新建l项目 Small提供了Small-pods模版，安装Xcode模版创建空白的Small项目。\n安装Xcode模板 1 2 3 git clone https://github.com/wequick/Small.git cd Small/iOS cp -r Templates ~/Library/Developer/Xcode/Templates 新建项目 File-\u0026gt;New-\u0026gt;Project...，选择Small-pods模板 库依赖配置文件podfile： 1 2 3 4 5 6 platform :ios, \u0026#39;7.0\u0026#39; use_frameworks! target \u0026#39;SmallAPP\u0026#39; do pod \u0026#34;Small\u0026#34;, :git =\u0026gt; \u0026#39;https://github.com/wequick/Small.git\u0026#39; end 路由文件bundle.json: 1 2 3 4 5 6 7 8 9 { \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;bundles\u0026#34;: [ { \u0026#34;uri\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;pkg\u0026#34;: \u0026#34;hsg.com.cn.SmallAPP.app.main\u0026#34; } ] } 安装pod依赖 1 2 3 cd [your-project-path] pod install --no-repo-update open *.xcworkspace 解读插件路由配置 插件路由:为了方便插件之间的跨平台调用，Small 提供了 bundle.json 来完成插件路由。 bundle.json路由配置包括version:指定插件的版本号，bundles:插件注册的清单数组，其中插件清单的每个插件四个属性，来确定加载组件的方式： uri：指定加载插件的跟路径\n1 2 3 4 //获取控制器 let VC = Small.controller(forUri: \u0026#34;fixurl\u0026#34;) //将VC.view直接设置为window根视图 Small.openUri(\u0026#34;fixurl\u0026#34;, from: self) pkg：配置要求新建的Framework命名时必须包含.lib.、.app.，因为在加载组件过程中用它来判断你插件的类型： rules：规定页面的分发规则，可以通过rules来设置插件的多个入口，配和uri使用:openuri(uri/ruleskey),当不配置rules时，默认通过info.plist NSPrincipalClass来加载组件openuri(uri)。 路由配置文件bundle.json部分内容如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 { \u0026#34;version\u0026#34;: \u0026#34;1.0.0\u0026#34;, \u0026#34;bundles\u0026#34;: [ { \u0026#34;uri\u0026#34;: \u0026#34;lib.utils\u0026#34;, \u0026#34;pkg\u0026#34;: \u0026#34;com.example.small.lib.utils\u0026#34;, \u0026#34;rules\u0026#34;: { //会覆盖掉`Principal class`默认的启动页配置 \u0026#34;Storyboard\u0026#34;: \u0026#34;storyboardName/controllerId\u0026#34;, \u0026#34;xib\u0026#34;: \u0026#34;controllerName\u0026#34; } }, { \u0026#34;uri\u0026#34;: \u0026#34;main\u0026#34;, \u0026#34;pkg\u0026#34;: \u0026#34;com.example.small.app.main\u0026#34; } ] .... } small加载接口的相关方法\n1 2 3 4 5 6 7 8 + (void)openUri:(NSString *)uri fromView:(UIView *)view; + (void)openURL:(NSURL *)url fromView:(UIView *)view; + (void)openUri:(NSString *)uri fromController:(UIViewController *)controller; + (void)openURL:(NSURL *)url fromController:(UIViewController *)controller; + (UIViewController *)controllerForUri:(NSString *)uri; + (UIViewController *)controllerForURL:(NSURL *)url; 支持Storyboard作为启动页的解析 根据SMBundle路由配置信息，通过SMAppBundleLauncher的实例方法_controllerForBundle:加载Framework，支持storyboard加载。\n路由rules字典 1 2 3 \u0026#34;rules\u0026#34;:{ \u0026#34;\u0026#34;:\u0026#34;Main/MainViewController\u0026#34; } 空字串(\u0026quot;\u0026quot;)的value值两种格式类型：\n`\u0026quot;$controllerName\u0026quot;`: `SMAppBundleLauncher`通过反射，初始化controller `\u0026quot;storyboardName/controllerId\u0026quot;`:`SMAppBundleLauncher`会识别找到storyboard在更具id初始化controller 最终可以SMBundle实例变量target中得到该key(\u0026quot;\u0026quot;)的value值来定位插件包，在该过程通过对SMBundle的属性bundle.queryParams的处理，完成对插件对象的值传递\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 if ([bundle.target isEqualToString:@\u0026#34;\u0026#34;]) { targetClazz = bundle.principalClass; } else { NSString *target = bundle.target; NSInteger index = [target rangeOfString:@\u0026#34;/\u0026#34;].location; if (index != NSNotFound) { // Storyboard: \u0026#34;$storyboardName/$controllerId\u0026#34; NSString *storyboardName = [target substringToIndex:index]; targetBoard = [UIStoryboard storyboardWithName:storyboardName bundle:bundle]; targetId = [target substringFromIndex:index + 1]; } else { // Controller: \u0026#34;$controllerName\u0026#34; targetClazz = [bundle classNamed:target]; if (targetClazz == nil \u0026amp;\u0026amp; !SMStringHasSuffix(target, @\u0026#34;Controller\u0026#34;)) { targetClazz = [bundle classNamed:[target stringByAppendingString:@\u0026#34;Controller\u0026#34;]]; } } } UIViewController *controller = nil; if (targetClazz != nil) { //尝试获取xib资源 NSString *nibName = NSStringFromClass(targetClazz); NSString *nibPath = [bundle pathForResource:nibName ofType:@\u0026#34;nib\u0026#34;]; if (nibPath != nil) { // 通过xib资源文件创建控制器实例 controller = [[targetClazz alloc] initWithNibName:nibName bundle:bundle]; } else { /// 通过反射类方式创建控制器实例 controller = [[targetClazz alloc] init]; } ... // Initialize controller parameters if (bundle.queryParams != nil) { [controller setValuesForKeysWithDictionary:bundle.queryParams]; } 参数传递 使用 Query标准来传递参数，即在 uri 之后加上 ? 再带上键值对，多个键值对用\u0026amp; 来分开。\n传值方式 detail?id=1000\u0026amp;title=test。 1 [Small openUri:@\u0026#34;detail?from=app.home\u0026#34; fromController:controller]; 接收解析为属性值 例如DetailController)定义两个属性，属性名称和uri键值名保持一致，因为是通过setValuesForKeysWithDictionary来给相应属性赋值。 1 2 3 4 5 6 7 8 9 10 11 // DetailController.h @property (nonatomic, strong) NSString *id; // DetailController.m NSString *id = self.id; 样例 // Initialize controller parameters if (bundle.queryParams != nil) { [controller setValuesForKeysWithDictionary:bundle.queryParams]; } 插件命名规则和入口设置 路由配置对插件包的命名有严格要求，SMBundle主要通过pkg名称包含.app.(模块库)/.lib.(工具库)来定位插件包的，否则全部默认加载bundle包。 模块命名规范\nframework编译成功后，名称跟Product Name一样命名规则: 1 2 3 xx_xx_lib_xx【com_example_small_lib_utils】 xx_xx_app_xx xx_xx_xx_xx 注意lib、app这些对查找framework文件相当重要，这所以会有_，是small对.做了替换\n1 2 3 4 5 6 7 8 9 10 NSString *bundlePath = nil; NSString *bundleSuffix = @\u0026#34;bundle\u0026#34;; //默认 SMBundleType bundleType = SMBundleTypeAssets; if ([pkg rangeOfString:@\u0026#34;.app.\u0026#34;].location != NSNotFound || [pkg rangeOfString:@\u0026#34;.lib.\u0026#34;].location != NSNotFound) { bundleSuffix = @\u0026#34;framework\u0026#34;; bundleType = SMBundleTypeApplication; } NSString *bundleName = [pkg stringByReplacingOccurrencesOfString:@\u0026#34;.\u0026#34; withString:@\u0026#34;_\u0026#34;]; bundleName = [bundleName stringByAppendingFormat:@\u0026#34;.%@\u0026#34;, bundleSuffix]; 设置加载模块的入口类\ninfo.plist方式实现 在 framework模块工程的info.plist文件中添加Principal class字段： 1 2 \u0026lt;key\u0026gt;NSPrincipalClass\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;ESHomeController\u0026lt;/string\u0026gt; //指定入口类名 bundle.json路由方式实现 通过设置bundle.json的rules字典，指定初始化库的入口 1 2 3 4 5 \u0026#34;rules\u0026#34;: { \u0026#34;\u0026#34;: \u0026#34;默认入口类名\u0026#34; \u0026#34;/Storyboard\u0026#34;: \u0026#34;storyboardName/controllerId\u0026#34;, \u0026#34;/xib\u0026#34;: \u0026#34;controllerName\u0026#34; } bundle.json中配置的入口，优先于info.plist中的Principal class的入口。\n集成插件到主工程 插件集成 就是将framework添加到主工程，不能以Linked方式进行添加，使用Build Phases中的Copy Bundle Resources 选项，将framework拖动添加其中即可，这样可以完成对framework编译完后的拷贝. 插件启动原理 small框架会依次优先顺序检查Documents/temp（下载的zip）\u0026ndash;\u0026gt;/Documents/bundles(存放Framework)\u0026ndash;\u0026gt;/iSmallApp.app/(app根目录)，small规定插件Framework必须存放在这几个目录中，才能被small框架动态加载。 具体实现 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 NSString *bundleName = [pkg stringByReplacingOccurrencesOfString:@\u0026#34;.\u0026#34; withString:@\u0026#34;_\u0026#34;]; bundleName = [bundleName stringByAppendingFormat:@\u0026#34;.%@\u0026#34;, bundleSuffix]; NSString *documentBundlesPath = [SMFileManager documentBundlesPath]; NSString *patchFilePath = [SMFileManager tempBundlePathForName:bundleName]; //沙盒中查找插件包，一旦发现，解压加载 if ([[NSFileManager defaultManager] fileExistsAtPath:patchFilePath]) { // Unzip NSString *unzipPath = documentBundlesPath; ZipArchive *zipArchive = [[ZipArchive alloc] init]; [zipArchive UnzipOpenFile:patchFilePath]; [zipArchive UnzipFileTo:unzipPath overWrite:YES]; [zipArchive UnzipCloseFile]; [[NSFileManager defaultManager] removeItemAtPath:patchFilePath error:nil]; } NSString *patchPath = [documentBundlesPath stringByAppendingPathComponent:bundleName]; ///主工程目录下查找 NSString *builtinPath = [[SMFileManager mainBundlesPath] stringByAppendingPathComponent:bundleName]; NSArray *bundlePaths = @[patchPath, builtinPath]; for (NSString *aBundlePath in bundlePaths) { if ([[NSFileManager defaultManager] fileExistsAtPath:aBundlePath]) { bundlePath = aBundlePath; break; } } 测试 完成添加，进入测试。使用过程中，有可以模块更新代码后，主工程调用发现功能未更新，这时候需要清理工程，重新编译；或者修改编译包配置，从而时时更新。 small的两种开发模式的demo 使用者模式 使用场景：作为第三方集成到自己的项目，包含两个特殊的文件podfile和Small-subprojects.rb安装脚本文件。 podfile 1 2 3 4 5 6 platform :ios, \u0026#39;7.0\u0026#39; use_frameworks! target \u0026#39;Sample\u0026#39; do pod \u0026#34;Small\u0026#34;, :path =\u0026gt; \u0026#34;../../\u0026#34; end Small-subprojects.rb安装脚本文件 通过脚本来设置build settings中的FRAMEWORK_SEARCH_PATHS配置：\n1 2 config.build_settings[\u0026#39;FRAMEWORK_SEARCH_PATHS\u0026#39;] \u0026lt;\u0026lt; \u0026#34;$(CONFIGURATION_BUILD_DIR)/**\u0026#34; puts \u0026#34;Small: Add framework search paths for \u0026#39;#{dep.name}\u0026#39;\u0026#34; 开发者模式 使用场景：需要对Small框架集成自己的功能需求时，可以使用该Demo快速部署对Small框架的开发环境 需要去除并行编译模式：Edit Scheme...-\u0026gt;Build-\u0026gt;Build Options-\u0026gt; [ ] Parallelize Build\n各个组件需要签名后才支持代码级别更新。示例中更新例子为xib内容更新。\n使用Small创建iOS工程目录 Small UI route文档\n","date":"2018-04-11T16:42:17Z","permalink":"https://it-boyer.github.io/post/old/xcode/iOS%E6%8F%92%E4%BB%B6%E5%8C%96%E5%BC%80%E5%8F%91%E4%B9%8BSmall/","section":"post","tags":["架构"],"title":"iOS插件化开发之Small"},{"categories":["解决方案"],"contents":"设置全局提交信息 1 2 git config --global user.email \u0026#34;you@example.com\u0026#34; git config --global user.name \u0026#34;Your Name\u0026#34; 修改最后一次提交的用户名信息 ``git git config user.name \u0026lsquo;wangz\u0026rsquo; git config user.email \u0026lsquo;wangz@alib.com\u0026rsquo; git commit \u0026ndash;amend \u0026ndash;author=wangz\n1 2 3 4 5 6 7 8 9 10 11 12 13 ### 项目过大问题 \u0026gt;git clone 主工程出现 fatal: The remote end hung up unexpectedly3) 通常的解决办法： 1. 设置提交缓存的大小为 1G：1048576000 git config http.postBuffer 1048576000 2. 否则，需要配置github/gitlab的公钥 生成：`ssh-keygen -t rsa -C \u0026#34;$your_email\u0026#34;` 拷贝：`pbcopy \u0026lt; ~/.ssh/id_rsa.pub` 创建SSHKey： 在github/gitlab新建公钥`add SSH Key`：粘贴到密钥文本框中即可。 ","date":"2018-04-04T17:44:24Z","permalink":"https://it-boyer.github.io/post/old/git/%E5%BD%93%E9%A1%B9%E7%9B%AE%E8%BF%87%E5%A4%A7%E9%9C%80%E8%A6%81%E9%80%9A%E8%BF%87SSH%E6%96%B9%E5%BC%8FClone/","section":"post","tags":["git"],"title":"当项目过大需要通过SSH方式Clone"},{"categories":["解决方案"],"contents":"当需要导航条为透明色，与背景色一体时，需要去除底边线： 如下代码：使用空图片设置背景图，并指定bar的样式。\n1 2 self.navigationController.navigationBar setBackgroundImage:[UIImage new] forBarMetrics:UIBarMetricsDefault]; self.navigationController.navigationBar.barStyle = UIBarStyleBlackTranslucent; ","date":"2018-03-12T13:51:07Z","permalink":"https://it-boyer.github.io/post/old/iOS/%E9%9A%90%E8%97%8F%E5%AF%BC%E8%88%AA%E6%9D%A1%E5%BA%95%E9%83%A8%E9%BB%91%E7%BA%BF/","section":"post","tags":["iOS"],"title":"隐藏导航条底部黑线"},{"categories":["学习笔记"],"contents":"Objective-C 运行时 Objective-C 是一门基于运行时的编程语言，这意味着所有方法、变量、类之间的链接，都会推迟到应用实际运行的最后一刻才会建立。这将给开发人员极高的灵活性，因为我们可以修改这些链接。而不同的是，Swift 绝大多数时候是一门面向编译时的语言。因此在 Swift 当中，灵活性受到了限制，不过您会因此得到更多的安全性。\nruntime.h开源库 Objective-C 的运行时本质上是一个库。它负责了 “Objective” 这个部分，因此您所知、所爱的面向对象编程，都是在这里实现的。如果您想要访问里面的函数的话，只需要导入这个库即可：\n1 #import \u0026lt;objc/runtime.h\u0026gt; runtime.h开源库主要由 C 和汇编编写而成，其实现了诸如类、对象、方法调度、协议等面向对象编程这个部分。\n成员结构体 在运行时中对象和类本质上是一个非常简单的结构体，在运行时环境下，我们就可以创建，读取，修改这些属性方法等，例如：使用allocateClassPair函数创建类。\n对象结构体 对象结构体中仅提供一个**isa**属性，是关联类引用的指针。这也就是 Objective-C 当中的所有对象都需要实现的。 在 runtime.h 当中对象的定义： 1 2 3 4 typedef struct objc_class *Class; struct objc_object { Class isa; }; 类结构体 1 2 3 4 5 6 7 8 9 10 11 12 struct objc_class { Class isa; Class super_class; const char *name; long version; long info; long instance_size; struct objc_ivar_list *ivars; struct objc_method_list **methodLists; struct objc_cache *cache; struct objc_protocol_list *protocols; }; isa属性：建立自身与 super_class 这个值进行关联。 super_class:除了 NSObject 这个类之外，super_class 的值永远不会为 nil，因为 Objective-C 当中的其余类都是以某种方式继承自 NSObject 的。 ivars：变量列表，methodLists：方法列表，protocols：协议列表，其他属性：name、version、info 之类的值。\n变量结构体 包含了变量类型和变量名称。偏移量 (offset) 则是内存管理方面的内容。 1 2 3 4 5 struct objc_ivar { char *ivar_name; char *ivar_type; int ivar_offset; } 方法结构体 1 2 3 4 5 struct objc_method { SEL method_name; char *method_types; IMP method_imp; } method_name： 方法名，使用Selector来表示方法编号，对应在 performSelector 当中所匹配的内容。 method_types：方法类型，使用char字符来表示。 method_imp：方法的实现，IMP是一个函数指针，方法实现的一种特定的表示方式，是方法混淆特性的根本所在。\n成员函数 运行时库提供一系列运行时函数，实现在运行时动态的对成员结构体（类/对象）进行创建，修改等相关操作，例如：创建类，在类别中添加存储属性\n动态创建运行时类 在制作库框架会大量运用使用到运行时函数。如果您无法知道用户将会创建什么样的数据，那么您就需要在运行时进行类的创建了。Core Data 就使用了这个功能。此外，如果您愿意的话，它还可以用在 JSON 解析当中。 类的创建要用的 Objective-C 两个运行时函数：allocateClassPair和objc_registerClassPair\n1 2 3 4 5 6 //类函数的构造器 Class myClass = objc_allocateClassPair([NSObject class], \u0026#34;MyClass\u0026#34;, 0); // 在这里添加变量、方法和协议 objc_registerClassPair(myClass); // 当类注册之后，变量列表将会被锁定 [[myClass alloc] init]; //可见这个运行时类和Objective-C创建的类毫无区别 [NSObject class]：就是类结构体的属性isa要关联的类引用 \u0026ldquo;MyClass\u0026rdquo;：指定类结构体的name属性值 额外字节的定义：通常我们都直接赋值 0 即可 2. 添加变量、方法以及协议 3. registerClassPair注册这个 ClassPair,注册之后，我们就无法修改变量列表了，不过其余的内容仍然可以修改。\n为类别中新增存储属性 类别可以在既有的类中添加函数、计算属性，无法添加存储属性。但是在运行时环境下，可以借助 setAssociatedObject 和 getAssociatedObject实现向既有的类当中添加存储属性。 例如在NSObject新增一个Name存储属性：\n1 2 3 4 5 6 7 8 9 @implementation NSObject (Name) @dynamic Name; - (void)setName:(id)object { objc_setAssociatedObject(self, @selector(Name), object, OBJC_ASSOCIATION_RETAIN_NONATOMIC); } - (id)Name { return objc_getAssociatedObject(self, @selector(Name)); } 内省机制 内省机制是用来判别这个类是否实现具备某项功能。当我们使用了一个带有可选方法的协议时，为了避免崩溃发生，可以借助这个内省机制来判断这个对象是否可以调用此可选方法。 内省机制提供了两个运行时函数 isMemberOfClass: 对比两者的 isa 是否相同。 respondsToSelector:则封装了一个运行时函数：class_respondsToSelector，两个参数类和 Selector\n1 2 3 4 5 6 //类成员判断 [myObject isMemberOfClass:NSObject.class]; //类方法判断 [myObject respondsToSelector:@selector(doStuff:)]; //等价上一句 class_respondsToSelector(myObject.class, @selector(doStuff:)); 使用运行时实现单元测试 当我们在编写 XCTestCase 的时候，需要完成 setUp 和 tearDown 的设定，随后才能编写相关的 test 函数。当测试运行的时候，系统会自行遍历所有的测试函数，并自动运行。\n1 2 3 4 5 6 7 8 9 10 11 12 unsigned int count; Method *methods = class_copyMethodList(myObject.class,\u0026amp;count); //方法列表 //Ivar *list = class_copyIvarList(myObject.class,\u0026amp;count); //变量列表 for(unsigned i = 0; i \u0026lt; count; i++) { SEL selector = method_getName(methods[i]); //获取到方法名 NSString *selectorString = NSStringFromSelector(selector); //转为字符串 if ([selectorString containsString:@\u0026#34;test\u0026#34;]) { [myObject performSelector:selector]; } } free(methods); 单元测试的原理就是借助了运行时函数class_copyMethodList获取到方法名，然后将其转换为字符串，检查其是否包含有 “test”，如果有便可以运行。\n运行时方法调度 动态的向对象当中添加方法并调用新增的方法。方法转发，方法混淆：替换或交换\n动态的为类新增方法 了解到运行时的方法的结构体组成：方法名，SEL和IMP实现，需要三个运行时函数来新建一个运行时方法 1 2 3 4 5 6 7 8 // Method doStuff = class_getInstanceMethod(self.class, @selector(doStuff)); //获取方法的实现 IMP doStuffImplementation = method_getImplementation(doStuff); //获取方法的类型 const char *types = method_getTypeEncoding(doStuff); //“v@:@\u0026#34; class_addMethod(myClass.class, @selector(doStuff:), doStuffImplementation, types); class_getInstanceMethod:获取方法的SEL method_getImplementation:方法的实现IMP method_getTypeEncoding: 获取方法的类型，char字符表示 class_addMethod: 向对象当中添加方法的运行时函数。它所需的参数，即上述方法结构体当中的那三个值：Selector、方法实现和方法类型。\n调用运行时方法 我们可以使用 [self doStuff] 或者[self performSelector:@selector(doStuff)]来进行调用。 实际上在运行时级别，它们都是借助 objc_msgSend 向对象发送了一个消息： 1 objc_msgSend(self, @selector(message)); 但是如果调用方法所在的对象为 nil 的时候，我们就会得到一个异常，应用便会崩溃。但事实证明，在崩溃之前会预留几个步骤，从而允许我们对某个不存在的函数进行一些操作：方法转发/替换等。\n方法转发 当桥接两个不同的框架的时候，可以将方法转发给其它目标，或者，当我们调用某个未实现的方法时，运行时有如下处理步骤： 1 2 3 4 5 6 7 8 9 10 11 // 1添加实例方法/类方法，如果 return YES，就会调用原始方法 +(BOOL)resolveInstanceMethod:(SEL)sel; +(BOOL)resolveClassMethod:(SEL)sel; // 2 返回可以处理 Selector 的对象 - (id)forwardingTargetForSelector:(SEL)aSelector; // 3 创建 NSInvocation - (NSMethodSignature *)methodSignatureForSelector:(SEL)aSelector; // 4 在您所选择的目标上调用 Selector - (void)forwardInvocation:(NSInvocation *)invocation { [invocation invokeWithTarget:target]; } 3.1. 首先调用两个类方法：一个名为 resolveInstanceMethod/resolveClassMethod类方法，这时候我们便有机会来添加方法了，如果我们返回了 YES，就意味着原始方法将会再次被调用。 3.2. forwardingTargetForSelector：当不要添加新方法时，可以直接返回需要调用方法的目标对象，之后这个对象就会调用 Selector。 3.3. forwardInvocation：实现目标对象调用 Selector，所有的调用过程都被封装到 NSInvocation 对象当中。需要 通过methodSignatureForSelector函数创建。\n动态特性方法混淆：替换或交换 方法混淆是通过 class_replaceMethod 或者 method_exchangeImplementations 实现方法的替换。常用于日志记录和 Mock 测试。 当类加载之后，会调用一个名为 load 的类函数。由于我们只打算混淆一次，因此我们需要使用 dispatch_once。接着我们便可以得到该方法，然后使用 class_replaceMethod 或者 method_exchangeImplementations 来替换方法。 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 + (void)load { static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ Class class = [self class]; SEL originalSelector = @selector(doSomething); SEL swizzledSelector = @selector(mo_doSomething); Method originalMethod = class_getInstanceMethod(class, originalSelector); Method swizzledMethod = class_getInstanceMethod(class, swizzledSelector); BOOL didAddMethod = class_addMethod(class, originalSelector, method_getImplementation(swizzledMethod), method_getTypeEncoding(swizzledMethod)); if (didAddMethod) { class_replaceMethod(class,swizzledSelector, method_getImplementation(originalMethod), method_getTypeEncoding(originalMethod)); } else { method_exchangeImplementations(originalMethod, swizzledMethod); } }); } ","date":"2017-09-25T20:01:36Z","permalink":"https://it-boyer.github.io/post/old/swift/Objective-C%E7%9A%84%E8%BF%90%E8%A1%8C%E6%97%B6%E5%BA%93/","section":"post","tags":["swift"],"title":"Objective-C的运行时库"},{"categories":["解决方案"],"contents":"MVVM 所以，MVVM 到底是什么？与其专注于说明 MVVM 的来历，不如让我们看一个典型的 iOS 是如何构建的，并从那里了解 MVVM：\n我们看到的是一个典型的 MVC 设置。Model 呈现数据，View 呈现用户界面，而 View Controller 调节它两者之间的交互。\n稍微考虑一下，虽然 View 和 View Controller 是技术上不同的组件，但它们几乎总是手牵手在一起，成对的。你什么时候看到一个 View 能够与不同 View Controller 配对？或者反过来？所以，为什么不正规化它们的连接呢？\n这更准确地描述了你可能已经编写的 MVC 代码。但它并没有做太多事情来解决 iOS 应用中日益增长的重量级视图控制器的问题。\n在典型的 MVC 应用里，许多逻辑被放在 View Controller 里。它们中的一些确实属于 View Controller，但更多的是所谓的“表示逻辑（presentation logic）”，以 MVVM 属术语来说，就是那些将 Model 数据转换为 View 可以呈现的东西的事情，例如将一个 NSDate 转换为一个格式化过的 NSString。 我们的图解里缺少某些东西，那些使我们可以把所有表示逻辑放进去的东西。我们打算将其称为 “View Model” —— 它位于 View/Controller 与 Model 之间：\n看起好多了！这个图解准确地描述了什么是 MVVM：一个 MVC 的增强版，我们正式连接了视图和控制器，并将表示逻辑从 Controller 移出放到一个新的对象里，即 View Model。MVVM 听起来很复杂，但它本质上就是一个精心优化的 MVC 架构，而 MVC 你早已熟悉。\n优点 现在我们知道了什么是 MVVM，但为什么我们会想要去使用它呢？在 iOS 上使用 MVVM 的动机，对我来说，无论如何，就是它能减少 View Controller 的复杂性并使得表示逻辑更易于测试。通过一些例子，我们将看到它如何达到这些目标。\n此处有三个重点是我希望你看完本文能带走的：\nMVVM 可以兼容你当下使用的 MVC 架构。 MVVM 增加你的应用的可测试性。 MVVM 配合一个绑定机制效果最好。 如我们之前所见，MVVM 基本上就是 MVC 的改进版，所以很容易就能看到它如何被整合到现有使用典型 MVC 架构的应用中。\n示例 让我们看一个简单的 Person Model 以及相应的 View Controller：\n1 2 3 4 5 6 7 8 9 10 @interface Person : NSObject - (instancetype)initwithSalutation:(NSString *)salutation firstName:(NSString *)firstName lastName:(NSString *)lastName birthdate:(NSDate *)birthdate; @property (nonatomic, readonly) NSString *salutation; @property (nonatomic, readonly) NSString *firstName; @property (nonatomic, readonly) NSString *lastName; @property (nonatomic, readonly) NSDate *birthdate; @end 现在我们假设我们有一个 PersonViewController ，在 viewDidLoad 里，只需要基于它的 model 属性设置一些 Label 即可。\n1 2 3 4 5 6 7 8 9 10 11 12 13 - (void)viewDidLoad { [super viewDidLoad]; if (self.model.salutation.length \u0026gt; 0) { self.nameLabel.text = [NSString stringWithFormat:@\u0026#34;%@ %@ %@\u0026#34;, self.model.salutation, self.model.firstName, self.model.lastName]; } else { self.nameLabel.text = [NSString stringWithFormat:@\u0026#34;%@ %@\u0026#34;, self.model.firstName, self.model.lastName]; } NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\u0026#34;EEEE MMMM d, yyyy\u0026#34;]; self.birthdateLabel.text = [dateFormatter stringFromDate:model.birthdate]; } 这全都直截了当，标准的 MVC。现在来看看我们如何用一个 View Model 来增强它。\n1 2 3 4 5 6 7 8 9 10 @interface PersonViewModel : NSObject - (instancetype)initWithPerson:(Person *)person; @property (nonatomic, readonly) Person *person; @property (nonatomic, readonly) NSString *nameText; @property (nonatomic, readonly) NSString *birthdateText; @end 我们的 View Model 的实现大概如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 @implementation PersonViewModel - (instancetype)initWithPerson:(Person *)person { self = [super init]; if (!self) return nil; _person = person; if (person.salutation.length \u0026gt; 0) { _nameText = [NSString stringWithFormat:@\u0026#34;%@ %@ %@\u0026#34;, self.person.salutation, self.person.firstName, self.person.lastName]; } else { _nameText = [NSString stringWithFormat:@\u0026#34;%@ %@\u0026#34;, self.person.firstName, self.person.lastName]; } NSDateFormatter *dateFormatter = [[NSDateFormatter alloc] init]; [dateFormatter setDateFormat:@\u0026#34;EEEE MMMM d, yyyy\u0026#34;]; _birthdateText = [dateFormatter stringFromDate:person.birthdate]; return self; } @end 我们已经将 viewDidLoad 中的表示逻辑放入我们的 View Model 里了。此时，我们新的 viewDidLoad 就会非常轻量：\n1 2 3 4 5 6 - (void)viewDidLoad { [super viewDidLoad]; self.nameLabel.text = self.viewModel.nameText; self.birthdateLabel.text = self.viewModel.birthdateText; } 所以，如你所见，并没有对我们的 MVC 架构做太多改变。还是同样的代码，只不过移动了位置。它与 MVC 兼容，带来更轻量的 View Controllers。\n可测试 View Controller 是出了名的难以测试，因为它们做了太多事情。在 MVVM 里，我们试着尽可能多的将代码移入 View Model 里。测试 View Controller 就变得容易多了，因为它们不再做一大堆事情，并且 View Model 也非常易于测试。让我们来看看：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 SpecBegin(Person) NSString *salutation = @\u0026#34;Dr.\u0026#34;; NSString *firstName = @\u0026#34;first\u0026#34;; NSString *lastName = @\u0026#34;last\u0026#34;; NSDate *birthdate = [NSDate dateWithTimeIntervalSince1970:0]; it (@\u0026#34;should use the salutation available. \u0026#34;, ^{ Person *person = [[Person alloc] initWithSalutation:salutation firstName:firstName lastName:lastName birthdate:birthdate]; PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person]; expect(viewModel.nameText).to.equal(@\u0026#34;Dr. first last\u0026#34;); }); it (@\u0026#34;should not use an unavailable salutation. \u0026#34;, ^{ Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate]; PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person]; expect(viewModel.nameText).to.equal(@\u0026#34;first last\u0026#34;); }); it (@\u0026#34;should use the correct date format. \u0026#34;, ^{ Person *person = [[Person alloc] initWithSalutation:nil firstName:firstName lastName:lastName birthdate:birthdate]; PersonViewModel *viewModel = [[PersonViewModel alloc] initWithPerson:person]; expect(viewModel.birthdateText).to.equal(@\u0026#34;Thursday January 1, 1970\u0026#34;); }); SpecEnd 如果我们没有将这个逻辑移入 View Model，我们将不得不实例化一个完整的 View Controller 以及伴随的 View，然后去比较我们 View 中 Label 的值。这样做不只是会变成一个麻烦的间接层，而且它只代表了一个十分脆弱的测试。现在，我们可以按意愿自由地修改视图层级而不必担心破坏我们的单元测试。使用 MVVM 带来的对于测试的好处非常清晰，甚至从这个简单的例子来看也可见一斑，而在有更复杂的表示逻辑的情况下，这个好处会更加明显。\n响应式同步 注意到在这个简单的例子中， Model 是不可变的，所以我们可以只在初始化的时候指定我们 View Model 的属性。对于可变 Model，我们还需要使用一些绑定机制，这样 View Model 就能在背后的 Model 改变时更新自身的属性。此外，一旦 View Model 上的 Model 发生改变，那 View 的属性也需要更新。Model 的改变应该级联向下通过 View Model 进入 View。\n在 OS X 上，我们可以使用 Cocoa 绑定，但在 iOS 上我们并没有这样好的配置可用。我们想到了 KVO（Key-Value Observation），而且它确实做了很伟大的工作。然而，对于一个简单的绑定都需要很大的样板代码，更不用说有许多属性需要绑定了。作为替代，我个人喜欢使用 ReactiveCocoa，但 MVVM 并未强制我们使用 ReactiveCocoa。MVVM 是一个伟大的典范，它自身独立，只是在有一个良好的绑定框架时做得更好。\n我们覆盖了不少内容：从普通的 MVC 派生出 MVVM，看它们是如何相兼容的范式，从一个可测试的例子观察 MVVM，并看到 MVVM 在有一个配对的绑定机制时工作得更好。如果你有兴趣学习更多关于 MVVM 的知识，你可以看看这篇博客，它用更多细节解释了 MVVM 的好处，或者这一篇关于我们如何在最近的项目里使用 MVVM 获得巨大的成功的文章。我同样还有一个经过完整测试，基于 MVVM 的应用，叫做 C-41 ，它是开源的。去看看吧，如果你有任何疑问，请告诉我。\n话题 #13 下的更多文章\n原文 Introduction to MVVM\n","date":"2017-09-24T19:26:28Z","permalink":"https://it-boyer.github.io/post/old/iOS/MVVM%E4%BB%8B%E7%BB%8D/","section":"post","tags":["设计模式"],"title":"MVVM介绍"},{"categories":["解决方案"],"contents":"这篇文章将专注于实用技巧，设计模式，以及对于写出线程安全类和使用 GCD 来说所特别需要注意的一些反面模式。\n线程安全 Apple 的框架 首先让我们来看看 Apple 的框架。一般来说除非特别声明，大多数的类默认都不是线程安全的。对于其中的一些类来说，这是很合理的，但是对于另外一些来说就很有趣了。\n就算是在经验丰富的 iOS/Mac 开发者，也难免会犯从后台线程去访问 UIKit/AppKit 这种错误。比如因为图片的内容本身就是从后台的网络请求中获取的话，顺手就在后台线程中设置了 image 之类的属性，这样的错误其实是屡见不鲜的。Apple 的代码都经过了性能的优化，所以即使你从别的线程设置了属性的时候，也不会产生什么警告。\n在设置图片这个例子中，症结其实是你的改变通常要过一会儿才能生效。但是如果有两个线程在同时对图片进行了设定，那么很可能因为当前的图片被释放两次，而导致应用崩溃。这种行为是和时机有关系的，所以很可能在开发阶段没有崩溃，但是你的用户使用时却不断 crash。\n现在没有官方的用来寻找类似错误的工具，但我们确实有一些技巧来避免这个问题。UIKit Main Thread Guard 是一段用来监视每一次对 setNeedsLayout 和 setNeedsDisplay 的调用代码，并检查它们是否是在主线程被调用的。因为这两个方法在 UIKit 的 setter （包括 image 属性）中广泛使用，所以它可以捕获到很多线程相关的错误。虽然这个小技巧并不包含任何私有 API， 但我们还是不建议将它是用在发布产品中，不过在开发过程中使用的话还是相当赞的。\nApple没有把 UIKit 设计为线程安全的类是有意为之的，将其打造为线程安全的话会使很多操作变慢。而事实上 UIKit 是和主线程绑定的，这一特点使得编写并发程序以及使用 UIKit 十分容易的，你唯一需要确保的就是对于 UIKit 的调用总是在主线程中来进行。\n为什么 UIKit 不是线程安全的？ 对于一个像 UIKit 这样的大型框架，确保它的线程安全将会带来巨大的工作量和成本。将 non-atomic 的属性变为 atomic 的属性只不过是需要做的变化里的微不足道的一小部分。\n通常来说，UI需要同时改变若干个属性，才能看到它所带来的结果。为了解决这个问题，苹果可能不得不提供像 Core Data 中的 performBlock: 和 performBlockAndWait: 那样类似的方法来同步变更。 绝大多数对 UIKit 类的调用其实都是以配置为目的的，这使得将 UIKit 改为线程安全这件事情更显得毫无意义了。 然而即使是那些与配置共享的内部状态之类事情无关的调用，其实也不是线程安全的。如果你做过 iOS 3.2 或之前的黑暗年代的 app 开发的话，你肯定有过一边在后台准备图像时一边使用 NSString 的 drawInRect:withFont: 时的随机崩溃的经历。值得庆幸的事，在 iOS 4 中 苹果将大部分绘图的方法和诸如 UIColor 和 UIFont 这样的类改写为了后台线程可用。\n但不幸的是 Apple 在线程安全方面的文档是极度匮乏的。他们推荐只访问主线程，并且甚至是绘图方法他们都没有明确地表示保证线程安全。因此在阅读文档的同时，去读读 iOS 版本更新说明会是一个很好的选择。\n对于大多数情况来说，UIKit 类确实只应该用在应用的主线程中。这对于那些继承自 UIResponder 的类以及那些操作你的应用的用户界面的类来说，不管如何都是很正确的。\n内存回收 (deallocation) 问题 另一个在后台使用 UIKit 对象的的危险之处在于“内存回收问题”。Apple 在技术笔记 TN2109 中概述了这个问题，并提供了多种解决方案。 这个问题其实是要求 UI 对象应该在主线程中被回收，因为在它们的 dealloc 方法被调用回收的时候，可能会去改变 view 的结构关系，而如我们所知，这种操作应该放在主线程来进行。\n因为调用者被其他线程持有是非常常见的（不管是由于 operation 还是 block 所导致的），这也是很容易犯错并且难以被修正的问题。在 AFNetworking 中也一直长久存在这样的 bug，但是由于其自身的隐蔽性而鲜为人知，也很难重现其所造成的崩溃。在异步的 block 或者操作中一致使用 __weak，并且不去直接访问局部变量会对避开这类问题有所帮助。\n集合类 Apple 有一个针对 iOS 和 Mac 的很好的总览性文档，为大多数基本的 foundation 类列举了其线程安全特性。 总的来说，比如 NSArry 这样不可变类是线程安全的。然而它们的可变版本，比如 NSMutableArray 是线程不安全的。 事实上，如果是在一个队列中串行地进行访问的话，在不同线程中使用它们也是没有问题的。要记住的是即使你申明了返回类型是不可变的，方法里还是有可能返回的其实是一个可变版本的集合类。 一个好习惯是写类似于 return [array copy] 这样的代码来确保返回的对象事实上是不可变对象。\n与和Java这样的语言不一样，Foundation 框架并不提供直接可用的集合类，这是有其道理的，因为大多数情况下，你想要的是在更高层级上的锁，以避免太多的加解锁操作。但缓存是一个值得注意的例外，iOS 4 中 Apple 添加的 NSCache 使用一个可变的字典来存储不可变数据，它不仅会对访问加锁，更甚至在低内存情况下会清空自己的内容。\n也就是说，在你的应用中存在可变的且线程安全的字典是可以做到的。借助于 class cluster 的方式，我们也很容易写出这样的代码。\n原子属性 (Atomic Properties) 你曾经好奇过 Apple 是怎么处理 atomic 的设置/读取属性的么？至今为止，你可能听说过自旋锁 (spinlocks)，信标 (semaphores)，锁 (locks)，@synchronized 等，Apple 用的是什么呢？因为 Objctive-C 的 runtime 是开源的，所以我们可以一探究竟。\n一个非原子的 setter 看起来是这个样子的：\n1 2 3 4 5 6 7 - (void)setUserName:(NSString *)userName { if (userName != _userName) { [userName retain]; [_userName release]; _userName = userName; } } 这是一个手动 retain/release 的版本，ARC 生成的代码和这个看起来也是类似的。当我们看这段代码时，显而易见要是 setUserName: 被并发调用的话会造成麻烦。我们可能会释放 _userName 两次，这回使内存错误，并且导致难以发现的 bug。\n对于任何没有手动实现的属性，编译器都会生成一个 objc_setProperty_non_gc(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, signed char shouldCopy) 的调用。在我们的例子中，这个调用的参数是这样的：\n1 2 objc_setProperty_non_gc(self, _cmd, (ptrdiff_t)(\u0026amp;_userName) - (ptrdiff_t)(self), userName, NO, NO);` ptrdiff_t 可能会吓到你，但是实际上这就是一个简单的指针算术，因为其实 Objective-C 的类仅仅只是 C 结构体而已。\nobjc_setProperty 调用的是如下方法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 static inline void reallySetProperty(id self, SEL _cmd, id newValue, ptrdiff_t offset, bool atomic, bool copy, bool mutableCopy) { id oldValue; id *slot = (id*) ((char*)self + offset); if (copy) { newValue = [newValue copyWithZone:NULL]; } else if (mutableCopy) { newValue = [newValue mutableCopyWithZone:NULL]; } else { if (*slot == newValue) return; newValue = objc_retain(newValue); } if (!atomic) { oldValue = *slot; *slot = newValue; } else { spin_lock_t *slotlock = \u0026amp;PropertyLocks[GOODHASH(slot)]; _spin_lock(slotlock); oldValue = *slot; *slot = newValue; _spin_unlock(slotlock); } objc_release(oldValue); } 除开方法名字很有趣以外，其实方法实际做的事情非常直接，它使用了在 PropertyLocks 中的 128 个自旋锁中的 1 个来给操作上锁。这是一种务实和快速的方式，最糟糕的情况下，如果遇到了哈希碰撞，那么 setter 需要等待另一个和它无关的 setter 完成之后再进行工作。\n虽然这些方法没有定义在任何公开的头文件中，但我们还是可用手动调用他们。我不是说这是一个好的做法，但是知道这个还是蛮有趣的，而且如果你想要同时实现原子属性和自定义的 setter 的话，这个技巧就非常有用了。\n1 2 3 4 5 6 7 8 9 10 // 手动声明运行时的方法 extern void objc_setProperty(id self, SEL _cmd, ptrdiff_t offset, id newValue, BOOL atomic, BOOL shouldCopy); extern id objc_getProperty(id self, SEL _cmd, ptrdiff_t offset, BOOL atomic); #define PSTAtomicRetainedSet(dest, src) objc_setProperty(self, _cmd, (ptrdiff_t)(\u0026amp;dest) - (ptrdiff_t)(self), src, YES, NO) #define PSTAtomicAutoreleasedGet(src) objc_getProperty(self, _cmd, (ptrdiff_t)(\u0026amp;src) - (ptrdiff_t)(self), YES) 参考这个 gist 来获取包含处理结构体的完整的代码，但是我们其实并不推荐使用它。\n为何不用 @synchronized ？ 你也许会想问为什么苹果不用 @synchronized(self) 这样一个已经存在的运行时特性来锁定属？？你可以看看这里的源码，就会发现其实发生了很多的事情。Apple 使用了最多三个加/解锁序列，还有一部分原因是他们也添加了异常开解(exception unwinding)机制。相比于更快的自旋锁方式，这种实现要慢得多。由于设置某个属性一般来说会相当快，因此自旋锁更适合用来完成这项工作。@synchonized(self) 更适合使用在你需要确保在发生错误时代码不会死锁，而是抛出异常的时候。\n你自己的类 单独使用原子属性并不会使你的类变成线程安全。它不能保护你应用的逻辑，只能保护你免于在 setter 中遭遇到竞态条件的困扰。看看下面的代码片段：\n1 2 3 4 5 if (self.contents) { CFAttributedStringRef stringRef = CFAttributedStringCreate(NULL, (__bridge CFStringRef)self.contents, NULL); // 渲染字符串 } 我之前在 PSPDFKit 中就犯了这个错误。时不时地应用就会因为 contents 属性在通过检查之后却又被设成了 nil 而导致 EXC_BAD_ACCESS 崩溃。捕获这个变量就可以简单修复这个问题；\n1 2 3 4 5 6 NSString *contents = self.contents; if (contents) { CFAttributedStringRef stringRef = CFAttributedStringCreate(NULL, (__bridge CFStringRef)contents, NULL); // 渲染字符串 } 在这里这样就能解决问题，但是大多数情况下不会这么简单。 想象一下我们还有一个 textColor 的属性，我们在一个线程中将两个属性都做了改变。我们的渲染线程有可能使用了新的内容，但是依旧保持了旧的颜色，于是我们得到了一组奇怪的组合。这其实也是为什么 Core Data 要将 model 对象都绑定在一个线程或者队列中的原因。\n对于这个问题，其实没有万用解法。使用 不可变模型是一个可能的方案，但是它也有自己的问题。另一种途径是限制对存在在主线程或者某个特定队列中的既存对象的改变，而是先进行一次拷贝之后再在工作线程中使用。对于这个问题的更多对应方法，我推荐阅读 Jonathan Sterling 的关于 Objective-C 中轻量化不可变对象的文章。\n一个简单的解决办法是使用 @synchronize。其他的方式都非常非常可能使你误入歧途，已经有太多聪明人在这种尝试上一次又一次地以失败告终。\n可行的线程安全设计 在尝试写一些线程安全的东西之前，应该先想清楚是不是真的需要。确保你要做的事情不会是过早优化。如果要写的东西是一个类似配置类 (configuration class) 的话，去考虑线程安全这种事情就毫无意义了。更正确的做法是扔一个断言上去，以保证它被正确地使用：\n1 2 3 4 5 void PSPDFAssertIfNotMainThread(void) { NSAssert(NSThread.isMainThread, @\u0026#34;Error: Method needs to be called on the main thread. %@\u0026#34;, [NSThread callStackSymbols]); } 对于那些肯定应该线程安全的代码（一个好例子是负责缓存的类）来说，一个不错的设计是使用并发的 dispatch_queue 作为读/写锁，并且确保只锁着那些真的需要被锁住的部分，以此来最大化性能。一旦你使用多个队列来给不同的部分上锁的话，整件事情很快就会变得难以控制了。\n于是你也可以重新组织你的代码，这样某些特定的锁就不再需要了。看看下面这段实现了一种多委托的代码（其实在大多数情况下，用 NSNotifications 会更好，但是其实也还是有多委托的实用例子）的\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 // 头文件 @property (nonatomic, strong) NSMutableSet *delegates; // init方法中 _delegateQueue = dispatch_queue_create(\u0026#34;com.PSPDFKit.cacheDelegateQueue\u0026#34;, DISPATCH_QUEUE_CONCURRENT); - (void)addDelegate:(id\u0026lt;PSPDFCacheDelegate\u0026gt;)delegate { dispatch_barrier_async(_delegateQueue, ^{ [self.delegates addObject:delegate]; }); } - (void)removeAllDelegates { dispatch_barrier_async(_delegateQueue, ^{ self.delegates removeAllObjects]; }); } - (void)callDelegateForX { dispatch_sync(_delegateQueue, ^{ [self.delegates enumerateObjectsUsingBlock:^(id\u0026lt;PSPDFCacheDelegate\u0026gt; delegate, NSUInteger idx, BOOL *stop) { // 调用delegate }]; }); } 除非 addDelegate: 或者 removeDelegate: 每秒要被调用上千次，否则我们可以使用一个相对简洁的实现方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 // 头文件 @property (atomic, copy) NSSet *delegates; - (void)addDelegate:(id\u0026lt;PSPDFCacheDelegate\u0026gt;)delegate { @synchronized(self) { self.delegates = [self.delegates setByAddingObject:delegate]; } } - (void)removeAllDelegates { @synchronized(self) { self.delegates = nil; } } - (void)callDelegateForX { [self.delegates enumerateObjectsUsingBlock:^(id\u0026lt;PSPDFCacheDelegate\u0026gt; delegate, NSUInteger idx, BOOL *stop) { // 调用delegate }]; } 就算这样，这个例子还是有点理想化，因为其他人可以把变更限制在主线程中。但是对于很多数据结构，可以在可变更操作的方法中创建不可变的拷贝，这样整体的代码逻辑上就不再需要处理过多的锁了。\nGCD 的陷阱 对于大多数上锁的需求来说，GCD 就足够好了。它简单迅速，并且基于 block 的 API 使得粗心大意造成非平衡锁操作的概率下降了不少。然后，GCD 中还是有不少陷阱，我们在这里探索一下其中的一些。\n将 GCD 当作递归锁使用 GCD 是一个对共享资源的访问进行串行化的队列。这个特性可以被当作锁来使用，但实际上它和 @synchronized 有很大区别。 GCD队列并非是可重入的，因为这将破坏队列的特性。很多有试图使用 dispatch_get_current_queue() 来绕开这个限制，但是这是一个糟糕的做法，Apple 在 iOS6 中将这个方法标记为废弃，自然也是有自己的理由。\n1 2 3 4 5 6 // This is a bad idea. inline void pst_dispatch_sync_reentrant(dispatch_queue_t queue, dispatch_block_t block) { dispatch_get_current_queue() == queue ? block() : dispatch_sync(queue, block); } 对当前的队列进行测试也许在简单情况下可以行得通，但是一旦你的代码变得复杂一些，并且你可能有多个队列在同时被锁住的情况下，这种方法很快就悲剧了。一旦这种情况发生，几乎可以肯定的是你会遇到死锁。当然，你可以使用 dispatch_get_specific()，这将截断整个队列结构，从而对某个特定的队列进行测试。要这么做的话，你还得为了在队列中附加标志队列的元数据，而去写自定义的队列构造函数。嘛，最好别这么做。其实在实用中，使用 NSRecursiveLock 会是一个更好的选择。\n用 dispatch_async 修复时序问题 在使用 UIKit 的时候遇到了一些时序上的麻烦？很多时候，这样进行“修正”看来非常完美：\n1 2 3 4 5 dispatch_async(dispatch_get_main_queue(), ^{ // Some UIKit call that had timing issues but works fine // in the next runloop. [self updatePopoverSize]; }); 千万别这么做！相信我，这种做法将会在之后你的 app 规模大一些的时候让你找不着北。这种代码非常难以调试，并且你很快就会陷入用更多的 dispatch 来修复所谓的莫名其妙的\u0026quot;时序问题\u0026quot;。审视你的代码，并且找到合适的地方来进行调用（比如在 viewWillAppear 里调用，而不是 viewDidLoad 之类的）才是解决这个问题的正确做法。我在自己的代码中也还留有一些这样的 hack，但是我为它们基本都做了正确的文档工作，并且对应的 issue 也被一一记录过。\n记住这不是真正的 GCD 特性，而只是一个在 GCD 下很容易实现的常见反面模式。事实上你可以使用 performSelector:afterDelay: 方法来实现同样的操作，其中 delay 是在对应时间后的 runloop。\n在性能关键的代码中混用 dispatch_sync 和 dispatch_async 这个问题我花了好久来研究。在 PSPDFKit 中有一个使用了 LRU（最久未使用）算法列表的缓存类来记录对图片的访问。当你在页面中滚动时，这个方法将被调用非常多次。最初的实现使用了 dispatch_sync 来进行实际有效的访问，使用 dispatch_async 来更新 LRU 列表的位置。这导致了帧数远低于原来的 60 帧的目标。\n当你的 app 中的其他运行的代码阻挡了 GCD 线程的时候，dispatch manager 需要花时间去寻找能够执行 dispatch_async 代码的线程，这有时候会花费一点时间。在找到合适的执行线程之前，你的同步调用就会被 block 住了。其实在这个例子中，异步情况的执行顺序并不是很重要，但没有能将这件事情告诉 GCD 的好办法。读/写锁这里并不能起到什么作用，因为在异步操作中基本上一定会需要进行顺序写入，而在此过程中读操作将被阻塞住。如果误用了 dispatch_async 代价将会是非常惨重的。在将它用作锁的时候，一定要非常小心。\n使用 dispatch_async 来派发内存敏感的操作 我们已经谈论了很多关于 NSOperations 的话题了，一般情况下，使用这个更高层级的 API 会是一个好主意。当你要处理一段内存敏感的操作的代码块时，这个优势尤为突出、\n在 PSPDFKit 的老版本中，我用了 GCD 队列来将已缓存的 JPG 图片写到磁盘中。当 retina 的 iPad 问世之后，这个操作出现了问题。ß因为分辨率翻倍了，相比渲染这张图片，将它编码花费的时间要长得多。所以，操作堆积在了队列中，当系统繁忙时，甚至有可能因为内存耗尽而崩溃。\n我们没有办法追踪有多少个操作在队列中等待运行（除非你手动添加了追踪这个的代码），我们也没有现成的方法来在接收到低内存通告的时候来取消操作、这时候，切换到 NSOperations 可以使代码变得容易调试得多，并且允许我们在不添加手动管理的代码的情况下，做到对操作的追踪和取消。\n当然也有一些不好的地方，比如你不能在你的 NSOperationQueue 中设置目标队列（就像 DISPATCH_QUEUE_PRIORITY_BACKGROUND 之于 缓速 I/O 那样）。但这只是为了可调试性的一点小代价，而事实上这也帮助你避免遇到优先级反转的问题。我甚至不推荐直接使用已经包装好的 NSBlockOperation 的 API，而是建议使用一个 NSOperation 的真正的子类，包括实现其 description。诚然，这样做工作量会大一些，但是能输出所有运行中/准备运行的操作是及其有用的。\n话题 #2 下的更多文章\n原文 Thread-Safe Class Design\n","date":"2017-09-24T19:06:03Z","permalink":"https://it-boyer.github.io/post/old/iOS/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E7%B1%BB%E7%9A%84%E8%AE%BE%E8%AE%A1/","section":"post","tags":["线程"],"title":"线程安全类的设计"},{"categories":["学习笔记"],"contents":"这篇文章里，我们将会讨论一些 iOS 和 OS X 都可以使用的底层 API。除了 dispatch_once ，我们一般不鼓励使用其中的任何一种技术。\n但是我们想要揭示出表面之下深层次的一些可利用的方面。这些底层的 API 提供了大量的灵活性，随之而来的是大量的复杂度和更多的责任。在我们的文章常见的后台实践中提到的高层的 API 和模式能够让你专注于手头的任务并且免于大量的问题。通常来说，高层的 API 会提供更好的性能，除非你能承受起使用底层 API 带来的纠结于调试代码的时间和努力。\n尽管如此，了解深层次下的软件堆栈工作原理还是有很有帮助的。我们希望这篇文章能够让你更好的了解这个平台，同时，让你更加感谢这些高层的 API。\n首先，我们将会分析大多数组成 Grand Central Dispatch 的部分。它已经存在了好几年，并且苹果公司持续添加功能并且改善它。现在苹果已经将其开源，这意味着它对其他平台也是可用的了。最后，我们将会看一下原子操作——另外的一种底层代码块的集合。\n或许关于并发编程最好的书是 M. Ben-Ari 写的《Principles of Concurrent Programming》,ISBN 0-13-701078-8。如果你正在做任何与并发编程有关的事情，你需要读一下这本书。这本书已经30多年了，仍然非常卓越。书中简洁的写法，优秀的例子和练习，带你领略并发编程中代码块的基本原理。这本书现在已经绝版了，但是它的一些复印版依然广为流传。有一个新版书，名字叫《Principles of Concurrent and Distributed Programming》,ISBN 0-321-31283-X,好像有很多相同的地方，不过我还没有读过。\n常用的GCD 单例：dispatch_once 或许GCD中使用最多并且被滥用功能的就是 dispatch_once 了。正确的用法看起来是这样的：\n1 2 3 4 5 6 7 8 9 + (UIColor *)boringColor; { static UIColor *color; static dispatch_once_t onceToken; dispatch_once(\u0026amp;onceToken, ^{ color = [UIColor colorWithRed:0.380f green:0.376f blue:0.376f alpha:1.000f]; }); return color; } 上面的 block 只会运行一次。并且在连续的调用中，这种检查是很高效的。你能使用它来初始化全局数据比如单例。要注意的是，使用 dispatch_once_t 会使得测试变得非常困难（单例和测试不是很好配合）。\n要确保 onceToken 被声明为 static ，或者有全局作用域。任何其他的情况都会导致无法预知的行为。换句话说，不要把 dispatch_once_t 作为一个对象的成员变量，或者类似的情形。\n退回到远古时代（其实也就是几年前），人们会使用 pthread_once ，因为 dispatch_once_t 更容易使用并且不易出错，所以你永远都不会再用到 pthread_once 了。\n延后执行：dispatch_after 它能使工作延后执行。它是很强大的，但是要注意：你很容易就陷入到一堆麻烦中。一般用法是这样的：\n1 2 3 4 5 6 7 8 - (void)foo { double delayInSeconds = 2.0; dispatch_time_t popTime = dispatch_time(DISPATCH_TIME_NOW, (int64_t) (delayInSeconds * NSEC_PER_SEC)); dispatch_after(popTime, dispatch_get_main_queue(), ^(void){ [self bar]; }); } 第一眼看上去这段代码是极好的。但是这里存在一些缺点。我们不能（直接）取消我们已经提交到 dispatch_after 的代码，它将会运行。\n时序性bug 当人们使用 dispatch_after 去处理他们代码中存在的时序 bug 时，会存在一些有问题的倾向。一些代码执行的过早而你很可能不知道为什么会这样，所以你把这段代码放到了 dispatch_after 中，现在一切运行正常了。但是几周以后，之前的工作不起作用了。由于你并不十分清楚你自己代码的执行次序，调试代码就变成了一场噩梦。所以不要像上面这样做。\n解决方案 大多数的情况下，你最好把代码放到正确的位置。如果代码放到 -viewWillAppear 太早，那么或许 -viewDidAppear 就是正确的地方。 通过在自己代码中建立直接调用（类似 -viewDidAppear ）而不是依赖于 dispatch_after ，你会为自己省去很多麻烦。\n推荐场景 如果你需要一些事情在某个特定的时刻运行，那么 dispatch_after 或许会是个好的选择。确保同时考虑了 NSTimer，这个API虽然有点笨重，但是它允许你取消定时器的触发。\n队列 GCD是一个很大抽象层级用户 API，提供管理线程池队列的管理。 当使用 GCD 来完成并发的工作时，你不必考虑线程方面的问题，只需考虑队列和功能点（提交给队列的 block）。虽然往下深究，依然都是线程，但是 GCD 的抽象层级为你惯用的编码提供了更好的方式。 隔离队列：默认情况下，它们是串行的，也就是说，任何给定的时间内，只能有一个单独的 block 运行。 并行队列：同一时间内允许多个 block 一起执行。 GCD 中一个基本的代码块就是队列。下面我们会给出一些如何使用它的例子。当使用队列的时候，给它们一个明显的标签会帮自己不少忙。在调试时，这个标签会在 Xcode (和 lldb)中显示，这会帮助你了解你的 app 是由什么决定的：\n1 2 3 4 5 6 7 8 9 10 11 12 13 - (id)init; { self = [super init]; if (self != nil) { NSString *label = [NSString stringWithFormat:@\u0026#34;%@.isolation.%p\u0026#34;, [self class], self]; self.isolationQueue = dispatch_queue_create([label UTF8String], 0); label = [NSString stringWithFormat:@\u0026#34;%@.work.%p\u0026#34;, [self class], self]; //创建一个队列 self.workQueue = dispatch_queue_create([label UTF8String], 0); } return self; } 解决扇出问题 队列和功能点同时解决了一个连续不断的扇出的问题：如果我们直接使用线程，并且想要做一些并发的事情，我们很可能将我们的工作分成 100 个小的功能点，然后基于可用的 CPU 内核数量来创建线程，假设是 8。我们把这些功能点送到这 8 个线程中。当我们处理这些功能点时，可能会调用一些函数作为功能的一部分。写那个函数的人也想要使用并发，因此当你调用这个函数的时候，这个函数也会创建 8 个线程。现在，你有了 8 × 8 = 64 个线程，尽管你只有 8 个CPU内核——也就是说任何时候只有12%的线程实际在运行而另外88%的线程什么事情都没做。使用 GCD 你就不会遇到这种问题，当系统关闭 CPU 内核以省电时，GCD 甚至能够相应地调整线程数量。\nGCD中创建线程 GCD 通过创建所谓的线程池来大致匹配 CPU 内核数量。要记住，线程的创建并不是无代价的。每个线程都需要占用内存和内核资源。这里也有一个问题：如果你提交了一个 block 给 GCD，但是这段代码阻塞了这个线程，那么这个线程在这段时间内就不能用来完成其他工作——它被阻塞了。为了确保功能点在队列上一直是执行的，GCD 不得不创建一个新的线程，并把它添加到线程池。\n线程阻塞问题 如果你的代码阻塞了许多线程，这会带来很大的问题。首先，线程消耗资源，此外，创建线程会变得代价高昂。创建过程需要一些时间。并且在这段时间中，GCD 无法以全速来完成功能点。有不少能够导致线程阻塞的情况，但是最常见的情况与 I/O 有关，也就是从文件或者网络中读写数据。正是因为这些原因，你不应该在GCD队列中以阻塞的方式来做这些操作。看一下下面的输入输出段落去了解一些关于如何以 GCD 运行良好的方式来做 I/O 操作的信息。\n目标队列 目标队列可以设置队列的名字，这让调试变得轻松许多—— Xcode 可以让你在 Debug Navigator 中看到所有的队列名字，如果你直接使用 lldb。(lldb) thread list 命令将会在控制台打印出所有队列的名字。一旦你使用大量的异步内容，这会是非常有用的帮助。 如果一个队列的目标队列是串行的（也就是非并发），那么实际上这个队列也会转换为一个串行队列。 你能够为你创建的任何一个队列设置一个目标队列。这会是很强大的，并且有助于调试。\n使用私有队列同样强调封装性。这时你自己的队列，你要自己决定如何使用它。\n队列转发控制 默认情况下，一个新创建的队列转发到默认优先级的全局队列中。我们就将会讨论一些有关优先级的东西。\n你可以改变你队列转发到的队列——你可以设置自己队列的目标队列。以这种方式，你可以将不同队列链接在一起。你的 Foo 类有一个队列，该队列转发到 Bar 类的队列，Bar 类的队列又转发到全局队列。\n当你为了隔离目的而使用一个队列时，这会非常有用。Foo 有一个隔离队列，并且转发到 Bar 的隔离队列，与 Bar 的隔离队列所保护的有关的资源，会自动成为线程安全的。\n优先级 你可以通过设置目标队列为一个全局队列来改变自己队列的优先级，但是你应该克制这么做的冲动。\n在大多数情况下，改变优先级不会使事情照你预想的方向运行。一些看起简单的事情实际上是一个非常复杂的问题。你很容易会碰到一个叫做优先级反转的情况。我们的文章《并发编程：API 及挑战》有更多关于这个问题的信息，这个问题几乎导致了NASA的探路者火星漫游器变成砖头。\n此外，使用 DISPATCH_QUEUE_PRIORITY_BACKGROUND 队列时，你需要格外小心。除非你理解了 throttled I/O 和 background status as per setpriority(2) 的意义，否则不要使用它。不然，系统可能会以难以忍受的方式终止你的 app 的运行。打算以不干扰系统其他正在做 I/O 操作的方式去做 I/O 操作时，一旦和优先级反转情况结合起来，这会变成一种危险的情况。\n隔离 隔离队列是 GCD 队列使用中非常普遍的一种模式。这里有两个变种。\n资源保护 多线程编程中，最常见的情形是你有一个资源，每次只有一个线程被允许访问这个资源。\n我们在有关多线程技术的文章中讨论了资源在并发编程中意味着什么，它通常就是一块内存或者一个对象，每次只有一个线程可以访问它。\n串行队列读写共享资源 举例来说，我们需要以多线程（或者多个队列）方式访问 NSMutableDictionary 。我们可能会照下面的代码来做：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 - (void)setCount:(NSUInteger)count forKey:(NSString *)key { key = [key copy]; dispatch_async(self.isolationQueue, ^(){ if (count == 0) { [self.counts removeObjectForKey:key]; } else { self.counts[key] = @(count); } }); } - (NSUInteger)countForKey:(NSString *)key; { __block NSUInteger count; dispatch_sync(self.isolationQueue, ^(){ NSNumber *n = self.counts[key]; count = [n unsignedIntegerValue]; }); return count; } 通过以上代码，只有一个线程可以访问 NSMutableDictionary 的实例。\n注意以下四点：\n不要使用上面的代码，请先阅读多读单写和锁竞争 我们使用 async 方式来保存值，这很重要。我们不想也不必阻塞当前线程只是为了等待写操作完成。当读操作时，我们使用 sync 因为我们需要返回值。 从函数接口可以看出，-setCount:forKey: 需要一个 NSString 参数，用来传递给 dispatch_async。函数调用者可以自由传递一个 NSMutableString 值并且能够在函数返回后修改它。因此我们必须对传入的字符串使用 copy 操作以确保函数能够正确地工作。如果传入的字符串不是可变的（也就是正常的 NSString 类型），调用copy基本上是个空操作。 isolationQueue 创建时，参数 dispatch_queue_attr_t 的值必须是DISPATCH_QUEUE_SERIAL（或者0）。 barrier分发block实现并行队列多读单写 我们能够改善上面的那个例子。GCD 有可以让多线程运行的并发队列。我们能够安全地使用多线程来从 NSMutableDictionary 中读取只要我们不同时修改它。 我们使用 barrier 来分发一个block实现对字典的多读单写操作。这样的一个 block 的运行时机是，在它之前所有计划好的 block 完成之后，并且在所有它后面的 block 运行之前。\n以如下方式创建队列：\n1 self.isolationQueue = dispatch_queue_create([label UTF8String], DISPATCH_QUEUE_CONCURRENT); 并且用以下代码来改变setter函数：\n1 2 3 4 5 6 7 8 9 10 11 - (void)setCount:(NSUInteger)count forKey:(NSString *)key { key = [key copy]; dispatch_barrier_async(self.isolationQueue, ^(){ if (count == 0) { [self.counts removeObjectForKey:key]; } else { self.counts[key] = @(count); } }); } 当使用并发队列时，要确保所有的 barrier 调用都是 async 的。如果你使用 dispatch_barrier_sync ，那么你很可能会使你自己（更确切的说是，你的代码）产生死锁。写操作需要 barrier，并且可以是 async 的。\n锁竞争 首先，这里有一个警告：上面这个例子中我们保护的资源是一个 NSMutableDictionary，出于这样的目的，这段代码运行地相当不错。但是在真实的代码中，把隔离放到正确的复杂度层级下是很重要的。\n如果你对 NSMutableDictionary 的访问操作变得非常频繁，你会碰到一个已知的叫做锁竞争的问题。锁竞争并不是只是在 GCD 和队列下才变得特殊，任何使用了锁机制的程序都会碰到同样的问题——只不过不同的锁机制会以不同的方式碰到。\n时序性避免使用锁 所有对 dispatch_async，dispatch_sync 等等的调用都需要完成某种形式的锁——以确保仅有一个线程或者特定的线程运行指定的代码。GCD 某些程序上可以使用时序(译注：原词为 scheduling)来避免使用锁，但在最后，问题只是稍有变化。 根本问题仍然存在：如果你有大量的线程在相同时间去访问同一个锁或者队列，你就会看到性能的变化。性能会严重下降。\n平衡两个开销 你应该直接从复杂层次中隔离开。当你发现了性能下降，这明显表明代码中存在设计问题。这里有两个开销需要你来平衡： 第一个是独占临界区资源太久的开销，以至于别的线程都因为进入临界区的操作而阻塞。例如：一个在隔离队列中运行 block，它可能潜在的阻塞了其他将要在这个隔离队列中运行的代码。 第二个是太频繁出入临界区的开销。例如频繁调用 dispatch_async 和 dispatch_sync 。 无论再怎么优化，这两个操作都不是无代价的。 令人忧伤的，不存在通用的标准来指导如何正确的平衡，你需要自己评测和调整。启动 Instruments 观察你的 app 忙于什么操作。\n设计层保护隔离队列 在你自己的代码中，要考虑自己是否在更高的层次保护了隔离队列。 举个例子： 类 Foo 有一个隔离队列并且它本身保护着对 NSMutableDictionary 的访问，代替的，可以有一个用到了 Foo 类的 Bar 类有一个隔离队列保护所有对类 Foo 的使用。 换句话说，你可以把类 Foo 变为非线程安全的（没有隔离队列），并在 Bar 中，使用一个隔离队列来确保任何时刻只能有一个线程使用 Foo 。\n死锁问题 全都使用异步分发\n同步分发死锁 在 GCD 中，同步和异步地分发一个 block，一个工作单元。以同步分发的方式非常容易出现死锁。见下面的代码： 1 2 3 4 5 6 dispatch_queue_t queueA; // assume we have this dispatch_sync(queueA, ^(){ dispatch_sync(queueA, ^(){ foo(); }); }); 一旦我们进入到第二个 dispatch_sync 就会发生死锁。我们不能分发到queueA，因为有人（当前线程）正在队列中并且永远不会离开。 2. 更隐晦的产生死锁方式：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 dispatch_queue_t queueA; // assume we have this dispatch_queue_t queueB; // assume we have this dispatch_sync(queueA, ^(){ foo(); }); void foo(void) { dispatch_sync(queueB, ^(){ bar(); }); } void bar(void) { dispatch_sync(queueA, ^(){ baz(); }); } 单独的每次调用 dispatch_sync() 看起来都没有问题，但是一旦组合起来，就会发生死锁。\n解决：异步调用不会产生死锁 这是使用同步分发存在的固有问题，如果我们使用异步分发，比如：\n1 2 3 4 5 6 dispatch_queue_t queueA; // assume we have this dispatch_async(queueA, ^(){ dispatch_async(queueA, ^(){ foo(); }); }); 一切运行正常。异步调用不会产生死锁。因此值得我们在任何可能的时候都使用异步分发。我们使用一个异步调用结果 block 的函数，来代替编写一个返回值（必须要用同步）的方法或者函数。这种方式，我们会有更少发生死锁的可能性。\n异步调用的副作用就是它们很难调试。当我们在调试器里中止代码运行，回溯并查看已经变得没有意义了。\n要牢记这些。死锁通常是最难处理的问题。\n如何设计健壮的异步 API 记住几种好的实践：\n需要倾向于异步 API。 当你创建一个 API，它会在你的控制之外以各种方式调用，如果你的代码能产生死锁，那么死锁就会发生。 主动在自己的函数或者方法中调用异步分发dispatch_async()。 不要让你的函数调用者来这么做，这个调用应该在你的方法或者函数中来做。 返回值传递，异步地将方法或函数的返回值传递给回调处理程序。 这个API（方法或函数）应该同时持有一个结果 block 和一个将结果传递过去的队列。不需要API调用者自己来做分发。 这么做的原因很简单：几乎所有事件，函数调用都应该在一个适当的队列中，而且以这种方式编写的代码是很容易阅读的。总之，你的函数将会（必须）调用 dispatch_async() 去运行回调处理程序，所以它同时也可能在需要调用的队列上做这些工作。 如果你写一个类，让你类的使用者设置一个回调处理队列或许会是一个好的选择。你的代码可能像这样：\n1 2 3 4 5 6 7 8 9 - (void)processImage:(UIImage *)image completionHandler:(void(^)(BOOL success))handler; { dispatch_async(self.isolationQueue, ^(void){ // do actual processing here dispatch_async(self.resultQueue, ^(void){ handler(YES); }); }); } 如果你以这种方式来写你的类，让类之间协同工作就会变得容易。如果类 A 使用了类 B，它会把自己的隔离队列设置为 B 的回调队列。\n迭代执行 如果你正在倒弄一些数字，并且手头上的问题可以拆分出同样性质的部分，那么 dispatch_apply 会很有用。\n如果你的代码看起来是这样的：\n1 2 3 4 5 for (size_t y = 0; y \u0026lt; height; ++y) { for (size_t x = 0; x \u0026lt; width; ++x) { // Do something with x and y here } } 小小的改动或许就可以让它运行的更快：\n1 2 3 4 5 dispatch_apply(height, dispatch_get_global_queue(0, 0), ^(size_t y) { for (size_t x = 0; x \u0026lt; width; x += 2) { // Do something with x and y here } }); 代码运行良好的程度取决于你在循环内部做的操作。\nblock 中运行的工作必须是非常重要的，否则这个头部信息就显得过于繁重了。除非代码受到计算带宽的约束，每个工作单元为了很好适应缓存大小而读写的内存都是临界的。这会对性能会带来显著的影响。受到临界区约束的代码可能不会很好地运行。详细讨论这些问题已经超出了这篇文章的范围。使用 dispatch_apply 可能会对性能提升有所帮助，但是性能优化本身就是个很复杂的主题。维基百科上有一篇关于 Memory-bound function 的文章。内存访问速度在 L2，L3 和主存上变化很显著。当你的数据访问模式与缓存大小不匹配时，10倍性能下降的情况并不少见。\n组 很多时候，你发现需要将异步的 block 组合起来去完成一个给定的任务。这些任务中甚至有些是并行的。 现在，如果你想要在这些任务都执行完成后运行一些代码，\u0026ldquo;groups\u0026rdquo; 可以完成这项任务。看这里的例子：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 dispatch_group_t group = dispatch_group_create(); dispatch_queue_t queue = dispatch_get_global_queue(0, 0); dispatch_group_async(group, queue, ^(){ // Do something that takes a while [self doSomeFoo]; dispatch_group_async(group, dispatch_get_main_queue(), ^(){ self.foo = 42; }); }); dispatch_group_async(group, queue, ^(){ // Do something else that takes a while [self doSomeBar]; dispatch_group_async(group, dispatch_get_main_queue(), ^(){ self.bar = 1; }); }); // This block will run once everything above is done: dispatch_group_notify(group, dispatch_get_main_queue(), ^(){ NSLog(@\u0026#34;foo: %d\u0026#34;, self.foo); NSLog(@\u0026#34;bar: %d\u0026#34;, self.bar); }); 需要注意的重要事情是，所有的这些都是非阻塞的。我们从未让当前的线程一直等待直到别的任务做完。恰恰相反，我们只是简单的将多个 block 放入队列。由于代码不会阻塞，所以就不会产生死锁。\n同时需要注意的是，在这个小并且简单的例子中，我们是怎么在不同的队列间进切换的。\n对现有API使用 dispatch_group_t 一旦你将 groups 作为你的工具箱中的一部分，你可能会怀疑为什么大多数的异步API不把 dispatch_group_t 作为一个可选参数。这没有什么无法接受的理由，仅仅是因为自己添加这个功能太简单了，但是你还是要小心以确保自己使用 groups 的代码是成对出现的。\n举例来说，我们可以给 Core Data 的 -performBlock: API 函数添加上 groups，就像这样：\n1 2 3 4 5 6 7 8 9 10 11 12 - (void)withGroup:(dispatch_group_t)group performBlock:(dispatch_block_t)block { if (group == NULL) { [self performBlock:block]; } else { dispatch_group_enter(group); [self performBlock:^(){ block(); dispatch_group_leave(group); }]; } } 当 Core Data 上的一系列操作(很可能和其他的代码组合起来)完成以后，我们可以使用 dispatch_group_notify 来运行一个 block 。\n很明显，我们可以给 NSURLConnection 做同样的事情：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 + (void)withGroup:(dispatch_group_t)group sendAsynchronousRequest:(NSURLRequest *)request queue:(NSOperationQueue *)queue completionHandler:(void (^)(NSURLResponse*, NSData*, NSError*))handler { if (group == NULL) { [self sendAsynchronousRequest:request queue:queue completionHandler:handler]; } else { dispatch_group_enter(group); [self sendAsynchronousRequest:request queue:queue completionHandler:^(NSURLResponse *response, NSData *data, NSError *error){ handler(response, data, error); dispatch_group_leave(group); }]; } } 为了能正常工作，你需要确保:\ndispatch_group_enter() 必须要在 dispatch_group_leave()之前运行。 dispatch_group_enter() 和 dispatch_group_leave() 一直是成对出现的（就算有错误产生时）。 事件源 GCD 有一个较少人知道的特性：事件源 dispatch_source_t。\n跟 GCD 一样，它也是很底层的东西。当你需要用到它时，它会变得极其有用。它的一些使用是秘传招数，我们将会接触到一部分的使用。但是大部分事件源在 iOS 平台不是很有用，因为在 iOS 平台有诸多限制，你无法启动进程（因此就没有必要监视进程），也不能在你的 app bundle 之外写数据（因此也就没有必要去监视文件）等等。\nGCD 事件源是以极其资源高效的方式实现的。\n监视进程 如果一些进程正在运行而你想知道他们什么时候存在，GCD 能够做到这些。你也可以使用 GCD 来检测进程什么时候分叉，也就是产生子进程或者传送给了进程的一个信号（比如 SIGTERM）。\n1 2 3 4 5 6 7 8 9 10 11 12 NSRunningApplication *mail = [NSRunningApplication runningApplicationsWithBundleIdentifier:@\u0026#34;com.apple.mail\u0026#34;]; if (mail == nil) { return; } pid_t const pid = mail.processIdentifier; self.source = dispatch_source_create(DISPATCH_SOURCE_TYPE_PROC, pid, DISPATCH_PROC_EXIT, DISPATCH_TARGET_QUEUE_DEFAULT); dispatch_source_set_event_handler(self.source, ^(){ NSLog(@\u0026#34;Mail quit.\u0026#34;); }); dispatch_resume(self.source); 当 Mail.app 退出的时候，这个程序会打印出 Mail quit.。\n注意：在所有的事件源被传递到你的事件处理器之前，必须调用 dispatch_resume()。\n监视文件 这种可能性是无穷的。你能直接监视一个文件的改变，并且当改变发生时事件源的事件处理将会被调用。\n你也可以使用它来监视文件夹，比如创建一个 watch folder：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 NSURL *directoryURL; // assume this is set to a directory int const fd = open([[directoryURL path] fileSystemRepresentation], O_EVTONLY); if (fd \u0026lt; 0) { char buffer[80]; strerror_r(errno, buffer, sizeof(buffer)); NSLog(@\u0026#34;Unable to open \\\u0026#34;%@\\\u0026#34;: %s (%d)\u0026#34;, [directoryURL path], buffer, errno); return; } dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_VNODE, fd, DISPATCH_VNODE_WRITE | DISPATCH_VNODE_DELETE, DISPATCH_TARGET_QUEUE_DEFAULT); dispatch_source_set_event_handler(source, ^(){ unsigned long const data = dispatch_source_get_data(source); if (data \u0026amp; DISPATCH_VNODE_WRITE) { NSLog(@\u0026#34;The directory changed.\u0026#34;); } if (data \u0026amp; DISPATCH_VNODE_DELETE) { NSLog(@\u0026#34;The directory has been deleted.\u0026#34;); } }); dispatch_source_set_cancel_handler(source, ^(){ close(fd); }); self.source = source; dispatch_resume(self.source); 你应该总是添加 DISPATCH_VNODE_DELETE 去检测文件或者文件夹是否已经被删除——然后就停止监听。\n定时器 大多数情况下，对于定时事件你会选择 NSTimer。定时器的GCD版本是底层的，它会给你更多控制权——但要小心使用。\n需要特别重点指出的是，为了让 OS 节省电量，需要为 GCD 的定时器接口指定一个低的余地值(译注：原文leeway value)。如果你不必要的指定了一个低余地值，将会浪费更多的电量。\n这里我们设定了一个5秒的定时器，并允许有十分之一秒的余地值：\n1 2 3 4 5 6 7 8 9 10 dispatch_source_t source = dispatch_source_create(DISPATCH_SOURCE_TYPE_TIMER, 0, 0, DISPATCH_TARGET_QUEUE_DEFAULT); dispatch_source_set_event_handler(source, ^(){ NSLog(@\u0026#34;Time flies.\u0026#34;); }); dispatch_time_t start dispatch_source_set_timer(source, DISPATCH_TIME_NOW, 5ull * NSEC_PER_SEC, 100ull * NSEC_PER_MSEC); self.source = source; dispatch_resume(self.source); 取消 所有的事件源都允许你添加一个 cancel handler 。这对清理你为事件源创建的任何资源都是很有帮助的，比如关闭文件描述符。GCD 保证在 cancel handle 调用前，所有的事件处理都已经完成调用。\n参考上面的监视文件例子中对 dispatch_source_set_cancel_handler() 的使用。\n输入输出 写出能够在繁重的 I/O 处理情况下运行良好的代码是一件非常棘手的事情。GCD 有一些能够帮上忙的地方。不会涉及太多的细节，我们只简单的分析下问题是什么，GCD 是怎么处理的。\n习惯上，当你从一个网络套接字中读取数据时，你要么做一个阻塞的读操作，也就是让你个线程一直等待直到数据变得可用，或者是做反复的轮询。这两种方法都是很浪费资源并且无法度量。然而，kqueue 通过当数据变得可用时传递一个事件解决了轮询的问题，GCD 也采用了同样的方法，但是更加优雅。当向套接字写数据时，同样的问题也存在，这时你要么做阻塞的写操作，要么等待套接字直到能够接收数据。\n在处理 I/O 时，还有一个问题就是数据是以数据块的形式到达的。当从网络中读取数据时，依据 MTU([]最大传输单元](https://en.wikipedia.org/wiki/Maximum_transmission_unit))，数据块典型的大小是在1.5K字节左右。这使得数据块内可以是任何内容。一旦数据到达，你通常只是对跨多个数据块的内容感兴趣。而且通常你会在一个大的缓冲区里将数据组合起来然后再进行处理。假设（人为例子）你收到了这样8个数据块：\n0: HTTP/1.1 200 OK\\r\\nDate: Mon, 23 May 2005 22:38 1: :34 GMT\\r\\nServer: Apache/1.3.3.7 (Unix) (Red-H 2: at/Linux)\\r\\nLast-Modified: Wed, 08 Jan 2003 23 3: :11:55 GMT\\r\\nEtag: \u0026ldquo;3f80f-1b6-3e1cb03b\u0026rdquo;\\r\\nCon 4: tent-Type: text/html; charset=UTF-8\\r\\nContent- 5: Length: 131\\r\\nConnection: close\\r\\n\\r\\n\\r 6: \\n\\r\\n An Example Page\\r\\n 7: \\r\\n\\r\\n Hello World, this is a ve\n如果你是在寻找 HTTP 的头部，将所有数据块组合成一个大的缓冲区并且从中查找 \\r\\n\\r\\n 是非常简单的。但是这样做，你会大量地复制这些数据。大量 旧的 C 语言 API 存在的另一个问题就是，缓冲区没有所有权的概念，所以函数不得不将数据再次拷贝到自己的缓冲区中——又一次的拷贝。拷贝数据操作看起来是无关紧要的，但是当你正在做大量的 I/O 操作的时候，你会在 profiling tool(Instruments) 中看到这些拷贝操作大量出现。即使你仅仅每个内存区域拷贝一次，你还是使用了两倍的存储带宽并且占用了两倍的内存缓存。\nGCD 和缓冲区 最直接了当的方法是使用数据缓冲区。GCD 有一个 dispatch_data_t 类型，在某种程度上和 Objective-C 的 NSData 类型很相似。但是它能做别的事情，而且更通用。\n注意，dispatch_data_t 可以被 retained 和 releaseed ，并且 dispatch_data_t 拥有它持有的对象。\n这看起来无关紧要，但是我们必须记住 GCD 只是纯 C 的 API，并且不能使用Objective-C。通常的做法是创建一个缓冲区，这个缓冲区要么是基于栈的，要么是 malloc 操作分配的内存区域 —— 这些都没有所有权。\ndispatch_data_t 的一个相当独特的属性是它可以基于零碎的内存区域。这解决了我们刚提到的组合内存的问题。当你要将两个数据对象连接起来时：\n1 2 3 dispatch_data_t a; // Assume this hold some valid data dispatch_data_t b; // Assume this hold some valid data dispatch_data_t c = dispatch_data_create_concat(a, b); 数据对象 c 并不会将 a 和 b 拷贝到一个单独的，更大的内存区域里去。相反，它只是简单地 retain 了 a 和 b。你可以使用 dispatch_data_apply 来遍历对象 c 持有的内存区域：\n1 2 3 4 dispatch_data_apply(c, ^bool(dispatch_data_t region, size_t offset, const void *buffer, size_t size) { fprintf(stderr, \u0026#34;region with offset %zu, size %zu\\n\u0026#34;, offset, size); return true; }); 类似的，你可以使用 dispatch_data_create_subrange 来创建一个不做任何拷贝操作的子区域。\n读和写 在 GCD 的核心里，调度 I/O（译注：原文为 Dispatch I/O） 与所谓的通道有关。调度 I/O 通道提供了一种与从文件描述符中读写不同的方式。创建这样一个通道最基本的方式就是调用：\n1 2 dispatch_io_t dispatch_io_create(dispatch_io_type_t type, dispatch_fd_t fd, dispatch_queue_t queue, void (^cleanup_handler)(int error)); 这将返回一个持有文件描述符的创建好的通道。在你通过它创建了通道之后，你不准以任何方式修改这个文件描述符。\n有两种从根本上不同类型的通道：流和随机存取。如果你打开了硬盘上的一个文件，你可以使用它来创建一个随机存取的通道（因为这样的文件描述符是可寻址的）。如果你打开了一个套接字，你可以创建一个流通道。\n如果你想要为一个文件创建一个通道，你最好使用需要一个路径参数的 dispatch_io_create_with_path ，并且让 GCD 来打开这个文件。这是有益的，因为GCD会延迟打开这个文件以限制相同时间内同时打开的文件数量。\n类似通常的 read(2)，write(2) 和 close(2) 的操作，GCD 提供了 dispatch_io_read，dispatch_io_write 和 dispatch_io_close。无论何时数据读完或者写完，读写操作调用一个回调 block 来结束。这些都是以非阻塞，异步 I/O 的形式高效实现的。\n在这你得不到所有的细节，但是这里会提供一个创建TCP服务端的例子：\n首先我们创建一个监听套接字，并且设置一个接受连接的事件源：\n_isolation = dispatch_queue_create([[self description] UTF8String], 0); _nativeSocket = socket(PF_INET6, SOCK_STREAM, IPPROTO_TCP); struct sockaddr_in sin = {}; sin.sin_len = sizeof(sin); sin.sin_family = AF_INET6; sin.sin_port = htons(port); sin.sin_addr.s_addr= INADDR_ANY; int err = bind(result.nativeSocket, (struct sockaddr *) \u0026amp;sin, sizeof(sin)); NSCAssert(0 \u0026lt;= err, @\u0026quot;\u0026quot;);\n_eventSource = dispatch_source_create(DISPATCH_SOURCE_TYPE_READ, _nativeSocket, 0, _isolation); dispatch_source_set_event_handler(result.eventSource, ^{ acceptConnection(_nativeSocket); });\n当接受了连接，我们创建一个I/O通道：\ntypedef union socketAddress { struct sockaddr sa; struct sockaddr_in sin; struct sockaddr_in6 sin6; } socketAddressUnion;\nsocketAddressUnion rsa; // remote socket address socklen_t len = sizeof(rsa); int native = accept(nativeSocket, \u0026amp;rsa.sa, \u0026amp;len); if (native == -1) { // Error. Ignore. return nil; }\n_remoteAddress = rsa; _isolation = dispatch_queue_create([[self description] UTF8String], 0); _channel = dispatch_io_create(DISPATCH_IO_STREAM, native, _isolation, ^(int error) { NSLog(@\u0026ldquo;An error occured while listening on socket: %d\u0026rdquo;, error); });\n//dispatch_io_set_high_water(_channel, 8 * 1024); dispatch_io_set_low_water(_channel, 1); dispatch_io_set_interval(_channel, NSEC_PER_MSEC * 10, DISPATCH_IO_STRICT_INTERVAL);\nsocketAddressUnion lsa; // remote socket address socklen_t len = sizeof(rsa); getsockname(native, \u0026amp;lsa.sa, \u0026amp;len); _localAddress = lsa;\n如果我们想要设置 SO_KEEPALIVE（如果使用了HTTP的keep-alive），我们需要在调用 dispatch_io_create 前这么做。\n创建好 I/O 通道后，我们可以设置读取处理程序：\ndispatch_io_read(_channel, 0, SIZE_MAX, _isolation, ^(bool done, dispatch_data_t data, int error){ if (data != NULL) { if (_data == NULL) { _data = data; } else { _data = dispatch_data_create_concat(_data, data); } [self processData]; } });\n如果所有你想做的只是读取或者写入一个文件，GCD 提供了两个方便的封装： dispatch_read 和 dispatch_write 。你需要传递给 dispatch_read 一个文件路径和一个在所有数据块读取后调用的 block。类似的，dispatch_write 需要一个文件路径和一个被写入的 dispatch_data_t 对象。\n基准测试 在 GCD 的一个不起眼的角落，你会发现一个适合优化代码的灵巧小工具：\nuint64_t dispatch_benchmark(size_t count, void (^block)(void));\n把这个声明放到你的代码中，你就能够测量给定的代码执行的平均的纳秒数。例子如下：\nsize_t const objectCount = 1000; uint64_t n = dispatch_benchmark(10000, ^{ @autoreleasepool { id obj = @42; NSMutableArray *array = [NSMutableArray array]; for (size_t i = 0; i \u0026lt; objectCount; ++i) { [array addObject:obj]; } } }); NSLog(@\u0026quot;-[NSMutableArray addObject:] : %llu ns\u0026quot;, n);\n在我的机器上输出了：\n-[NSMutableArray addObject:] : 31803 ns\n也就是说添加1000个对象到 NSMutableArray 总共消耗了31803纳秒，或者说平均一个对象消耗32纳秒。\n正如 dispatch_benchmark 的帮助页面指出的，测量性能并非如看起来那样不重要。尤其是当比较并发代码和非并发代码时，你需要注意特定硬件上运行的特定计算带宽和内存带宽。不同的机器会很不一样。如果代码的性能与访问临界区有关，那么我们上面提到的锁竞争问题就会有所影响。\n不要把它放到发布代码中，事实上，这是无意义的，它是私有API。它只是在调试和性能分析上起作用。\n访问帮助界面：\ncurl \u0026ldquo;http://opensource.apple.com/source/libdispatch/libdispatch-84.5/man/dispatch_benchmark.3?txt\u0026quot; | /usr/bin/groffer \u0026ndash;tty -T utf8\n原子操作 头文件 libkern/OSAtomic.h 里有许多强大的函数，专门用来底层多线程编程。尽管它是内核头文件的一部分，它也能够在内核之外来帮助编程。\n这些函数都是很底层的，并且你需要知道一些额外的事情。就算你已经这样做了，你还可能会发现一两件你不能做，或者不易做的事情。当你正在为编写高性能代码或者正在实现无锁的和无等待的算法工作时，这些函数会吸引你。\n这些函数在 atomic(3) 的帮助页里全部有概述——运行 man 3 atomic 命令以得到完整的文档。你会发现里面讨论到了内存屏障。查看维基百科中关于内存屏障的文章。如果你还存在疑问，那么你很可能需要它。\n计数器 OSAtomicIncrement 和 OSAtomicDecrement 有一个很长的函数列表允许你以原子操作的方式去增加和减少一个整数值 —— 不必使用锁（或者队列）同时也是线程安全的。如果你需要让一个全局的计数器值增加，而这个计数器为了统计目的而由多个线程操作，使用原子操作是很有帮助的。如果你要做的仅仅是增加一个全局计数器，那么无屏障版本的 OSAtomicIncrement 是很合适的，并且当没有锁竞争时，调用它们的代价很小。\n类似的，OSAtomicOr ，OSAtomicAnd，OSAtomicXor 的函数能用来进行逻辑运算，而 OSAtomicTest 可以用来设置和清除位。\n10.2、比较和交换 OSAtomicCompareAndSwap 能用来做无锁的惰性初始化，如下：\nvoid * sharedBuffer(void) { static void * buffer; if (buffer == NULL) { void * newBuffer = calloc(1, 1024); if (!OSAtomicCompareAndSwapPtrBarrier(NULL, newBuffer, \u0026amp;buffer)) { free(newBuffer); } } return buffer; }\n如果没有 buffer，我们会创建一个，然后原子地将其写到 buffer 中如果 buffer 为NULL。在极少的情况下，其他人在当前线程同时设置了 buffer ，我们简单地将其释放掉。因为比较和交换方法是原子的，所以它是一个线程安全的方式去惰性初始化值。NULL的检测和设置 buffer 都是以原子方式完成的。\n明显的，使用 dispatch_once() 我们也可以完成类似的事情。\n原子队列 OSAtomicEnqueue() 和 OSAtomicDequeue() 可以让你以线程安全，无锁的方式实现一个LIFO队列(常见的就是栈)。对有潜在精确要求的代码来说，这会是强大的代码。\n还有 OSAtomicFifoEnqueue() 和 OSAtomicFifoDequeue() 函数是为了操作FIFO队列，但这些只有在头文件中才有文档 —— 阅读他们的时候要小心。\n自旋锁 最后，OSAtomic.h 头文件定义了使用自旋锁的函数：OSSpinLock。同样的，维基百科有深入的有关自旋锁的信息。使用命令 man 3 spinlock 查看帮助页的 spinlock(3) 。当没有锁竞争时使用自旋锁代价很小。\n在合适的情况下，使用自旋锁对性能优化是很有帮助的。一如既往：先测量，然后优化。不要做乐观的优化。\n下面是 OSSpinLock 的一个例子：\n@interface MyTableViewCell : UITableViewCell\n@property (readonly, nonatomic, copy) NSDictionary *amountAttributes;\n@end\n@implementation MyTableViewCell { NSDictionary *_amountAttributes; }\n(NSDictionary *)amountAttributes; { if (_amountAttributes == nil) { static __weak NSDictionary *cachedAttributes = nil; static OSSpinLock lock = OS_SPINLOCK_INIT; OSSpinLockLock(\u0026amp;lock); _amountAttributes = cachedAttributes; if (_amountAttributes == nil) { NSMutableDictionary *attributes = [[self subtitleAttributes] mutableCopy]; attributes[NSFontAttributeName] = [UIFont fontWithName:@\u0026ldquo;ComicSans\u0026rdquo; size:36]; attributes[NSParagraphStyleAttributeName] = [NSParagraphStyle defaultParagraphStyle]; _amountAttributes = [attributes copy]; cachedAttributes = _amountAttributes; } OSSpinLockUnlock(\u0026amp;lock); } return _amountAttributes; } 就上面的例子而言，或许用不着这么麻烦，但它演示了一种理念。我们使用了ARC的 __weak 来确保一旦 MyTableViewCell 所有的实例都不存在， amountAttributes 会调用 dealloc 。因此在所有的实例中，我们可以持有字典的一个单独实例。\n这段代码运行良好的原因是我们不太可能访问到方法最里面的部分。这是很深奥的——除非你真正需要，不然不要在你的 App 中使用它。\n话题 #2 下的更多文章\n原文 Low-Level Concurrency APIs\n译文 Objc的底层并发API - webfrogs\n","date":"2017-09-24T18:21:38Z","permalink":"https://it-boyer.github.io/post/old/iOS/GCD%E5%BA%95%E5%B1%82%E5%B9%B6%E5%8F%91API/","section":"post","tags":["线程","API"],"title":"GCD底层并发API"},{"categories":["学习笔记"],"contents":"概览 本文主要探讨一些常用后台任务的最佳实践：\n如何做异步网络请求 如何异步处理大型文件，以保持较低的内存占用 操作队列 (Operation Queues) 还是 GCD ? 操作队列提供了在 GCD 中不那么容易复制的有用特性。其中最重要的一个就是可以取消在任务处理队列中的任务，而且操作队列在管理操作间的依赖关系方面也容易一些。 GCD 给予你更多的控制权力以及操作队列中所不能使用的底层函数。详细介绍可以参考底层并发 API 这篇文章。\n后台 UI 代码 首先要强调：UIKit 只能在主线程上运行。而那部分不与 UIKit 直接相关，却会消耗大量时间的 UI 代码可以被移动到后台去处理，以避免其将主线程阻塞太久。\n后台获取UI数据 例如使用操作队列隔离以下昂贵操作：\n1 2 3 4 5 6 7 8 __weak id weakSelf = self; [self.operationQueue addOperationWithBlock:^{ NSNumber* result = findLargestMersennePrime(); [[NSOperationQueue mainQueue] addOperationWithBlock:^{ MyClass* strongSelf = weakSelf; strongSelf.textLabel.text = [result stringValue]; }]; }]; 如你所见，这些代码其实一点也不直接明了。我们首先声明了一个 weak 引用来参照 self，否则会形成循环引用（ block 持有了 self，私有的 operationQueue retain 了 block，而 self 又 retain 了 operationQueue ）。为了避免在运行 block 时访问到已被释放的对象，在 block 中我们又需要将其转回 strong 引用。\n这在 ARC 和 block 主导的编程范式中是解决 retain cycle 的一种常见也是最标准的方法。\n后台绘制UI 如果你确定 drawRect: 是你的应用的性能瓶颈，那么你可以将这些绘制代码放到后台去做。但是在你这样做之前，检查下看看是不是有其他方法来解决，比如、考虑使用 core animation layers 或者预先渲染图片而不去做 Core Graphics 绘制。\n如果你确实认为在后台执行绘制代码会是你的最好选择时再这么做。其实解决起来也很简单，把 drawRect: 中的代码放到一个后台操作中去做就可以了。然后将原本打算绘制的视图用一个 image view 来替换，等到操作执行完后再去更新。在绘制的方法中，使用 UIGraphicsBeginImageContextWithOptions 来取代 UIGraphicsGetCurrentContext ：\n1 2 3 4 5 UIGraphicsBeginImageContextWithOptions(size, NO, 0); // drawing code here UIImage *i = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return i; 通过在第三个参数中传入 0 ，设备的主屏幕的 scale 将被自动传入，这将使图片在普通设备和 retina 屏幕上都有良好的表现。\ncell在操作队列中异步绘制 如果你在 table view 或者是 collection view 的 cell 上做了自定义绘制的话，最好将它们放入 operation 的子类中去。你可以将它们添加到后台操作队列，也可以在用户将 cell 滚动出边界时的 didEndDisplayingCell 委托方法中进行取消。这些技巧都在 2012 年的WWDC Session 211 \u0026ndash; Building Concurrent User Interfaces on iOS中有详细阐述。\n其他方案 除了在后台自己调度绘制代码，以也可以试试看使用 CALayer 的 drawsAsynchronously 属性。然而你需要精心衡量这样做的效果，因为有时候它能使绘制加速，有时候却适得其反。\n异步网络请求处理 你的所有网络请求都应该采取异步的方式完成。\n然而，在 GCD 下，有时候你可能会看到这样的代码\n1 2 3 4 5 6 7 // 警告：不要使用这些代码。 dispatch_async(backgroundQueue, ^{ NSData* contents = [NSData dataWithContentsOfURL:url] dispatch_async(dispatch_get_main_queue(), ^{ // 处理取到的日期 }); }); 乍看起来没什么问题，但是这段代码却有致命缺陷。你没有办法去取消这个同步的网络请求。它将阻塞主线程直到它完成。如果请求一直没结果，那就只能干等到超时（比如 dataWithContentsOfURL: 的超时时间是 30 秒）。\n分析状况 当队列是串行执行时，它将一直被阻塞住。 当队列是并行执行时，GCD 需要重开一个线程来补凑你阻塞住的线程。 两种结果都不太妙，所以最好还是不要阻塞线程。\n方案一 要解决上面的困境，我们可以使用 NSURLConnection 的异步方法，并且把所有操作转化为 operation 来执行。通过这种方法，我们可以从操作队列的强大功能和便利中获益良多：我们能轻易地控制并发操作的数量，添加依赖，以及取消操作。 例如：在NSOperation子类DownloadOperation中重写start方法，并实现NSURLConnectionDelegate代理方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 @interface DownloadOperation : NSOperation\u0026lt;NSURLConnectionDelegate\u0026gt; - (void)start { NSURLRequest* request = [NSURLRequest requestWithURL:self.url]; self.isExecuting = YES; self.isConcurrent = YES; self.isFinished = NO; [[NSOperationQueue mainQueue] addOperationWithBlock:^ { self.connection = [NSURLConnection connectionWithRequest:request delegate:self]; }]; } 然而，在这里还有一些事情值得注意： NSURLConnection 是通过 run loop 来发送事件的。因为发送事件不会花多少时间，因此最简单的是就只使用 main run loop 来做这个。然后，我们就可以用后台线程来处理输入的数据了。\n方案二 另一种可能的方式是使用像 AFNetworking 这样的框架：建立一个独立的线程，为建立的线程设置自己的 run loop，然后在其中调度 URL 连接。但是并不推荐你自己去实现这些事情。\n要处理URL 连接，我们重写自定义的 operation 子类中的 start 方法：\n1 2 3 4 5 6 7 8 9 10 11 - (void)start { NSURLRequest* request = [NSURLRequest requestWithURL:self.url]; self.isExecuting = YES; self.isFinished = NO; [[NSOperationQueue mainQueue] addOperationWithBlock:^ { self.connection = [NSURLConnectionconnectionWithRequest:request delegate:self]; }]; } 由于重写的是 start 方法，所以我们需要自己要管理操作的 isExecuting 和 isFinished 状态。要取消一个操作，我们需要取消 connection ，并且设定合适的标记，这样操作队列才知道操作已经完成。\n1 2 3 4 5 6 7 - (void)cancel { [super cancel]; [self.connection cancel]; self.isFinished = YES; self.isExecuting = NO; } 当连接完成加载后，它向代理发送回调：\n1 2 3 4 5 6 7 - (void)connectionDidFinishLoading:(NSURLConnection *)connection { self.data = self.buffer; self.buffer = nil; self.isExecuting = NO; self.isFinished = YES; } 就这么多了。完整的代码可以参见GitHub上的示例工程。\n总结来说，我们建议要么你花时间来把事情做对做好，要么就直接使用像 AFNetworking 这样的框架。其实 AFNetworking 还提供了不少好用的小工具，比如有个 UIImageView 的 category，来负责异步地从一个 URL 加载图片。在你的 table view 里使用的话，还能自动帮你处理取消加载操作，非常方便。\n扩展阅读：\nConcurrency Programming Guide NSOperation Class Reference: Concurrent vs. Non-Concurrent Operations Blog: synchronous vs. asynchronous NSURLConnection GitHub: SDWebImageDownloaderOperation.m Blog: Progressive image download with ImageIO WWDC 2012 Session 211: Building Concurrent User Interfaces on iOS 进阶：后台文件 I/O 构建一个类，负责一行一行读取文件而不是一次将整个文件读入内存，另外要在后台队列处理文件，以保持应用相应用户的操作。 为了达到这个目的，我们使用能让我们异步处理文件的 NSInputStream 。根据官方文档的描述：\n如果你总是需要从头到尾来读/写文件的话，streams 提供了一个简单的接口来异步完成这个操作\n不管你是否使用 streams，大体上逐行读取一个文件的模式是这样的：\n建立一个中间缓冲层以提供，当没有找到换行符号的时候可以向其中添加数据 从 stream 中读取一块数据 对于这块数据中发现的每一个换行符，取中间缓冲层，向其中添加数据，直到（并包括）这个换行符，并将其输出 将剩余的字节添加到中间缓冲层去 回到 2，直到 stream 关闭 为了将其运用到实践中，我们又建立了一个示例应用，里面有一个 Reader 类完成了这件事情，它的接口十分简单\n1 2 3 4 @interface Reader : NSObject - (void)enumerateLines:(void (^)(NSString*))block completion:(void (^)())completion; - (id)initWithFileAtPath:(NSString*)path; @end runloop分发NSInputStream事件 注意，这个类不是 NSOperation 的子类。与 URL connections 类似，输入的 streams 通过 run loop 来传递它的事件。这里，我们仍然采用 main run loop 来分发事件，然后将数据处理过程派发至后台操作线程里去处理。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 - (void)enumerateLines:(void (^)(NSString*))block completion:(void (^)())completion { if (self.queue == nil) { self.queue = [[NSOperationQueue alloc] init]; self.queue.maxConcurrentOperationCount = 1; //串行队列 } self.callback = block; self.completion = completion; self.inputStream = [NSInputStream inputStreamWithURL:self.fileURL]; self.inputStream.delegate = self; //分发NSInputStream事件 [self.inputStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode]; [self.inputStream open]; } 调用时的代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 - (void)import:(id)sender { NSURL *fileURL = [[NSBundle mainBundle] URLForResource:@\u0026#34;Clarissa Harlowe\u0026#34; withExtension:@\u0026#34;txt\u0026#34;]; NSAssert([[NSFileManager defaultManager] fileExistsAtPath:[fileURL path]], @\u0026#34;Please download the sample data\u0026#34;); self.reader = [[Reader alloc] initWithFileAtURL:fileURL]; [self.reader enumerateLinesWithBlock:^(NSUInteger i, NSString *line){ if ((i % 2000ull) == 0) { NSLog(@\u0026#34;i: %d\u0026#34;, i); [[NSOperationQueue mainQueue] addOperationWithBlock:^{ [self.button setTitle:line forState:UIControlStateNormal]; }]; } } completionHandler:^(NSUInteger numberOfLines){ NSLog(@\u0026#34;lines: %d\u0026#34;, numberOfLines); [self.button setTitle:@\u0026#34;Done\u0026#34; forState:UIControlStateNormal]; }]; } NSInputStream代理方法 现在，input stream 将（在主线程）向我们发送代理消息，然后我们可以在操作队列中加入一个 block 操作来执行处理了：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 - (void)stream:(NSStream*)stream handleEvent:(NSStreamEvent)eventCode { switch (eventCode) { ... case NSStreamEventHasBytesAvailable: { NSMutableData *buffer = [NSMutableData dataWithLength:4 * 1024]; NSUInteger length = [self.inputStream read:[buffer mutableBytes] maxLength:[buffer length]]; if (0 \u0026lt; length) { [buffer setLength:length]; __weak id weakSelf = self; [self.queue addOperationWithBlock:^{ //在后台串行队列的线程池中逐行处理缓冲区 [weakSelf processDataChunk:buffer]; }]; } break; } ... } } 缓冲区处理 处理数据块的过程是先查看当前已缓冲的数据，并将新加入的数据附加上去。接下来它将按照换行符分解成小的部分，并逐行处理。 数据处理过程中会不断的从buffer中获取已读入的数据。然后把这些新读入的数据按行分开并存储。剩余的数据被再次存储到缓冲区中：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 - (void)processDataChunk:(NSMutableData *)buffer { if (self.remainder != nil) { [self.remainder appendData:buffer]; } else { self.remainder = buffer; } [self.remainder obj_enumerateComponentsSeparatedBy:self.delimiter usingBlock:^(NSData* component, BOOL last) { if (!last) { [self emitLineWithData:component]; } else if (0 \u0026lt; [component length]) { self.remainder = [component mutableCopy]; } else { self.remainder = nil; } }]; } - (void)emitLineWithData:(NSData *)data; { NSUInteger lineNumber = self.lineNumber; self.lineNumber = lineNumber + 1; if (0 \u0026lt; data.length) { NSString *line = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding]; self.callback(lineNumber, line); } } 现在你运行示例应用的话，会发现它在响应事件时非常迅速，内存的开销也保持很低（在我们测试时，不论读入的文件有多大，堆所占用的内存量始终低于 800KB）。绝大部分时候，使用逐块读入的方式来处理大文件，是非常有用的技术。\n延伸阅读：\nFile System Programming Guide: Techniques for Reading and Writing Files Without File Coordinators StackOverflow: How to read data from NSFileHandle line by line? 总结 通过我们所列举的几个示例，我们展示了如何异步地在后台执行一些常见任务。在所有的解决方案中，我们尽力保持了代码的简单，这是因为在并发编程中，稍不留神就会捅出篓子来。\n很多时候为了避免麻烦，你可能更愿意在主线程中完成你的工作，在你能这么做事，这确实让你的工作轻松不少，但是当你发现性能瓶颈时，你可以尝试尽可能用最简单的策略将那些繁重任务放到后台去做。\n我们在上面例子中所展示的方法对于其他任务来说也是安全的选择。在主队列中接收事件或者数据，然后用后台操作队列来执行实际操作，然后回到主队列去传递结果，遵循这样的原则来编写尽量简单的并行代码，将是保证高效正确的不二法则。\n话题 #2 下的更多文章\n原文 Common Background Practices\n译文 常见的后台实践\n","date":"2017-09-24T11:03:35Z","permalink":"https://it-boyer.github.io/post/old/iOS/%E5%B8%B8%E8%A7%81%E7%9A%84%E5%90%8E%E5%8F%B0%E5%AE%9E%E7%8E%B0/","section":"post","tags":["iOS"],"title":"常见的后台实现"},{"categories":["学习笔记"],"contents":"并发所描述的概念就是同时运行多个任务。这些任务可能是以在单核 CPU 上分时（时间共享）的形式同时运行，也可能是在多核 CPU 上以真正的并行方式来运行。\nOS X 和 iOS 提供了几种不同的 API 来支持并发编程。每一个 API 都具有不同的功能和使用限制，这使它们适合不同的任务。同时，这些 API 处在不同的抽象层级上。我们有可能用其进行非常深入底层的操作，但是这也意味着背负起将任务进行良好处理的巨大责任。\n实际上，并发编程是一个很有挑战的主题，它有许多错综复杂的问题和陷阱。当开发者在使用类似 Grand Central Dispatch（GCD）或 NSOperationQueue 的 API 时，很容易遗忘这些问题和陷阱。本文首先对 OS X 和 iOS 中不同的并发编程 API 进行一些介绍，然后再深入了解并发编程中独立于与你所使用的特定 API 的一些内在挑战。\nOS X 和 iOS 中的并发编程 OS X 和 iOS 提供了相同的并发编程API。 本文会介绍 pthread 、 NSThread 、GCD 、NSOperationQueue，以及 NSRunLoop（并非并发）。\n由于高层 API 是基于底层 API 构建的，所以我们首先将从底层的 API 开始介绍，然后逐步扩展到高层 API。不过在具体编程中，选择 API 的顺序刚好相反：因为大多数情况下，选择高层的 API 不仅可以完成底层 API 能完成的任务，而且能够让并发模型变得简单。\n如果你对我们为何坚持推荐使用高抽象层级以及简单的并行代码有所疑问的话，那么你可以看看这篇文章的第二部分并发编程中面临的挑战，以及 Peter Steinberger 写的关于线程安全的文章。\n线程 线程（thread）是组成进程的子单元，操作系统的调度器可以对线程进行单独的调度。实际上，所有的并发编程 API 都是构建于线程之上的 —— 包括 GCD 和操作队列（operation queues）。\n多线程可以在单核 CPU 上同时（或者至少看作同时）运行。操作系统将小的时间片分配给每一个线程，这样就能够让用户感觉到有多个任务在同时进行。如果 CPU 是多核的，那么线程就可以真正的以并发方式被执行，从而减少了完成某项操作所需要的总时间。\n你可以使用 Instruments 中的 CPU strategy view 来得知你的代码或者你在使用的框架代码是如何在多核 CPU 中调度执行的。\n需要重点关注的是，你无法控制你的代码在什么地方以及什么时候被调度，以及无法控制执行多长时间后将被暂停，以便轮换执行别的任务。这种线程调度是非常强大的一种技术，但是也非常复杂，我们稍后研究。\n先把线程调度的复杂情况放一边，开发者可以使用 POSIX 线程 API，或者 Objective-C 中提供的对该 API 的封装 NSThread，来创建自己的线程。\n线程实例 在一百万个数字中查找最小值和最大值。\npthread 方式实现 下面这个小示例利用 pthread 来在一百万个数字中查找最小值和最大值。其中并发执行了 4 个线程。从该示例复杂的代码中，应该可以看出为什么你不会希望直接使用 pthread 。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 #import \u0026lt;pthread.h\u0026gt; struct threadInfo { uint32_t * inputValues; size_t count; }; struct threadResult { uint32_t min; uint32_t max; }; void * findMinAndMax(void *arg) { struct threadInfo const * const info = (struct threadInfo *) arg; uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i \u0026lt; info-\u0026gt;count; ++i) { uint32_t v = info-\u0026gt;inputValues[i]; min = MIN(min, v); max = MAX(max, v); } free(arg); struct threadResult * const result = (struct threadResult *) malloc(sizeof(*result)); result-\u0026gt;min = min; result-\u0026gt;max = max; return result; } int main(int argc, const char * argv[]) { size_t const count = 1000000; uint32_t inputValues[count]; // 使用随机数字填充 inputValues for (size_t i = 0; i \u0026lt; count; ++i) { inputValues[i] = arc4random(); } // 开始4个寻找最小值和最大值的线程 size_t const threadCount = 4; pthread_t tid[threadCount]; for (size_t i = 0; i \u0026lt; threadCount; ++i) { struct threadInfo * const info = (struct threadInfo *) malloc(sizeof(*info)); size_t offset = (count / threadCount) * i; info-\u0026gt;inputValues = inputValues + offset; info-\u0026gt;count = MIN(count - offset, count / threadCount); int err = pthread_create(tid + i, NULL, \u0026amp;findMinAndMax, info); NSCAssert(err == 0, @\u0026#34;pthread_create() failed: %d\u0026#34;, err); } // 等待线程退出 struct threadResult * results[threadCount]; for (size_t i = 0; i \u0026lt; threadCount; ++i) { int err = pthread_join(tid[i], (void **) \u0026amp;(results[i])); NSCAssert(err == 0, @\u0026#34;pthread_join() failed: %d\u0026#34;, err); } // 寻找 min 和 max uint32_t min = UINT32_MAX; uint32_t max = 0; for (size_t i = 0; i \u0026lt; threadCount; ++i) { min = MIN(min, results[i]-\u0026gt;min); max = MAX(max, results[i]-\u0026gt;max); free(results[i]); results[i] = NULL; } NSLog(@\u0026#34;min = %u\u0026#34;, min); NSLog(@\u0026#34;max = %u\u0026#34;, max); return 0; } NSThread方式实现 NSThread 是 Objective-C 对 pthread 的一个封装。通过封装，在 Cocoa 环境中，可以让代码看起来更加亲切。例如，开发者可以利用 NSThread 的一个子类来定义一个线程，在这个子类的中封装需要在后台线程运行的代码。针对上面的那个例子，我们可以定义一个这样的 NSThread 子类：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 @interface FindMinMaxThread : NSThread @property (nonatomic) NSUInteger min; @property (nonatomic) NSUInteger max; - (instancetype)initWithNumbers:(NSArray *)numbers; @end @implementation FindMinMaxThread { NSArray *_numbers; } - (instancetype)initWithNumbers:(NSArray *)numbers { self = [super init]; if (self) { _numbers = numbers; } return self; } - (void)main { NSUInteger min; NSUInteger max; // 进行相关数据的处理 self.min = min; self.max = max; } @end 要想启动一个新的线程，需要创建一个线程对象，然后调用它的 start 方法：\n1 2 3 4 5 6 7 8 9 10 11 12 NSMutableSet *threads = [NSMutableSet set]; NSUInteger numberCount = self.numbers.count; NSUInteger threadCount = 4; for (NSUInteger i = 0; i \u0026lt; threadCount; i++) { NSUInteger offset = (count / threadCount) * i; NSUInteger count = MIN(numberCount - offset, numberCount / threadCount); NSRange range = NSMakeRange(offset, count); NSArray *subset = [self.numbers subarrayWithRange:range]; FindMinMaxThread *thread = [[FindMinMaxThread alloc] initWithNumbers:subset]; [threads addObject:thread]; [thread start]; } 现在，我们可以通过检测到线程的 isFinished 属性来检测新生成的线程是否已经结束，并获取结果。\n线程问题 直接使用线程可能会引发的一个问题是，如果你的代码和所基于的框架代码都创建自己的线程时，那么活动的线程数量有可能以指数级增长。这在大型工程中是一个常见问题。例如，在 8 核 CPU 中，你创建了 8 个线程来完全发挥 CPU 性能。然而在这些线程中你的代码所调用的框架代码也做了同样事情（因为它并不知道你已经创建的这些线程），这样会很快产生成成百上千的线程。代码的每个部分自身都没有问题，然而最后却还是导致了问题。使用线程并不是没有代价的，每个线程都会消耗一些内存和内核资源。\n接下来，我们将介绍两个基于队列的并发编程 API ：GCD 和 operation queue 。它们通过集中管理一个被大家协同使用的线程池，来解决上面遇到的问题。\nGrand Central Dispatch 为了让开发者更加容易的使用设备上的多核CPU，苹果在 OS X 10.6 和 iOS 4 中引入了 Grand Central Dispatch（GCD）。在下一篇关于底层并发 API 的文章中，我们将更深入地介绍 GCD。\n通过 GCD，开发者不用再直接跟线程打交道了，只需要向队列中添加代码块即可，GCD 在后端管理着一个线程池。GCD 不仅决定着你的代码块将在哪个线程被执行，它还根据可用的系统资源对这些线程进行管理。这样可以将开发者从线程管理的工作中解放出来，通过集中的管理线程，来缓解大量线程被创建的问题。\nGCD 带来的另一个重要改变是，作为开发者可以将工作考虑为一个队列，而不是一堆线程，这种并行的抽象模型更容易掌握和使用。\nGCD 公开有 5 个不同的队列：运行在主线程中的 main queue，3 个不同优先级的后台队列，以及一个优先级更低的后台队列（用于 I/O）。 另外，开发者可以创建自定义队列：串行或者并行队列。自定义队列非常强大，在自定义队列中被调度的所有 block 最终都将被放入到系统的全局队列中和线程池中。\n使用不同优先级的若干个队列乍听起来非常直接，不过，我们强烈建议，在绝大多数情况下使用默认的优先级队列就可以了。如果执行的任务需要访问一些共享的资源，那么在不同优先级的队列中调度这些任务很快就会造成不可预期的行为。这样可能会引起程序的完全挂起，因为低优先级的任务阻塞了高优先级任务，使它不能被执行。更多相关内容，在本文的优先级反转部分中会有介绍。\n虽然 GCD 是一个低层级的 C API ，但是它使用起来非常的直接。不过这也容易使开发者忘记并发编程中的许多注意事项和陷阱。读者可以阅读本文后面的并发编程中面临的挑战，这样可以注意到一些潜在的问题。本期的另外一篇优秀文章：底层并发 API 中，包含了很多深入的解释和一些有价值的提示。\nOperation Queues 操作队列（operation queue）是由 GCD 提供的一个队列模型的 Cocoa 抽象。GCD 提供了更加底层的控制，而操作队列则在 GCD 之上实现了一些方便的功能，这些功能对于 app 的开发者来说通常是最好最安全的选择。\n操作队列成员 主队列：在主线程上运行 自定义队列：在后台子线程上执行 操作任务：NSOperation 的子类，即在前两种队列中所要执行的任务代码 实现操作任务 你可以通过重写 main 或者 start 方法 来定义自己的 operations 。\n重写 main方法 当 main 方法返回的时候，这个 operation 就结束了。无法控制操作状态属性（例如 isExecuting 和 isFinished）。\n1 2 3 4 5 6 @implementation YourOperation - (void)main { // 进行处理 ... } @end 重写 start方法 这种方式可以拥有更多的控制权，以及在一个操作中可以执行异步任务，重写 start 方法必须手动管理操作的状态（例如 isExecuting 和 isFinished）。\n重写实现： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 @implementation YourOperation - (void)start { self.isExecuting = YES; self.isFinished = NO; // 开始处理，在结束时应该调用 finished ... } - (void)finished { self.isExecuting = NO; self.isFinished = YES; } @end 注意：这种情况下，你必须手动管理操作的状态。 为了让操作队列能够捕获到操作的改变，需要将状态的属性以配合 KVO 的方式进行实现。如果你不使用它们默认的 setter 来进行设置的话，你就需要在合适的时候发送合适的 KVO 消息。 取消功能的实现 为了能使用操作队列所提供的取消功能，你需要在长时间操作中时不时地检查 isCancelled 属性： 1 2 3 4 5 6 - (void)main { while (notDone \u0026amp;\u0026amp; !self.isCancelled) { // 进行处理 } } 重写 operation 的description 方法 这样就可以很容易的标示出在某个队列中当前被调度的所有操作 。 操作队列管理 添加操作任务 当你定义好 operation 类之后，就可以很容易的将一个 operation 添加到队列中：\n1 2 3 NSOperationQueue *queue = [[NSOperationQueue alloc] init]; YourOperation *operation = [[YourOperation alloc] init]; [queue addOperation:operation]; 添加一次性任务 另外，你也可以将 block 添加到操作队列中。这有时候会非常的方便，比如你希望在主队列中调度一个一次性任务：\n1 2 3 [[NSOperationQueue mainQueue] addOperationWithBlock:^{ // 代码... }]; 操作队列的任务个数 除了提供基本的调度操作或 block 外，操作队列还提供了在 GCD 中不太容易处理好的特性的功能。例如，你可以通过 maxConcurrentOperationCount 属性来控制一个特定队列中可以有多少个操作参与并发执行。将其设置为 1 的话，你将得到一个串行队列，这在以隔离为目的的时候会很有用。\n操作优先级 另外还有一个方便的功能就是根据队列中 operation 的优先级对其进行排序，这不同于 GCD 的队列优先级，它只影响当前队列中所有被调度的 operation 的执行先后。\n操作依赖 如果你需要进一步在除了 5 个标准的优先级以外对 operation 的执行顺序进行控制的话，还可以在 operation 之间指定依赖关系。 使用NSOperation类的实例方法addDependency:实现操作之间的依赖关系。 对于需要明确的执行顺序时，操作依赖是非常强大的一个机制。它可以让你创建一些操作组，并确保这些操作组在依赖它们的操作被执行之前执行，或者在并发队列中以串行的方式执行操作。 如下：\n1 2 3 [intermediateOperation addDependency:operation1]; [intermediateOperation addDependency:operation2]; [finishedOperation addDependency:intermediateOperation]; 这些简单的代码可以确保 operation1 和 operation2 在 intermediateOperation 之前执行，当然，也会在 finishOperation 之前被执行。\n从本质上来看，操作队列的性能比 GCD 要低那么一点，不过，大多数情况下这点负面影响可以忽略不计，操作队列是并发编程的首选工具。\nRun Loops 实际上，Run loop并不像 GCD 或者操作队列那样是一种并发机制，因为它并不能并行执行任务。不过在主 dispatch/operation 队列中， run loop 将直接配合任务的执行，它提供了一种异步执行代码的机制。\nRun loop 比起操作队列或者 GCD 来说容易使用得多，因为通过 run loop ，你不必处理并发中的复杂情况，就能异步地执行任务。\n场景 一个 run loop 总是绑定到某个特定的线程中。main run loop 是与主线程相关的，在每一个 Cocoa 和 CocoaTouch 程序中，这个 main run loop 都扮演了一个核心角色，它负责处理 UI 事件、计时器，以及其它内核相关事件。无论你什么时候设置计时器、使用 NSURLConnection 或者调用 performSelector:withObject:afterDelay:，其实背后都是 run loop 在处理这些异步任务。\nrunloop运行模式 无论何时你使用 run loop 来执行一个方法的时候，都需要记住一点：run loop 可以运行在不同的模式中，每种模式都定义了一组事件，供 run loop 做出响应。这在对应 main run loop 中暂时性的将某个任务优先执行这种任务上是一种聪明的做法。\n关于这点，在 iOS 中非常典型的一个示例就是滚动。在进行滚动时，run loop 并不是运行在默认模式中的，因此， run loop 此时并不会响应比如滚动前设置的计时器。一旦滚动停止了，run loop 会回到默认模式，并执行添加到队列中的相关事件。如果在滚动时，希望计时器能被触发，需要将其设为 NSRunLoopCommonModes 的模式，并添加到 run loop 中。\n子线程中使用runloop 主线程一般来说都已经配置好了 main run loop。然而其他线程默认情况下都没有设置 run loop。你也可以自行为其他线程设置 run loop ，但是一般来说我们很少需要这么做。大多数时间使用 main run loop 会容易得多。如果你需要处理一些很重的工作，但是又不想在主线程里做，你仍然可以在你的代码在 main run loop 中被调用后将工作分配给其他队列。Chris 在他关于常见的后台实践的文章里阐述了一些关于这种模式的很好的例子。\n如果你真需要在别的线程中添加一个 run loop ，那么不要忘记在 run loop 中至少添加一个 input source 。如果 run loop 中没有设置好的 input source，那么每次运行这个 run loop ，它都会立即退出。\n并发编程中面临的挑战 使用并发编程会带来许多陷阱。只要一旦你做的事情超过了最基本的情况，对于并发执行的多任务之间的相互影响的不同状态的监视就会变得异常困难。 问题往往发生在一些不确定性（不可预见性）的地方，这使得在调试相关并发代码时更加困难。\n关于并发编程的不可预见性有一个非常有名的例子：在1995年， NASA (美国宇航局)发送了开拓者号火星探测器，但是当探测器成功着陆在我们红色的邻居星球后不久，任务嘎然而止，火星探测器莫名其妙的不停重启，在计算机领域内，遇到的这种现象被定为为优先级反转，也就是说低优先级的线程一直阻塞着高优先级的线程。稍后我们会看到关于这个问题的更多细节。在这里我们想说明的是，即使拥有丰富的资源和大量优秀工程师的智慧，并发也还是会在不少情况下反咬你一口。\n资源共享 并发编程中许多问题的根源就是在多线程中访问共享资源。资源可以是一个属性、一个对象，通用的内存、网络设备或者一个文件等等。在多线程中任何一个共享的资源都可能是一个潜在的冲突点，你必须精心设计以防止这种冲突的发生。\n示例 为了演示这类问题，我们举一个关于资源的简单示例： 描述：比如仅仅用一个整型值来做计数器。在程序运行过程中，我们有两个并行线程 A 和 B，这两个线程都尝试着同时增加计数器的值。 问题：你通过 C 语言或 Objective-C 写的代码大多数情况下对于 CPU 来说不会仅仅是一条机器指令。要想增加计数器的值，当前的必须被从内存中读出，然后增加计数器的值，最后还需要将这个增加后的值写回内存中。\n我们可以试着想一下，如果两个线程同时做上面涉及到的操作，会发生怎样的偶然。例如，线程 A 和 B 都从内存中读取出了计数器的值，假设为 17 ，然后线程A将计数器的值加1，并将结果 18 写回到内存中。同时，线程B也将计数器的值加 1 ，并将结果 18 写回到内存中。实际上，此时计数器的值已经被破坏掉了，因为计数器的值 17 被加 1 了两次，而它的值却是 18。\n这个问题被叫做竞态条件，在多线程里面访问一个共享的资源，如果没有一种机制来确保在线程 A 结束访问一个共享资源之前，线程 B 就不会开始访问该共享资源的话，资源竞争的问题就总是会发生。如果你所写入内存的并不是一个简单的整数，而是一个更复杂的数据结构，可能会发生这样的现象：当第一个线程正在写入这个数据结构时，第二个线程却尝试读取这个数据结构，那么获取到的数据可能是新旧参半或者没有初始化。为了防止出现这样的问题，多线程需要一种互斥的机制来访问共享资源。\n在实际的开发中，情况甚至要比上面介绍的更加复杂，因为现代 CPU 为了优化目的，往往会改变向内存读写数据的顺序（乱序执行）。\n互斥锁 互斥访问的意思就是同一时刻，只允许一个线程访问某个特定资源。为了保证这一点，每个希望访问共享资源的线程，首先需要获得一个共享资源的互斥锁，一旦某个线程对资源完成了操作，就释放掉这个互斥锁，这样别的线程就有机会访问该共享资源了。\n除了确保互斥访问，还需要解决代码无序执行所带来的问题。如果不能确保 CPU 访问内存的顺序跟编程时的代码指令一样，那么仅仅依靠互斥访问是不够的。为了解决由 CPU 的优化策略引起的副作用，还需要引入内存屏障。通过设置内存屏障，来确保没有无序执行的指令能跨过屏障而执行。\n当然，互斥锁自身的实现是需要没有竞争条件的。这实际上是非常重要的一个保证，并且需要在现代 CPU 上使用特殊的指令。更多关于原子操作（atomic operation）的信息，请阅读 Daniel 写的文章：底层并发技术。\n解决方案：原子声明属性 从语言层面来说，在 Objective-C 中将属性以 atomic 的形式来声明，就能支持互斥锁了。事实上在默认情况下，属性就是 atomic 的。将一个属性声明为 atomic 表示每次访问该属性都会进行隐式的加锁和解锁操作。虽然最把稳的做法就是将所有的属性都声明为 atomic，但是加解锁这也会付出一定的代价。\n性能开销及锁的竞争 在资源上的加锁会引发一定的性能代价。获取锁和释放锁的操作本身也需要没有竞态条件，这在多核系统中是很重要的。另外，在获取锁的时候，线程有时候需要等待，因为可能其它的线程已经获取过资源的锁了。这种情况下，线程会进入休眠状态。当其它线程释放掉相关资源的锁时，休眠的线程会得到通知。所有这些相关操作都是非常昂贵且复杂的。 在这里有一个东西需要进行权衡：获取和释放锁所是要带来开销的，因此你需要确保你不会频繁地进入和退出临界区段（比如获取和释放锁）。同时，如果你获取锁之后要执行一大段代码，这将带来锁竞争的风险：其它线程可能必须等待获取资源锁而无法工作。这并不是一项容易解决的任务。\n不同类型的锁 锁也有不同的类型。当没有竞争时，有些锁在没有锁竞争的情况下性能很好，但是在有锁的竞争情况下，性能就会大打折扣。另外一些锁则在基本层面上就比较耗费资源，但是在竞争情况下，性能的恶化会没那么厉害。(锁的竞争是这样产生的：当一个或者多个线程尝试获取一个已经被别的线程获取过了的锁)。\n我们经常能看到本来计划并行运行的代码，但实际上由于共享资源中配置了相关的锁，所以同一时间只有一个线程是处于激活状态的。对于你的代码会如何在多核上运行的预测往往十分重要，你可以使用 Instrument 的 CPU strategy view 来检查是否有效的利用了 CPU 的可用核数，进而得出更好的想法，以此来优化代码。\n死锁 互斥锁解决了竞态条件的问题，但很不幸同时这也引入了一些其他问题，其中一个就是死锁。当多个线程在相互等待着对方的结束时，就会发生死锁，这时程序可能会被卡住。\n看看下面的代码，它交换两个变量的值：\n1 2 3 4 5 6 7 8 9 10 11 void swap(A, B) { lock(lockA); lock(lockB); int a = A; int b = B; A = b; B = a; unlock(lockB); unlock(lockA); } 大多数时候，这能够正常运行。但是当两个线程使用相反的值来同时调用上面这个方法时：\n1 2 swap(X, Y); // 线程 1 swap(Y, X); // 线程 2 此时程序可能会由于死锁而被终止。线程 1 获得了 X 的一个锁，线程 2 获得了 Y 的一个锁。 接着它们会同时等待另外一把锁，但是永远都不会获得。\n再说一次，你在线程之间共享的资源越多，你使用的锁也就越多，同时程序被死锁的概率也会变大。这也是为什么我们需要尽量减少线程间资源共享，并确保共享的资源尽量简单的原因之一。\n解决方案 建议阅读一下底层并发编程 API 中的全部使用异步分发一节。\n资源饥饿（Starvation） 当你认为已经足够了解并发编程面临的问题时，又出现了一个新的问题。锁定的共享资源会引起读写问题。大多数情况下，限制资源一次只能有一个线程进行读取访问其实是非常浪费的。因此，在资源上没有写入锁的时候，持有一个读取锁是被允许的。这种情况下，如果一个持有读取锁的线程在等待获取写入锁的时候，其他希望读取资源的线程则因为无法获得这个读取锁而导致资源饥饿的发生。\n解决方案 为了解决这个问题，我们需要使用一个比简单的读/写锁更聪明的方法，例如给定一个 writer preference，或者使用 read-copy-update 算法。Daniel 在底层并发编程 API 中有介绍了如何用 GCD 实现一个多读取单写入的模式，这样就不会被写入资源饥饿的问题困扰了。\n优先级反转 本节开头介绍了美国宇航局发射的开拓者号火星探测器在火星上遇到的并发问题。现在我们就来看看为什么开拓者号几近失败，以及为什么有时候我们的程序也会遇到相同的问题，该死的优先级反转。\n优先级反转是指程序在运行时低优先级的任务阻塞了高优先级的任务，有效的反转了任务的优先级。由于 GCD 提供了拥有不同优先级的后台队列，甚至包括一个 I/O 队列，所以我们最好了解一下优先级反转的可能性。\n高优先级和低优先级的任务之间共享资源时，就可能发生优先级反转。当低优先级的任务获得了共享资源的锁时，该任务应该迅速完成，并释放掉锁，这样高优先级的任务就可以在没有明显延时的情况下继续执行。然而高优先级任务会在低优先级的任务持有锁的期间被阻塞。如果这时候有一个中优先级的任务(该任务不需要那个共享资源)，那么它就有可能会抢占低优先级任务而被执行，因为此时高优先级任务是被阻塞的，所以中优先级任务是目前所有可运行任务中优先级最高的。此时，中优先级任务就会阻塞着低优先级任务，导致低优先级任务不能释放掉锁，这也就会引起高优先级任务一直在等待锁的释放。\n在你的实际代码中，可能不会像发生在火星的事情那样戏剧性地不停重启。遇到优先级反转时，一般没那么严重。\n解决这个问题的方法，通常就是不要使用不同的优先级。通常最后你都会以让高优先级的代码等待低优先级的代码来解决问题。当你使用 GCD 时，总是使用默认的优先级队列（直接使用，或者作为目标队列）。如果你使用不同的优先级，很可能实际情况会让事情变得更糟糕。\n从中得到的教训是，使用不同优先级的多个队列听起来虽然不错，但毕竟是纸上谈兵。它将让本来就复杂的并行编程变得更加复杂和不可预见。如果你在编程中，遇到高优先级的任务突然没理由地卡住了，可能你会想起本文，以及那个美国宇航局的工程师也遇到过的被称为优先级反转的问题。\n总结 我们希望通过本文你能够了解到并发编程带来的复杂性和相关问题。并发编程中，无论是看起来多么简单的 API ，它们所能产生的问题会变得非常的难以观测，而且要想调试这类问题往往也都是非常困难的。\n但另一方面，并发实际上是一个非常棒的工具。它充分利用了现代多核 CPU 的强大计算能力。在开发中，关键的一点就是尽量让并发模型保持简单，这样可以限制所需要的锁的数量。\n我们建议采纳的安全模式是这样的：从主线程中提取出要使用到的数据，并利用一个操作队列在后台处理相关的数据，最后回到主队列中来发送你在后台队列中得到的结果。使用这种方式，你不需要自己做任何锁操作，这也就大大减少了犯错误的几率。\n话题 #2 下的更多文章\n原文 Concurrent Programming: APIs and Challenges\n精细校对 @onevcat\n","date":"2017-09-24T09:18:49Z","permalink":"https://it-boyer.github.io/post/old/iOS/iOS%E5%A4%9A%E7%BA%BF%E7%A8%8BAPI%E4%BB%8B%E7%BB%8D/","section":"post","tags":["线程"],"title":"iOS多线程API介绍"},{"categories":["学习笔记"],"contents":"图形堆栈 当像素映射到屏幕上的时候，后台发生了很多事情。但一旦他们显示到屏幕上，每一个像素均由三个颜色组件构成：红，绿，蓝。三个独立的颜色单元会根据给定的颜色显示到一个像素上。在 iPhone5 的液晶显示器上有1,136×640=727,040个像素，因此有2,181,120个颜色单元。在15寸视网膜屏的 MacBook Pro 上，这一数字达到15.5百万以上。所有的图形堆栈一起工作以确保每次正确的显示。当你滚动整个屏幕的时候，数以百万计的颜色单元必须以每秒60次的速度刷新，这是一个很大的工作量。\n软件堆栈组成 从简单的角度来看，软件堆栈看起来有点像这样：\nGPU强大的图形硬件 Display 的上一层便是图形处理单元 GPU，GPU 是一个专门为图形高并发计算而量身定做的处理单元。这也是为什么它能同时更新所有的像素，并呈现到显示器上。它并发的本性让它能高效的将不同纹理合成起来。我们将有一小块内容来更详细的讨论图形合成。关键的是，GPU 是非常专业的，因此在某些工作上非常高效。比如，GPU 非常快，并且比 CPU 使用更少的电来完成工作。通常 CPU 都有一个普遍的目的，它可以做很多不同的事情，但是合成图像在 CPU 上却显得比较慢。\nGPU 是一个非常强大的图形硬件，并且在显示像素方面起着核心作用。它连接到 CPU。从硬件上讲两者之间存在某种类型的总线，并且有像 OpenGL，Core Animation 和 Core Graphics 这样的框架来在 GPU 和 CPU 之间精心安排数据的传输。为了将像素显示到屏幕上，一些处理将在 CPU 上进行。然后数据将会传送到 GPU，这也需要做一些相应的操作，最终像素显示到屏幕上。\nGPU Driver 是直接和 GPU 交流的代码块。不同的GPU是不同的性能怪兽，但是驱动使他们在下一个层级上显示的更为统一，典型的下一层级有 OpenGL/OpenGL ES.\nOpenGL的扩展API OpenGL(Open Graphics Library) 是一个提供了 2D 和 3D 图形渲染的 API。GPU 是一块非常特殊的硬件，OpenGL 和 GPU 密切的工作以提高GPU的能力，并实现硬件加速渲染。\n在 iOS 上，几乎所有的东西都是通过 Core Animation 绘制出来，因为 Core Animation 使用 Core Graphics 来做一些渲染。像 AVFoundation，Core Image 框架，和其他一些混合的入口。 在OS X 上，绕过 Core Animation 直接使用 Core Graphics 绘制的情况并不少见。对于一些专门的应用，尤其是游戏，程序可能直接和 OpenGL/OpenGL ES 交流。\nGPU纹理合成渲染流程 合成挑战：GPU 需要将每一个 frame 的纹理(位图)合成在一起(一秒60次)。每一个纹理会占用 VRAM(video RAM)，所以需要给 GPU 同时保持纹理的数量做一个限制。GPU 在合成方面非常高效，但是某些合成任务却比其他更复杂，并且 GPU在 16.7ms(1/60s)内能做的工作也是有限的。\n耗时挑战：下一个挑战就是将数据传输到 GPU 上。为了让 GPU 访问数据，需要将数据从 RAM 移动到 VRAM 上。这就是提及到的上传数据到 GPU。这看起来貌似微不足道，但是一些大型的纹理却会非常耗时。\n最终，CPU 开始运行你的程序。你可能会让 CPU 从 bundle 加载一张 PNG 的图片并且解压它。这所有的事情都在 CPU 上进行。然后当你需要显示解压缩后的图片时，它需要以某种方式上传到 GPU。一些看似平凡的，比如显示文本，对 CPU 来说却是一件非常复杂的事情，这会促使 Core Text 和 Core Graphics 框架更紧密的集成来根据文本生成一个位图。一旦准备好，它将会被作为一个纹理上传到 GPU 并准备显示出来。当你滚动或者在屏幕上移动文本时，不管怎么样，同样的纹理能够被复用，CPU 只需简单的告诉 GPU 新的位置就行了,所以 GPU 就可以重用存在的纹理了。CPU 并不需要重新渲染文本，并且位图也不需要重新上传到 GPU。\n这张图涉及到一些错综复杂的方面，我们将会把这些方面提取出来并深一步了解。\n合成/纹理概念 合成：在图形世界中，合成是一个描述不同位图如何放到一起来创建你最终在屏幕上看到图像的过程。\n纹理：屏幕上一切事物皆纹理。一个纹理就是一个包含 RGBA 值的长方形，比如，每一个像素里面都包含红、绿、蓝和透明度的值。在 Core Animation 世界中的纹理就是 CALayer。\n纹理合成：在这个简化的设置中，每一个 layer 是一个纹理，所有的纹理都以某种方式堆叠在彼此的顶部。对于屏幕上的每一个像素，GPU 需要算出怎么混合这些纹理来得到像素 RGB 的值。\n纹理合成像素的计算公式 如果我们所拥有的是一个和屏幕大小一样并且和屏幕像素对齐的单一纹理，那么屏幕上每一个像素相当于纹理中的一个像素，纹理的最后一个像素也就是屏幕的最后一个像素。\n如果我们有第二个纹理放在第一个纹理之上，然后GPU将会把第二个纹理合成到第一个纹理中。有很多种不同的合成方法，但是如果我们假定两个纹理的像素对齐，并且使用正常的混合模式，我们便可以用下面这个公式来计算每一个像素：\n1 R = S + D * ( 1 – Sa ) 结果的颜色是源色彩(顶端纹理)+目标颜色(低一层的纹理)*(1-源颜色的透明度)。在这个公式中所有的颜色都假定已经预先乘以了他们的透明度。\n显然相当多的事情在这发生了。让我们进行第二个假定，两个纹理都完全不透明，比如 alpha=1.如果目标纹理(低一层的纹理)是蓝色(RGB=0,0,1)，并且源纹理(顶层的纹理)颜色是红色(RGB=1,0,0)，因为 Sa 为1，所以结果为：\n1 R = S 结果是源颜色的红色。这正是我们所期待的(红色覆盖了蓝色)。\n如果源颜色层为50%的透明，比如 alpha=0.5，既然 alpha 组成部分需要预先乘进 RGB 的值中，那么 S 的 RGB 值为(0.5, 0, 0)，公式看起来便会像这样:\n1 2 3 0.5 0 0.5 R = S + D * (1 - Sa) = 0 + 0 * (1 - 0.5) = 0 0 1 0.5 我们最终得到RGB值为(0.5, 0, 0.5),是一个紫色。这正是我们所期望将透明红色合成到蓝色背景上所得到的。\n记住我们刚刚只是将纹理中的一个像素合成到另一个纹理的像素上。当两个纹理覆盖在一起的时候，GPU需要为所有像素做这种操作。正如你所知道的一样，许多程序都有很多层，因此所有的纹理都需要合成到一起。尽管GPU是一块高度优化的硬件来做这种事情，但这还是会让它非常忙碌。\nopaque 的属性：不透明 VS 透明 当源纹理是完全不透明的时候，目标像素就等于源纹理。这可以省下 GPU 很大的工作量，这样只需简单的拷贝源纹理而不需要合成所有的像素值。 CALayer 有一个叫做 opaque 的属性会告诉 GPU 纹理上的像素是透明还是不透明的。如果这个属性为 YES，GPU 将不会做任何合成，而是简单从这个层拷贝，不需要考虑它下方的任何东西(因为都被它遮挡住了)。这节省了 GPU 相当大的工作量。这也正是 Instruments 中 color blended layers 选项中所涉及的。(这在模拟器中的Debug菜单中也可用).它允许你看到哪一个 layers(纹理) 被标注为透明的，比如 GPU 正在为哪一个 layers 做合成。合成不透明的 layers 因为需要更少的数学计算而更廉价。 所以如果你知道你的 layer 是不透明的，最好确定设置它的 opaque 为 YES。如果你加载一个没有 alpha 通道的图片，并且将它显示在 UIImageView 上，这将会自动发生。但是要记住如果一个图片没有 alpha 通道和一个图片每个地方的 alpha 都是100%，这将会产生很大的不同。在后一种情况下，Core Animation 需要假定是否存在像素的 alpha 值不为100%。在 Finder 中，你可以使用 Get Info 并且检查 More Info 部分。它将告诉你这张图片是否拥有 alpha 通道。\n像素对齐 VS 不重合在一起 像素对齐 到现在我们都在考虑像素完美重合在一起的 layers。当所有的像素是对齐的时候我们得到相对简单的计算公式。每当 GPU 需要计算出屏幕上一个像素是什么颜色的时候，它只需要考虑在这个像素之上的所有 layer 中对应的单个像素，并把这些像素合并到一起。或者，如果最顶层的纹理是不透明的(即图层树的最底层)，这时候 GPU 就可以简单的拷贝它的像素到屏幕上。 滚动/错位 当一个 layer 上所有的像素和屏幕上的像素完美的对应整齐，那这个 layer 就是像素对齐的。主要有两个原因可能会造成不对齐。 第一个便是滚动：当一个纹理上下滚动的时候，纹理的像素便不会和屏幕的像素排列对齐。 另一个原因便是：当纹理的起点不在一个像素的边界上。 在这两种情况下，GPU 需要再做额外的计算。它需要将源纹理上多个像素混合起来，生成一个用来合成的值。当所有的像素都是对齐的时候，GPU 只剩下很少的工作要做。\nCore Animation 工具和模拟器有一个叫做 color misaligned images 的选项，当这些在你的 CALayer 实例中发生的时候，这个功能便可向你展示。\nMasks位图蒙板 一个图层可以有一个和它相关联的 mask(蒙板)，mask 是一个拥有 alpha 值的位图，当像素要和蒙板下面包含的像素合并之前都会把 mask 应用到图层的像素上去，最终只有在 mask 中显示出来的(即图层中的部分)才会被渲染出来。 例如：当你要设置一个图层的圆角半径时，你可以有效的在图层上面设置一个 mask。但是也可以指定任意一个蒙板。比如，一个字母 A 形状的 mask。\n离屏渲染(Offscreen Rendering) 离屏渲染：即在屏幕外对图层树的合并/渲染，此时会有一个屏幕外缓冲区缓存图层树，然后该缓冲区会被渲染到屏幕上。离屏渲染可以被 Core Animation 自动触发，或者被应用程序强制触发。\n离屏渲染合成计算是非常昂贵的, 但有时你也许希望强制这种操作。一种好的方法就是缓存合成的纹理/图层。如果你的渲染树非常复杂(所有的纹理，以及如何组合在一起)，你可以强制离屏渲染缓存那些图层，然后可以用缓存作为合成的结果放到屏幕上。 Instrument 的 Core Animation 工具有一个叫做 Color Offscreen-Rendered Yellow 的选项，它会将已经被渲染到屏幕外缓冲区的区域标注为黄色(这个选项在模拟器中也可以用)。同时记得检查 Color Hits Green and Misses Red 选项。绿色代表无论何时一个屏幕外缓冲区被复用，而红色代表当缓冲区被重新创建。\nGPU离屏渲染多图层动画 如果你的程序混合了很多图层，并且想要他们一起做动画，GPU 通常会为每一帧(1/60s)重复合成所有的图层。当使用离屏渲染时，GPU 第一次会混合所有图层到一个基于新的纹理的位图缓存上，然后使用这个纹理来绘制到屏幕上。现在，当这些图层一起移动的时候，GPU 便可以复用这个位图缓存，并且只需要做很少的工作。需要注意的是，只有当那些图层不改变时，这才可以用。如果那些图层改变了，GPU 需要重新创建位图缓存。你可以通过设置 shouldRasterize 为 YES 来触发这个行为。\n两个权衡点 第一，这可能会使事情变得更慢。创建额外的屏幕外缓冲区是 GPU 需要多做的一步操作，特殊情况下这个位图可能再也不需要被复用，这便是一个无用功了。 第二，可以被复用的位图，GPU 也有可能将它卸载了。所以你需要计算 GPU 的利用率和帧的速率来判断这个位图是否有用。\n副作用：mask蒙板渲染至缓冲区 离屏渲染也可能产生副作用。如果你正在直接或者间接的将mask应用到一个图层上，Core Animation 为了应用这个 mask，会强制进行屏幕外渲染。这会对 GPU 产生重负。通常情况下 mask 只能被直接渲染到帧的缓冲区中(在屏幕内)。\n避免使用离屏渲染 因为直接将图层合成到帧的缓冲区中(在屏幕上)比先创建屏幕外缓冲区，然后渲染到纹理中，最后将结果渲染到帧的缓冲区中要廉价很多。这其中涉及两次昂贵的环境转换(转换环境到屏幕外缓冲区，然后转换环境到帧缓冲区)。 layer的几种触发离屏渲染 为 layer 使用蒙板或者设置圆角半径会造成屏幕外渲染，产生阴影也会如此。 至于 mask，圆角半径(特殊的mask)和 clipsToBounds/masksToBounds，你可以简单的为一个已经拥有 mask 的 layer 创建内容，比如，已经应用了 mask 的 layer 使用一张图片。如果你想根据 layer 的内容为其应用一个长方形 mask，你可以使用 contentsRect 来代替蒙板。 如果你最后设置了 shouldRasterize 为 YES，那也要记住设置 rasterizationScale 为 contentsScale。 所以当你打开 Color Offscreen-Rendered Yellow 后看到黄色，这便是一个警告，但这不一定是不好的。如果 Core Animation 能够复用屏幕外渲染的结果，这便能够提升性能。\n离屏渲染空间限制 同时还要注意，rasterized layer 的空间是有限的。苹果暗示大概有屏幕大小两倍的空间来存储 rasterized layer/屏幕外缓冲区。\n更多的关于合成 像往常一样，维基百科上有更多关于透明合成的基础公式。当我们谈完像素后，我们将更深入一点的谈论红，绿，蓝和 alpha 是怎么在内存中表现的。\nOS X 如果你是在 OS X 上工作，你将会发现大多数 debugging 选项在一个叫做 Quartz Debug 的独立程序中，而不是在 Instruments 中。Quartz Debug 是 Graphics Tools 中的一部分，这可以在苹果的 developer portal 中下载到。\nCore Animation OpenGL ES 正如名字所建议的那样，Core Animation 让你在屏幕上实现动画。我们将跳过动画部分，而集中在绘图上。需要注意的是，Core Animation 允许你做非常高效的渲染。这也是为什么当你使用 Core Animation 时可以实现每秒 60 帧的动画。\nCore Animation 的核心是 OpenGL ES 的一个抽象物，简而言之，它让你直接使用 OpenGL ES 的功能，却不需要处理 OpenGL ES 做的复杂的事情。当我们上面谈论合成的时候，我们把 layer 和 texture 当做等价的，但是他们不是同一物体，可又是如此的类似。\nCore Animation 的 layer 可以有子 layer，所以最终你得到的是一个图层树。Core Animation 所需要做的最繁重的任务便是判断出哪些图层需要被(重新)绘制，而 OpenGL ES 需要做的便是将图层合并、显示到屏幕上。\n举个例子，当你设置一个 layer 的内容为 CGImageRef 时，Core Animation 会创建一个 OpenGL 纹理，并确保在这个图层中的位图被上传到对应的纹理中。以及当你重写 -drawInContext 方法时，Core Animation 会请求分配一个纹理，同时确保 Core Graphics 会将你所做的(即你在drawInContext中绘制的东西)放入到纹理的位图数据中。一个图层的性质和 CALayer 的子类会影响到 OpenGL 的渲染结果，许多低等级的 OpenGL ES 行为被简单易懂地封装到 CALayer 概念中。\nCore Animation 通过 Core Graphics 的一端和 OpenGL ES 的另一端，精心策划基于 CPU 的位图绘制。因为 Core Animation 处在渲染过程中的重要位置上，所以你如何使用 Core Animation 将会对性能产生极大的影响。\nCPU限制 VS GPU限制 当你在屏幕上显示东西的时候，有许多组件参与了其中的工作。其中，CPU 和 GPU 在硬件中扮演了重要的角色。在他们命名中 P 和 U 分别代表了”处理”和”单元”，当需要在屏幕上进行绘制时，他们都需要做处理，同时他们都有资源限制(即 CPU 和 GPU 的硬件资源)。\n为了每秒达到 60 帧，你需要确定 CPU 和 GPU 不能过载。此外，即使你当前能达到 60fps(frame per second),你还是要把尽可能多的绘制工作交给 GPU 做，而让 CPU 尽可能的来执行应用程序。通常，GPU 的渲染性能要比 CPU 高效很多，同时对系统的负载和消耗也更低一些。\n既然绘图性能是基于 CPU 和 GPU 的，那么你需要找出是哪一个限制你绘图性能的。如果你用尽了 GPU 所有的资源，也就是说，是 GPU 限制了你的性能，同样的，如果你用尽了 CPU，那就是 CPU 限制了你的性能。\n要告诉你，如果是 GPU 限制了你的性能，你可以使用 OpenGL ES Driver instrument。点击上面那个小的 i 按钮，配置一下，同时注意勾选 Device Utilization %。现在，当你运行你的 app 时，你可以看到你 GPU 的负荷。如果这个值靠近 100%，那么你就需要把你工作的重心放在GPU方面了。\nCore Graphics / Quartz 2D 通过 Core Graphics 这个框架，Quartz 2D 被更为广泛的知道。\nQuartz 2D 拥有比我们这里谈到更多的装饰。我们这里不会过多的讨论关于 PDF 的创建，渲染，解析，或者打印。只需要注意的是，PDF 的打印、创建和在屏幕上绘制位图的操作是差不多的。因为他们都是基于 Quartz 2D。\n让我们简单的了解一下 Quartz 2D 主要的概念。有关详细信息可以到苹果的官方文档中了解。\n放心，当 Quartz 2D 涉及到 2D 绘制的时候，它是非常强大的。有基于路径的绘制，反锯齿渲染，透明图层，分辨率，并且设备独立，可以说出很多特色。这可能会让人产生畏惧，主要因为这是一个低级并且基于 C 的 API。\n主要的概念相对简单，UIKit 和 AppKit 都包含了 Quartz 2D 的一些简单 API，一旦你熟练了，一些简单 C 的 API 也是很容易理解的。最终你学会了一个能实现 Photoshop 和 Illustrator 大部分功能的绘图引擎。苹果把 iOS 程序里面的股票应用作为讲解 Quartz 2D 在代码中实现动态渲染的一个例子。\n当你的程序进行位图绘制时，不管使用哪种方式，都是基于 Quartz 2D 的。也就是说，CPU 部分实现的绘制是通过 Quartz 2D 实现的。尽管 Quartz 可以做其它的事情，但是我们这里还是集中于位图绘制，在缓冲区(一块内存)绘制位图会包括 RGBA 数据。\n比方说，我们要画一个八角形，我们通过 UIKit 能做到这一点\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(16.72, 7.22)]; [path addLineToPoint:CGPointMake(3.29, 20.83)]; [path addLineToPoint:CGPointMake(0.4, 18.05)]; [path addLineToPoint:CGPointMake(18.8, -0.47)]; [path addLineToPoint:CGPointMake(37.21, 18.05)]; [path addLineToPoint:CGPointMake(34.31, 20.83)]; [path addLineToPoint:CGPointMake(20.88, 7.22)]; [path addLineToPoint:CGPointMake(20.88, 42.18)]; [path addLineToPoint:CGPointMake(16.72, 42.18)]; [path addLineToPoint:CGPointMake(16.72, 7.22)]; [path closePath]; path.lineWidth = 1; [[UIColor redColor] setStroke]; [path stroke]; 相对应的 Core Graphics 代码：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 CGContextBeginPath(ctx); CGContextMoveToPoint(ctx, 16.72, 7.22); CGContextAddLineToPoint(ctx, 3.29, 20.83); CGContextAddLineToPoint(ctx, 0.4, 18.05); CGContextAddLineToPoint(ctx, 18.8, -0.47); CGContextAddLineToPoint(ctx, 37.21, 18.05); CGContextAddLineToPoint(ctx, 34.31, 20.83); CGContextAddLineToPoint(ctx, 20.88, 7.22); CGContextAddLineToPoint(ctx, 20.88, 42.18); CGContextAddLineToPoint(ctx, 16.72, 42.18); CGContextAddLineToPoint(ctx, 16.72, 7.22); CGContextClosePath(ctx); CGContextSetLineWidth(ctx, 1); CGContextSetStrokeColorWithColor(ctx, [UIColor redColor].CGColor); CGContextStrokePath(ctx); 需要问的问题是:这个绘制到哪儿去了？这正好引出所谓的 CGContext 登场。我们传过去的ctx参数正是在那个上下文中。而这个上下文定义了我们需要绘制的地方。如果我们实现了 CALayer 的 -drawInContext: 这时已经传过来一个上下文。绘制到这个上下文中的内容将会被绘制到图层的备份区(图层的缓冲区).但是我们也可以创建我们自己的上下文，叫做基于位图的上下文，比如 CGBitmapContextCreate().这个方法返回一个我们可以传给 CGContext 方法来绘制的上下文。\n注意 UIKit 版本的代码为何不传入一个上下文参数到方法中？这是因为当使用 UIKit 或者 AppKit 时，上下文是唯一的。UIkit 维护着一个上下文堆栈，UIKit 方法总是绘制到最顶层的上下文中。你可以使用 UIGraphicsGetCurrentContext() 来得到最顶层的上下文。你可以使用 UIGraphicsPushContext() 和 UIGraphicsPopContext() 在 UIKit 的堆栈中推进或取出上下文。\n最为突出的是，UIKit 使用 UIGraphicsBeginImageContextWithOptions() 和 UIGraphicsEndImageContext() 方便的创建类似于 CGBitmapContextCreate() 的位图上下文。混合调用 UIKit 和 Core Graphics 非常简单：\n1 2 3 4 5 6 7 8 UIGraphicsBeginImageContextWithOptions(CGSizeMake(45, 45), YES, 2); CGContextRef ctx = UIGraphicsGetCurrentContext(); CGContextBeginPath(ctx); CGContextMoveToPoint(ctx, 16.72, 7.22); CGContextAddLineToPoint(ctx, 3.29, 20.83); ... CGContextStrokePath(ctx); UIGraphicsEndImageContext(); 或者另外一种方法:\n1 2 3 4 5 6 7 8 9 10 CGContextRef ctx = CGBitmapContextCreate(NULL, 90, 90, 8, 90 * 4, space, bitmapInfo); CGContextScaleCTM(ctx, 0.5, 0.5); UIGraphicsPushContext(ctx); UIBezierPath *path = [UIBezierPath bezierPath]; [path moveToPoint:CGPointMake(16.72, 7.22)]; [path addLineToPoint:CGPointMake(3.29, 20.83)]; ... [path stroke]; UIGraphicsPopContext(ctx); CGContextRelease(ctx); 你可以使用 Core Graphics 创建大量的非常酷的东西。一个很好的理由就是，苹果的文档有很多例子。我们不能得到所有的细节，但是 Core Graphics 有一个非常接近 Adobe Illustrator 和 Adobe Photoshop 如何工作的绘图模型，并且大多数工具的理念翻译成 Core Graphics 了。终究，他是起源于 NeXTSTEP 。(原来也是乔老爷的作品)。\nCGLayer 我们最初指出 CGLayer 可以用来提升重复绘制相同元素的速度。正如 Dave Hayden指出，这些小道消息不再可靠。\n像素 屏幕上的像素是由红，绿，蓝三种颜色组件构成的。因此，位图数据有时也被叫做 RGB 数据。你可能会对数据如何组织在内存中感到好奇。而事实是，有很多种不同的方式在内存中展现RGB位图数据。\n稍后我们将会谈到压缩数据，这又是一个完全不同的概念。现在，我们先看一下RGB位图数据，我们可以从颜色组件:红，绿，蓝中得到一个值。而大多数情况下，我们有第四个组件:透明度。最终我们从每个像素中得到四个单独的值。\n默认的像素布局 在 iOS 和 OS X 上最常见的格式就是大家所熟知的 32bits-per-pixel(bpp), 8bits-per-componet(bpc),透明度会首先被乘以到像素值上(就像上文中提到的那个公式一样),在内存中，像下面这样:\n1 2 3 A R G B A R G B A R G B | pixel 0 | pixel 1 | pixel 2 0 1 2 3 4 5 6 7 8 9 10 11 ... 这个格式经常被叫做 ARGB。每个像素占用 4 字节(32bpp),每一个颜色组件是1字节(8bpc).每个像素有一个 alpha 值，这个值总是最先得到的(在RGB值之前)，最终红、绿、蓝的值都会被预先乘以 alpha 的值。预乘的意思就是 alpha 值被烘烤到红、绿、蓝的组件中。如果我们有一个橙色，他们各自的 8bpc 就像这样: 240,99,24.一个完全不透明的橙色像素拥有的 ARGB 值为: 255，240，99，24，它在内存中的布局就像上面图示那样。如果我们有一个相同颜色的像素，但是 alpha 值为 33%，那么他的像素值便是:84，80，33，8.\n另一个常见的格式便是 32bpp，8bpc，跳过第一个 alpha 值，看起来像下面这样：\n1 2 3 x R G B x R G B x R G B | pixel 0 | pixel 1 | pixel 2 0 1 2 3 4 5 6 7 8 9 10 11 ... 这常被叫做 xRGB。像素并没有任何 alpha 值(他们都被假定为100%不透明)，但是内存布局是一样的。你应该想知道为什么这种格式很流行，当我们每一个像素中都有一个不用字节时，我们将会省下 25% 的空间。事实证明，这种格式更容易被现代的 CPU 和绘图算法消化，因为每一个独立的像素都对齐到 32-bit 的边界。现代的 CPU 不喜欢装载(读取)不对齐的数据，特别是当将这种数据和上面没有 alpha 值格式的数据混合时，算法需要做很多挪动和蒙板操作。\n当处理 RGB 数据时，Core Graphics 也需要支持把alpha 值放到最后(另外还要支持跳过)。有时候也分别称为 RGBA 和 RGBx，假定是 8bpc，并且预乘了 alpha 值。\n深奥的布局 大多数时候，当处理位图数据时，我们也需要处理 Core Graphics/Quartz 2D。有一个非常详细的列表列出了他支持的混合组合。但是让我们首先看一下剩下的 RGB 格式：\n另一个选择是 16bpp，5bpc，不包含 alpha 值。这个格式相比之前一个仅占用 50% 的存储大小(每个像素2字节)，但将使你存储它的 RGB 数据到内存或磁盘中变得困难。既然这种格式中，每个颜色组件只有 5bits(原文中写的是每个像素是5bits，但根据上下文可知应该是每个组件)，这样图形(特别是平滑渐变的)会造成重叠在一起的假象。\n还有一个是 64bpp，16bpc，最终为 128bpp，32bpc，浮点数组件(有或没有 alpha 值)。它们分别使用 8 字节和 16 字节，并且允许更高的精度。当然，这会造成更多的内存使用和昂贵的计算。\n整件事件中，Core Graphics 也支持一些像灰度模式和 CMYK 格式，这些格式类似于仅有 alpha 值的格式(蒙板)。\n二维数据 当颜色组件(红、绿、蓝、alpha)混杂在一起的时候，大多数框架(包括 Core Graphics )使用像素数据。正是这种情况下我们称之为二维数据，或者二维组件。这个意思是：每一个颜色组件都在它自己的内存区域，也就是说它是二维的。比如 RGB 数据，我们有三个独立的内存区域，一个大的区域包含了所有像素的红颜色的值，一个包含了所有绿颜色的值，一个包含了所有蓝颜色的值。\n在某些情况下，一些视频框架便会使用二维数据。\nYCbCr 当我们处理视频数据时，YCbCr 是一种常见的格式。它也是包含了三种(Y,Cb和Cr)代表颜色数据的组件。但是简单的讲，它更类似于通过人眼看到的颜色。人眼对 Cb 和 Cr 这两种组件的色彩度不太能精确的辨认出来，但是能很准确的识别出 Y 的亮度。当数据使用 YCbCr 格式时，在同等的条件下，Cb 和 Cr 组件比 Y 组件压缩的更紧密。\n出于同样的原因，JPEG 图像有时会将像素数据从 RGB 转换到 YCbCr。JPEG 单独的压缩每一个二维颜色。当压缩基于 YCbCr 的平面时，Cb 和 Cr 能比 Y 压缩得更完全。\n图片格式 当你在 iOS 或者 OS X 上处理图片时，他们大多数为 JPEG 和 PNG。让我们更进一步观察。\nJPEG 每个人都知道 JPEG。它是相机的产物。它代表着照片如何存储在电脑上。甚至你妈妈都听说过 JPEG。\n一个很好的理由，很多人都认为 JPEG 文件仅是另一种像素数据的格式，就像我们刚刚谈到的 RGB 像素布局那样。这样理解离真相真是差十万八千里了。\n将 JPEG 数据转换成像素数据是一个非常复杂的过程，你通过一个周末的计划都不能完成，甚至是一个非常漫长的周末(原文的意思好像就是为了表达这个过程非常复杂，不过老外的比喻总让人拎不清)。对于每一个二维颜色，JPEG 使用一种基于离散余弦变换(简称 DCT 变换)的算法，将空间信息转变到频域.这个信息然后被量子化，排好序，并且用一种哈夫曼编码的变种来压缩。很多时候，首先数据会被从 RGB 转换到二维 YCbCr，当解码 JPEG 的时候，这一切都将变得可逆。\n这也是为什么当你通过 JPEG 文件创建一个 UIImage 并且绘制到屏幕上时，将会有一个延时，因为 CPU 这时候忙于解压这个 JPEG。如果你需要为每一个 tableviewcell 解压 JPEG，那么你的滚动当然不会平滑(原来 tableviewcell 里面最要不要用 JPEG 的图片)。\n那究竟为什么我们还要用 JPEG 呢？答案就是 JPEG 可以非常非常好的压缩图片。一个通过 iPhone5 拍摄的，未经压缩的图片占用接近 24M。但是通过默认压缩设置，你的照片通常只会在 2-3M 左右。JPEG 压缩这么好是因为它是失真的，它去除了人眼很难察觉的信息，并且这样做可以超出像 gzip 这样压缩算法的限制。但这仅仅在图片上有效的，因为 JPEG 依赖于图片上有很多人类不能察觉出的数据。如果你从一个基本显示文本的网页上截取一张图，JPEG 将不会这么高效。压缩效率将会变得低下，你甚至能看出来图片已经压缩变形了。\nPNG PNG读作”ping”。和 JPEG 相反，它的压缩对格式是无损的。当你将一张图片保存为 PNG，并且打开它(或解压)，所有的像素数据会和最初一模一样，因为这个限制，PNG 不能像 JPEG 一样压缩图片，但是对于像程序中的原图(如buttons，icons)，它工作的非常好。更重要的是，解码 PNG 数据比解码 JPEG 简单的多。\n在现实世界中，事情从来没有那么简单，目前存在了大量不同的 PNG 格式。可以通过维基百科查看详情。但是简言之，PNG 支持压缩带或不带 alpha 通道的颜色像素(RGB)，这也是为什么它在程序原图中表现良好的另一个原因。\n挑选一个格式 当你在你的程序中使用图片时，你需要坚持这两种格式: JPEG 或者 PNG。读写这种格式文件的压缩和解压文件能表现出很高的性能，另外，还支持并行操作。同时 Apple 正在改进解压缩并可能出现在将来的新操作系统中，届时你将会得到持续的性能提升。如果尝试使用另一种格式，你需要注意到，这可能对你程序的性能会产生影响，同时可能会打开安全漏洞，经常，图像解压缩算法是黑客最喜欢的攻击目标。\n已经写了很多关于优化 PNGs，如果你想要了解更多，请到互联网上查询。非常重要的一点，注意 Xcode 优化 PNG 选项和优化其他引擎有很大的不同。\n当 Xcode 优化一个 PNG 文件的时候，它将 PNG 文件变成一个从技术上讲不再是有效的PNG文件。但是 iOS 可以读取这种文件，并且这比解压缩正常的 PNG 文件更快。Xcode 改变他们，让 iOS 通过一种对正常 PNG 不起作用的算法来对他们解压缩。值得注意的重点是，这改变了像素的布局。正如我们所提到的一样，在像素之下有很多种方式来描绘 RGB 数据，如果这不是 iOS 绘制系统所需要的格式，它需要将每一个像素的数据替换，而不需要加速来做这件事。\n让我们再强调一遍，如果你可以，你需要为原图设置 resizable images。你的文件将变得更小，因此你只需要从文件系统装载更少的数据。\n图层后备存储的渲染 UIKit 和 Pixels 每一个在 UIKit 中的 view 都有它自己的 CALayer。依次，这些图层都有一个叫像素位图的后备存储，有点像一个图像。这个后备存储正是被渲染到显示器上的。\nWith –drawRect: 如果你的视图类实现了 -drawRect:，他们将像这样工作:\n设置一个标示 当你调用 -setNeedsDisplay，UIKit 将会在这个视图的图层上调用 -setNeedsDisplay。这为图层设置了一个标识，标记为 dirty(直译是脏的意思，想不出用什么词比较贴切,污染？)，但还显示原来的内容。它实际上没做任何工作，所以多次调用 -setNeedsDisplay并不会造成性能损失。 装备后备存储 当渲染系统准备好，它会调用视图图层的-display方法.此时，图层会装配它的后备存储。然后建立一个 Core Graphics 上下文(CGContextRef)，将后备存储对应内存中的数据恢复出来，绘图会进入对应的内存区域，并使用 CGContextRef 绘制。 2.1 使用 UIKit 的绘制方法 当你使用 UIKit 的绘制方法，例如: UIRectFill() 或者 -[UIBezierPath fill] 代替你的 -drawRect: 方法，他们将会使用这个上下文。 使用方法是，UIKit 将后备存储的 CGContextRef 推进他的 graphics context stack，也就是说，它会将那个上下文设置为当前的。因此 UIGraphicsGetCurrent() 将会返回那个对应的上下文。既然 UIKit 使用 UIGraphicsGetCurrent() 绘制方法，绘图将会进入到图层的后备存储。 2.2 直接使用 Core Graphics 方法 通过调用 UIGraphicsGetCurrent() 得到相同的上下文，并将这个上下文传给 Core Graphics 方法。 从现在开始，图层的后备存储将会被不断的渲染到屏幕上。直到下次再次调用视图的 -setNeedsDisplay ，将会依次将图层的后备存储更新到视图上。\n不使用 -drawRect: 当你用一个 UIImageView 时，事情略有不同，这个视图仍然有一个 CALayer，但是图层却没有申请一个后备存储。取而代之的是使用一个 CGImageRef 作为他的内容，并且渲染服务将会把图片的数据绘制到帧的缓冲区，比如，绘制到显示屏。\n在这种情况下，将不会继续重新绘制。我们只是简单的将位图数据以图片的形式传给了 UIImageView，然后 UIImageView 传给了 Core Animation，然后轮流传给渲染服务。\n实现-drawRect: 还是不实现 -drawRect: 最快的绘制就是你不要做任何绘制。 大多数时间，你可以不要合成你在其他视图(图层)上定制的视图(图层)，这正是我们推荐的，因为 UIKit 的视图类是非常优化的 (就是让我们不要闲着没事做,自己去合并视图或图层) 。\n当你需要自定义绘图代码时，Apple 在WWDC 2012’s session 506:Optimizing 2D Graphics and Animation Performance 中展示了一个很好的例子:”finger painting”。\n另一个地方需要自定义绘图的就是 iOS 的股票软件。股票是直接用 Core Graphics 在设备上绘制的，注意，这仅仅是你需要自定义绘图，你并不需要实现 -drawRect: 方法。有时，通过 UIGraphicsBeginImageContextWithOptions() 或者 CGBitmapContextCeate() 创建位图会显得更有意义，从位图上面抓取图像，并设置为 CALayer 的内容。下面我们将给出一个例子来测试，检验。\n单一颜色 如果我们看这个例子：\n1 2 3 4 5 6 // Don\u0026#39;t do this - (void)drawRect:(CGRect)rect { [[UIColor redColor] setFill]; UIRectFill([self bounds]); } 现在我们知道这为什么不好:我们促使 Core Animation 来为我们创建一个后备存储，并让它使用单一颜色填充后备存储，然后上传给 GPU。\n我们跟本不需要实现 -drawRect:，并节省这些代码工作量，只需简单的设置这个视图图层的背景颜色。如果这个视图有一个 CAGradientLayer 作为图层，那么这个技术也同样适用于此（渐变图层）。\n可变尺寸的图像 类似的，你可以使用可变尺寸的图像来降低绘图系统的压力。让我们假设你需要一个 300×50 点的按钮插图，这将是 600×100=60k 像素或者 60kx4=240kB 内存大小需要上传到 GPU，并且占用 VRAM。如果我们使用所谓的可变尺寸的图像，我们只需要一个 54×12 点的图像，这将占用低于 2.6k 的像素或者 10kB 的内存，这样就变得更快了。\nCore Animation 可以通过 CALayer 的 contentsCenter 属性来改变图像，大多数情况下，你可能更倾向于使用，-[UIImage resizableImageWithCapInsets:resizingMode:]。\n同时注意，在第一次渲染这个按钮之前，我们并不需要从文件系统读取一个 60k 像素的 PNG 并解码，解码一个小的 PNG 将会更快。通过这种方式，你的程序在每一步的调用中都将做更少的工作，并且你的视图将会加载的更快。\n并发绘图 上一次 objc.io 的话题是关于并发的讨论。正如你所知道的一样，UIKit 的线程模型是非常简单的：你仅可以从主队列(比如主线程)中调用 UIKit 类(比如视图),那么并发绘图又是什么呢？\n如果你必须实现 -drawRect:，并且你必须绘制大量的东西，这将占用时间。由于你希望动画变得更平滑，除了在主队列中，你还希望在其他队列中做一些工作。同时发生的绘图是复杂的，但是除了几个警告，同时发生的绘图还是比较容易实现的。\n我们除了在主队列中可以向 CALayer 的后备存储中绘制一些东西，其他方法都将不可行。可怕的事情将会发生。我们能做的就是向一个完全断开链接的位图上下文中进行绘制。 为了同时绘制，我们需要做下面的操作:\n正如我们上面所提到的一样，在 Core Graphics 下，所有 Core Graphics 绘制方法都需要一个上下文参数来指定绘制到那个上下文中。UIKit 有一个当前上下文的概念(也就是绘制到哪儿去)。这个当前的上下文就是 per-thread. 我们需要在另一个队列创建一个图像，一旦我们拥有了图像，我们可以切换回主队列，并且设置这个图像为 UIImageView 的图像。这个技术在 WWDC 2012 session 211 中讨论过。(异步下载图片经常用到这个) 增加一个你可以在其中绘制的新方法：\n1 2 3 4 5 6 7 8 9 10 - (UIImage *)renderInImageOfSize:(CGSize)size { UIGraphicsBeginImageContextWithOptions(size, NO, 0); // 绘制代码块 UIImage *result = UIGraphicsGetImageFromCurrentImageContext(); UIGraphicsEndImageContext(); return result; } 这个方法通过 UIGraphicsBeginImageContextWithOptions() 方法，并根据给定的大小创建一个新的 CGContextRef 位图上下文。这个方法也会将这个上下文设置为当前UIKit的上下文。现在你可以在这里做你想在 -drawRect: 中做的事了。然后通过 UIGraphicsGetImageFromCurrentImageContext(),获得的这个上下文位图数据作为一个 UIImage，最终移除这个上下文。\n很重要的一点就是，你在这个方法中所做的所有绘图的代码都是线程安全的，也就是说，当你访问属性等等，他们需要线程安全。因为你是在另一个队列中调用这个方法的。如果这个方法在你的视图类中，那就需要注意一点了。 另一个选择就是创建一个单独的渲染类，并设置所有需要的属性，然后通过触发来渲染图片。如果这样，你可以通过使用简单的 UIImageView 或者 UITableViewCell。\n要知道，所有 UIKit 的绘制 API 在使用另一个队列时，都是安全的。只需要确定是在同一个操作中调用他们的，这个操作需要以 UIGraphicsBeginImageContextWithOptions() 开始，以 UIGraphicsEndIamgeContext() 结束。\n你需要像下面这样触发渲染代码：\n1 2 3 4 5 6 7 8 9 UIImageView *view; // assume we have this NSOperationQueue *renderQueue; // assume we have this CGSize size = view.bounds.size; [renderQueue addOperationWithBlock:^(){ UIImage *image = [renderer renderInImageOfSize:size]; [[NSOperationQueue mainQueue] addOperationWithBlock:^(){ view.image = image; }]; }]; 要注意，我们是在主队列中调用 view.image = image.这是一个非常重要的细节。你不可以在任何其他队列中调用这个代码。\n像往常一样，同时绘制会伴随很多问题，你现在需要取消后台渲染。并且在渲染队列中设置合理的同时绘制的最大限度。为了支持这一切，最简单的就是在一个 NSOperation 子类内部实现 -renderInImageOfSize:。\n最终，需要指出，设置 UITableViewCell 内容为异步是非常困难的。单元格很有可能在完成异步渲染前已经被复用了。尽管单元格已经被其他地方复用，但你只需要设置内容就行了。\nCALayer 到现在为止，你需要知道在 GPU 内，一个 CALayer 在某种方式上和一个纹理类似。图层有一个后备存储，这便是被用来绘制到屏幕上的位图。\n通常，当你使用 CALayer 时，你会设置它的内容为一个图片。这到底做了什么？这样做会告诉 Core Animation 使用图片的位图数据作为纹理。如果这个图片(JPEG或PNG)被压缩了，Core Animation 将会这个图片解压缩，然后上传像素数据到 GPU。\n尽管还有很多其他种类的图层，如果你是用一个简单的没有设置上下文的 CALayer，并为这个 CALayer 设置一个背景颜色，Core Animation 并不会上传任何数据到 GPU，但却能够不用任何像素数据而在 GPU 上完成所有的工作，类似的，对于渐变的图层，GPU 是能创建渐变的，而且不需要 CPU 做任何工作，并且不需要上传任何数据到 GPU。\n自定义绘制的图层 如果一个 CALayer 的子类实现了 -drawInContext: 或者它的代理，类似于 -drawLayer:inContest:, Core Animation 将会为这个图层申请一个后备存储，用来保存那些方法绘制进来的位图。那些方法内的代码将会运行在 CPU 上，结果将会被上传到 GPU。\n形状和文本图层 形状和文本图层还是有些不同的。开始时，Core Animation 为这些图层申请一个后备存储来保存那些需要为上下文生成的位图数据。然后 Core Animation 会讲这些图形或文本绘制到后备存储上。这在概念上非常类似于，当你实现 -drawInContext: 方法，然后在方法内绘制形状或文本，他们的性能也很接近。\n在某种程度上，当你需要改变形状或者文本图层时，这需要更新它的后备存储，Core Animation 将会重新渲染后备存储。例如，当动态改变形状图层的大小时，Core Animation 需要为动画中的每一帧重新绘制形状。\n异步绘图 CALayer 有一个叫做 drawsAsynchronously 的属性，这似乎是一个解决所有问题的高招。注意，尽管这可能提升性能，但也可能让事情变慢。\n当你设置 drawsAsynchronously 为 YES 时，发生了什么？你的 -drawRect:/-drawInContext: 方法仍然会被在主线程上调用。但是所有调用 Core Graphics 的操作都不会被执行。取而代之的是，绘制命令被推迟，并且在后台线程中异步执行。\n这种方式就是先记录绘图命令，然后在后台线程中重现。为了这个过程的顺利进行，更多的工作需要被做，更多的内存需要被申请。但是主队列中的一些工作便被移出来了(大概意思就是让我们把一些能在后台实现的工作放到后台实现，让主线程更顺畅)。\n对于昂贵的绘图方法，这是最有可能提升性能的，但对于那些绘图方法来说，也不会节省太多资源。\n话题 #3 下的更多文章\n原文 Getting Pixels onto the Screen\n译文 将像素绘制到屏幕上去 - answer-huang\n","date":"2017-09-23T14:51:07Z","permalink":"https://it-boyer.github.io/post/old/iOS/UI/iOS%E8%A7%86%E5%9B%BE%E6%B8%B2%E6%9F%93/","section":"post","tags":["iOS"],"title":"iOS视图渲染"},{"categories":["项目总结"],"contents":"简介 iResearcher是一款科研/研发领域大数据分析系统+应用。旨在为科研/技术研发工作者提供 资源直达服务。iResearcher计划提供的资源服务既包括论文，方法，数据集，也包括人，资金等。最终建立，人与人，人与资金，人与技术方法之间的互联。为科研/研发工作者，提供一站式科研服务平台。\nAPP截图 由于运营方已停止服务器访问，暂时只能截图呈现APP相关功能。\n","date":"2017-09-10T14:09:39Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/iResearcher%E7%AE%80%E4%BB%8B/","section":"post","tags":[],"title":"iResearcher简介"},{"categories":["学习笔记"],"contents":"iOS 7 和 Mac OS X 10.9 Mavericks 中一个显著的变化就是对 Foundation URL 加载系统的彻底重构。\n现在已经有人在深入苹果的网络层基础架构的地方做研究了，所以我想是时候来分享一些对于我对于这些新的 API 的看法和心得了，新的 API 将如何影响我们编写程序，以及它们对于 API 设计理念的影响。\nNSURLConnection机制 NSURLConnection 作为 Core Foundation / CFNetwork 框架的 API 之上的一个抽象，在 2003 年，随着第一版的 Safari 的发布就发布了。NSURLConnection 这个名字，实际上是指代的 Foundation 框架的 URL 加载系统中一系列有关联的组件：NSURLRequest、NSURLResponse、NSURLProtocol、 NSURLCache、 NSHTTPCookieStorage、NSURLCredentialStorage 以及同名类 NSURLConnection。\nNSURLRequest 被传递给 NSURLConnection。被委托对象（遵守以前的非正式协议 \u0026lt;NSURLConnectionDelegate\u0026gt; 和 \u0026lt;NSURLConnectionDataDelegate\u0026gt;）异步地返回一个 NSURLResponse 以及包含服务器返回信息的 NSData。\n缓存策略 在一个请求被发送到服务器之前，系统会先查询共享的缓存信息，然后根据**策略（policy）以及可用性（availability）**的不同，一个已经被缓存的响应可能会被立即返回。如果没有缓存的响应可用，则这个请求将根据我们指定的策略来缓存它的响应以便将来的请求可以使用。\n鉴权查询 在把请求发送给服务器的过程中，服务器可能会发出鉴权查询（authentication challenge），这可以由共享的 cookie 或**机密存储（credential storage）**来自动响应，或者由被委托对象来响应。发送中的请求也可以被注册的 NSURLProtocol 对象所拦截，以便在必要的时候无缝地改变其加载行为。\n不管怎样，NSURLConnection 作为网络基础架构，已经服务了成千上万的 iOS 和 Mac OS 程序，并且做的还算相当不错。但是这些年，一些用例——尤其是在 iPhone 和 iPad 上面——已经对 NSURLConnection 的几个核心概念提出了挑战，让苹果有理由对它进行重构。\n在 2013 的 WWDC 上，苹果推出了 NSURLConnection 的继任者：NSURLSession。\nNSURLSession成员 和 NSURLConnection 一样，NSURLSession 指的也不仅是同名类 NSURLSession，还包括一系列相互关联的类。NSURLSession 包括了与之前相同的组件，NSURLRequest 与 NSURLCache，但是把 NSURLConnection 替换成了 NSURLSession、NSURLSessionConfiguration 以及 NSURLSessionTask 的 3 个子类：NSURLSessionDataTask，NSURLSessionUploadTask，NSURLSessionDownloadTask。\nNSURLSessionConfiguration可配置性初始化 与 NSURLConnection 相比，NSURLsession 最直接的改进就是可以配置每个 session 的缓存，协议，cookie，以及证书策略（credential policy），甚至跨程序共享这些信息。这将允许程序和网络基础框架之间相互独立，不会发生干扰。每个 NSURLSession 对象都由一个 NSURLSessionConfiguration 对象来进行初始化，后者指定了刚才提到的那些策略以及一些用来增强移动设备上性能的新选项。 抽象类NSURLSessionTask数据加载 NSURLSession 中另一大块就是 session task。它负责处理数据的加载以及文件和数据在客户端与服务端之间的上传和下载。NSURLSessionTask 与 NSURLConnection 最大的相似之处在于它也负责数据的加载，最大的不同之处在于所有的 task 共享其创造者 NSURLSession 这一公共委托者（common delegate）。 我们先来深入探讨 task，过后再来讨论 NSURLSessionConfiguration。\nNSURLSessionTask NSURLsessionTask 是一个抽象类，其下有 3 个实体子类封装了现代程序三个最基本的网络任务：\nNSURLSessionDataTask：加载数据，当加载任务完成时，它会返回相关联的数据，比如 JSON 或者 XML NSURLSessionUploadTask：上传文件，当上传任务完成时，也会有上传相关数据返回，所以继承自 NSURLSessionDataTask。 NSURLSessionDownloadTask：下载文件，当下载任务结束时，它会返回已下载文件的一个临时的文件路径。 所有的 task 都是可以取消，暂停或者恢复的。当一个 download task 取消时，可以通过选项来创建一个恢复数据（resume data），然后可以传递给下一次新创建的 download task，以便继续之前的下载。\n工厂方法 不同于直接使用 alloc-init 初始化方法，task 是由一个 NSURLSession 创建的。每个 task 的构造方法都对应有或者没有 completionHandler 这个 block 的两个版本:\nblock回调构造方式: –dataTaskWithRequest:completionHandler: 通过指定 completionHandler 这个 block 将创建一个隐式的 delegate，来替代该 task 原来的 delegate——session。 代理回调构造方式：–dataTaskWithRequest: 对于需要 override 原有 session task 的 delegate 的默认行为的情况,使用代理回调 这里不会立即运行 task，而是将该 task 对象先返回，允许我们进一步的配置，然后可以使用 resume 方法来让它开始运行。\n数据加载工厂 Data task 可以通过 NSURL 或 NSURLRequest 创建（使用前者相当于是使用一个对于该 URL 进行标准 GET 请求的 NSURLRequest，这是一种快捷方法）：\n1 2 3 4 5 6 7 8 9 10 11 NSURL *URL = [NSURL URLWithString:@\u0026#34;http://example.com\u0026#34;]; NSURLRequest *request = [NSURLRequest requestWithURL:URL]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDataTask *task = [session dataTaskWithRequest:request completionHandler: ^(NSData *data, NSURLResponse *response, NSError *error) { // ... }]; [task resume]; 数据上传工厂 Upload task 的创建需要使用一个 request，另外加上一个要上传的 NSData 对象或者是一个本地文件的路径对应的 NSURL：\n1 2 3 4 5 6 7 8 9 10 11 12 13 NSURL *URL = [NSURL URLWithString:@\u0026#34;http://example.com/upload\u0026#34;]; NSURLRequest *request = [NSURLRequest requestWithURL:URL]; NSData *data = ...; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionUploadTask *uploadTask = [session uploadTaskWithRequest:request fromData:data completionHandler: ^(NSData *data, NSURLResponse *response, NSError *error) { // ... }]; [uploadTask resume]; 数据下载工厂 Download task 也需要一个 request，不同之处在于 completionHandler 这个 block。Data task 和 upload task 会在任务完成时一次性返回，但是 Download task 是将数据一点点地写入本地的临时文件。所以在 completionHandler 这个 block 里，我们需要把文件从一个临时地址移动到一个永久的地址保存起来：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 NSURL *URL = [NSURL URLWithString:@\u0026#34;http://example.com/file.zip\u0026#34;]; NSURLRequest *request = [NSURLRequest requestWithURL:URL]; NSURLSession *session = [NSURLSession sharedSession]; NSURLSessionDownloadTask *downloadTask = [session downloadTaskWithRequest:request completionHandler: ^(NSURL *location, NSURLResponse *response, NSError *error) { NSString *documentsPath = [NSSearchPathForDirectoriesInDomains(NSDocumentDirectory, NSUserDomainMask, YES) firstObject]; NSURL *documentsDirectoryURL = [NSURL fileURLWithPath:documentsPath]; NSURL *newFileLocation = [documentsDirectoryURL URLByAppendingPathComponent:[[response URL] lastPathComponent]]; [[NSFileManager defaultManager] copyItemAtURL:location toURL:newFileLocation error:nil]; }]; [downloadTask resume]; 编者注 原文中这块代码以及上文的表述中存有一些问题，详见这个 issue，本文已进行更正，如果您有不同意见，欢迎在 Github 上给我们反馈。\nNSURLSession 的 delegate 方法 NSURLSession 的 delegate 方法是 NSURLConnection 的演化的十年中对于 ad-hoc 模式的一个显著改善。您可以查看这个映射表来进行一个完整的概览。\n连接层/任务层代理 NSURLSession 既拥有 seesion 的 delegate 方法，又拥有 task 的 delegate 方法用来处理鉴权查询。\nsession 的 delegate 方法处理连接层的问题：诸如服务器信任，客户端证书的评估，NTLM 和 Kerberos 协议这类问题。 task 的 delegate 处理网络请求为基础的问题：如 Basic，Digest，以及**代理身份验证（Proxy authentication）**等。 网络请求结束代理 在 NSURLConnection 中两个delegate方法： 数据加载完成：NSURLConnectionDataDelegate 中的 -connectionDidFinishLoading: 网络连接失败： NSURLConnectionDelegate 中的 -connection:didFailWithError:， 在 NSURLSession 中改为一个 delegate 方法： NSURLSessionTaskDelegate 的 -URLSession:task:didCompleteWithError: NSURLSession 中表示传输多少字节的参数类型现在改为 int64_t，以前在 NSURLConnection 中相应的参数的类型是 long long。 block参数回调代理模式 NSURLSession 给 Foundation 框架引入了一种全新的模式：即 代理方法中以completionHandler: 这种block 作为参数的方式。\n这种模式允许 delegate 方法可以安全地在主线程与运行，而不会阻塞主线程； Delgate 只需要简单地调用 dispatch_async 就可以切换到后台进行相关的操作，然后在操作完成时调用 completionHandler 即可。 它还可以有效地拥有多个返回值，而不需要我们使用笨拙的参数指针。 以 NSURLSessionTaskDelegate代理中的方法为例：\n1 -URLSession:task:didReceiveChallenge:completionHandler: completionHandler 接受的两个参数： 参数一：NSURLSessionAuthChallengeDisposition:鉴权查询的策略 参数二：NSURLCredential:证书（仅当第一个参数——应对鉴权查询的策略为使用证书，即 NSURLSessionAuthChallengeUseCredential 时有效，否则该参数为 NULL）。\n想要查看更多关于 session task 的信息，可以查看 WWDC Session 705: \u0026ldquo;What’s New in Foundation Networking\u0026rdquo;\nNSURLSessionConfiguration NSURLSessionConfiguration 对象用于对 NSURLSession 对象进行初始化。\n配置开发灵活性 NSURLSessionConfiguration 扩充了 NSMutableURLRequest 所提供的网络请求层的设置选项，从指定可用网络，到 cookie，安全性，缓存策略，再到使用自定义协议，启动事件的设置，以及用于移动设备优化的几个新属性，你会发现使用 NSURLSessionConfiguration 可以找到几乎任何你想要进行配置的选项，提供给我们相当大的灵活性和控制权。 配置加载机制 NSURLSession 在初始化时会把配置它的 NSURLSessionConfiguration 对象进行一次 copy，并保存到自己的 configuration 属性中，而且这个属性是只读的。因此之后再修改最初配置 session 的那个 configuration 对象对于 session 是没有影响的。也就是说，configuration 只在初始化时被读取一次，之后都是不会变化的。 三个配置类工厂方法 针对NSURLSession 不同的使用场景，如下三个配置类方法：\n+defaultSessionConfiguration： 返回一个标准的 configuration，这个配置实际上与 NSURLConnection 的**网络堆栈（networking stack）**是一样的，具有相同的共享 NSHTTPCookieStorage，共享 NSURLCache 和共享 NSURLCredentialStorage。 +ephemeralSessionConfiguration： 返回一个预设配置，这个配置中不会对缓存，Cookie 和证书进行持久性的存储。这对于实现像秘密浏览这种功能来说是很理想的。 +backgroundSessionConfiguration:(NSString *)identifier 的独特之处在于，它会创建一个后台 session。后台 session 不同于常规的，普通的 session，它甚至可以在应用程序挂起，退出或者崩溃的情况下运行上传和下载任务。初始化时指定的标识符，被用于向任何可能在进程外恢复后台传输的**守护进程（daemon）**提供上下文。 想要查看更多关于后台 session 的信息，可以查看 WWDC Session 204: \u0026ldquo;What\u0026rsquo;s New with Multitasking\u0026rdquo;\n配置属性 NSURLSessionConfiguration 拥有 20 个配置属性。熟练掌握这些配置属性的用处，可以让应用程序充分地利用其网络环境。\n基本配置 HTTPAdditionalHeaders: 指定了一组默认的可以设置**出站请求（outbound request）**的数据头。这对于跨 session 共享信息，如内容类型，语言，用户代理和身份认证，是很有用的。 1 2 3 4 5 6 7 8 9 10 NSString *userPasswordString = [NSString stringWithFormat:@\u0026#34;%@:%@\u0026#34;, user, password]; NSData * userPasswordData = [userPasswordString dataUsingEncoding:NSUTF8StringEncoding]; NSString *base64EncodedCredential = [userPasswordData base64EncodedStringWithOptions:0]; NSString *authString = [NSString stringWithFormat:@\u0026#34;Basic %@\u0026#34;, base64EncodedCredential]; NSString *userAgentString = @\u0026#34;AppName/com.example.app (iPhone 5s; iOS 7.0.2; Scale/2.0)\u0026#34;; configuration.HTTPAdditionalHeaders = @{@\u0026#34;Accept\u0026#34;: @\u0026#34;application/json\u0026#34;, @\u0026#34;Accept-Language\u0026#34;: @\u0026#34;en\u0026#34;, @\u0026#34;Authorization\u0026#34;: authString, @\u0026#34;User-Agent\u0026#34;: userAgentString}; networkServiceType: 对标准的网络流量，网络电话，语音，视频，以及由一个后台进程使用的流量进行了区分。大多数应用程序都不需要设置这个。 allowsCellularAccess 和 discretionary 被用于节省通过蜂窝网络连接的带宽。对于后台传输的情况，推荐大家使用 discretionary 这个属性，而不是 allowsCellularAccess，因为前者会把 WiFi 和电源的可用性考虑在内。 timeoutIntervalForRequest 和 timeoutIntervalForResource 分别指定了对于请求和资源的超时间隔。许多开发人员试图使用 timeoutInterval 去限制发送请求的总时间，但其实它真正的含义是：**分组（packet）**之间的时间。实际上我们应该使用 timeoutIntervalForResource 来规定整体超时的总时间，但应该只将其用于后台传输，而不是用户实际上可能想要去等待的任何东西。 HTTPMaximumConnectionsPerHost: 是 Foundation 框架中 URL 加载系统的一个新的配置选项。它曾经被 NSURLConnection 用于管理私有的连接池。现在有了 NSURLSession，开发者可以在需要时限制连接到特定主机的数量。 HTTPShouldUsePipelining: 这个属性在 NSMutableURLRequest 下也有，它可以被用于开启 HTTP 管线化（HTTP pipelining），这可以显着降低请求的加载时间，但是由于没有被服务器广泛支持，默认是禁用的。 sessionSendsLaunchEvents: 是另一个新的属性，该属性指定该 session 是否应该从后台启动。 connectionProxyDictionary: 指定了 session 连接中的代理服务器。同样地，大多数面向消费者的应用程序都不需要代理，所以基本上不需要配置这个属性。 关于连接代理的更多信息可以在 CFProxySupport Reference 找到。\nCookie 策略 HTTPCookieStorage: 存储了 session 所使用的 cookie。默认情况下会使用 NSHTTPCookieShorage 的 +sharedHTTPCookieStorage 这个单例对象，这与 NSURLConnection 是相同的。 HTTPCookieAcceptPolicy: 决定了什么情况下 session 应该接受从服务器发出的 cookie。 HTTPShouldSetCookies: 指定了请求是否应该使用 session 存储的 cookie，即 HTTPCookieSorage 属性的值。 安全策略 URLCredentialStorage: 存储了 session 所使用的证书。默认情况下会使用 NSURLCredentialStorage 的 +sharedCredentialStorage 这个单例对象，这与 NSURLConnection 是相同的。 TLSMaximumSupportedProtocol 和 TLSMinimumSupportedProtocol 确定 session 是否支持 SSL 协议。 缓存策略 URLCache : 是 session 使用的缓存。默认情况下会使用 NSURLCache 的 +sharedURLCache 这个单例对象，这与 NSURLConnection 是相同的。 requestCachePolicy : 指定了一个请求的缓存响应应该在什么时候返回。这相当于 NSURLRequest 的 -cachePolicy 方法。 自定义协议 protocolClasses: 用来配置特定某个 session 所使用的自定义协议（该协议是 NSURLProtocol 的子类）的数组。 结论 iOS 7 和 Mac OS X 10.9 Mavericks 中 URL 加载系统的变化，是对 NSURLConnection 进行深思熟虑后的一个自然而然的进化。总体而言，苹果的 Foundation 框架团队干了一件令人钦佩的的工作，他们研究并预测了移动开发者现有的和新兴的用例，创造了能够满足日常任务而且非常好用的 API 。\n尽管在这个体系结构中，某些决定对于可组合性和可扩展性而言是一种倒退，但是 NSURLSession 仍然是实现更高级别网络功能的一个强大的基础框架。\n","date":"2017-09-08T18:48:43Z","permalink":"https://it-boyer.github.io/post/old/iOS/NSURLSession%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","section":"post","tags":["iOS"],"title":"NSURLSession的使用说明"},{"categories":["解决方案"],"contents":"运行scheme： PDFReaderForOSX 即可\n{% github it-boyer PDFReader 737a7e %}\n支持iOS pageViewController: pdf翻页效果视图控制器 startingViewController:DataViewController,翻页视图控制器的视图源 modelController:ModelController:NSObject,数据视图数据源的model模型。\n1 2 3 4 5 6 @startuml object 阅读器 object pageView object source object model @enduml ","date":"2017-09-08T18:48:43Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E6%94%AF%E6%8C%81OSX%E6%B5%8F%E8%A7%88PDF%E7%AE%80%E5%8D%95%E8%A7%86%E5%9B%BE/","section":"post","tags":["pdf"],"title":"支持OSX浏览PDF简单视图"},{"categories":["博客站务"],"contents":"注册 1.注册https://ngrok.com/signup\nStart by downloading ngrok. Install your authtoken 1 ./ngrok authtoken 2tpoyojTzL5w55Y4na5DY_3shJgaMVzjJ***** Create your first secure tunnel 1 ./ngrok http 80 Open the web interface at http://localhost:4040 to inspect and replay requests Read the documentation for instructions on advanced features like adding HTTP authentication, setting custom subdomains and more. 开启TCP协议 开启TCP实现SSH远程访问. 详见 1 ./ngrok tcp 22 如图：\n每当执行开启命令，端口就会随机生成最新的。\n配置SSH远程工具 自定义SSH名：ngrok SSH域名地址：0.tcp.ngrok.io (ngrok提供的免费域名，IP地址ping就变新) SSH端口号：16335 （每次重新启动时需更新） 用户名称/密码: 电脑管理员账户/密码 手机热点访问远程内网电脑 连接前准备： 使用“网络实用工具”扫描0.tcp.ngrok.io域名，确保当前网络16335端口开启 备选方案，使用手机热点分享，来访问内网电脑，进行连通测试。 连接成功。 总结：可以使用ngrok客户端，开启tcp协议端口，实现SSH远程控制，在不要求过高的网速和安全，可以不搭建ngrok服务器。 强大的tunnel(隧道)工具部署原理 部署 ngrok在其github官方页面上的自我诠释是 “introspected tunnels to localhost\u0026quot;，这个诠释有两层含义： 1、可以用来建立public到localhost的tunnel，让居于内网主机上的服务可以暴露给public，俗称内网穿透。 2、支持对隧道中数据的introspection（内省），支持可视化的观察隧道内数据，并replay（重放）相关请求（诸如http请 求）。 因此ngrok可以很便捷的协助进行服务端程序调试，尤其在进行一些Web server开发中。ngrok更强大的一点是它支持tcp层之上的所有应用协议或者说与应用层协议无关。比如：你可以通过ngrok实现ssh登录到内 网主 机，也可以通过ngrok实现远程桌面(VNC)方式访问内网主机。\n一、ngrok tunnel与ngrok部署\n网络tunnel（隧道）对多数人都是很”神秘“的概念，tunnel种类很多，没有标准定义，我了解的也不多（日常工作较少涉及），这里也就不 深入了。在《HTTP权威指南》中有关于HTTP tunnel（http上承载非web流量）和SSL tunnel的说明，但ngrok中的tunnel又与这些有所不同。\nngrok实现了一个tcp之上的端到端的tunnel，两端的程序在ngrok实现的Tunnel内透明的进行数据交互。 ngrok分为client端(ngrok)和服务端(ngrokd)，实际使用中的部署如下： 内网服务程序可以与ngrok client部署在同一主机，也可以部署在内网可达的其他主机上。ngrok和ngrokd会为建立与public client间的专用通道（tunnel）。\n","date":"2017-09-06T12:23:24Z","permalink":"https://it-boyer.github.io/post/old/hexo/ngrok%E4%BD%BF%E7%94%A8/","section":"post","tags":["hexo"],"title":"ngrok使用"},{"categories":["学习笔记"],"contents":"11个模型\n《搞定III》 第1章 GTD现象 几类读者：似懂非懂型，止步于列举清单等 第二类：很难坚持 第三类：学以致用型 如何阅读本书： 手头备小本子，“假设的肯定” 自我培训：可信赖，可操作，长期追踪的步骤找到最终答案 相信自己的决定的钥匙\n第2章 步骤 第3章 自我管理的基本内容\n获得掌控 第4章 捕捉 :梦想家，发散思维搜集所有信息 第5章 明确意义:执行者，处理原材料，有的放矢 1. 结果导向型思维的战术价值 2. 第6章 组织整理 第7章 深思 第8章 参与 第9章 把GTD运用到工作和生活中 六个高度:六层次法 第10章 摆正视角 第11章 紧急问题：下一步行动 第12章 1万英尺：项目 第13章 2万英尺：关注和责任范围 第14章 3万英尺：长短期目标 第15章 4万英尺：愿景 第16章 5万英尺：宗旨和原则 第17章 摆正视角：重访“格雷西的花园” 实际运用 第18章 实际运用 第19章 尾声\n","date":"2017-08-17T15:41:11Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9AIII%E7%9B%AE%E5%BD%95%E7%AC%94%E8%AE%B0/","section":"post","tags":["图书"],"title":"搞定III目录笔记"},{"categories":["解决方案"],"contents":"space-vim 首次启用一个 layer，需要执行 SPC f R, 或者 :so $MYVIMRC, 重新加载 .vimrc 并执行 :PlugInstall 安装所需的相关插件 。或者退出重新打开 vim, vim-plug 将会检测并自动安装缺失的插件。 基于vim-plug的插件管理平台 vim-plug命令工具\nCommands Command Description PlugInstall [name ...] [#threads] Install plugins PlugUpdate [name ...] [#threads] Install or update plugins PlugClean[!] Remove unused directories (bang version will clean without prompt) PlugUpgrade Upgrade vim-plug itself PlugStatus Check the status of plugins PlugDiff Examine changes from the previous update and the pending changes PlugSnapshot[!] [output path] Generate script for restoring the current snapshot of the plugins Plug options Option Description branch/tag/commit Branch/tag/commit of the repository to use rtp Subdirectory that contains Vim plugin dir Custom directory for the plugin as Use different name for the plugin do Post-update hook (string or funcref) on On-demand loading: Commands or \u0026lt;Plug\u0026gt;-mappings for On-demand loading: File types frozen Do not update unless explicitly specified 安装objc 自动提示插件YouCompleteMe YouCompleteMe命令工具\n在spacevim添加 使用space-vim封装的layer 1 Layer \u0026#39;ycmd\u0026#39; \u0026#34;语法自动补齐 YouCompleteMe 安装位置： ~/.vim/plugged/YouCompleteMe 。\n编译 YCM 在使用space-vim平台上，使用layer方式安装会执行如下编译操作： 1 !./install.py --clang-completer 详见脚本：space-vim/layers/+tools/ycmd/packages.vim\n参考：征服恐惧！用 Vim 写 iOS App\n1 2 brew install cmake ./install.py --clang-completer --system-libclang --clang-completer: 告诉脚本需要 clang 的支持 --system-libclang: 告诉编译脚本使用系统的 clang，因为之前 clang 升级 4.0 的时候，并没有已经编译好的包给我下载，所以这里不用系统 clang 的话，编译脚本会下载一个 clang 3.0，这样就无法支持 iOS 10.0 以后的 sdk 了，因为 iOS 10.0 以后的 sdk 为了支持 swift 引入了一些 clang 3.0 不支持的新语法，所以这里要加上 \u0026ndash;system-libclang。\nFlagsForFile脚本获取编译参数 YCMD 是通过每个项目路径下的 .ycm_extra_conf.py 脚本文件，定义了FlagsForFile 的函数来获取某一个特定文件需要的编译参数，一般情况下大部分文件的编译参数是相同的。\n安装vim插件 使用vim-plug安装\n1 Plug \u0026#39;keith/sourcekittendaemon.vim\u0026#39; NOTE: This plugin doesn\u0026rsquo;t provide Swift runtime files. If you\u0026rsquo;d like those checkout swift.vim\nAsyncRun shell command 编辑器命令:AsyncRun + shell命令即可在后台执行shell命令，打开quickfix就可以实时查看执行结果了。也可以通过添加配置的方式来实现开始执行命令的时候自动打开quickfix窗口：\n1 2 :copen //打开脚本运行日志窗口 :AsyncRun git status //异步执行shell脚本 ","date":"2017-08-17T14:26:46Z","permalink":"https://it-boyer.github.io/post/old/shell/%E5%9C%A8space-vim%E5%B9%B3%E5%8F%B0%E5%AE%89%E8%A3%85%E8%8B%A5%E5%B9%B2%E6%8F%92%E4%BB%B6/","section":"post","tags":["shell"],"title":"在space-vim平台安装若干插件"},{"categories":["项目总结"],"contents":"\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 80 81 82 83 84 85 86 87 88 89 90 91 92 93 94 95 96 97 98 99 100 101 102 103 104 105 106 107 108 109 110 111 112 113 114 115 116 117 118 119 120 121 122 123 124 125 title PBBReader项目重构模型 center header PBBReader项目重构模型 endheader \u0026#39;******* 声明组件模块 component/[组件名] 中括号支持\\n换行 *******\u0026#39; \u0026#39;---- 声明备注:组件线备注可以通过虚线\u0026#34;..\u0026#34;连接到其他对象---\u0026#39; \u0026#39;##### 备注模块 位置：left/right/top/bottom #####\u0026#39; \u0026#39;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; 组件组合模块 支持模块嵌套 \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026#39; \u0026#39;六种组合样式:Node,Rectangle,Folder,Frame,Cloud,Database\u0026#39; Frame \u0026#34;启动APP\u0026#34;{ [APPDelegate] as LaunchAPP } Folder \u0026#34;注册模块\u0026#34;{ [欢迎页] -- [密码找回页] [欢迎页] -- [忘记密码页] [密码找回页] -- [完成注册页] [忘记密码页] -- [完成注册页] } Frame \u0026#34;功能项\u0026#34;{ Folder \u0026#34;制作模块\u0026#34;{ [多媒体选择页] -- [设定权限页] [设定权限页] -- [外发分享页] [外发分享页] -- [已发送列表页] } Folder \u0026#34;阅读模块\u0026#34;{ [已接收页] -- [广告页] [广告页] -- [播放视频页] [广告页] -- [播放音频页] [广告页] -- [浏览PDF页] } Folder \u0026#34;发现Tab\u0026#34;{ [发现页] -- [店铺详情页] } Folder \u0026#34;个人中心Tab\u0026#34;{ [个人中心] -- [个人设置] } } Database \u0026#34;sqliteDB\u0026#34; { \u0026#39;reader数据库 Database \u0026#34;PBBReader\u0026#34; { Folder \u0026#34;sqlite\u0026#34; { [dao] [db] [model] } } \u0026#39;online数据库 Database \u0026#34;PBBOnline\u0026#34; { [待定] } } Cloud \u0026#34;http+socket\u0026#34;{ Cloud \u0026#34;socket\u0026#34;{ [basesocket] [code] [other] [publiclib] } Cloud \u0026#34;HTTP\u0026#34; { [ASIHttp] } } Node \u0026#34;第三方SDK\u0026#34;{ [极光推送] [ShareSDK] [mupdf] } Node \u0026#34;公用工具\u0026#34;{ [CustomIOS7AlertView] [timers] [Advertising] } Node \u0026#34;项目依赖\u0026#34;{ \u0026#39;[SZMobileSDK] -- LaunchAPP [PBBMaker] -- LaunchAPP \u0026#39;[PBBMaker] --\u0026gt; [设定权限页] [IJKMediaPlayer] -- LaunchAPP \u0026#39;[IJKMediaPlayer] --\u0026gt; [播放视频页] } Node \u0026#34;资源\u0026#34;{ folder \u0026#34;IB\u0026#34;{ [主iPad] [Personal] [Register] [space] [WelcomeView] } folder \u0026#34;Images.xcassets\u0026#34;{ [主iPadImages] [PersonalImages] [RegisterImages] [spaceImages] [WelcomeViewImages] } } \u0026#39;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 关系模块 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#39; LaunchAPP -- [欢迎页] [完成注册页] -- [多媒体选择页] [完成注册页] -- [已接收页] [ShareSDK] -left-\u0026gt; [外发分享页] [Advertising] -right-\u0026gt; [广告页] IB -right- Images.xcassets 资源 -left-\u0026gt; 功能项 资源 -right-\u0026gt; 注册模块 center footer boyer制作 endfooter ","date":"2017-07-25T17:06:47Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/PBBReader%E9%A1%B9%E7%9B%AE%E9%87%8D%E6%9E%84%E6%A8%A1%E5%9E%8B/","section":"post","tags":[],"title":"PBBReader项目重构模型"},{"categories":["学习笔记"],"contents":"WebKit简介 {% github it-boyer WKWebView-JS d03bc0e width = 30% %} 自iOS8 以后，苹果推出了新框架 WebKit，提供了替换 UIWebView 的组件 WKWebView。各种 UIWebView 的性能问题没有了，速度更快了，占用内存少了，体验更好了，下面列举一些其它的优势: 1、在性能、稳定性、功能方面有很大提升（加载速度，内存的提升谁用谁知道） 2、更多的支持 HTML5 的特性 3、官方宣称的高达60fps的滚动刷新率以及内置手势 4、Safari 相同的 JavaScript 引擎 5、将 UIWebViewDelegate 与 UIWebView 拆分成了14类与3个协议，包含该更细节功能的实现。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 title WKWebView和JS脚本 center header 了解传参原理和交互机制 endheader \u0026#39;******* 类声明模块 *******\u0026#39; \u0026#39;类型:class,abstract,interface,annotation,enum\u0026#39; \u0026#39;访问域:(-)私有,(#)保护,(~)包私有,(+)公有\u0026#39; \u0026#39;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp; 类组合模块 类模块 \u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026amp;\u0026#39; \u0026#39;六种组合样式:Node,Rectangle,Folder,Frame,Cloud,Database\u0026#39; package \u0026#34;iOS原生API\u0026#34;\u0026lt;\u0026lt;Folder\u0026gt;\u0026gt;{ class WK\u0026lt;WKWebView\u0026gt;{ __ 方法组 __ + (id)initWithFrame:configuration: + (void)evaluateJavaScript:completionHandler: } class config\u0026lt;WKWebViewConfiguration\u0026gt;{ -- 属性组 -- + WKUserContentController *userContentController __方法组__ +(id)init } class userCC\u0026lt;WKUserContentController\u0026gt;{ __方法组__ +(void)addScriptMessageHandler:name: +(void)addUserScript: } class delegate\u0026lt;WKScriptMessageHandler\u0026gt;{ --代理方法-- +(void)userContentController:didReceiveScriptMessage: } class script\u0026lt;WKUserScript\u0026gt;{ --构造器-- + (id)initWithSource:injectionTime:forMainFrameOnly:; } } package JS脚本 \u0026lt;\u0026lt;Folder\u0026gt;\u0026gt; #red{ class js脚本{ --配置组-- messageHandlers:js接口名 postMessage参数 } } \u0026#39;###### 类备注模块 类声明末尾使用:note 位置: 备注#########\u0026#39; note top of WK 浏览器主体 end note note right of config #gray 用于在构造WK时，预加载js脚本，设置监听JS接口清单 end note note bottom of userCC:1.提供预加载JS脚本操作\\n2.在OC中添加监听的接口清单：JS脚本的接口名\\n3.注入代理类 note top of js脚本: 调用原生\\n window.webkit.messageHandlers.js接口名.postMessage(参数)\\n 参数为id类型，当无参调用时，参数设置为null note right of delegate:代理方法：拦截监听JS接口，获取JS传递的参数值\\n在回调中获取该参数值：message.body \u0026#39;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt; 类关系图及连接备注模块 \u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026gt;\u0026#39; \u0026#39;关系节点符:(|\u0026gt;)继承,(*)合成 ,(o)聚合, 其他#,x,},+,^ 连线符:(--)实线 ，(..)虚线\u0026#39; WK\u0026#34;1\u0026#34; *-[#red]- \u0026#34;1\u0026#34; config:构造参数 \u0026lt; note right on link #white 构造WK时，配置webView的预设条件 end note config *-[#green]- userCC:核心组件 \u0026lt; script o-left[#red]- js脚本:浏览器预加载JS脚本 \u0026lt; WK o-left[#red]- js脚本:浏览器调用JS脚本 \u0026lt; userCC *-[#blue] delegate:处理监听到的JS脚本 \u0026lt; delegate \u0026lt;|.left[#black]. WK: 代理类 \u0026lt; userCC o-left[#gray]- script:注入脚本 \u0026lt; center footer boyer模型 endfooter 添加监听代理和JS接口 在OC中添加监听的接口清单：以JS脚本的接口showMobile为例：\n1 2 3 4 WKWebViewConfiguration *config = [[WKWebViewConfiguration alloc] init]; WKUserContentController *userCC = config.userContentController; //MARK:在OC中添加监听的接口清单：JS脚本的接口名 [userCC addScriptMessageHandler:self name:@\u0026#34;showMobile\u0026#34;]; 设置WKUserContentController的代理 设置代理类遵守WKScriptMessageHandler协议 1 @interface ViewController () \u0026lt;WKScriptMessageHandler\u0026gt; 注册对JS接口监听，注入代理类 1 [userCC addScriptMessageHandler:self name:@\u0026#34;showMobile\u0026#34;]; 实现WKUserContentController代理的回调方法,响应JS接口事件 1 2 3 - (void)userContentController:(WKUserContentController *)userContentController didReceiveScriptMessage:(WKScriptMessage *)message { NSLog(@\u0026#34;%@\u0026#34;,message.body); } JS脚本接口 js接口声明格式：\n1 window.webkit.messageHandlers.接口名.postMessage(\u0026#39;参数\u0026#39;) 接口名: 在WKWebView中，当JS执行该接口时，OC会拦截预先监听的接口，并处理相关事件。\n参数：object类型，多个参数时需要封装为集合类型来实现多参传递。\n当OC拦截到该接口时，可以在WKScriptMessageHandler回调方法中的WKScriptMessage参数实例中获取该参数值: message.body。\n三个例子：\nJS无参调用OC 当无参调用OC时，参数必须为null 1 window.webkit.messageHandlers.showMobile.postMessage(null) JS传参调用OC 传递单个参数时，直接写入即可，例如：xiao黄 1 window.webkit.messageHandlers.showName.postMessage(\u0026#39;xiao黄\u0026#39;) 传递多个参数时，需要封装为集合类型实现多参传递。 例如:当传递一个电话，一条信息，需要封装为['13300001111','Go Climbing This Weekend !!!']\n1 window.webkit.messageHandlers.showSendMsg.postMessage([\u0026#39;13300001111\u0026#39;, \u0026#39;Go Climbing This Weekend !!!\u0026#39;]) iOS原生API调用JS脚本 在网页加载完成之后调用JS代码才会执行，因为这个时候html页面已经注入到webView中并且可以响应到对应方法。 例如调用JS函数alertMobile()：\n1 2 3 4 [self.wkWebView evaluateJavaScript:@\u0026#34;alertMobile()\u0026#34; completionHandler:^(id _Nullable response, NSError * _Nullable error) { //TODO NSLog(@\u0026#34;%@ %@\u0026#34;,response,error); }]; 在OC中为JS定义属性/函数 当注入的类型字符串类型时，必须用''括起来。 OC注入的参数为全局属性，在html中的JS脚本可以直接调用属性名来获取值。 通过NSString形式，编写JS脚本，通过以下两种方式注入网页\n方式一：在初始化WKWebView时，通过配置WKWebViewConfiguration\u0026gt;userContentController注入JS脚本 。\n1 2 3 4 5 6 //MARK:向网页中注入JS脚本例如，参数/函数等 WKUserScript *script = [[WKUserScript alloc] initWithSource:@\u0026#34;var number=0;\u0026#34; injectionTime:WKUserScriptInjectionTimeAtDocumentStart forMainFrameOnly:YES]; WKUserContentController *userCC = config.userContentController; [userCC addUserScript:script]; 方式二：使用WKWebView实例方法evaluateJavaScript动态注入JS脚本\n1 [self.wkWebView evaluateJavaScript:@\u0026#34;var number=0;\u0026#34; completionHandler:nil]; iOS原生API调用JS函数 使用WKWebView实例方法evaluateJavaScript动态调用JS函数\n1 [self.wkWebView evaluateJavaScript:@\u0026#34;alertSendMsg(\u0026#39;18870707070\u0026#39;,\u0026#39;下午好！\u0026#39;)\u0026#34; completionHandler:nil]; ","date":"2017-07-07T09:54:41Z","permalink":"https://it-boyer.github.io/post/old/iOS/UI/WKWebView%E6%8E%A7%E4%BB%B6%E5%92%8CJS%E8%84%9A%E6%9C%AC%E4%BC%A0%E5%8F%82%E5%8F%8A%E4%BA%A4%E4%BA%92/","section":"post","tags":["JS"],"title":"WKWebView控件和JS脚本传参及交互"},{"categories":["解决方案"],"contents":"使用:map命令，可以将键盘上的某个按键与Vim的命令绑定起来。 例如使用以下命令，可以通过F5键将单词用花括号括起来：\n1 :map \u0026lt;F5\u0026gt; i{e\u0026lt;Esc\u0026gt;a}\u0026lt;Esc\u0026gt; 执行过程：i{将插入字符{，然后使用Esc退回到命令状态；接着用e移到单词结尾，a}增加字符}，最后退至命令状态。 在执行以上命令之后，光标定位在一个单词上（例如amount），按下F5键，这时字符就会变成{amount}的形式。\n不同模式下的键盘映射 使用下表中不同形式的map命令，可以针对特定的模式设置键盘映射：\nCommand 命令 Normal 常规模式 Visual可视化模式 Operator Pending运算符模式 Insert Only插入模式 Command Line 命令行模式 :map y y y :nmap y :vmap y :omap y :map! y y :imap y :cmap y 查看键盘映射 1 :map 取消键盘映射 1 :unmap \u0026lt;F10\u0026gt; #参数 注意：必须为:unmap命令指定一个参数。如果未指定任何参数，那么系统将会报错，而不会取消所有的键盘映射。 针对不同模式下的键盘映射，需要使用与其相对应的unmap命令。例如：使用:iunmap命令，取消插入模式下的键盘映射；而取消常规模式下的键盘映射，则需要使用:nunmap命令。 如果想要取消所有映射，可以使用:mapclear命令。请注意，这个命令将会移除所有用户定义和系统默认的键盘映射。\n参考文章 VIM键盘映射 (Map) Vim按键映射\n","date":"2017-07-04T15:06:52Z","permalink":"https://it-boyer.github.io/post/old/shell/vim%E7%BC%96%E8%BE%91%E5%99%A8%E9%94%AE%E7%9B%98%E6%98%A0%E5%B0%84%E5%91%BD%E4%BB%A4map/","section":"post","tags":["shell"],"title":"vim编辑器键盘映射命令map"},{"categories":["解决方案"],"contents":"参考\n基本操作 基本概念 动作：是指移动光标的操作，你肯定很熟悉 h、j、k 和 l，以及 w 和 b。但其实，/ 也是一个动作。\n1 :h navigation 操作符： 对某个区域文本执行的操作。比如，d、~、gU 和 \u0026gt; 都是操作符。这些操作符既可以在普通模式下使用，也可以在可视模式下使用。\n1 :h operator 文本对象：\n1 :h text-objects 缓冲区列表 缓冲区的几种状态：已激活，已载入，已列出，已命名\n1 2 :ls #列出所有可以列出的缓冲区 :ls! #命令可以显示被放入缓冲区列表的和未被放入列表的缓冲区 创建一个无名临时缓冲区\n1 :enew 激活一个缓冲区\n1 :e file2 命名一个缓冲区\n1 :w /path/file #存储位置 参数列表 1 :h argument-list 操作命令范围概念 关键字符：,|;|数字|$|%\n跳转历史和变更历史 1 2 3 4 :jumps :changes :h changelist :h jumplist 常用命令 space-Vim使用文档 空格 f t 打开/关闭树型栏 SPC f R 刷新文件结构目录 , f c unite命令集合快速查找命令集 SPC b h 返回vim主页 SPC f r 最近打开过的文件清单\nmarkdown插件命令 ,1..3 快速标题格式###生成章节 ,ct 在当前位置插入所有章节的清单 ,cs 新建窗口显示博客章节目录清单,支持编辑时跳转到指定的章节位置 ,cp 预览博客发布的效果\ngit插件命令 SPC g s git status SPC g d git diff AsyncRun git add file git add file SPC g c git commit SPC g p git push\nunite Vim插件：Unite新手指导(译) Unite可以在一个项目中快速浏览文件。但是它不仅限于文件，其他任何可以列出的东西都可以很好的被显示和搜索。这个开放式的特性很可能是人们找到它的原因\n用法 Unite命令采用的格式为:Unite source，其中\u0026quot;source\u0026quot;是buffer，file和file_rec其中之一。\nbuffer: 浏览当前打开的buffer列表 file: 浏览当前目录的文件列表 file_rec: 递归的列出当前目录的文件 当一个命令被使用，一个新的水平分割窗口会被打开。 比如，命令:Unite file将会显示当前目录的文件列表。在这个窗口中，标准的Vim命令模式下的命令可以使用。可以使用“j”和“k”浏览该列表，可以使用“/”来查询。如果你在一个文件上按下enter键，Unite将会打开它。如果光标是在一个目录上，Unite将会进入该目录，并且更新该文件列表。 使用NERO Tree命令 查看帮助命令\n1 ? 将选中的目录变为根目录：\n1 C # change tree root to the selected dir 模式 插入搜索模式 如果你在Unite窗口进入插入模式，光标将会移到该窗口的最上方，并显示“\u0026gt;”提示符。输入字符会搜索该列表\u0026ndash;这里和FuzzyFinder相似。和常规vim一样，按键可以退出插入模式回到命令模式。\n命令模式 在命令模式下，当光标在一个文件上，按下a，Unite会显示一个可以操作该文件命令的列表。这个命令列表被称为actions，这个列表可以像Unite其他部分一样被搜索和调用。\n操作 actions可以组合通配符。如果输入:Unite file, 然后按下*将会标记所有文件，再输入a将会列出所有actions，最后选择above，Unite将会打开所有被标记的文件。\n单行操作 光标移动 hjkl (强例推荐使用其移动光标，但不必需) →你也可以使用光标键 (←↓↑→). 注: j 就像下箭头。\n单词移动： 1.一个单词由字母，数字和下划线组成，那么就用小写的e和w。即：程序变量移动。 2.单词是由blank字符分隔符，那么就用大写的E和W。 即：程序语句移动。 1 2 3 w → 到下一个单词的开头。 e → 到下一个单词的结尾。 b → 到前一个单词的开头。 本行移动： 1 2 3 4 0 → 数字零，到行头 ^ → 到本行第一个不是blank字符的位置（所谓blank字符就是空格，tab，换行，回车等） $ → 到本行行尾 g_ → 到本行最后一个不是blank字符的位置。 行间移动： 1 2 3 NG → 到第 N 行 （陈皓注：注意命令中的G是大写的，另我一般使用 : N 到第N行，如 :137 到第137行） gg → 到第一行。（陈皓注：相当于1G，或 :1） G 到最后一行 多行范围 范围 (Ranges) 其实很好理解，但很多 Vim 用户的理解不到位。\n很多命令都可以加一个数字，用于指明操作范围 范围可以是一个行号，用于指定某一行 范围也可以是一对通过 , 或 ; 分割的行号 大部分命令，默认只作用于当前行 只有 :write 和 :global 是默认作用于所有行的 范围的使用是十分直观的。以下为一些例子（其中，:d 为 :delete 的缩写）：\n命令 操作的行 :d 当前行 :.d 当前行 :1d 第一行 :$d 最后一行 :1,$d 所有行 :%d 所有行（这是 1,$ 的语法糖） :.,5d 当前行至第 5 行 :,5d 同样是当前行至第 5 行 :,+3d 当前行及接下来的 3 行 :1,+3d 第一行至当前行再加 3 行 :,-3d 当前行及向上的 3 行（Vim 会弹出提示信息，因为这是一个保留的范围） :3,'xdelete 第三行至标注 为 x 的那一行 :/^foo/,$delete 当前行以下，以字符 \u0026ldquo;foo\u0026rdquo; 开头的那一行至结尾 :/^foo/+1,$delete 当前行以下，以字符 \u0026ldquo;foo\u0026rdquo; 开头的那一行的下一行至结尾 需要注意的是，; 也可以用于表示范围。区别在于，a,b 的 b 是以当前行作为参考的。而 a;b 的 b 是以 a 行作为参考的。举个例子，现在你的光标在第 5 行。这时 :1,+1d 会删除第 1 行至第 6 行，而 :1;+1d 会删除第 1 行和第 2 行。\n可视化区域选择并编辑文本 1.区域选择其命令格式：\n\u0026lt;action\u0026gt;a\u0026lt;object\u0026gt; 或 \u0026lt;action\u0026gt;i\u0026lt;object\u0026gt; 在visual 模式下，这些命令很强大。\naction可以是任何的命令，如 d (删除), y (拷贝),v (可以视模式选择)。 object 可能是： w 一个单词， W 一个以空格为分隔的单词， s 一个句字， p 一个段落。也可以是一个特别的字符：\u0026quot;、 \u0026lsquo;、 )、 }、 ]。\n示例： 假设你有一个字符串 (map (+) (\u0026ldquo;foo\u0026rdquo;)).而光标键在第一个 o 的位置。\n1 2 3 4 5 6 vi\u0026#34; → 会选择 foo. va\u0026#34; → 会选择 \u0026#34;foo\u0026#34;. vi) → 会选择 \u0026#34;foo\u0026#34;. va) → 会选择(\u0026#34;foo\u0026#34;). v2i) → 会选择 map (+) (\u0026#34;foo\u0026#34;) v2a) → 会选择 (map (+) (\u0026#34;foo\u0026#34;)) 2.可视化选择： v,V,\n前面，我们看到了 的示例 （在Windows下应该是），我们可以使用 v 和 V。一但被选好了，你可以做下面的事：\n1 2 3 J → 把所有的行连接起来（变成一行） \u0026lt; 或 \u0026gt; → 左右缩进 = → 自动给缩进 （陈皓注：这个功能相当强大，我太喜欢了） 3.在所有被选择的行后加上点东西：\n1 2 3 选中相关的行 (可使用 j 或 \u0026lt;C-d\u0026gt; 或是 /pattern 或是 % 等……) $ 到行最后 A, 输入字符串，按 ESC。 文本编辑 插入光标位置\n1 2 3 4 i → Insert 模式，按 ESC 回到 Normal 模式. a → 在光标后插入 o → 在当前行后插入一个新行 O → 在当前行前插入一个新行 操作文本：\n1.删除：字符，单词，行\nx → 删当前光标所在的一个字符。 cw → 替换从光标所在位置后到一个单词结尾的字符【准确的说是删除从光标位置到一个单词结尾的字符并进入插入模式】 dd → 删除当前行，并把删除的行存到剪贴板里 通过行号确定你要删除的行；\nset nu → 显示行号； :32,65d → 32-65行就被删除了 2.拷贝：单词，行，段\nye → 当前位置拷贝到本单词的最后一个字符。 yy → 拷贝当前行相当于 ddP（dd删除当前行，再粘贴） 0y$ → 拷贝当前行，即：光标移动组合操作格式：\u0026lt;start position\u0026gt;\u0026lt;command\u0026gt;\u0026lt;end position\u0026gt; y2/foo → 拷贝2个 “foo” 之间的字符串。 还有很多时候并不一定你就一定要按y才会拷贝，下面的命令也会被拷贝：\nd (删除 ) v (可视化的选择) gU (变大写) gu (变小写) 等等 注：可视化选择是一个很有意思的命令，你可以先按v，然后移动光标，你就会看到文本被选择，然后，你可能d，也可y，也可以变大写等\n3.粘帖：\n1 p/P → p是表示在当前位置之后，P表示在当前位置之前 ","date":"2017-07-04T10:09:29Z","permalink":"https://it-boyer.github.io/post/old/shell/vim%E7%BC%96%E8%BE%91%E5%99%A8%E7%9A%84%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/","section":"post","tags":["shell"],"title":"vim编辑器的基本用法"},{"categories":["解决方案"],"contents":"vim插件工具：Vundle\n主题色： |组合键 | Description| 空格 + T + n| 随机切换颜色主题。 SPC T s |使用unite buffer方式切换一个主题\n插件 Unite 预定义操作命令 Unite或unite.vim插件可以搜索和显示信息，例如：任意源文件、缓冲区的，最近使用的文件或记录。可以直接运行在Unite窗口中显示的几个预设操作。\nneocomplete 一个自动补全的插件，使用TAB或ENTER键来选择。 同时，它又额外附带了补全代码段的特性（模版补全），要想使用这种特性，必须安装另外的插件neosnippet或者ultisnips。 NERD Commenter 快速注释/解开注释\nGoyo and Limelight 干净模式和背景虚化。两者配合使用，效果非常好。vim 也可以很文艺\nBookmarks 插件旨在解决 Vim 自带书签无法高亮、无法持久化、难于记忆的问题，而且解决的非常漂亮. 下面列出其主要特性:\n单行书签切换 ⚑ 单行的注释(说明)书签 ☰ 在 quickfix 窗口中访问所有书签 书签自动保存，下次开启自动加载 针对工作目录的独立书签(可选) 高度可定制 可以和 Unite 插件的 quickfix 结合 不依赖 Vim 自身的 marks\nGita git插件\n其他插件 Key Mode Action +gu Normal Open undo tree +i Normal Toggle indentation lines +j Normal Start smalls +r Normal Quickrun +? Normal Dictionary +W Normal Wiki +K Normal Thesaurus\n","date":"2017-06-29T10:08:50Z","permalink":"https://it-boyer.github.io/post/old/shell/SourceKittenSwift%E8%AF%AD%E6%B3%95%E8%87%AA%E5%8A%A8%E8%A1%A5%E9%BD%90%E5%B7%A5%E5%85%B7/","section":"post","tags":["shell"],"title":"SourceKittenSwift语法自动补齐工具"},{"categories":["学习笔记"],"contents":"umlbot源码库\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 title 部署一台heroku机器人\\n支持在slack窗口实时绘制uml图 center header umlbot工具 endheader [slack] as slack cloud \u0026#34;heroku服务器\u0026#34;{ [umlbot] as umlbot [heroku] as hero umlbot -[#yellow]\u0026gt; hero: 部署机器人 hero -[#green]\u0026gt; umlbot: 原脚本 } umlbot -[#green]-\u0026gt; slack: 绘制UML slack -\u0026gt; hero: 输入hook用户数据\\nTOKEN hero --\u0026gt; slack: 机器人URL \u0026#39;注释模块\u0026#39; note right of umlbot : github源码库\\nhero支持github直接部署 note left of heroku服务器 #white: 运行umlbot机器人\\n 从slack获取源数据 note left of slack #red: 配置outgoing hook\\n输出:token\\n输入:机器人URL(s) \u0026#39;接口模块\u0026#39; ()\u0026#34;注册\u0026#34; --\u0026gt; hero: 部署前提 ()\u0026#34;部署\u0026#34; --\u0026gt; hero: 设置TOKEN note left of \u0026#34;注册\u0026#34; #green: 需要翻墙\\n\u0026#34;Please confirm you\u0026#39;re not a robot.\u0026#34; note right of \u0026#34;部署\u0026#34; #red: 设置**TOKEN**位置\\n通过readme提供的部署按钮\\n来实现设置token center footer 目前测试并没有实现slack绘制UML的效果 endfooter ","date":"2017-06-28T15:57:00Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/%E5%9C%A8slack%E4%B8%8A%E5%AE%9E%E7%8E%B0%E5%AE%9E%E6%97%B6%E7%BB%98UML%E5%9B%BE/","section":"post","tags":["UML"],"title":"在slack上实现实时绘UML图"},{"categories":["项目总结"],"contents":"支持OS X浏览PDF简单视图 运行scheme： PDFReaderForOSX 即可\n支持iOS pageViewController: pdf翻页效果视图控制器 startingViewController:DataViewController,翻页视图控制器的视图源 modelController:ModelController:NSObject,数据视图数据源的model模型。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 34 35 36 37 38 39 40 41 42 43 44 45 46 47 48 49 50 51 52 53 54 55 56 57 58 59 60 61 62 63 64 65 66 67 68 69 70 71 72 73 74 75 76 77 78 79 title 阅读器的内部结构图 center header 解析PDF目录，显示PDF页面 endheader class FileViewController\u0026lt;UIViewController\u0026gt;{ -- 属性组 -- +IBOutlet UIView *pdfView; +UIPageViewController *pageViewController; -startingViewController; __ 函数组 __ - (IBAction)ibaBookmarks:(UIButton *)sender; - (IBAction)ibaOutline:(UIButton *)sender; - (IBAction)ibSearchBtn:(id)sender; } class UIPageViewController\u0026lt;pageView\u0026gt;{ -- 属性组 -- +delegate; +dataSource; +view.frame; +gestureRecognizers; __ 函数组 __ +init() } class startingViewController\u0026lt;dataSource\u0026gt;{ __ 函数组 __ -(init)viewControllerAtIndex:storyboard: -- 搜索模块 -- -(void)restSearchResultColor:(NSString *)searchStr; } \u0026#39;关系层\u0026#39; startingViewController .left.\u0026gt; UIPageViewController:model聚合数据源 UIPageViewController ..\u0026gt;FileViewController:手势传递 note on link #red: 把翻页控制器的手势事件\\n传递给阅读器的PdfView中 FileViewController \u0026#34;1\u0026#34; *-[#blue]- \u0026#34;1\u0026#34;UIPageViewController note on link #blue: 构造实例为阅读器添加翻页功能 startingViewController .left[#gray].\u0026gt; \u0026#34;1\u0026#34;FileViewController:pageViewController的数据源 note on link #gray: 仅用于初始化第一次显示的PDF阅读器界面内容 FileViewController --\u0026gt; startingViewController: 搜索bar传递字符串 \u0026gt; note right of startingViewController #white: 1. 为翻页提供数据源\\n 2. 更新搜索字段颜色 note left of FileViewController #red : PDF阅读器主页面 note left of UIPageViewController : 实现翻页效果的控制器 class PDFParser\u0026lt;工具类\u0026gt;{ __ 函数组 __ -(id)initWithFileName:(NSString *)filename; -(id)initWithPDFDoc:(CGPDFDocumentRef)doc; -(NSArray *)getPDFContents; } class OutLine\u0026lt;UIViewController\u0026gt;{ __ 属性组 __ NSMutableArray *outlineEntries; NSMutableArray *openOutlineEntries; IBOutlet UITableView *outlineTableView; NSObject\u0026lt;MyOutlineViewControllerDelegate\u0026gt; *delegate; } \u0026#39;关系图\u0026#39; PDFParser --\u0026gt; OutLine:解析PDF文档获取目录结构 OutLine -.\u0026gt; FileViewController: 提供目录界面 note left of PDFParser #green 解析pdf目录结构的核心工具包 end note note right of OutLine #white : 创建目录界面\\n显示解析PDF目录工具中得到的数据 center footer 了解具体的项目结构 endfooter ","date":"2017-06-26T17:02:18Z","permalink":"https://it-boyer.github.io/post/old/iOS/PBBReader%E9%98%85%E8%AF%BB%E5%99%A8%E8%A7%A3%E6%9E%90/","section":"post","tags":["iOS"],"title":"PBBReader阅读器解析"},{"categories":["学习笔记"],"contents":"Perfect介绍 Perfect提供一系列代表请求和响应的对象组件，并允许在服务器上增加管理句柄用于产生页面内容。 所有对象都是在服务器对象创建后开始工作。服务器对象会被执行配置，随后会根据配置绑定并监听特定端口。一旦出现连接，服务器会读取请求数据，请求数据读取完成后，服务器会将request object请求对象传递给请求过滤器。\n请求过滤器 过滤器可能会根据需要修改查询请求。服务器会使用请求的URI路径检索routing请求／响应路由以获取处理该请求的具体句柄。如果找到了合适的处理句柄，服务器会传递给句柄对应的response object响应对象。当句柄反馈响应完成时，响应对象会被传递给响应过滤器。这些过滤器会根据需要修改最终输出的数据内容。最后响应结果数据会被推送给客户端浏览器，而客户端到服务器的连接或者被关闭、或者被拒绝维持HTTP持久连接、或者为后续请求和响应维持HTTP活动连接。\nHTTP请求/响应路由 HTTP请求/响应路由是用于决定在当前请求下，哪一个句柄去接收和响应。\n句柄:可以是一个函数、过程或者方法，只要能够接收特定类型的请求并做出反应即可。 路由:主要依据请求的方法HTTP request method和请求内容包括的路径信息来决定的。 1 2 3 4 routes.add(method: .post, uris: [\u0026#34;HostMonitor/client/log/addLog\u0026#34;]){ (request,response) in //处理请求,并响应请求 } URI路由变量 URI变量是用于处理动态请求的好方法。比如，一个包含用户id的URL可以用该方法实现相关请求的用户管理。 每个变量组件是通过一个程序块{ }声明的。在程序块中是变量名称。每个变量名称都可以使用出了括号}之外的任何字符。变量名有点像单功能通配符一样，这样就可以匹配任何符合变量模式的路径。 变量值:在匹配该模式下URL能够通过HTTPRequest.urlVariables字典查询变量值。该字典是[String:String]类型。 请求对象HTTPRequest 当处理一个HTTP请求时，所有客户端的互动操作都是通过HTTPRequest请求对象和HTTPResponse响应对象实现的。 HTTPRequest对象包含了客户端浏览器发过来的全部数据，包括请求消息头、查询参数、POST表单数据以及其它所有相关信息，比如客户IP地址和URL变量。\nHTTPRequest对象将采用application/x-www-form-urlencoded编码格式对客户请求进行解析解码。而如果请求中采用multipart/form-data“多段”编码方式，则HTTP请求可以把各种未处理的原始格式表单传输过来。当处理“多段”表单数据时，HTTPRequest对象会为请求上传的文件自动创建临时目录并执行解码。这些文件会在请求过程中一直保持直到请求处理完毕，随后自动被删除。\n以上涉及到的各种属性和函数都是HTTPRequest请求协议的部分内容。\n","date":"2017-06-26T17:01:24Z","permalink":"https://it-boyer.github.io/post/old/macOS/Perfect%E5%BC%80%E5%8F%91%E5%A4%A9%E6%B0%94%E6%8E%A5%E5%8F%A3API/","section":"post","tags":["swift"],"title":"Perfect开发天气接口API"},{"categories":["学习笔记"],"contents":"《搞定II》 前言 轻松实现轻松做事 第一部分 理清头绪，发挥创造力 第1章 理清思路，确立新方向 第2章 知道哪些事情自己尚未做，你才会为之心安 第3章 理清承担的任务，可以更好地选择新任务 第4章 要实现未来的目标，首先明确当前的位置 第5章 以有限的可能，去利用无限的机遇 第6章 一心二用带来压力与失败 第7章 有意识地权衡轻重缓急 第8章 完成未竟之事，释放自身能量 第9章 如果你一直想着某件事，很可能是还没有搞定 第10章 只要有空间，创造力就会展现 第11章 渠深流畅 第12章 担忧无益 第13章 你不是你的工作 第二部分 高效关注 第14章 想看得更清楚，请从更高处着眼 第15章 只有身体力行，你才会知道如何去做 第16章 工作足够努力是不可能的 第17章 精力随心思而动 第18章 目标越明确，实现目标的途径越多 第19章 精益求精 第20章 关注重心的变化等于结果的变化 第21章 视角是地球上最贵重的商品 第22章 多加思考 第23章 思考有度 第24章 效率是改善工作的唯一机会 第25章 关注一件事才能“全神贯注” 第26章 未来目标的价值，在于它当前培育的变化 第三部分 建立有效的制约机制 第27章 稳定带来创造力 第28章 形式与功能必须符合效率最高的原则 第29章 优化系统，放飞思想 第30章 反应能力提升生存能力 第31章 系统的强弱取决于最薄弱的环节 第32章 系统的效率与你的感知度成反比 第33章 功能取决于形式 第34章 目标明确才能赢得胜利 第35章 多人负责等于无人负责 第36章 确定原则，而不是监管制度 第37章 利用大脑来思考工作，而不是单纯关注工作 第38章 思考的价值超乎想象 第39章 资源越是有限，规划越有必要 第四部分 放松自我，开始工作 第40章 对自己做的事情承担起责任 第41章 过度控制等于失去控制 第42章 进展越好，状态越好 第43章 相信自己的行动选择，需要多层面的自我管理 第44章 你的力量取决于你的放松能力 第45章 预料之内的意外算不上意外 第46章 目光越长远，进展越顺畅 第47章 放慢速度以提升速度 第48章 你没有时间做任何项目 第49章 坚持做好小事，就能产生重大影响 第50章 亲力亲为才能了解事物 第51章 动中求变更容易 第52章 最伟大的成功源自最惨重的失败 第五部分 注意基本要素 工作流程的5个阶段 处理与组织整理流程图 自然式计划模式 每周回顾指南 后记 致谢 {%pdf /images/搞定2提升工作与生活效率的52项原则.pdf %}\n","date":"2017-06-26T10:41:37Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9A2%E6%8F%90%E5%8D%87%E5%B7%A5%E4%BD%9C%E4%B8%8E%E7%94%9F%E6%B4%BB%E6%95%88%E7%8E%87%E7%9A%8452%E9%A1%B9%E5%8E%9F%E5%88%99/","section":"post","tags":["图书"],"title":"搞定2提升工作与生活效率的52项原则"},{"categories":["学习笔记"],"contents":"资源 Core ML开发文档 ML模型资源页面 在Working with Models中包含有几个常用的模型模板，例如用于在图片中检测物体——树、动物、人等等。 Integrating a Core ML Model into Your App\n官方Core ML文档示例 App MarsHabitatPricePredictor 模型的输入只是数字，因此代码直接使用生成的 MarsHabitatPricer 方法和属性，而不是将模型包装在 Vision 模型中。每次都改一下参数，很容易看出模型只是一个线性回归： 137 * solarPanels + 653.50 * greenHouses + 5854 * acres\n配置 ：将 Core ML 模型集成到你的 App 本教程使用 Places205-GoogLeNet 模型，可以从苹果的ML页面下载。往下滑找到 Working with Models，下载第一个。还在这个页面，注意一下其它三个模型，它们都用于在图片中检测物体——树、动物、人等等。\n注意：如果你有一个训练过的模型，并且是使用受支持的机器学习工具训练的，例如 Caffe、Keras 或 scikit-learn，Converting Trained Models to Core ML 介绍了如何将其转换为 Core ML 格式。\n添加模型 下载 GoogLeNetPlaces.mlmodel 后，把它从 Finder 拖到项目导航器的 Resources 组里： 生成模型类 选择该文件，然后等一会儿。Xcode 生成了模型类后会显示一个箭头： 查看模型类 点击箭头，查看生成的类： 三个类： GoogLeNetPlaces: 主类，包含一个 model 属性和两个 prediction 方法 GoogLeNetPlacesInput: 输入类,包含一个 CVPixelBuffer 类型的 sceneImage 属性，Vision 框架会负责把我们熟悉的图片格式转换成正确的输入类型。 GoogLeNetPlacesOutput：输出属性,Vision 框架会将 GoogLeNetPlacesOutput 属性转换为自己的 results 类型. 实现Vision工作流程 标准的 Vision 工作流程是创建模型，创建一或多个请求，然后创建并运行请求处理程序。 并管理对 prediction 方法的调用，所以在所有生成的代码中，我们只会使用 model 属性。\n创建模型：在 Vision Model 中包装 Core ML Model CoreML模型 是用于 Vision 请求的 Core ML 模型的容器 打开 ViewController.swift，并在 import UIKit 下面 import 两个框架： 1 2 import CoreML import Vision 创建VNCoreMLRequest图像分析请求 VNCoreMLRequest 是一个图像分析请求，它使用 Core ML 模型来完成工作。它的 completion handler 接收 request 和 error 对象。 Core ML 模型GoogLeNetPlaces 是一个分类器，因为它仅预测一个特征：图像的场景分类。这时request.results 是 VNClassificationObservation 对象数组。 1 2 3 4 5 6 7 8 9 10 11 12 13 // 创建一个带有 completion handler 的 Vision 请求 let request = VNCoreMLRequest(model: model) { [weak self] request, error in guard let results = request.results as? [VNClassificationObservation], let topResult = results.first else { fatalError(\u0026#34;unexpected result type from VNCoreMLRequest\u0026#34;) } // 在主线程上更新 UI let article = (self?.vowels.contains(topResult.identifier.first!))! ? \u0026#34;an\u0026#34; : \u0026#34;a\u0026#34; DispatchQueue.main.async { [weak self] in self?.answerLabel.text = \u0026#34;\\(Int(topResult.confidence * 100))% it\u0026#39;s \\(article) \\(topResult.identifier)\u0026#34; } } VNClassificationObservation 有两个属性：identifier - 一个 String，以及 confidence - 介于0和1之间的数字，这个数字是是分类正确的概率。使用对象检测模型时，你可能只会看到那些 confidence 大于某个阈值的对象，例如 30％ 的阈值。 然后取第一个结果，它会具有最高的 confidence 值，然后根据 identifier 的首字母把不定冠词设置为“a”或“an”。最后，dispatch 回到主线程来更新 label。你很快会明白分类工作为什么不在主线程，因为它会很慢。\n创建并运行VNImageRequestHandler请求处理程序 VNImageRequestHandler 是标准的 Vision 框架请求处理程序；不特定于 Core ML 模型。给它 image 作为 detectScene(image:) 的参数。然后调用它的 perform 方法来运行处理程序，传入请求数组。在这个例子里，我们只有一个请求。 把下面几行添加到 detectScene(image:) 的末尾：\n1 2 3 4 5 6 7 8 9 // 在主线程上运行 Core ML GoogLeNetPlaces 分类器 let handler = VNImageRequestHandler(ciImage: image) DispatchQueue.global(qos: .userInteractive).async { do { try handler.perform([request]) } catch { print(error) } } 使用模型来自动识别场景 在两个地方调用 detectScene(image:) 把下面几行添加到 viewDidLoad() 的末端和 imagePickerController(_:didFinishPickingMediaWithInfo:) 的末端：\n1 2 3 4 5 guard let ciImage = CIImage(image: image) else { fatalError(\u0026#34;couldn\u0026#39;t convert UIImage to CIImage\u0026#34;) } detectScene(image: ciImage) 现在构建并运行。\n场景一: 机器识别出了50%的概率是摩天大厦 场景二 机器人识别出了75%的概率是水族池 什么是深度学习 自20世纪50年代以来，AI 研究人员开发了许多机器学习方法。苹果的 Core ML 框架支持神经网络、树组合、支持向量机、广义线性模型、特征工程和流水线模型。但是，神经网络最近已经取得了很多极为神奇的成功，开始于 2012 年谷歌使用 YouTube 视频训练 AI 来识别猫和人。仅仅五年后，谷歌正在赞助一场确定 5000 种植物和动物的比赛。像 Siri 和 Alexa 这样的 App 也存在它们自己的神经网络。 神经网络尝试用节点层来模拟人脑流程，并将节点层用不同的方式连接在一起。每增加一层都需要增加大量计算能力：Inception v3，一个对象识别模型，有48层以及大约2000万个参数。但计算基本上都是矩阵乘法，GPU 来处理会非常有效。GPU 成本的下降使我们能够创建多层深度神经网络，此为深度学习。 神经网络，circa 2016 神经网络需要大量的训练数据，这些训练数据理想化地代表了全部可能性。用户生成的数据爆炸性地产生也促成了机器学习的复兴。 训练模型意味着给神经网络提供训练数据，并让它计算公式，此公式组合输入参数以产生输出。训练是离线的，通常在具有多个 GPU 的机器上。 要使用这个模型，就给它新的输入，它就会计算输出：这叫做推论。推论仍然需要大量计算，以从新的输入计算输出。因为有了 Metal 这样的框架，现在可以在手持设备上进行这些计算。 在本教程的结尾你会发现，深度学习远非完美。真的很难建立具有代表性的训练数据，很容易就会过度训练模型，以至于它会过度重视一些古怪的特征。 苹果提供了什么？ 苹果在 iOS 5 里引入了 NSLinguisticTagger 来分析自然语言。iOS 8 出了 Metal，提供了对设备 GPU 的底层访问。 去年，苹果在 Accelerate 框架添加了 Basic Neural Network Subroutines (BNNS)，使开发者可以构建用于推理（不是训练）的神经网络。 今年，苹果给了我们 Core ML 和 Vision！ Core ML 让我们更容易在 App 中使用训练过的模型。 Vision 让我们轻松访问苹果的模型，用于面部检测、面部特征点、文字、矩形、条形码和物体。 你还可以在 Vision 模型中包装任意的图像分析 Core ML 模型，我们在这篇教程中就干这个。由于这两个框架是基于 Metal 构建的，它们能在设备上高效运行，所以不需要把用户的数据发送到服务器。\n","date":"2017-06-24T22:10:44Z","permalink":"https://it-boyer.github.io/post/old/iOS/CoreML%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0%E5%88%9D%E7%BA%A7%E6%95%99%E7%A8%8B/","section":"post","tags":["CoreML"],"title":"CoreML机器学习初级教程"},{"categories":["学习笔记"],"contents":"{% pdf http://p27uwfdhv.bkt.clouddn.com/static/pdf/PlantUML_Language_Reference_Guide_ZH.pdf %}\n","date":"2017-06-24T18:08:49Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/plantuml%E8%AF%AD%E6%B3%95%E6%A6%82%E8%A7%88/","section":"post","tags":["UML"],"title":"plantuml语法概览"},{"categories":["学习笔记"],"contents":"MarkDown插件 {% github bubkoo hexo-filter-sequence 4ab9c15 width = 30% %} 这个插件在markdown暂时无法渲染出图像，不建议使用。\n官方 序列图预览工具\n概述 序列图(sequence diagram)，又称时序图。\n通过描述对象之间发送消息的时间顺序 显示多个对象之间的动态协作 元素 =====\n1 2 3 Alice-\u0026gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u0026gt;Alice: I am good thanks! 角色Actor 系统角色。 http://blog.csdn.net/ethmery/article/details/50670284\n标题 MarkDown语法：\n1 Title:[标题] 对象Object 位于序列图顶部，代表参与交互行为的对象。常见的命名方式：\n类名+对象名 类名，无对象名（匿名对象） 对象名，无类名 对象(object)是对客观事物的抽象，类(class)是对对象的抽象。 一个对象可以通过发送消息来创建另一个对象 一个对象可以被删除/自我删除，此时以”×”表示 MarkDown语法： 声明一个或多个对象 1 2 participant [对象名1] participant [对象名2] 1 2 3 4 5 6 participant A participant B Note left of A: 这是对A的注释 Note right of B: 这是对B的注释 Note over A: 这是A上的注释 Note over A,B: 这是A和B共有的注释 为对象添加注释 1 2 3 Note left/right to [对象名]: [注释] Note over [对象名]: [注释] Note over [多个对象，之间以,隔开]: [注释] 生命线Lifeline 序列图中的对象在一段时间内的存在 以从对象底部中心延伸出的竖直虚线表示 对象之间的消息传递发生于生命线之间 激活期Activation 序列图中的对象执行一项操作的时期 或执行其自身的代码 或等待另一个对象的返回信息 以生命线上相应时间段内窄矩形表示 消息Message 用于对对象间通信内容进行建模的类 以垂直于生命线的单方向箭头表示 消息包含内容： 消息名称 消息参数 可能带有条件表达式，以确定是否发送/发送分支 MarkDown语法： 语法格式： 1 [发送对象][箭头符号][接收对象]: [消息] 效果实现： 1 2 3 4 A-\u0026gt;B: -\u0026gt; B--\u0026gt;C: --\u0026gt; B-\u0026gt;\u0026gt;A: -\u0026gt;\u0026gt; C--\u0026gt;\u0026gt;A: --\u0026gt;\u0026gt; 定义箭头语法： -\u0026gt; 实线黑色三角箭头 –-\u0026gt; 虚线黑色三角箭头 -\u0026raquo; 实线开放箭头 –-\u0026raquo; 虚线开放箭头 消息显示顺序与代码中消息编写顺序一致 ","date":"2017-06-24T16:00:03Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/%E5%BA%8F%E5%88%97%E5%9B%BEsequencediagram%E8%AF%AD%E6%B3%95/","section":"post","tags":["UML"],"title":"序列图sequence语法插件"},{"categories":["博客站务"],"contents":"基本格式 http://blog.csdn.net/KimBing/article/details/52934959?locationNum=2\u0026amp;fps=1\n对象 六种对象：开始对象，结束对象，操作对象，条件对象，输入对象，子任务对象 1 对象变量=\u0026gt;[start|end|operation|condition|inputoutput|subroutine]:[描述信息] 流程控制语法 流程控制三要素：位置、方向，条件 1 2 条件对象(YES/NO/消息)-\u0026gt; 其他对象 操作对象(left/right/top)-\u0026gt; 其他对象 样例\n1 2 3 4 5 6 7 8 9 10 //结构模块 st=\u0026gt;start: 开始 e=\u0026gt;end: 结束 op=\u0026gt;operation: 我的操作 cond=\u0026gt;condition: 确认？ //流程控制模块 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;op 效果：\n1 2 3 4 5 6 7 8 9 10 //结构模块 st=\u0026gt;start: 开始 e=\u0026gt;end: 结束 op=\u0026gt;operation: 我的操作 cond=\u0026gt;condition: 确认？ //流程模块 st-\u0026gt;op-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;op ","date":"2017-06-24T15:32:41Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/flowchart%E6%B5%81%E7%A8%8B%E5%9B%BE%E8%AF%AD%E6%B3%95/","section":"post","tags":["UML"],"title":"flowchart流程图语法"},{"categories":["博客站务"],"contents":"安装插件 //保证格式正确：\u0026ldquo;插件名\u0026rdquo;: \u0026ldquo;^版本号\u0026rdquo;,\n方式一通过package.json 新增插件库 //保证格式正确：\u0026ldquo;插件名\u0026rdquo;: \u0026ldquo;^版本号\u0026rdquo;, 1 2 3 4 \u0026#34;hexo-filter-plantuml\u0026#34;: \u0026#34;^1.0.1\u0026#34;, \u0026#34;hexo-filter-sequence\u0026#34;: \u0026#34;^1.0.3\u0026#34;, \u0026#34;hexo-tag-plantuml\u0026#34;: \u0026#34;^1.0.0\u0026#34;, \u0026#34;hexo-pdf\u0026#34;: \u0026#34;^1.1.1\u0026#34; 如何插件版本号：可以在插件的github库文件package.json中得到。\n执行安装：\n1 sudo npm install 方式二: 安装单个插件 即下文的作图插件说明中使用的安装方式 举例：作图插件 flowchart流程图 sequence队列图 plantuml类图 plantuml hexo-filter-plantuml 安装：\n1 npm install --save hexo-filter-plantuml hexo使用语法：\n1 2 3 @startuml class A @enduml 1 2 3 @startuml class A @enduml 效果图：\nhexo-filter-sequence sequence\n安装：\n1 npm install --save hexo-filter-sequence 配置 _config.yml:\n1 2 3 4 5 6 7 8 9 sequence: # webfont: # optional, the source url of webfontloader.js # snap: # optional, the source url of snap.svg.js # underscore: # optional, the source url of underscore.js # sequence: # optional, the source url of sequence-diagram.js # css: # optional, the url for css, such as hand drawn theme options: theme: css_class: hexo使用语法：\n1 2 3 Alice-\u0026gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u0026gt;Alice: I am good thanks! 1 2 3 Alice-\u0026gt;Bob: Hello Bob, how are you? Note right of Bob: Bob thinks Bob--\u0026gt;Alice: I am good thanks! 效果图：\nhexo-filter-flowchart 安装：\n1 npm install --save hexo-filter-flowchart hexo使用语法：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank] e=\u0026gt;end: End:\u0026gt;http://www.google.com op1=\u0026gt;operation: My Operation|past op2=\u0026gt;operation: Stuff|current sub1=\u0026gt;subroutine: My Subroutine|invalid cond=\u0026gt;condition: Yes or No?|approved:\u0026gt;http://www.google.com c2=\u0026gt;condition: Good idea|rejected io=\u0026gt;inputoutput: catch something...|request st-\u0026gt;op1(right)-\u0026gt;cond cond(yes, right)-\u0026gt;c2 cond(no)-\u0026gt;sub1(left)-\u0026gt;op1 c2(yes)-\u0026gt;io-\u0026gt;e c2(no)-\u0026gt;op2-\u0026gt;e 效果图：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 st=\u0026gt;start: Start|past:\u0026gt;http://www.google.com[blank] e=\u0026gt;end: End:\u0026gt;http://www.google.com op1=\u0026gt;operation: My Operation|past op2=\u0026gt;operation: Stuff|current sub1=\u0026gt;subroutine: My Subroutine|invalid cond=\u0026gt;condition: Yes or No?|approved:\u0026gt;http://www.google.com c2=\u0026gt;condition: Good idea|rejected io=\u0026gt;inputoutput: catch something...|request st-\u0026gt;op1(right)-\u0026gt;cond cond(yes, right)-\u0026gt;c2 cond(no)-\u0026gt;sub1(left)-\u0026gt;op1 c2(yes)-\u0026gt;io-\u0026gt;e c2(no)-\u0026gt;op2-\u0026gt;e 插件hexo-pdf 安装：\n1 npm install --save hexo-pdf hexo使用语法：\n普通 PDF 1 {% pdf http://7xov2f.com1.z0.glb.clouddn.com/bash_freshman.pdf %} 相对路径 1 {% pdf ./bash_freshman.pdf %} 支持Google盘/Slideshare 1 {% pdf https://drive.google.com/file/d/0B6qSwdwPxPRdTEliX0dhQ2JfUEU/preview %} Slideshare\n1 {% pdf http://www.slideshare.net/slideshow/embed_code/key/8Jl0hUt2OKUOOE %} 预览： \u0026ldquo;hexo-tag-plantuml\u0026rdquo;\n","date":"2017-06-24T11:59:03Z","permalink":"https://it-boyer.github.io/post/old/hexo/Hexo%E5%8A%9F%E8%83%BD%E6%8F%92%E4%BB%B6/","section":"post","tags":["hexo"],"title":"Hexo功能插件"},{"categories":["解决方案"],"contents":"截取字符串 %+字符+正则表达式 删除字符及右边内容，从源字符串右边开始匹配 % 单井号表示一旦匹配成功立即删除 %% 双井号表示一直等相匹配到最后一个字符时再删除 #+正则表达式+字符 删除字符及左边内容，从源字符串左边开始匹配 # 单井号表示一旦匹配成功立即删除 ## 双井号表示一直等相匹配到最后一个字符时再删除 实例 从line指定的路径中截取两个信息，类别和文件名称\n1 line=\u0026#34;shell/shell命令处理字符串.md\u0026#34; 截取文件类别：shell 删除最右边的“/shell命令处理字符串.md” 1 categories=\u0026#34;${line%%/*}\u0026#34; # %%/* 表示从右边开始，删除最后（最左边）一个 / 号及右边的字符 截取文件名称：shell命令处理字符串 先删除最左边的“shell/”,再删除最右边的“.md” 1 2 titlemd=\u0026#34;${line##*/}\u0026#34; # ##*/: 删除\u0026#34;/\u0026#34;左边所有字段即\u0026#34;shell/\u0026#34; title=\u0026#34;${titlemd%%\\.*}\u0026#34; # 删除.md文件后缀 ","date":"2017-06-23T10:32:45Z","permalink":"https://it-boyer.github.io/post/old/shell/shell%E5%91%BD%E4%BB%A4%E5%A4%84%E7%90%86%E5%AD%97%E7%AC%A6%E4%B8%B2/","section":"post","tags":["shell"],"title":"shell命令处理字符串"},{"categories":["项目总结"],"contents":"环境搭建说明 迁出项目 mupdf已合并到PBBReader_Mac项目中，迁出库即可 1 https://192.168.81.13/svn/PBBReader_Mac 运行PBB Reader项目 发布pkg包 运行target :MakeInstaller，它依赖PBB Reader项目,当运行时，如下过程：\n编译生成运行PBB Reader.app包 通过Packages打包工具生成pkg安装包，生成pkg目录在Distribution/ImportSVN/${timeDir}/。 例如：Distribution/ImportSVN/20170118/PbbReader for OS 1.0.4.0037α.pkg 上传至SVN服务器 方式一：可以在第二步中拿到pkg文件，手动上传。 方式二：通过脚本来上传。 1 2 3 4 5 #先判断svn目录是否存在,直接checkout目录导ImportSVN中 cd $ImportSVN ... echo \u0026#34;导入SVN成功：$SVNURL/${timeDir}/${ProductName}.pkg\u0026#34; fi 通过SVN脚本上传时，可以直接在Distribution/releaseNote.md文件中输入提交信息。\n脚本清单 发布脚本目录：Distribution/Packages/Script\nPreInstall.sh:发布脚本,Xcode运行MakeInstaller执行的脚本。 updateVersion.sh:更新版本号脚本，读取PBBReader-Info.plist文件两个字段信息： 1 2 CFBundleShortVersionString:版本号 CFBundleVersion:build版本号 将两个版本号组合成发布内测版本号后，更新Welcome.html文件中的版本信息块中。具体呈现在双击pkg安装包安装过程中，显示的app版本信息的内容。\n","date":"2017-06-22T11:25:08Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE%E6%A6%82%E8%A7%88%E5%8F%8A%E7%8E%AF%E5%A2%83%E6%90%AD%E5%BB%BA/","section":"post","tags":[],"title":"个人项目概览及环境搭建"},{"categories":["解决方案"],"contents":"需求描述 目前手机端使用mupdf，通过在底层添加加密方法实现定制pbb阅读器功能。 资源获取如下： {% blockquote %} Download packages of the latest release for your system: Source code for all platforms. Windows viewer and tools. Android viewer on Google Play. Android viewer APK installer files. iPad and iPhone version on the App Store. The latest development source is available directly from the git repository: git clone \u0026ndash;recursive git://git.ghostscript.com/mupdf.git {% endblockquote %}\n总结：没有适配osx版本，放弃。\n使用apple 官方提供的demo，来分析pdf结构，显示pdf内容。 猜想：这样以来，使用苹果提供相关API，将无法定制底层操作，即无法实现密文浏览功能，故先从明文阅读器开发开始。\nmupdf源码库集成加密 最新整合集成加密到源码库，并发布到git服务器上，便于协作维护:https://server.local/git/mupdf.git 协作过程： 在服务器端添加账号：test test123\n1 2 3 4 5 6 $ git clone https://server.local/git/mupdf.git mupdf $ cd mupdf/thirdparty/ $ git submodule init $ git submodule update $ open mupdf/platform/ios/MuPDF.xcodeproj $ build \u0026amp; run 封装MuPDFFramework便于集成至PBBReader中： 初始化mupdf页面接口：\n1 2 3 4 MuPDFViewController *bindingPhone = [[MuPDFViewController alloc] initWithNibName:nil bundle:nil]; bindingPhone.filename=filename; bindingPhone.openfilepath=select_files; [self.view.window.contentViewController presentViewControllerAsSheet:bindingPhone]; ","date":"2017-06-19T18:25:32Z","permalink":"https://it-boyer.github.io/post/old/%E7%BC%96%E8%AF%91/mupdf%E7%9A%84%E4%BD%BF%E7%94%A8%E8%AF%B4%E6%98%8E/","section":"post","tags":["PDF"],"title":"mupdf使用说明"},{"categories":["日志随笔"],"contents":"米粉卡：联通/电信 办卡需要实名制，可以根据情况办理： 米粉卡分为三种：\n日租无限流量卡，1元/天 3G流量套餐 ，3元/天无限流量卡 如果平时在外不常使用流量，偶尔需求量大的话，天租比较合适。\n10元/G 流量卡，两种套装：29元/月 2G流量。59元/月 4G流量 如果对移动办公比较感冒，对流量需求量大，可以考虑10元/G，每月20元\n0月租卡，任我行 降预存，最节省套餐，不过也以为这没有流量福利\n","date":"2017-06-17T21:44:31Z","permalink":"https://it-boyer.github.io/post/old/%E5%85%B6%E4%BB%96/%E7%B1%B3%E7%B2%89%E5%8D%A1%E7%9A%84%E5%8C%BA%E5%88%AB%E5%8F%82%E8%80%83%E5%8A%9E%E7%90%86/","section":"post","tags":[],"title":"米粉卡的区别参考办理"},{"categories":["学习笔记"],"contents":"Pages文档、Numbers电子表格 和 Keynote演示文稿无不集思广益， 是创建精彩作品的理想工具。利用实时协作功能，你的团队成员可通过 Mac、iPad 或 iPhone 协作，共同编辑文档、电子表格或演示文稿，而 PC 用户也可通过 iCloud 版 iWork 一起参与。另外，你可以通过 Touch ID 瞬间解锁带有密码保护的文档。\n与其他人协作 有了 iCloud 版 Pages、Numbers 和 Keynote，你和团队可通过 Mac 或 PC 上的网页浏览器，访问并编辑你的各种文件。只需登录 iCloud.com，打开网页上的 app，就可以开始工作。无论你的团队成员是近在咫尺，还是远在天边，合作起来都是如此高效。 登录iCloud版APP\n图表使用法 功能一：实用模版任君选择 Numbers丰富的模板样式供用户选择，包括核对清单、贷款比较、预算、支出报告、员工日程表等，这些模版可广泛应用于企业员工日常的工作中，而且颜色、字体和图表质感均非常搭调，不仅实用还很美观。\n基础 空白，核对清单，核对清单总计，制图基础知识\n个人财务 简单预算，个人预算，个人储蓄，净值，退休储蓄，贷款比较，抵押贷款计算器\n个人 日历，日程表，跑步记录，家居装饰，球队组织，宝宝计划，旅游计划，聚会计划，膳食计划，食谱\n商业 员工日程表，发票，投资回报，盈亏平衡分析\n教育 出勤，成绩簿，概率实验，相关性项目，教育储蓄\n功能二：演示效果佳 表格/形状/图片/视频便捷插入 （iPad中不存在画笔）\n功能三：空白模版很方便 格式随意修改 功能四：熟练使用250多个函数成为神算手 菜单\u0026mdash;插入\u0026mdash;公式（Formula）\u0026mdash; 基本公式算法 功能五：三维、交互式图表效果更出色 功能六：可指定数据类型的单元格的技巧 功能七：数据随时存 iCloud用处大 ","date":"2017-06-16T17:43:31Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/%E4%BD%BF%E7%94%A8Numbers%E5%81%9A%E5%AF%BC%E5%9B%BE/","section":"post","tags":[],"title":"使用Numbers做导图"},{"categories":["学习笔记"],"contents":"无线调试 升级设备系统 体验iOS11系统需要几步操作：\n下载配置文件：iOS_11_beta_Configuration_Profile，在手机端使用safari浏览器打开链接，自动安装到描述文件中。 设置中的“软件更新”会自动检测到iOS11 Developer beta版本，表明可以下载更新了。 配置设备信息 链接你的设备 选择Window -\u0026gt; Device and Simulators，完成之后左侧Connected区域你的设备右侧会显示小地图的图标，表示你已经连接上，此时断开数据线，就可以开始无线调试了。如下图所示： 如果iphone和mac不在同一局域网，你可以按照下图进行设置： xcode 的新特性 集成github 在偏好设置中，新增github账号 2. 在导航栏中，新增git版本库导航器 快速查看本地版本的Branches／Tags和commit时间轴，以及Remotes远程版本库信息。支持版本库基本操作：新建／合并／切换分支，打tag标签。还支持新建远程仓库，删除远程分支。 通过双击commit的时间轴的一个条目来查看某次提交中文件的更改详情 3. xcode欢迎页面，clone已有库的界面，可以直接查看readme.md markdown的支持 在Markdown文件中，您键入时，标题，粗体和斜体文本，链接和其他格式将立即在编辑器中呈现。Jump Bar甚至可以了解Markdown结构，因此您可以快速浏览README.md和文档文件。\n色彩管理 在Xcode中的xcassets中添加自定义的颜色，指定颜色名字:MyColor，这样就可以在代码和IB中方便的引用了。\n右键选择添加New Color Set 点击Any，在右侧区域中轻松设置你的颜色 使用 代码中引用：UIColor(named:) 新方法引用你的颜色 1 view.backgroundColor = UIColor(named:\u0026#34;MyColor\u0026#34;) IB中引用你的颜色 ![](https://static.oschina.net/uploads/space/2017/0610/113750_bVTy_2279344.png) ","date":"2017-06-15T16:54:38Z","permalink":"https://it-boyer.github.io/post/old/xcode/Xcode9%E6%96%B0%E7%89%B9%E6%80%A7/","section":"post","tags":[],"title":"Xcode9新特性"},{"categories":["学习笔记"],"contents":"升级xcode8之后，打开storyboard发现xcode7适配界面的size class被Trait Variations所取代: Trait Variations只是size class的直观表现方式，改善了原本九宫格选取过于抽象的问题，直接选机型很清晰直观，但本质未变。\n添加竖屏约束 xcode8版本的选择器，由原来的九宫格形式，改进为机型选择器：\n以前版本：\nVary for Traits 对不同设备和方向上添加约束\n点击右侧的Vary for Traits 会弹出选择Width／Height或组合, 左边的会立即显示将适配的所有机型和方向，即此时新增的约束应用到的不同方向的所有机型\n假如：选width，会发现约束会同时应用到iPhone的横竖屏： 选中了Height之后（这里Width选不选中都是可以的），会发现左侧横屏的设备消失，接下来添加的约束就只会运用到竖屏界面上了\n接下来为竖屏状态的界面添加约束， 点击Done Varying按钮完成对约束的添加 iPad适配时无法区分横竖屏 对比iPhone横竖屏： 竖屏状态是wC：hR 横屏下是wC：hC (w是width h是height，C是Compact R是Regular) ，所以可以方便横竖屏俩套UI是由于横竖屏的size class是不同的。\n但iPad横竖屏都是wR：hR, 所以在竖屏设置的约束同样会应用到横屏上。 所以iPad横竖屏布局还得监听屏幕旋转更改约束，或者在layoutSubview中修改frame了。所以就目前而言一套界面同时适配iPhone与iPad横竖屏这4种界面还是有些困难，也很少(没有？)有应用这样干，大多数应用还是单独做了HD版本，或者直接用iPhone的布局方案。\n","date":"2017-06-13T17:33:59Z","permalink":"https://it-boyer.github.io/post/old/xcode/Xcode8%E4%B8%ADSB%E9%80%82%E9%85%8D%E6%A8%AA%E7%AB%96%E5%B1%8F%E6%8C%89%E9%92%AEVaryforTraits/","section":"post","tags":["Xcode","工具"],"title":"Xcode8中SB适配横竖屏按钮VaryforTraits"},{"categories":["学习笔记"],"contents":"前言 第一部分 通向从容之道 第1章 新情况，新做法 如何回归“心如止水”的境界 在知识工作的环境下（信息大爆炸，事物繁杂的特点），传统时间管理法逐渐无法达到心如止水的境界， 第2章 掌控生活：横向管理工作流程的5个步骤 横向管理的5个步骤\n收集：把一切会引起大脑注意的事务，不分轻重缓急（潜在的重要信息／任务／想法／行动／安排）一律从大脑中清空，作为原始材料放置工作篮中。 理清：它是什么？检查工作篮的材料，理清它们的意义，扔掉垃圾事件 整理：理清流程图和整理流程图一样，2分钟原则 回顾：思考回顾体现了GTD的最核心 执行： 策划行动的三个方法： 四标准法：情境，时间，精力，重要性 每日工作三分类法：事先计划的事，突发事件，安排自己的事 检视工作的六层次法： 当前行动，当前项目，关注及责任范围，目标，愿景，目的和原则 流程图如下：\n衍生的清单： 项目清单 下一步行动 将要／也许清单 孵化清单 第3章 控制项目：纵向管理项目计划的5个阶段 第二部分 远离压力，提高效率 第4章 准备工作：确定时间、空间和工具 第5章 收集阶段：归拢材料 第6章 处理阶段：清空工作篮 第7章 组织整理：建立好清单 第8章 检查回顾：保障系统的有效运行 第9章 执行阶段：选择最合适的行动 第10章 学会控制项目 第三部分 三个关键原则 第11章 原则一：养成收集的习惯 第12章 原则二：确定“下一步行动” 第13章 原则三：学会关注结果 结语 {% pdf /images/搞定1无压工作的艺术.pdf %}\n","date":"2017-06-13T10:34:26Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9A1%E6%97%A0%E5%8E%8B%E5%B7%A5%E4%BD%9C%E7%9A%84%E8%89%BA%E6%9C%AF/","section":"post","tags":["管理"],"title":"搞定1无压工作的艺术"},{"categories":["解决方案"],"contents":"使用场景 梳理任务列表，整理阅读笔记和思维导图，来配合iPad完成每日工作任务\n使用效率 按时出图，分解任务，规划职业\n带来的回报 Starter.playgroundbook iPad学习开发swift 第一步：创建书本的结构（参考模版）Starter.playgroundbook 第二步：了解模版的结构 第三步：增删改模版，增加个人的书本内容 官方建议流程： Make targeted changes to the book’s content and structure in Xcode. Transfer the updated book into Swift Playgrounds using iCloud or AirDrop. 只能使用iCloud和AirDrop来同步swift书籍同步到iPad上。 Open the updated book and test the changes. Note any additional changes that are needed, and return to step 1.\n最终使用方法： 是在iPad上的一款应用，支持swift快速开发，只需要在appStore中下载Swift Playgrounds程序。 在这个这个程序中有精选栏，和我的Playgorund\n精选：就是内置了一些有趣的swift学习编程，从基础进阶再探索，简单易学的教学 我的Playground：有新建，分享，编辑三个按钮，和自己的程序书架。 有两种方式开始编程： 新建一个空白的playgroundbook 通过iCloud 云同步已有的playgroundbook，这也是和mac端共享代码的途径（airdrop暂时没有测通，Mac端开启airdrop却看不到ipad设备），也可以通过第三方来同步，比如sync 源码分享： 点击分享按钮，再点击要分享的playgroundbook文件，然后通过airdrop方式同 Mac共享文件。不过暂时没测通。如果使用微信，qq分享似乎发送到Mac端显示的是目录，无法通过打开方式来使用swift playground 程序 效果分享： 在playgroundbook编辑页面，点击\u0026quot;。。。\u0026ldquo;弹出下拉列表页，提供fenxiang四种方式 拍照 创建PDF 录制影片 实时直播（需要第三方直播软件，暂时没测试） 激活iPad拥有自己的工作空间 激活iPad，安装自己喜欢的几款APP 测试电耗，连续使用8个小时，89%到30%，耗损50%，按工作场景应该能续航16小时左右 尝试键盘连接，使用外设键盘编辑文本还是比较舒服的，便捷，坐等移动键盘到手 摸索iPad使用场景 第一屏为咨询APP主页，在这里将发现更多新的东西，和未知的兴趣点，并同步至Pocker中，即搜集箱，充满期待 第二屏为下一步行动列表页，将第一屏搜集到的原材料，参考四象限法则，整理筛选排优先级，加工成可执行的下一步行动，过滤不能行动的事件 第三屏将行动导图梳理规范化，提高趣味性，增强行动动力，自我鼓励督促完成任务，培养自觉性和对承诺的责任心，逐步养成生活习惯 ","date":"2017-06-03T23:32:45Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/WacomSlate%E7%AC%94%E8%AE%B0%E6%9C%AC%E4%BD%BF%E7%94%A8/","section":"post","tags":["智能设备"],"title":"WacomSlate笔记本使用"},{"categories":["解决方案"],"contents":"开源 开发文档\ngitHub源码库\n效率 可用功能 滴答清单，同步神速，可以使用麦步来标记完成任务\n表盘：纯黑背景比较适合，内置白底表盘无法卸载 工具：计步准确，睡眠监测还行，久坐提醒不错\n思考功能 怎样充分使用麦步，融入到现有的时间管理习惯中\n开发一款麦步trello清单APP 需求：麦步app获取到当天的trello清单，支持查看和完成操作 预研：麦步无须APP账号绑定等，仅凭蓝牙是如何获取到滴答清单的？ 原理： 结果：开发一款trello清单是否可行 1.2 文档分析： 在第二步：编译及打包环境\ngcc-arm-none-eabi-4_7-2014q2-20140408-win32.exe 编译环境 IDE工具Visual MWatch.exe执行编译操作。 可见暂时仅支持win系统开发。 借助IFTTT工具是否能将trello清单同步至麦步中 2.1 中间APP 选择系统提醒APP/(日历APP支持时间设置) 原理： 通过IFTTT工具将trello清单同步到提醒APP中，然后滴答清单读取提醒清单同步到麦步上。 缺点：trello开始与截止日期等属性无法同步至提醒app，由于麦步仅同步滴答清单的当天任务列表，中间必须认为设置起始时间等。\n日历属于一块圣地，不要轻易设置日程安排。他应该是第三象限不急重要的事情。当指定时间地点时，优先级立即为最高\ntrello创建人物是否能讲日期同步到系统提醒APP中，不可行的话，就需要单独对任务指定开始和截止时间。 提醒 麦步获取信息的通道：蓝牙\n平台区别：\nApple手机全局提醒，安卓可以过滤app\n针对性个例：滴答清单 麦步是如何针对性滴答清单，获取APP内部信息的。\n其中的原理，涉及到，如果开发一款trello清单是否可行。\n耗电： 使用计步表盘，及时更新数据，相较普通时钟表盘，电耗是否一致，差距在哪？\ntrello日历订阅源 滴答清单订阅日历功能：设置\u0026mdash;安全与数据\u0026mdash;订阅日历 (普通用户仅支持订阅系统日历)\n获取从trello看板中生成订阅源 普通用户的看板限制的Power-Ups的一个数 两步设置：\n第一步：启动日历\n看板的菜单项\u0026mdash;Power-Ups\u0026mdash;Calendar\u0026ndash;点击启动\u0026mdash;出现设置图标按钮，如图： 第二步：开启日历订阅功能（默认关闭） 点击设置按钮，并启动订阅功能，自动生成订阅路径 添加日历订阅源 iPhone日历订阅需要通过通过Mac实现 使用 iCloud 日历订阅 滴答清单订阅日历功能：设置\u0026mdash;安全与数据\u0026mdash;订阅日历 (普通用户仅支持订阅系统日历)\n可以通过监听事件来同步trello看板中的所有信息\n","date":"2017-06-02T14:39:46Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/%E9%BA%A6%E6%AD%A5%E7%AC%AC%E4%B8%80%E5%A4%A9%E4%BD%93%E9%AA%8C/","section":"post","tags":["智能设备"],"title":"麦步第一天体验"},{"categories":["学习笔记"],"contents":"教程 命令行程序MacOS的教程\n使用swift创建一个命令行程序，相比其他语言如C、Perl、Ruby或java。 选用SWIFT的理由： Swift可以用作解释脚本语言，也可以用作编译语言。这使您具有脚本语言的优势，如零编译时间和易于维护，以及选择编译应用程序，以提高执行时间或捆绑出售给公众。\nmain.swift主体 许多C语言的main函数作为切入点，例如当操作系统调用这个程序时执行的代码入口。这意味着程序的执行始于这个函数的第一行。 Swift没有一个main函数，而是main.swift文件。这样在运行Swift项目时，直接运行的事main.swift文件，执行入口开始于第一行代码。\n终端调用程序 命令行可分两种模式\n静态可执行模式：通过终端app直接运行命令行工具，执行固有功能。 交互命令行模式 ：需要用户通过使用说明信息，对命令行程序输入交互命令，执行相应的功能。 在同一个目录下执行 1 ./Panagram 相对路径执行 1 Debug/Panagram ","date":"2017-05-29T13:00:08Z","permalink":"https://it-boyer.github.io/post/old/macOS/swift%E5%BC%80%E5%8F%91macOS%E7%B3%BB%E7%BB%9F%E7%9A%84%E7%BB%88%E7%AB%AF%E5%91%BD%E4%BB%A4%E8%A1%8C%E5%BA%94%E7%94%A8/","section":"post","tags":["工具","macOS"],"title":"swift开发macOS系统的终端命令行应用"},{"categories":["学习笔记"],"contents":"《搞定I》 前言 第一部分 通向从容之道？ 第1章 新情况，新做法？ 收集存档清空大脑，万物皆于此， 2分钟法则整理可立刻执行的有效清单，不做材料清单 第2章 掌控生活：横向管理工作流程的5个阶段 第3章 控制项目：纵向管理项目计划的5个阶段 第二部分 远离压力，提高效率 第4章 准备工作：确定时间、空间和工具 第5章 收集阶段：归拢材料 第6章 处理阶段：清空工作篮 第7章 组织整理：建立好清单 第8章 检查回顾：保障系统的有效运行 第9章 执行阶段：选择最合适的行动 第10章 学会控制项目 第三部分 三个关键原则 第11章 原则一：养成收集的习惯 第12章 原则二：确定“下一步行动” 第13章 原则三：学会关注结果 结语 ","date":"2017-05-28T12:04:28Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E6%90%9E%E5%AE%9A%E4%B9%A6%E7%B1%8D%E7%9B%AE%E5%BD%95/","section":"post","tags":["管理"],"title":"搞定书籍目录"},{"categories":["学习笔记"],"contents":"脑图 {% iframe http://naotu.baidu.com/file/3cd277713d4ebb210443ffaf9c8f38e6?token=9200f134c9b8f825 700 300 %}\n第一篇 阅读的层次 第一章 阅读的活力与艺术 第二章 阅读的层次 第三章 阅读的第一个层次：基础阅读 第四章 阅读的第二个层次：检视阅读 第五章 如何做一个自我要求的读者 第二篇 阅读的第三个层次：分析阅读 第六章 一本书的分类 第七章 透视一本书 第八章 与作者找出共通的词义 第九章 判断作者的主旨 第十章 公正地评断一本书 第十一章 赞同或反对作者 第十二章 辅助阅读 第三篇 阅读不同读物的方法 第十三章 如何阅读实用型的书 第十四章 如何阅读想像文学 第十五章 阅读故事、戏剧与诗的一些建议 第十六章 如何阅读历史书 第十七章 如何阅读科学与数学 第十八章 如何阅读哲学书 第十九章 如何阅读社会科学 第四篇 阅读的最终目标 第二十章 阅读的第四个层次：主题阅读 第二十一章 阅读与心智的成长 附录一 建议阅读书目 附录二 四种层次阅读的练习与测验 索引 ","date":"2017-05-28T12:04:28Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E5%A6%82%E4%BD%95%E9%98%85%E8%AF%BB%E4%B8%80%E6%9C%AC%E4%B9%A6%E7%9B%AE%E5%BD%95/","section":"post","tags":["图书"],"title":"如何阅读一本书目录"},{"categories":["日志随笔"],"contents":"问题 现状：两个项目源码存在八成为同样的代码，管理在两个SVN库中。 背景：从一个SVN项目分裂成两个独立项目（PBB_2/Reader_v2）对应延伸出来SVN库，随后在两个库中开发不同的功能版本（PBB_7/Reader_v9）。 需求：现在准备将两项目中新增的功能重新合并起来，即将PBB_v7合并到Reader_v9中。 分析：需要把PBB_v3\u0026ndash;PBB_v7的5个提交，合并到Reader_v9中\n对PBB迭代的十几个版本中新增的功能涉及面太广，手动合并出错率高，协作难度大，纯劳力搬砖着实要命。 以下总结几条建议\n方案一：打补丁法合并源码 注：仅适用于同一个库使用\n实现步骤：\ngit-svn命令把svn库转为git库 将5个提交重演到Reader_v9版中 重演方案：\n打补丁法：通过压缩提交法把PBB_v7若干提交整合成一个提交，再创建一个补丁，重演到Reader_v9上 交互变基压缩法，压缩成一个提交 reset压缩提交法，将提交压缩 git reset \u0026ndash;soft 1bf27c6a33d87c2e36fa75431224124f91d8b482 案例：在大型项目中，贡献者常以使用补丁文件贡献代码 结论：打补丁法的前提打补丁的宿主库必须和将要应用补丁的库为同一库源。故使用版本库来合并两个独立不想关的svn库，无法通过打补丁法实现合并。\n方案二：项目模块化合并 在PBB Reader中通过项目依赖整合IJK／mupdf／maker\n操作 取消Maker原有IJK，mupdf的依赖 在PBB Reader中配置Maker依赖 ：隐私空间涉及到的阅读功能在Reader中实现 新需求开发 好处 源码隔离，功能共享，对现有功能的源码无要做任何修改 项目之间相互独立，便于后续拆分或整合 更多精力专注代码优化 否决方案二，采用手动合并 Reader本属于一个播放器，是从PBB应用的lite版，主要业务都是在PBB中实现的，当前需求是让PBB集成到Reader中，如何使用PBB Framework集成，需要暴漏大量的接口，业务层的高耦合性已经违背了封装原则。故作罢。\n突破了合并时遇到的棘手问题，加密崩溃，最终排查出socker传输结构体导致的异常，maker和Reader之间的差异导致合并过程更加困难，最终采用对讲maker中对加密实现文件的封装，在集成到Reader中，即隔离冲突，暴露功能，程序架构集成过程中更便捷合理化。\n相关知识：\n引用日志： git reflog 引用日志只存在本地仓库中，只记录第一次clone到之后，在本地仓库中的操作日志，服务器端不会同步这些引用记录，所以在本地无法查看别人的引用日志。\n祖先引用 几种表达式含义\n第一种：^/^^^(多个) HEAD^:指向祖先提交 hash值^（^^^） :指向该引用的上一个提交，几个符号就是指向上几个提交 ^数字:只适用于合并（merge）提交，有多个父提交。如：hash值^2表示第二父提交。第一父提交是指合并时所在的分支，第二父提交是指合并进来的分支。\n第二种：数字 HEAD: 指向祖先提交 HEAD~数字:指向指向上几个提交\nhash值^数字:指向该引用的上几个提交\n","date":"2017-05-27T15:06:17Z","permalink":"https://it-boyer.github.io/post/old/%E4%B8%AA%E4%BA%BA%E9%A1%B9%E7%9B%AE/%E7%97%9B%E5%AE%9A%E6%80%9D%E7%97%9B%E7%9A%84%E9%A1%B9%E7%9B%AE%E7%AE%A1%E7%90%86%E5%BC%8A%E7%97%85/","section":"post","tags":["管理"],"title":"痛定思痛的项目管理弊病"},{"categories":["学习笔记"],"contents":"“老付”谈论的是目标，所有的方法都是为目标服务的，目标统率人的行为。\n怎样规划自己的人生？ 怎样树立自己的目标？ 怎样把目标转化成实际的行动？ 怎样提高自己实现目标的能力？ ","date":"2017-05-25T18:09:00Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E4%BF%AE%E7%82%BC%E5%8D%87%E8%81%8C%E5%BF%85%E5%A4%87%E7%9A%84%E6%8A%80%E8%83%BD%E4%BA%8C/","section":"post","tags":["工具","管理"],"title":"升职必备的技能修炼二 以道御术"},{"categories":["学习笔记"],"contents":"焦虑是由于缺乏控制力，以及组织管理、准备和行动不足所造成的。\n四象限 走出第三象限，将工作重心放进第二象限\n第二象限法则 猴子法则：屏蔽干扰的伎俩 项目与行动的区别 项目需要分解为可执行的行动\n以动词开头的行动 添加行动的预期效果 下一步行动法，驱动项目的进行。\n时间投资 衣柜整理法 收集，处理，组织，回顾，行动\n2分钟法则\n无论在什么情况下，我们在工作时都将经历这五个阶段：\n收集篮：收集一切引起我们注意的事情。 收集的关键是将‘一切引起我们注意的东西’放在‘收集篮’里，在清空大脑的同时达到‘心如止水’的境界。 工具军规\n收集工具越少越好 保证5秒钟内拿出工具 定期清空工具： 今日事今日毕 ，定期清空，比如每周五清空所有事件迎接周末 处理收集篮：加工处理后，确定它们的实质以及解决方法。 2分钟突击原则：指定任务可行性标签 不可行： 1. 垃圾事件 2. 将来某时／也许事件 3. 参考资料（处理方法就是分类归档） 可执行： 1. 2分钟事件（专治拖延症） 2. 项目事件 3. 委托事件 4. 预约事件 5.待办事件\n原则：\n从最上面一项开始处理 一次只处理一件事情 永远不要再放回收集篮（被迫中断的事情除外），争取一次做好 组织：组织整理，得出结论 ‘3+1’组合的清单系统 材料， 收集篮清单（做到每日清理）\n将某时／也许清单\n待办事清单\n项目清单（多任务集合，多个下一步行动）一般会放在待办清单中\n回顾： 解决盲目的问题，我们还需要做到对任务进行回顾。\n让灵感应运而生\n周回顾的时候恰恰是这样一种状态，对所有的一切都了如指掌，对所有的一切都做了充足的准备。\n站在3万米的高度去看待问题 通过对自己一周工作的重新审视，向自己发问：到底哪些事有利于我更好地接近目标？今后遇到类似的事情应该如何取舍？当我们站在一个新的高度去看待现在的人和事，你会有前所未有的发现。\n孵化和修剪你的任务及目标\n把它们列为我们行动的选择方案。\n行动：选择最佳方案 利用一个月的时间去思考自己的未来发展，然后制定一个‘自上而下’的职业规划；当这个规划确定之后，我会‘自下而上’地搞定自己的工作，并且在工作的过程中随时修订自己的规划，这就是我的工作方式。\n‘自上而下’的目标系统 大卫·艾伦的六个高度去进行检视和规划：\n原则 （五万米）\n你首先必须要找个时间好好地思考一下自己的价值观、原则和目标，这是你工作的灵魂所在。如果你以前没有思考过这些，建议你现在就开始思考。我可以和你分享一下我的原则：工作是谋求更好生活的途径，追求无压、流畅、高效的工作。\n愿景（四万米）\n这里面包含3—5年的工作目标，可以是职位的，也可以是组织能力、协调能力等。在这个层面你需要问自己 ◎我的目标是什么？ ◎哪些人已经达到了我的这个目标？ ◎他们是如何达到目标的？ ◎达到这个目标之后我的工作和生活会是怎样的？\n目标（三万米） 目标是比愿景更细化的东西，通常在一年内就可以有一个阶段性的成果。比如说我现在的目标就是：\n◎每周通过参加商务聚会来扩展自己的人脉，主动给朋友们打电话来巩固自己的人脉； ◎参加管理学的培训课程或者是参加MBA学习来提高自己的综合能力； ◎每天坚持阅读40分钟，以扩充自己的知识面，并且更深层次地研究自己所在的专属领域。\n责任范围（两万米）\n工作上的角色：如销售、管理、产品开发等；\n生活中的角色：如家庭、个人财务、精神层面等。\n要把每一个角色扮演好，就需要执行一些任务，以拉近现实和期望的距离。比如在这个层面我会拿出我负责的项目和产品，看看在开发、销售、管理上是否还有提升的可能性，因为毕竟要把自己责任范围内的事情做得漂亮，才有可能升职或者有其他进一步的发展。\n任务（一万米）\n所有需要一步以上完成的事情都是一个任务，虽然我们已经有了一个‘自上而下’的目标系统，但是我们仍然要将注意力放在眼前的任务上，比如‘新产品的营销策略’等。\n下一步行动（跑道）\n这是最细枝末节的事件，我们要将它们全部放进我们的清单，然后逐一完成。谁更关注细节，谁就能获得更大的成功。刚开始我们都在同一个跑道里面绕圈，但是最终只有职业规划清晰的人才会驾车进入快车道，直奔目标而去。”\n","date":"2017-05-25T16:40:42Z","permalink":"https://it-boyer.github.io/post/old/%E9%98%85%E8%AF%BB/%E4%BF%AE%E7%82%BC%E5%8D%87%E8%81%8C%E5%BF%85%E5%A4%87%E7%9A%84%E6%8A%80%E8%83%BD/","section":"post","tags":["管理"],"title":"修炼升职必备的技能"},{"categories":["解决方案"],"contents":"Calibre，是一个免费的开源的“一站式”的电子书解决方案，它可以全面满足你的电子书需求。Calibre 是免费的，源代码开放，拥有跨平台的设计。它是一个完整的电子图书馆，包括图书管理，格式转换，新闻，将材料转换为电子书，以及电子书阅读器同步功能、整合进电子图书阅读器。当然它也内置了一个 ePub 格式电子书编辑工具以满足修改电子书的需要。\n感兴趣的几个功能点：\n爬虫功能，即可以支持一键抓取新闻，根据指定的feed订阅源，来制作书籍。 这样便可每天爬取最新消息，发到kindle上看新闻\n支持kindle书籍，相比kindle应用，它能自由复制书本内容，便于笔记整理。\n","date":"2017-05-25T14:26:15Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/calibre%E4%B8%80%E7%AB%99%E5%BC%8F%E7%94%B5%E5%AD%90%E4%B9%A6%E8%A7%A3%E5%86%B3%E6%96%B9%E6%A1%88/","section":"post","tags":["工具","calibre"],"title":"calibre一站式电子书解决方案"},{"categories":["学习笔记"],"contents":"腾讯云服务器 申请账户，体验5天，搭建一个jira服务，还有微信小程序服务\n需要在服务器上安装docker （腾讯服务器提供了一款支持docker的Ubuntu系统）\n想使用daocloud加速器，就要更新docker版本 docker run \u0026ndash;detach \u0026ndash;publish 8080:8080 cptactionhank/atlassian-jira:latest http://[dockerhost]:8080 and finish the configuration\n远程服务器的基本操作 登录：ssh -l username 服务ip／域名 ssh ubuntu@123...6 5***RtH sudo docker pull cptactionhank/atlassian-jira 服务器端拷贝文件目录 scp -i localDir serveruser@serverip:serverDir docker下安装mysql数据库镜像 1 2 sudo docker pull mysql sudo docker run --name jiradb -e MYSQL_ROOT_PASSWORD=jiradb -d mysql/mysql-server:latest -name : 容器名 MYSQL_ROOT_PASSWORD : 数据库密码 -d : 镜像名:tag 版本\n终端：单行登录mysql 1 sudo docker exec -it jiradb mysql -ujira -pjira 进入mysql终端,访问数据库 1 2 3 4 5 6 sudo docker exec -it jiradb bash #登录数据库 默认用户root 密码为空，如果前边设置了MYSQL_ROOT_PASSWORD的值，则需要密码 mysql -uroot -p #登录本地数据库 可以 省略-h参数 -h 127.0.0.1 回车 输入密码：jiradb #就是$MYSQL_ROOT_PASSWORD的值 即登录 用户权限控制 查看sql服务器的状态： 1 status; 创建用户名 1 create user jira identified by \u0026#39;jira\u0026#39;; 赋予权限 1 2 3 4 grant all privileges on *.* to \u0026#39;jira\u0026#39;@\u0026#39;%\u0026#39; identified by \u0026#39;jira\u0026#39; with grant option; grant all privileges on *.* to \u0026#39;jira\u0026#39;@\u0026#39;localhost\u0026#39; identified by \u0026#39;jira\u0026#39; with grant option; flush privileges; quit; 数据库操作 创建数据库 1 create database jiradb character set \u0026#39;UTF8\u0026#39;; 查看当前数据库名： 1 select database(); 切换指定数据库 1 use jiradb; 查看数据库表 1 show tables; 创建表\njira和数据库关联结果 无法通过 docker 中mysql镜像的盒子来实现jira和数据库关联： 从另一个容器中的应用来访问jiradb容器中的mysql服务：没成功\n1 2 Connect to MySQL from an application in another Docker container sudo docker run --name jirad --link jiradb:mysql/mysql-server -d cptactionhank/atlassian-jira:latest 最终采用在ubuntu系统中安装mysql：\n1 $sudo apt-get -y install mysql-server ##问题：Could not reach any registry endpoint 安装Linux加速器： curl -sSL https://get.daocloud.io/daotools/set_mirror.sh | sh -s http://142900b5.m.daocloud.io 该脚本可以将 \u0026ndash;registry-mirror 加入到你的 Docker 配置文件 /etc/default/docker 中。适用于 Ubuntu14.04、Debian、CentOS6 、CentOS7、Fedora、Arch Linux、openSUSE Leap 42.1，其他版本可能有细微不同。 ubuntu 系统安装daocloud检测工具： curl -sSL https://get.daocloud.io/daomonit/install.sh | sh -s d0312f829e9807ee0bf157cdc9c9cca42380395c\n更新服务器上的docker 官网教程\nUpdate your apt sources To set APT to use packages from the Docker repository:\nLog into your machine as a user with sudo or root privileges. Open a terminal window. Update package information, ensure that APT works with the https method, and that CA certificates are installed. 1 2 $ sudo apt-get update $ sudo apt-get install apt-transport-https ca-certificates Docker资源库 Ubuntu version Repository Precise 12.04 (LTS) deb https://apt.dockerproject.org/repo ubuntu-precise main Trusty 14.04 (LTS) deb https://apt.dockerproject.org/repo ubuntu-trusty main Wily 15.10 deb https://apt.dockerproject.org/repo ubuntu-wily main Xenial 16.04 (LTS) deb https://apt.dockerproject.org/repo ubuntu-xenial main Note: Docker does not provide packages for all architectures. Binary artifacts are built nightly, and you can download them from https://master.dockerproject.org. To install docker on a multi-architecture system, add an [arch=\u0026hellip;] clause to the entry. Refer to Debian Multiarch wiki for details.\n导入库 = deb https://apt.dockerproject.org/repo ubuntu-precise main 1 $ echo \u0026#34;\u0026lt;REPO\u0026gt;\u0026#34; | sudo tee /etc/apt/sources.list.d/docker.list ` 6.Update the APT package index.\n1 $ sudo apt-get update 7.Verify that APT is pulling from the right repository. When you run the following command, an entry is returned for each version of Docker that is available for you to install. Each entry should have the URL https://apt.dockerproject.org/repo/. The version currently installed is marked with ***.The output below is truncated.\n$ apt-cache policy docker-engine\ndocker-engine: Installed: 1.12.2-0trusty Candidate: 1.12.2-0trusty Version table: *** 1.12.2-0trusty 0 500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages 100 /var/lib/dpkg/status 1.12.1-0trusty 0 500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages 1.12.0-0~trusty 0 500 https://apt.dockerproject.org/repo/ ubuntu-trusty/main amd64 Packages\nFrom now on when you run apt-get upgrade, APT pulls from the new repository.\nTo upgrade your kernel and install the additional packages, do the following:\nOpen a terminal on your Ubuntu host. Update your package manager. $ sudo apt-get update Install both the required and optional packages. $ sudo apt-get install linux-image-generic-lts-trusty Repeat this step for other packages you need to install. Reboot your host to use the updated kernel. $ sudo reboot After your system reboots, go ahead and install Docker.\nInstall the latest version Make sure you have satisfied all the prerequisites, then follow these steps.\nNote: For production systems, it is recommended that you install a specific version so that you do not accidentally update Docker. You should plan upgrades for production systems carefully. Log into your Ubuntu installation as a user with sudo privileges. Update your APT package index. $ sudo apt-get update Install Docker. $ sudo apt-get install docker-engine Start the docker daemon. $ sudo service docker start Verify that docker is installed correctly by running the hello-world image. $ sudo docker run hello-world This command downloads a test image and runs it in a container. When the container runs, it prints an informational message and exits.\n","date":"2017-05-24T17:07:47Z","permalink":"https://it-boyer.github.io/post/old/%E5%85%B6%E4%BB%96/%E8%BF%9C%E7%A8%8B%E6%93%8D%E4%BD%9Cmysql%E6%95%B0%E6%8D%AE%E5%BA%93/","section":"post","tags":["数据库"],"title":"远程操作mysql数据库"},{"categories":["学习笔记"],"contents":"在项目中使用git submodule工具集成子项目ObjectiveGit\n在新项目中使用git submodule集成gitAPI 参考官方提供的两个demo\nOS X: CommitViewer\niOS: ObjectiveGit iOS Example\n1 2 3 git submodule add https://github.com/libgit2/objective-git.git External/ObjectiveGit 如果之前配置过，直接更新： git submodule update --init --recursive cd External/ObjectiveGit，然后执行./script/bootstrap安装相关依赖. 拖动 ObjectiveGitFramework.xcodeproj 文件 到iOS/OSX项目导航窗口 . 在build Phases中配置APP的依赖，根据平台添加ObjectiveGit-Mac or ObjectiveGit-iOS. APP通过连接器链接 ObjectiveGit.framework. 在build setting中“Header Search Paths” (HEADER_SEARCH_PATHS)设置libgit2头文件在项目的路径，例如：External/ObjectiveGit/External/libgit2/include. Add a new \u0026ldquo;Copy Files\u0026rdquo; build phase, set the destination to \u0026ldquo;Frameworks\u0026rdquo; and add ObjectiveGit.framework to the list. This will package the framework with your application as an embedded private framework. It\u0026rsquo;s hard to tell the difference between the platforms, but the Mac framework is in build/Debug whereas the iOS framework is in build/Debug-iphoneos Don\u0026rsquo;t forget to #import \u0026lt;ObjectiveGit/ObjectiveGit.h\u0026gt; or @import ObjectiveGit; as you would with any other framework. 知识点 类变量关联.xib控件text值 字体样式菜单来改变字体样式 在OSX中设置控件的Bindings代替IBOutlet 先关联再使用属性依赖特性来同步数据\n类变量关联.xib控件text值 相关参考\n选中NSTextField的bindings检查器面板 在value单元内设置bind to 的值，通过下拉框选中 Delegate Model key Path:输入类变量的名称。 切换到 NSTextField／Delegate的Connections检查器面板,就会看到已经建立了关联： 依赖属性 Foundation 框架提供的表示属性依赖的机制如下： 参考属性的依赖\n1 2 3 4 + (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key 或 + (NSSet *)keyPathsForValuesAffecting\u0026lt;键名\u0026gt; 将属性关联起来，这样就可以将类变量的值同步至UI控件中了：\n1 2 3 4 5 6 7 8 9 10 11 12 + (NSSet *)keyPathsForValuesAffectingValueForKey:(NSString *)key { NSSet *keySet = [NSSet setWithObjects:@\u0026#34;commit\u0026#34;, nil]; if ([key isEqualToString:@\u0026#34;messageTitle\u0026#34;] || [key isEqualToString:@\u0026#34;messageDetails\u0026#34;] || [key isEqualToString:@\u0026#34;author\u0026#34;] || [key isEqualToString:@\u0026#34;date\u0026#34;]) { return keySet; } return [super keyPathsForValuesAffectingValueForKey:key]; } 实现字体样式菜单来改变字体样式 在xib中拖一个Object并设置为NSFontManager.h类的实现。 选中NSFontManager.h的connections面板，将Received Actions关联到对应的菜单项即可 ","date":"2017-05-17T17:33:46Z","permalink":"https://it-boyer.github.io/post/old/%E5%BC%80%E6%BA%90%E5%BA%93/iOS%E5%92%8COSX%E9%9B%86%E6%88%90gitAPI/","section":"post","tags":["SDK"],"title":"iOS和OSX集成gitAPI"},{"categories":["学习笔记"],"contents":"核心区别 git submodule类似于引用，而git subtree类似于拷贝，比如你在一篇博客中想用到你另一篇博客的内容，git submodule是使用那篇博客的链接，而git subtree则是将内容完全copy过来。\nsubmodule命令 添加submodule 1 2 git submodule add -b branchA http://github.com/../repoA.git pathA git submodule add http://github.com/../repoB.git pathB 执行以上命令后会生成.gitmodule的文件，文件存储子模块信息:\n1 2 3 4 5 6 7 [submodule \u0026#34;repoA\u0026#34;] path = pathA url = http://github.com/../repoA.git branch = branchA [submodule \u0026#34;ModuleB\u0026#34;] path = ModuleB url = http://github.com/../repoB.git 提交.gitmodule文件\n1 2 git commit -m \u0026#39;add submodule\u0026#39; git push clone新库初始化submodule clone之后各模块内容为空目录，需要执行： 1 git submodule init 拉取所有子模块 需要在.gitmodules文件中指定branch:分支名 1 2 3 git submodule foreach git pull 或 git submodule foreach git pull origin master 更新所有模块 更新后每个子模块并非在指定分支上，而是关联最近一次commitID。 使用git submodule foreach为每一个子模块执行切换命令: 1 git submodule foreach git checkout master 切换到所有master分支上（ModuleB为ResourceEvaluate，暂时需要单独执行）\n删除子模块 1 2 3 4 5 6 git rm --cached moduleA rm -rf moduleA vi .gitmodules //删除moduleA相关的内容 git add . git commit -m \u0026#34;remove moduleA\u0026#34; git push origin master subtree命令 subtree添加子模块 通过subtree添加子模块,–squash可省略，其功能是只有最新的提交记录被引入，去掉后则是引入所有历史提交记录 1 2 3 4 #增加远程仓库并设置引用名`ModuleA`，此步可省略，主要是为了简化后面的操作 git remote add ModuleA http://github.com/../ModuleA.git master #`subtree`添加子模块 git subtree add --prefix=ModuleA --squash ModuleA master subtree更新 1 git subtree pull -P ModuleA ModuleA master subtree提交 1 git subtree push --prefix=ModuleA ModuleA master / submodule subtree 结果 远程仓库空间占用 submodule只是引用，基本不占用额外空间 子模块copy，会占用较大的额外空间 submodule占用空间较小，略优 本地空间占用 可根据需要下载 会下载整个项目 所有模块基本都要下载，二者差异不大 仓库克隆 克降后所有子模块为空，需要注册及更新，同时更新后还需切换分支 克隆之后即可使用 submodule步骤略多，subtree占优 更新本地仓库 更新后所有子模块后指向最后一次提交，更新后需要重新切回分支，所有子模块只需一条更新语句即可 所有子模块需要单独更新 各有优劣，相对subtree更好用一些 提交本地修改 只需关心子模块即可，子模块的所有操作与普通git项目相同 提交执行命令相对复杂一些 submodule操作更简单，submodule占优 ","date":"2017-05-17T11:23:22Z","permalink":"https://it-boyer.github.io/post/old/git/SubModule%E4%B8%8ESubTree%E7%9A%84%E5%B7%AE%E5%BC%82/","section":"post","tags":["git"],"title":"SubModule与SubTree的差异"},{"categories":["学习笔记"],"contents":"OOP面向对象编程：1. 封装，2，继承，3. 多态 五大原则： SRP单一职责原则：一个类的功能要单一，表现突出的VIPER模式 OCP开放封闭原则:模块扩展性为开放的，模块更改性则为封闭的。 LSP替换原则， DIP依赖原则， ISP接口分离原则：模块间的功能通过抽象接口隔离\n封装：将抽象事物的特征，行为，转化为代码中的类：属性和方法即为封装，体现2.对属性和方法的访问权限的控制 私有，公有不同级别的保护。 继承：广义上也是一种对代码的复用。继承有两种方式：实现继承和接口继承。\n多态：一个类实例的同一个方法，在不同情形有不同的表现形式。类似多个构造器和便利构造器，实现的功能都是初始化类实例的作用\n子类场景 优点：代码封装，重用组件\n自定义系统控件时： 如：对UITableViewCell等视图，自定义布局。 针对多平台，多版本来编写代码 实现：创建一个基类，创建iPhone子类／iPad子类来继承重写特性方法。 子类化模型对象，继承isEqual:,hash,copyWithZone:和description等方法，参考开源框架Mantle 子类的场景替代方案 深层次的集成的替代方案：\n子类使用相同的接口，协议替代， 当对象正常运行需要大量配置时，使用代理来完成配置 对现有的类增加简单功能时，使用类别来扩展 重写一堆相同方法子类时，使用配置对象代替 当重用某些功能时，使用组合多个对象来代替，而不是扩展它们 简明架构：VIPER模式：单一职责， 将APP逻辑结构划分为不同的责任层： View视图，Interactor交互器，Presenter展示器，Entity实体，Routing路由\n接口隔离原则：隔离依赖项， 单一职责原则：利于测试各层间边界处的交互。 轻量化VC，提高可读性，维护性。 基于用例的应用设计 待办事项清单示例 用例别称为验收标准，或行为集，它们用来描述应用的用途。独立于用户界面，主要针对在应用程序中的负责业务逻辑层的测试操作。 举例：清单可以根据时间，类型以及名字排序，这就是一个用例。 特征：足够小，良好的定义。 作用：将复杂的应用分解成较小的用例。\n单一职责原则：便于测试 测试用例： 模拟网络数据-\u0026gt;拦截HTTP请求-\u0026gt;模拟一个响应对象给请求方 目的： 模拟数据，激活iResearcher\n多线程下载 VIPER架构 LLDB命令和断点的合用 变量，对象：p ，po，e 表达式， 流程控制：thread 断点管理：breakpoint LLDB和Python AppleScript\nInstruments 自定义工具\u0026ndash;DTrace语法 -\u0026gt;自动化脚本 终端成员DTrace 使用IB工具来编写DTrace脚本，并可以方便的导出DTrace脚本，可用于脚本自动化时收集APP运行状态的数据， 探针 （断言，动作，提供者，全部变量 ，begin，end） DTrace脚本是在内核中运行中的，需要IB工具做缓冲区，来封装内核数据达到ib工具识别\n废除功能： run Browser浏览器功能 UI automation功能\nview属性的自动布局 ","date":"2017-05-15T16:14:07Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/%E5%BC%80%E5%8F%91%E6%80%9D%E6%83%B3%E6%A8%A1%E5%BC%8F%E6%80%BB%E7%BB%93/","section":"post","tags":null,"title":"开发思想模式总结"},{"categories":["解决方案"],"contents":"背景 Xcode7插件工具Alcatraz 开发者可以在Xcode运行的时候通过注入代码去实现插件的功能。插件可以在一个Alcatraz这个优秀的APP上面提交和分发。 以往Xcode插件开发在没有官方支持的情况下，提供了Xcode-Plugin-Template和各种dump好的头文件，我们仍然需要在没有文档的情况下做各种猜测和hook。关于插件的开发，可以看看这篇文章。 Xcode8编辑源码的插件Xcode source editor extensions Xcode 8验证每个库和包，以防止恶意代码未经您的许可运行。苹果公司在今年的WWDC上宣布了可以通过开发Xcode source editor extensions来扩展以下三个功能: Add commands to the source editor // 给Xcode的代码编辑器扩展一些命令（在Editor菜单下增加额外的菜单） Edit text //通过这些命令对源代码进行编辑 Change selections //对选中文本的编辑功能 源码编辑器插件 添加命令菜单 通过Info.plist中添加菜单 打开Info.plist，展开NSExtension至XCSourceEditorCommandDefinitions，命令菜单的定义如下：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 \u0026lt;key\u0026gt;NSExtensionAttributes\u0026lt;/key\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;XCSourceEditorCommandDefinitions\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;XCSourceEditorCommandClassName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;$(PRODUCT_MODULE_NAME).SourceEditorCommand\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;XCSourceEditorCommandIdentifier\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;com.xt.APPlugins.AutoComment.SourceEditorCommand\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;XCSourceEditorCommandName\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;Source Editor Command\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;XCSourceEditorExtensionPrincipalClass\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;$(PRODUCT_MODULE_NAME).SourceEditorExtension\u0026lt;/string\u0026gt; \u0026lt;/dict\u0026gt; 其中：\nXCSourceEditorCommandClassName指向命令的处理类，该类实现XCSourceEditorCommand。 XCSourceEditorCommandIdentifier是命令的唯一标识，通常我们会对一组命令设置同一个XCSourceEditorCommand，在invocation中获取此标识做区分处理。 XCSourceEditorCommandName是命令在菜单栏展示的菜单名称。 通过代码定制命令菜单 此外，菜单项是动态加载的，可以实现SourceEditorExtension.swift的commandDefinitions:实现 SourceEditorExtension用来管理extension的生命周期相关,SourceEditorCommand则用来处理具体的命令。 这会覆盖掉Info.plist中的定义。\n1 2 3 4 5 6 7 8 9 10 //1. 启动extension被调用，自定义相关操作 func extensionDidFinishLaunching(){} var commandDefinitions: [[XCSourceEditorCommandDefinitionKey: AnyObject]] { // If your extension needs to return a collection of command definitions that differs from those in its Info.plist, implement this optional property getter. ////commandDefinitions属性的getter方法可以动态的展示或是隐藏特定的指令 return [[.classNameKey: \u0026#34;SourceEditorCommand\u0026#34;, .identifierKey: \u0026#34;CustomIdentifier\u0026#34;, .nameKey: \u0026#34;CustomeName\u0026#34;]] } 命令插件功能实现 打开SourceEditorCommand.swift，实现perform(with:completionHandler:)。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 31 32 33 class SourceEditorCommand: NSObject, XCSourceEditorCommand { //当通过Xcode菜单键调用插件时调用，实现插件功能的主体 func perform(with invocation: XCSourceEditorCommandInvocation, completionHandler: @escaping (Error?) -\u0026gt; Void ) -\u0026gt; Void { // 正则匹配含有 闭包 的文本 var updatedLineIndexes = [Int]() for lineIndex in 0 ..\u0026lt; invocation.buffer.lines.count { let line = invocation.buffer.lines[lineIndex] as! NSString do { let results = try findClosureSyntax(line: line) //简化所有闭包语法格式：移除闭包里面括号 _ = results.map { result in let cleanLine = line.remove(characters: [\u0026#34;(\u0026#34;, \u0026#34;)\u0026#34;], in: result.range) updatedLineIndexes.append(lineIndex) invocation.buffer.lines[lineIndex] = cleanLine } } catch { completionHandler(error as NSError) } } completionHandler(nil) } //使用正则表达式去遍历每一行代码是否含有闭包 func findClosureSyntax(line:NSString) throws -\u0026gt;[NSTextCheckingResult] { let regex = try NSRegularExpression(pattern: \u0026#34;\\\\{.*\\\\(.+\\\\).+in\u0026#34;, options: .caseInsensitive) let range = NSRange(0 ..\u0026lt; line.length) return regex.matches(in: line as String, options: .reportProgress, range: range) } } XCSourceEditorCommandInvocation的buffer提供了当前选中的文件源代码中的信息，包括文件的lines, selections, indentationWidth等等，具体作用可以查看WWDC视频或者苹果的文档查看，在此就不一一介绍了。\n测试 选择scheme后编译运行自定义的extensions插件 选择测试安装插件的Xcode 点击run按钮会单独启动一个全新的Xcode 在新的Xcode实例中，创建一个新的工程或是打开一个存在的工程。 然后执行Editor \u0026gt; Clean Closure \u0026gt; Source Editor Command，需要确保在当前的文件里面含有一个闭包。这样就可以看到如下的效果，刚才开发的extension工作了！ 命令快捷键 设置快捷键去自动调用Clean Syntax命令\n打开Xcode的Preferences，选择Key Bindings ; 搜索Clean Syntax，点击右边然后输入快捷键，例如：Command-Alt-Shift-+。 WWDC2016之初识Xcode Source Editor Extension xcode常用的插件清单 使用 Xcode Source Editor Extension开发Xcode 8 插件 详解一步步实现Xcode 8 插件\n","date":"2017-05-15T14:09:30Z","permalink":"https://it-boyer.github.io/post/old/xcode/Xcode8%E6%8F%92%E4%BB%B6%E5%88%B6%E4%BD%9C%E6%9B%BF%E4%BB%A3Alcatraz/","section":"post","tags":["工具"],"title":"Xcode8插件制作替代Alcatraz"},{"categories":["解决方案"],"contents":"不同点 NSWindowController 在Mac上应用都支持多窗口（NSWindowController），AppKit 中都有 NSWindowController担当着类似在iOS中的view controller处理的任务。\nwindow在iOS占据整个屏幕，几乎不怎么不用。\nNSViewController AppKit 中的 NSViewController默认不支持交互，缺少生命周期相关方法和UIKit中熟悉的特性。 但在OS X 10.10 Yosemite之后，NSViewController改进很多，默认支持交互中的响应链。\nNSWindow 和 UIWindow 在UIKit中UIWindow是一个 view 的子类. 在AppKit中NSWindow用 contentView 属性持有一个指向其顶层 view 的引用。\n响应者链（responder chain） 如果你在为 OS X 10.9 或者更低版本的系统开发，请注意在默认情况下view controller 并不是响应者链的一环。相反，事件会沿着视图树向上传递然后直接到达 window 和 window controller。在这种情况下，如果你想在 view controller 处理事件，你需要手动把它添加到响应者链中。\nTarget-Action消息传递方式 Target-Action 是回应 UI 事件时典型的消息传递方式。iOS 上的 UIControl 和 Mac 上的 NSControl/NSCell 都支持这个机制。 Target-Action 在消息的发送者和接收者之间建立了一个松散的关系。消息的接收者不知道发送者，甚至消息的发送者也不知道消息的接收者会是什么。如果 target 是 nil，action 会在响应链 (responder chain) 中被传递下去，直到找到一个响应它的对象。\n传递机制的局限 基于 target-action 传递机制的一个局限是，发送的消息不能携带自定义的信息：\n在iOS 中，可以选择性的把发送者和触发 action 的事件作为参数。 在 Mac 平台上 action 方法的第一个参数永远是发送者，否则将不视为无效方法。 在AppKit唯一有效的action 方法声明方式： {% codeblock lang:objc %} (void)performAction:(id)sender; {% endcodeblock %} 控件关联Action事件的区别 iOS 上的 UIControl 和 Mac 上的 NSControl/NSCell 都支持这个机制。\n在 iOS 中，每个控件可以通过addTarget:action:forControlEvents:和多个 target-action 关联。 在AppKit中通常一个控件仅对应一个 target-action对。 View视图系统 因为历史遗留问题，Mac 的视图系统和 iOS的视图系统有很大区别。\n绘图处理器差异 iOS由 Core Animation layer 驱动，使用GPU处理。 AppKit视图系统相关的任务主要靠 CPU 处理，因为在AppKit设计之初，GPU还没有诞生。 Mac开发参考资料： Introduction to View Programming Guide for Cocoa WWDC session：Layer-Backed Views: AppKit + Core Animation Optimizing Drawing and Scrolling Layer-Backed View: iOS反哺AppKit层支持视图 iOS反哺AppKit 默认情况下，AppKit 的 view 不是由 Core Animation layer 驱动的；AppKit 整合 layer-backing 是 iOS 反哺的结果。 layer backing启用／禁用:wantsLayer AppKit 区分 layer-backed view 和 layer-hosting view，可以在每个视图树的根节点启用或者禁用 layer backing。 启用 layer backing\n方法一：把窗口的 contentView 的 wantsLayer 属性设置为 YES 方法二：在 Interface Builder 的 View Effects Inspector 面板完成 这会导致 window 的视图树中所有的 view 都启用 layer backing，这样就没必要反复设置每个 view 的 wantsLayer 属性了。 修改layer属性 在AppKit上开启layer backing之后，layer的拥有者是AppKit，这就意味着不能直接编辑 layer的属性。 在 iOS 上可以直接编辑： {% codeblock lang:objc %} self.layer.backgroundColor = [UIColor redColor].CGColor; {% endcodeblock %} 在 AppKit编辑layer属性需要以下步骤：\n重写 NSView 的 wantsUpdateLayer 方法并返回 YES,这能让你可以改变 layer 的属性。 这样以来，在view 更新周期中，将不会再调用 view 的 drawRect: 方法。取而代之，调用updateLayer方法来更新Layer。 举个例子，用这方法去实现一个非常简单的有纯色背景的 view（没错，NSView 没有backgroundColor 属性）： 这个例子的前提是这个 view 的父 view 已经为其视图树启用了 layer backing。 另一种可行的实现则只需要重写 drawRect: 方法并在其中绘制背景颜色。 {% codeblock lang:objc %} @interface ColoredView: NSView @property (nonatomic) NSColor *backgroundColor; @end @implementation ColoredView\n(BOOL)wantsUpdateLayer { return YES; }\n(void)updateLayer { self.layer.backgroundColor = self.backgroundColor.CGColor; }\n(void)setBackgroundColor:(NSColor *)backgroundColor { _backgroundColor = backgroundColor; [self setNeedsDisplay:YES]; } @end {% endcodeblock %}\n合并 Layer 当APP启动过多的layer-backed view 会带来巨大的内存消耗（每一个 layer 有其自己的 backing store，还有可能和其他 view 的 backing store 重叠）而且会带来潜在的合成这些 layer 的消耗。\ncanDrawSubviewsIntoLayer合并Layer 从 OS X 10.9 开始，如果不单独对一个 view 中的子 view 做动画，可以通过设置 canDrawSubviewsIntoLayer 属性来让 AppKit 合并一个视图树中所有 layer 的内容到一个共有的 layer。\n隐式layer-backed合并Layer 所有隐式 layer-backed 的子 view（比如，没有显式地对这些子 view 设置 wantsLayer = YES）现在将会被绘制到同一个 layer 中。不过wantsLayer 设置为 YES 的子 view 仍然持有它们自己的 backing layer， 而且不管 wantsUpdateLayer 返回什么，它们的 drawRect: 方法仍然会被调用。\nLayer 重绘策略 layer-backed view 默认的自动重绘策略 layer-backed view 会默认设置重绘策略为 NSViewLayerContentsRedrawDuringViewResize。在行为上，这个非 layer-backed view 是类似的，不过如果动画的每一帧都引入一个绘制步骤的话可能会对动画的性能造成不利影响。\n设置layer-backed view手动重绘策略 设置手动重绘策略：把 layerContentsRedrawPolicy 属性设置为 NSViewLayerContentsRedrawOnSetNeedsDisplay 实现手动重绘操作：调用 -setNeedsDisplay:方法来触发重绘操作 这样便由你来决定 layer 的内容何时需要重绘。帧的改变将不再自动触发重绘。 设置view的属性来重绘Layer view中layerContentsPlacement属性：等价layer中的 contentGravity 属性。 这个属性允许你指定在调整大小的时候当前的 layer 内容该怎么映射到 layer 上。 Layer-Hosting View:使用 Core Animation layer layer-hosting view 是视图树中的叶子节点，使用这种模式可以对layer 及其子 layer 做任何操作，代价是你再也不能给该 view 添加任何子 view。\n创建 为 view 的 layer 属性分配一个 layer 对象， 设置wantsLayer 为 YES 这些步骤的顺序是非常关键： {% codeblock lang:swift %} (instancetype)initWithFrame:(NSRect)frame { self = [super initWithFrame:frame]; if (self) { self.layer = [[CALayer alloc] init]; self.wantsLayer = YES; } } {% endcodeblock %} 在你设置了自定义的 layer 之后，再设置 wantsLayer 是非常重要的。 其他与 View 相关的陷阱 坐标系统原点设置左下／左上角 通过重写isFlipped 并返回 YES 来恢复到你熟悉的左上角。\nView背景颜色属性drawsBackground 由于 AppKit 中的 view 没有背景颜色属性可以让你直接设置为 [NSColor clearColor] 来让其变得透明，许多 NSView 的子类比如 NSTextView 和 NSScrollView 开放了一个 drawsBackground 属性，如果你想让这一类 view 透明，你必须设置该属性为 NO。\n设置光标追踪区域 为了能接收光标进出一个 view 或者在 view 里面移动的事件，你需要创建一个追踪区域。你可以在 NSView 中指定的 updateTrackingAreas 方法中来做这件事情。一个通用的写法看起来是这样子的： {% codeblock lang:swift %}\n(void)updateTrackingAreas { [self removeTrackingArea:self.trackingArea]; self.trackingArea = [[NSTrackingArea alloc] initWithRect:CGRectZero options:NSTrackingMouseEnteredAndExited|NSTrackingInVisibleRect|NSTrackingActiveInActiveApp owner:self userInfo:nil]; [self addTrackingArea:self.trackingArea]; } {% endcodeblock %} NSCell困惑 AppKit 的控件之前是由 NSCell 的子类驱动的，可以被所有同类型的控件重用。 AppKit 最初区分 view 和 cell 是为了节省资源 - view 可以把所有的绘制工作代理给更轻量级的可以被所有同类型的 view 重用的 cell 对象。 不要混淆这些 cell 和 UIKit 里 table view 的 cell 及 collection view 的 cell。\n自定义一个按钮控件 Apple 正在一步步地抛弃这样的实现方法了，但是你还是会时不时碰到这样的问题。 举个例子，如果你想创建一个自定义的按钮，\n首先要继承 NSButton 和 NSButtonCell 然后在这个 cell 子类里面进行你自定义的绘制， 然后通过重写 +[NSControl cellClass] 方法告诉自定义按钮使用你的 cell 子类 获取 Core Graphics 上下文 最后，如果你想知道在你自己的 drawRect: 方法里怎么获取当前的 Core Graphics 上下文，答案是 NSGraphicsContext 的 graphicsPort 属性。详细内容请查看 Cocoa Drawing Guide。\n动画 如果你的 view 不是由 layer 驱动的，那你的动画自然是完全由 CPU 处理，这意味着动画的每一步都必须相应地绘制到 window-backing store 上。\n对 layer-backed view做动画 正如上面说的，在 AppKit 中,这些 layer 由 AppKit 管理，你不应该修改 layer-backed view 中的 layer。\n几何属性 与iOS 相反，view 的几何属性并不仅仅是对应的 layer 的几何属性的映射，但 AppKit 却会把 view 内部的几何属性同步到 layer。\n的animator proxy动画 {% codeblock lang:objc %} view.animator.alphaValue = .5; {% endcodeblock %} 在幕后，这句代码会启用 layer 的隐式动画，设置其透明度，然后再次禁用 layer 的隐式动画。\nNSAnimationContext动画 结束回调 {% codeblock lang:objc %} [NSAnimationContext runAnimationGroup:^(NSAnimationContext *context){\n//持续时间 context.duration = 1;\n//缓动类型 context.timingFunction = [CAMediaTimingFunction functionWithName:kCAMediaTimingFunctionEaseIn]; view.animator.alphaValue = .5;\n} completionHandler:^{ // \u0026hellip; }]; {% endcodeblock %} 2. 无结束回调 {% codeblock lang:objc %} [NSAnimationContext currentContext].duration = 1; view.animator.alphaValue = .5; {% endcodeblock %}\n启用隐式动画 {% codeblock lang:objc %} [NSAnimationContext currentContext].allowsImplicitAnimations = YES; view.alphaValue = .5; {% endcodeblock %}\nCAAnimations控制动画 使用 CAAnimation 实例更全面地控制动画。和 iOS 相反，你不能直接把它们加到 layer 上（因为 layer 不应该由你来修改），不过你可以使用 NSAnimatablePropertyContainer 协议中定义的 API，NSView 和 NSWindow 已经实现了该协议。 {% codeblock lang:objc %} CAKeyframeAnimation *animation = [CAKeyframeAnimation animation]; animation.values = @[@1, @.9, @.8, @.7, @.6]; view.animations = @{@\u0026ldquo;alphaValue\u0026rdquo;: animation}; view.animator.alphaValue = .5; {% endcodeblock %}\n帧动画 对于帧动画来说，把 view 的 layerContentsRedrawPolicy 设置为 NSViewLayerContentsRedrawOnSetNeedsDisplay 是非常重要的，不然的话 view 的内容在每一帧都会被重绘。\n很遗憾，NSView 没有开放 Core Animation layer 所有可以进行动画的属性，transform 是其中最重要的例子。看看 Jonathan Willings 的这篇文章，它描述了你可以如何解决这些限制。不过注意，文章中的解决方案是不受官方支持的。\n上面提到的所有东西都适用于 layer-backed view。对于 layer-hosting view 来说，你可以直接对 view 的 layer 或者子 layer 使用 CAAnimations，因为你拥有它们的控制权。\n文字系统 有了 TextKit，iOS 7 终于有了和 Mac 上早就有了的 Cocoa Text System 等效的东西。但 Apple 并不仅仅是把文字系统从 Mac 上转移到 iOS；相反，Apple 对其做了些显著的改变。 举个例子，AppKit 开放 NSTypesetter 和 NSGlyphGenerator，你可以通过继承这两者来自定义它们的一些特性。iOS 并不开放这些类，但是你可以通过 NSLayoutManagerDelegate 协议达到定制的目的。 总体来说，两个平台的文字系统还是非常相似的，所有你在 iOS 上能做的在 Mac 上都可以做（甚至更多），但对于一些东西，你必须从不同的地方寻找合适的方法实现。\n沙盒 符合沙盒机制的 Mac 应用才能通过 Mac App Store 销售。然而，我们已经习惯了沙盒机制还没出现之前的 Mac 开发环境，所以有时候会忽视一些你想要实现的功能会和沙盒的限制出现冲突。 管理Mac应用对沙盒支持：\n独有特性 有很多事情你只能在 Mac 上做，这主要是因为它不同的交互模型和它更为宽松的安全策略。在本期话题中，我们有一些文章深入探讨了其中的一些内容：进程间通讯，使 Mac 应用脚本化,在沙盒中脚本化其他应用 , 为你的应用构建插件。 当然，这只是 Mac 独有特性中很小的一部分，但这给了你一个很好的视角看待 iOS 8 从头开始打造其可扩展性和 app 间通讯。最后，还有很多东西等待你去探索：Drag and Drop，Printing，Bindings，OpenCL 等等，这里仅仅是举几个例子。\n","date":"2017-03-03T17:55:16Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E4%BB%8EUIKit%E5%88%B0AppKit/","section":"post","tags":["macos"],"title":"从UIKit到AppKit"},{"categories":["学习笔记"],"contents":"FRP函数式反应型编程 Functional Reactive Programming ， 缩写为 FRP\n函数编程 函数是第一等公民 所谓 第一等公民 (first class) ，指的是函数与其他数据类型一样，处于平等地位。既可以赋值给其他变量，也可以作为参数传入另一个函数，或者作为别的函数的返回值。 将数组通过指定的函数映射成另一个数组，例如将increment函数作为参数传入数组的map函数: {% codeblock lang:swift %} let increment = { return $0 + 1 } [1,2,3].map(increment) // [2,3,4] {% endcodeblock %}\n函数式的函数 map 映射函数 map 可以把一个数组按照一定的规则转换成另一个数组，定义如下： {% codeblock lang:swift %} func map(transform: (T) -\u0026gt; U) -\u0026gt; U[] //效果 [ x1, x2, \u0026hellip; , xn].map(f) -\u0026gt; [f(x1), f(x2), \u0026hellip; , f(xn)] {% endcodeblock %} map接受一个把 T 类型的转换成 U 类型的transform函数，最终返回的是 U 类型的集合。\nfilter 筛选函数 filter通过在闭包中对每个元素进行逻辑运算，来排除为false的元素 {% codeblock lang:swift %} func filter(includeElement: (T) -\u0026gt; Bool) -\u0026gt; [T] //实现 var oldArray = [10,20,45,32] var filteredArray = oldArray.filter({ return $0 \u0026gt; 30 }) println(filteredArray) // [45, 32] {% endcodeblock %}\nreduce 迭代函数 reduce函数把U类型集合中的所有元素，以initial为初始值，按照combine规则，逐个迭代并返回一个U类型的对象。 定义如下： {% codeblock lang:swift %} func reduce(initial: U, combine: (U, T) -\u0026gt; U) -\u0026gt; U {% endcodeblock %} reduce 有两个参数，initial是初始值，combine定义规则闭包，闭包有两个输入的参数，一个是原始值，一个是新进来的值，闭包返回的新值作为下一轮循环中的initial值。 写几个小例子试一下： {% codeblock lang:swift %} var oldArray = [10,20,45,32] var sum = 0 sum = oldArray.reduce(0,{$0 + $1}) // 0+10+20+45+32 = 107 sum = oldArray.reduce(1,{$0 + $1}) // 1+10+20+45+32 = 108 sum = oldArray.reduce(5,{$0 * $1}) // 510204532 = 1440000 sum = oldArray.reduce(0,+) // 0+10+20+45+32 = 107 println(sum) {% endcodeblock %}\n函数式和指令式的比较 响应式编程 - Reactive 在日常开发中，我们经常需要监听某个属性，并且针对该属性的变化做一些处理。比如以下几个场景：\n用户在输入邮箱的时候，监测输入的内容并在界面上提示是否符合邮箱规范。 用户在修改用户名之后，所有显示用户名的界面都要改为新的用户名。 外部输入信号的变化、事件的发生，这些都是典型的外部环境变化。根据外部环境的变化进行响应处理，直观上来讲像是一种自然地反应。我们可以将这种自动对变化作出响应的能力称为反应能力 (Reactive) 。 那么什么是反应型编程呢？\nReactive programming is programming with asynchronous data streams. 反应型编程是异步数据流的编程。 对于移动端来说，异步数据流的概念并不陌生，变量、点击事件、属性、缓存，这些就可以成为数据流。 我们可以通过一些简单的 ASCII 字符来演示如何将事件转换成数据流： \u0026ndash;a\u0026mdash;b-c\u0026mdash;d\u0026mdash;X\u0026mdash;|\u0026ndash;\u0026gt; a, b, c, d 是具体的值，代表了某个事件 X 表示发生了一个错误 | 是这个流已经结束了的标记 \u0026mdash;\u0026mdash;\u0026mdash;-\u0026gt; 是时间轴 比如我们要统计用户点击鼠标的次数，那么可以这样： clickStream: \u0026mdash;c\u0026mdash;-c\u0026ndash;c\u0026mdash;-c\u0026mdash;\u0026mdash;c\u0026ndash;\u0026gt; vvvvv map(c becomes 1) vvvv \u0026mdash;1\u0026mdash;-1\u0026ndash;1\u0026mdash;-1\u0026mdash;\u0026mdash;1\u0026ndash;\u0026gt; vvvvvvvvv scan(+) vvvvvvvvv counterStream: \u0026mdash;1\u0026mdash;-2\u0026ndash;3\u0026mdash;-4\u0026mdash;\u0026mdash;5\u0026ndash;\u0026gt; 反应型编程就是基于这些数据流的编程。而函数式编程则相当于提供了一个工具箱，可以方便的对数据流进行合并、创建和过滤等操作。\nswift 函数式编程 Swift 是苹果公司在 2014 年推出的编程语言，用于编写 iOS 和 OS X 应用程序。它吸收了很多其它语言的语法特性，例如闭包、元组、泛型、结构体等等，这使得它的语法简洁而灵活。 Swift 本身并不是一门函数式语言，不过有一些函数式的方法和特性\nmap reduce 等函数式函数 函数是一等公民 模式匹配 我们并不能因为 Swift 中的一些函数式特性就把它归为函数式语言，但是我们可以利用这些特性进行函数式 Style 的编程。 RxSwift 响应式编程 Rx.playground\nObservable观察者模式 Rx 的基础：Observable ， Observable\u0026lt;Element\u0026gt; 是观察者模式中可观察的对象，相当于一个事件序列 (GeneratorType)。 支持订阅的事件序列，在下文简称为订阅源或可观察者。 订阅源的事件队列中包括三种事件类型：\n.Next(value): 表示新的事件数据。 .Completed: 表示事件序列的完结。 .Error: 同样表示完结，但是代表异常导致的完结。 新建订阅源几种快捷方法 empty是一个空的序列，它只发送 .Completed 消息。 {% codeblock Observable+Creation.swift lang:swift %} public static func empty() -\u0026gt; Observable example(\u0026ldquo;empty\u0026rdquo;) { let emptySequence: Observable = empty() let subscription = emptySequence.subscribe { event in print(event) } } \u0026mdash; empty example \u0026mdash; Completed {% endcodeblock %} never 是没有任何元素、也不会发送任何事件的空序列。 {% codeblock Observable+Creation.swift lang:swift %} /** returns: An observable sequence whose observers will never get called. */ public static func never() -\u0026gt; Observable {% endcodeblock %} just 是只包含一个元素的序列，它会先发送 .Next(value) ，然后发送 .Completed {% codeblock Observable+Creation.swift lang:swift %} /** Returns an observable sequence that contains a single element. */ public static func just(_ element: E) -\u0026gt; Observable { return Just(element: element) } {% endcodeblock %} sequenceOf 可以把一系列元素转换成订阅源 {% codeblock lang:swift %} let sequenceOfElements/* : Observable */ = sequenceOf(0, 1, 2, 3) {% endcodeblock %} asObservable方法 将遵守ObservableType协议的对象转为可观察者序列 {% codeblock ObservableType.swift lang:swift %} public protocol ObservableType : ObservableConvertibleType { //Default implementation of converting ObservableType to Observable. public func asObservable() -\u0026gt; Observable } let sequenceFromArray = [1, 2, 3, 4, 5].asObservable() {% endcodeblock %} failWith创建一个没有元素的序列，只会发送失败 (.Error) 事件。 {% codeblock lang:swift %} let error = NSError(domain: \u0026ldquo;Test\u0026rdquo;, code: -1, userInfo: nil) let erroredSequence: Observable = failWith(error) let subscription = erroredSequence.subscribe { event in print(event)} \u0026mdash; failWith example \u0026mdash; Error(Error Domain=Test Code=-1 \u0026ldquo;The operation couldn’t be completed. (Test error -1.)\u0026rdquo;) {% endcodeblock %} create自定义订阅源 create 可以通过闭包创建序列，通过 .on(e: Event) 添加可观察者事件。 {% codeblock lang:swift %} example(\u0026ldquo;create\u0026rdquo;) { let myJust = { (singleElement: Int) -\u0026gt; Observable in return create { observer in observer.on(.Next(singleElement)) observer.on(.Completed) return NopDisposable.instance } }\nlet subscription = myJust(5).subscribe { event in print(event) } } \u0026mdash; create example \u0026mdash; Next(5) Completed {% endcodeblock %}\ndeferred订阅源的懒加载 deferred表示当有有新增订阅者第一次订阅了该订阅源时，订阅源才会被创建，且每个订阅者订阅的对象都是内容相同而完全独立的序列。 {% codeblock lang:swift %} example(\u0026ldquo;TestDeferred\u0026rdquo;) { var value: String? = nil var subscription: Observable\u0026lt;String?\u0026gt; = deferred { return just(value) } // got value value = \u0026ldquo;Hello!\u0026rdquo; subscription.subscribe { event in print(event) } } \u0026mdash; TestDeferred example \u0026mdash; Next(Optional(\u0026ldquo;Hello!\u0026rdquo;)) Completed {% endcodeblock %}\n几种特殊类型的订阅源 Subject 可以看做是一种代理和桥梁。它既是订阅者又是订阅源，这意味着它既可以订阅其他 Observable 对象，同时又可以对它的订阅者们发送事件。\nPublishSubject 向所有订阅者发送事件队列 当PublishSubject类型订阅源事件队列中.on()新增事件时，会触发所有订阅者，一起响应该事件。 {% codeblock lang:swift %} example(\u0026ldquo;PublishSubject\u0026rdquo;) { let subject = PublishSubject() writeSequenceToConsole(\u0026ldquo;1\u0026rdquo;, sequence: subject) subject.on(.Next(\u0026ldquo;a\u0026rdquo;)) subject.on(.Next(\u0026ldquo;b\u0026rdquo;)) writeSequenceToConsole(\u0026ldquo;2\u0026rdquo;, sequence: subject) subject.on(.Next(\u0026ldquo;c\u0026rdquo;)) subject.on(.Next(\u0026ldquo;d\u0026rdquo;)) } \u0026mdash; PublishSubject example \u0026mdash; Subscription: 1, event: Next(a) Subscription: 1, event: Next(b) Subscription: 1, event: Next(c) Subscription: 2, event: Next(c) Subscription: 1, event: Next(d) Subscription: 2, event: Next(d) {% endcodeblock %}\n基于PublishSubject的几种补发式订阅源 以下几种类型的订阅源，相较第一种仅多了补发历史事件，姑且称为补发式订阅源。\nReplaySubject先向最新订阅者补发所有已发生的事件 当ReplaySubject类型的订阅源，新增订阅者时，该类型的订阅源会把之前已发送过的所有事件队列重新补发给这个最新订阅者。这样就迫使订阅者会对从历史的事件队列逐一响应。 bufferSize 是缓冲区的大小，决定了补发队列的最大值。如果 bufferSize 是1，那么新的订阅者出现的时候就会补发上一个事件，如果是2，则补两个，以此类推。 {% codeblock lang:swift %} example(\u0026ldquo;ReplaySubject\u0026rdquo;) { let subject = ReplaySubject.create(bufferSize: 1) writeSequenceToConsole(\u0026ldquo;1\u0026rdquo;, sequence: subject) subject.on(.Next(\u0026ldquo;a\u0026rdquo;)) subject.on(.Next(\u0026ldquo;b\u0026rdquo;)) writeSequenceToConsole(\u0026ldquo;2\u0026rdquo;, sequence: subject) subject.on(.Next(\u0026ldquo;c\u0026rdquo;)) subject.on(.Next(\u0026ldquo;d\u0026rdquo;)) } \u0026mdash; ReplaySubject example \u0026mdash; Subscription: 1, event: Next(a) Subscription: 1, event: Next(b) Subscription: 2, event: Next(b) // 补了一个 b Subscription: 1, event: Next(c) Subscription: 2, event: Next(c) Subscription: 1, event: Next(d) Subscription: 2, event: Next(d) {% endcodeblock %}\nBehaviorSubject 先向最新订阅者补发最近一次历史事件 BehaviorSubject类型的订阅源会向最新订阅者发送最近一次的历史事件队列，如果没有则发送一个默认值。 {% codeblock lang:swift %} example(\u0026ldquo;BehaviorSubject\u0026rdquo;) { let subject = BehaviorSubject(value: \u0026ldquo;z\u0026rdquo;) writeSequenceToConsole(\u0026ldquo;1\u0026rdquo;, sequence: subject) subject.on(.Next(\u0026ldquo;a\u0026rdquo;)) subject.on(.Next(\u0026ldquo;b\u0026rdquo;)) writeSequenceToConsole(\u0026ldquo;2\u0026rdquo;, sequence: subject) subject.on(.Next(\u0026ldquo;c\u0026rdquo;)) subject.on(.Completed) } \u0026mdash; BehaviorSubject example \u0026mdash; Subscription: 1, event: Next(z) Subscription: 1, event: Next(a) Subscription: 1, event: Next(b) Subscription: 2, event: Next(b) Subscription: 1, event: Next(c) Subscription: 2, event: Next(c) Subscription: 1, event: Completed Subscription: 2, event: Completed\n{% endcodeblock %}\nVariable Variable 是基于 BehaviorSubject 的一层封装，它的优势是：不会被显式终结。 即：不会收到 .Completed 和 .Error 这类的终结事件，它会主动在析构的时候发送 .Complete {% codeblock lang:swift %} example(\u0026ldquo;Variable\u0026rdquo;) { let variable = Variable(\u0026ldquo;z\u0026rdquo;) writeSequenceToConsole(\u0026ldquo;1\u0026rdquo;, sequence: variable) variable.value = \u0026ldquo;a\u0026rdquo; variable.value = \u0026ldquo;b\u0026rdquo; writeSequenceToConsole(\u0026ldquo;2\u0026rdquo;, sequence: variable) variable.value = \u0026ldquo;c\u0026rdquo; } \u0026mdash; Variable example \u0026mdash; Subscription: 1, event: Next(z) Subscription: 1, event: Next(a) Subscription: 1, event: Next(b) Subscription: 2, event: Next(b) Subscription: 1, event: Next(c) Subscription: 2, event: Next(c) Subscription: 1, event: Completed Subscription: 2, event: Completed {% endcodeblock %}\n支持订阅的嵌套函数 map{规则} 遍历映射 通过闭包中定义的规则将队列中的数据映射到新的队列中，支持订阅遍历事件。 {% codeblock lang:swift %} func map(transform: (T) -\u0026gt; U) -\u0026gt; U[] //效果 [ x1, x2, \u0026hellip; , xn].map(f) -\u0026gt; [f(x1), f(x2), \u0026hellip; , f(xn)] {% endcodeblock %} map接受一个把 T 类型的转换成 U 类型的transform函数，最终返回的是 U 类型的集合。 {% codeblock lang:swift %} example(\u0026ldquo;map\u0026rdquo;) { let originalSequence = sequenceOf(1,2,3) originalSequence.map{ $0 * 2 }.subscribe{ print($0) } } \u0026mdash; map example \u0026mdash; Next(2) Next(4) Next(6) Completed {% endcodeblock %}\nflatMap 嵌套式遍历映射 嵌套式遍历描述：在遍历当前队列的过程中，每次执行闭包时都会遍历另一个嵌套队列中的所有事件。 可以想象嵌套for 循环来理解。 {% codeblock lang:swift %} example(\u0026ldquo;flatMap\u0026rdquo;) { let sequenceInt = sequenceOf(1, 2, 3) let sequenceString = sequenceOf(\u0026ldquo;A\u0026rdquo;, \u0026ldquo;B\u0026rdquo;, \u0026ldquo;\u0026ndash;\u0026rdquo;) sequenceInt.flatMap{ int in sequenceString }.subscribe{ print($0) } } \u0026mdash; flatMap example \u0026mdash; Next(A) Next(B) Next(\u0026ndash;) Next(A) Next(B) Next(\u0026ndash;) Next(A) Next(B) Next(\u0026ndash;) Completed {% endcodeblock %}\nscan(initial:U,combine:(U, T) -\u0026gt; U)迭代映射 scan 有点像 reduce ，把U类型集合中的所有元素，以initial为初始值，按照combine规则，逐个迭代并返回一个U类型的对象。 {% codeblock lang:swift %} example(\u0026ldquo;scan\u0026rdquo;) { let sequenceToSum = sequenceOf(0, 1, 2, 3, 4, 5) sequenceToSum.scan(0) { acum, elem in acum + elem } .subscribe { print($0) } } \u0026mdash; scan example \u0026mdash; Next(0) Next(1) Next(3) Next(6) Next(10) Next(15) Completed {% endcodeblock %}\nFiltering 支持订阅的过滤器 filter{布尔语句} 条件过滤法 {% codeblock lang:swift %} example(\u0026ldquo;filter\u0026rdquo;) { let subscription = sequenceOf(0, 1, 2, 3, 4, 5, 6, 7, 8, 9) .filter { $0 % 2 == 0 }.subscribe { print($0) } } \u0026mdash; filter example \u0026mdash; Next(0) Next(2) Next(4) Next(6) Next(8) Completed {% endcodeblock %}\ndistinctUntilChanged() 去重过滤法（相邻且不重复） {% codeblock lang:swift %} example(\u0026ldquo;distinctUntilChanged\u0026rdquo;) { let subscription = sequenceOf(1, 2, 3, 1, 1, 4) .distinctUntilChanged().subscribe{ print($0) } } \u0026mdash; distinctUntilChanged example \u0026mdash; Next(1) Next(2) Next(3) Next(1) Next(4) Completed {% endcodeblock %}\ntake(int) 掐尖过滤法 take只获取队列中前 n 个事件，在满足数量之后会自动 .Completed {% codeblock lang:swift %} example(\u0026ldquo;take\u0026rdquo;) { let subscription = sequenceOf(1, 2, 3, 4, 5, 6) .take(3).subscribe { print($0) } } \u0026mdash; take example \u0026mdash; Next(1) Next(2) Next(3) Completed {% endcodeblock %}\nCombining 订阅源聚合器 订阅源聚合器将多个可观察者（订阅源）合并成一个可观察者（聚合订阅源），这样更便于订阅者同时监听多个订阅源。\nstartWith 向可观察者队列中添加排头兵（新增的可观察者） {% codeblock lang:swift %} let subscription = sequenceOf(4, 5, 6).startWith(3).subscribe { print($0)} \u0026mdash; startWith example \u0026mdash; Next(3) Next(4) Next(5) Next(6) Completed {% endcodeblock %}\ncombineLatest 合并聚合订阅源最后一次事件数据，生成一个聚合事件 便于订阅者监听聚合订阅源中每个订阅源的最后一次事件数据 {% codeblock lang:swift %} example(\u0026ldquo;combineLatest 1\u0026rdquo;) { let intOb1 = PublishSubject() let intOb2 = PublishSubject() combineLatest(intOb1, intOb2) {\u0026quot;($0) ($1)\u0026quot;}.subscribe { print($0) } intOb1.on(.Next(\u0026ldquo;A\u0026rdquo;)) intOb2.on(.Next(1)) intOb1.on(.Next(\u0026ldquo;B\u0026rdquo;)) intOb2.on(.Next(2)) } \u0026mdash; combineLatest 1 example \u0026mdash; Next(A 1) Next(B 1) Next(B 2) {% endcodeblock %}\nzip(intOb1, intOb2) 拉链式合并 仅在凑齐聚合源中所有订阅源的事件时，才会聚合一次，触发订阅者的响应。可以将多达8个订阅源 {% codeblock lang:swift %} example(\u0026ldquo;zip 1\u0026rdquo;) { let intOb1 = PublishSubject() let intOb2 = PublishSubject() zip(intOb1, intOb2) { \u0026ldquo;($0) ($1)\u0026rdquo; }.subscribe { print($0)} intOb1.on(.Next(\u0026ldquo;A\u0026rdquo;)) intOb2.on(.Next(1)) intOb1.on(.Next(\u0026ldquo;B\u0026rdquo;)) intOb1.on(.Next(\u0026ldquo;C\u0026rdquo;)) intOb2.on(.Next(2)) } \u0026mdash; zip 1 example \u0026mdash; Next(A 1) Next(B 2) {% endcodeblock %}\nmerge() 按可观察者的新的事件次序合并队列 订阅者会按次序来响应聚合订阅源的每一件事件 {% codeblock lang:swift %} example(\u0026ldquo;merge 1\u0026rdquo;) { let subject1 = PublishSubject() let subject2 = PublishSubject() sequenceOf(subject1, subject2).merge().subscribeNext { int in print(int)} subject1.on(.Next(1)) subject1.on(.Next(2)) subject2.on(.Next(3)) subject1.on(.Next(4)) subject2.on(.Next(5)) } \u0026mdash; merge 1 example \u0026mdash; 1 2 3 4 5 {% endcodeblock %}\nswitchLatest订阅源切换器：用于嵌套式订阅源 通过切换（var3.value）嵌套的订阅源，来切换订阅者当前监听的订阅源，以响应当前订阅源中的可观察者的事件。 {% codeblock lang:swift %} example(\u0026ldquo;switchLatest\u0026rdquo;) { let var1 = Variable(0) let var2 = Variable(200) // var3 is like an Observable\u0026lt;Observable\u0026gt; let var3 = Variable(var1) let d = var3.switchLatest().subscribe{ print($0) } var1.value = 1 var1.value = 2 var1.value = 3 var1.value = 4 var3.value = var2 var2.value = 201 var1.value = 5 var3.value = var1 var2.value = 202 var1.value = 6 } \u0026mdash; switchLatest example \u0026mdash; Next(0) Next(1) Next(2) Next(3) Next(4) Next(200) Next(201) Next(5) Next(6) {% endcodeblock %}\n订阅器 订阅器：subscribe 用来订阅可观察者的事件队列（即订阅源），并指定响应的相关操作 Next订阅器：subscribeNext 只订阅 .Next 事件 Completed订阅器：subscribeCompleted 只订阅.Completed 完成事件 Error订阅器：subscribeError 订阅 .Error 失败事件 订阅器观察者：doOn 在订阅器执行之前，获得执行代码的机会。可对比理解：swift中的属性观察者 控制take掐尖过滤器 过滤器通过指定的事件和状态语句来判断是否停止take\ntakeUntil 得到指定事件之后触发 .Completed 事件 {% codeblock lang:swift %} example(\u0026ldquo;takeUntil\u0026rdquo;) { let originalSequence = PublishSubject() let whenThisSendsNextWorldStops = PublishSubject() originalSequence.takeUntil(whenThisSendsNextWorldStops) .subscribe { print($0) } originalSequence.on(.Next(1)) originalSequence.on(.Next(2)) whenThisSendsNextWorldStops.on(.Next(1)) originalSequence.on(.Next(3)) } \u0026mdash; takeUntil example \u0026mdash; Next(1) Next(2) Completed {% endcodeblock %}\ntakeWhile 判断语句 takeWhile 则是可以通过状态语句判断是否继续 take 。 {% codeblock lang:swift %} example(\u0026ldquo;takeWhile\u0026rdquo;) { let sequence = PublishSubject() sequence.takeWhile { int in int \u0026lt; 2 }.subscribe { print($0) } sequence.on(.Next(1)) sequence.on(.Next(2)) sequence.on(.Next(3)) } \u0026mdash; takeWhile example \u0026mdash; Next(1) Completed {% endcodeblock %}\n","date":"2017-03-03T13:01:41Z","permalink":"https://it-boyer.github.io/post/old/%E5%BC%80%E6%BA%90%E5%BA%93/RxSwift%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","section":"post","tags":["SDK"],"title":"RxSwift基本概念"},{"categories":["学习笔记"],"contents":"Playground 展示语法和实时执行真实数据的特性，为编写方法和库接口提供了很好的机会，通过实时编译我们能了解语法、写出例子以及获得方法如何使用的说明，所有这些就如一个活的文档展示在眼前。\n演习框架API，了解框架结构 SceneKitMac.playground 是一个功能完备带动画的 3D 场景。你需要打开 Assistant Editor (在菜单上依次点击 View | Assistant Editor | Show Assistant Editor)，3D 效果和动画将会被自动渲染。这不需要编译循环，而且任何的改动，比如改变颜色、几何形状、亮度等，都能实时反映出来。使用它能在一个交互例子中很好的记录和介绍如何使用SceneKit框架。 测试驱动开发 我们可以验证一个方法的执行是否正确，甚至在加载到 playground 的时候就能判断方法是否被正确解析。不难想象我们也可以在 playground 里添加断言，以及创建真正的单元测试。或者更进一步，创建出符合条件的测试，从而在你打字时就实现测试驱动开发。 Sources 打开 Project Navigator (⌘1) 并展开 Playground 文件，你就能看到\u0026quot;Sources\u0026quot;路径。 放到此目录下的源文件会被编译成模块(module)并自动导入到 Playground 中，并且这个编译只会进行一次(或者我们对该目录下的文件进行修改的时候)，而非每次你敲入一个字母的时候就编译一次。 这将会大大提高代码执行的效率。\n注意：由于此目录下的文件都是被编译成模块导入的，只有被设置成 public 的类型，属性或方法才能在 Playground 中使用。\n导入Frameworks 如果想要导入外部 framework，创建一个 Xcode Workspace 包含了 framework 项目和你的 Playground。在 Build 之后，就可以通过常规的import命令导入对应的包。\n手动配置cocoa touch Framework来桥接playground 在Playgroud中使用个人项目中的类相关方法，需要借助于Custom Frameworks桥接 注：.swift的文件中的方法必须是public修饰。 参考文档：Playground help -\u0026gt; Importing Custom Frameworks into a Playground\n导入个人项目文件，需要借助cocoa touch Framework桥接playground 需要workspace来管理Framework项目和playground文件，典型例子：pod项目都是用workspace来管理多个项目。 把个人项目的swift文件关联到Cocoa touch Framework项目的target中： 详细设置：选中target -\u0026gt; build phases -\u0026gt; compiles sources -\u0026gt;点击 + 加号，选中原项目中的swift 在build选项中选中Framework的scheme进行编译 ,要保证framework的target配置：build setting -\u0026gt; build active architecture Only -\u0026gt;debug选项设置为YES 打开playground文件 import Framework名称，此时即可使用Framework中的提供的public API方法了。 Workspace相关设置，build生成的目录：xcode偏好设置要和项目中的workspace中设置要保持一致. xcode的偏好设置中 -\u0026gt;Locations -\u0026gt; Locations -\u0026gt;点击打开 Advanced\u0026hellip;在弹出框中设置Unique选项. 在workspace中选中菜单 File -\u0026gt; workspace settings\u0026hellip; -\u0026gt; 在弹出框中设置为Unique选项. 导入cocopads管理的依赖库 xcode7.3.1和cocoapods1.0版本导致playground无法import相关动态库 解决办法：http://stackoverflow.com/questions/38216238/xcode-playground-with-cocoapods# {% codeblock lang:bash %} #在写入磁盘之前，修改一些工程的配置: post_install do |installer| installer.pods_project.targets.each do |target| if target.name != \u0026lsquo;CocoaAsyncSocket\u0026rsquo; #playground相关配置，会导致\u0026rsquo;GCDAsyncSocket.h\u0026rsquo; file not found target.build_configurations.each do |config| config.build_settings[\u0026lsquo;CONFIGURATION_BUILD_DIR\u0026rsquo;] = \u0026lsquo;$PODS_CONFIGURATION_BUILD_DIR\u0026rsquo;\n#Use Legacy Swift Language Version” (SWIFT_VERSION): # https://github.com/CocoaPods/CocoaPods/issues/5864#issuecomment-247109685 puts \u0026quot;SWIFT_VERSIION:\u0026quot; config.build_settings['SWIFT_VERSION'] = \u0026quot;3.0.1\u0026quot; puts config.build_settings['SWIFT_VERSION'] end else #输出操作 puts \u0026quot;以下不能在playground中使用的库名：\u0026quot; puts target.name end end end {% endcodeblock %}\nPlayground沙盒Resources Playgrounds 有两个与相关的Resources关联起来：一个是每一个独立的 playground 本地的，另一个则是 playground 之间共享的。在你的实验过程中，Playgrounds 能够支持 XML，JSON 数据，XIB，和图像文件。这也增加了其使用可用性。\n本地 bundle访问本地资源 Resources 文件夹, 与 Sources 文件夹一样在 Playground 的包路径中, 通过 Project Navigator 就可见了——只需要简单的拖拽图像和数据文件，就可以在 Playground 中使用了。对应的内容在 main bundle 中也是可见的。比如，我们可以像这样非常快捷的加载一个包含天气数据的 JSON 文件： {% codeblock lang:swift %} let jsonPath = NSBundle.mainBundle().bundlePath.stringByAppendingPathComponent(\u0026ldquo;weather.json\u0026rdquo;) if let jsonData = NSData(contentsOfFile: jsonPath), json = NSJSONSerialization.JSONObjectWithData(jsonData, options: nil, error: nil) as? [String: AnyObject] { // \u0026hellip; } {% endcodeblock %}\n共享 访问Documents共享目录 \u0026ldquo;共享 Playground 数据\u0026quot;的内容在你的\u0026quot;Documents\u0026quot;文件夹路径下，也同样对于你创建的任何 Playground 都可见。我们通过XCPSharedDataDirectoryPath常量来访问该共享文件夹。\n如果你自习想尝试，需要在 \u0026ldquo;~/Documents/Shared Playground Data\u0026rdquo; 下简历一个文件夹。 这里我们尝试载入一个名字叫做 \u0026ldquo;image.png\u0026rdquo; 的图片文件:\n{% codeblock lang:swift %} let sharedImagePath = XCPSharedDataDirectoryPath.stringByAppendingPathComponent(\u0026ldquo;image.png\u0026rdquo;) if let image = UIImage(contentsOfFile: sharedImagePath) { // \u0026hellip; } {% endcodeblock %}\nPlaygroundSupport liveView视图代理 实现在playground中实现UI显示及交互操作 liveView定义： {% codeblock lang:swift %} public var liveView: XCPlaygroundLiveViewable? {% endcodeblock %} 遵循了XCPlaygroundLiveViewable协议即可在playground中可视化显示：\n在iOS 和 tvOS中UIView and UIViewController遵循该协议 在OS X中NSView and NSViewController遵循该协议 用户自定类型，须遵守XCPlaygroundLiveViewable协议 总之，只要遵守改协议并实现代理方法，都可以在playground中可视化显示。 用法： {% codeblock lang:swift %} PlaygroundPage.current.liveView = UIView()／NSViewController() {% endcodeblock %} 捕获值（XCPCaptureValue在XCPlayground中过时） 冒泡排序可视化预览 {% codeblock XCPlayground Module lang:swift %} /// This function has been deprecated. @available(*, deprecated) public func XCPCaptureValue(identifier: String, value: T) {% endcodeblock %}\n简介：可以多次调用该方法来做图，相同的 identifier 的数据将会出现在同一张图上，而 value 将根据输入的次序进行排列,将一组数据轻而易举地绘制到时间轴上，从而让我们能看到每一步的结果。这不仅对我们直观且及时地了解算法内部的变化很有帮助，也会是教学或者演示时候的神兵利器。\n使用：导入框架import XCPlayground 扩展：XCPCaptureValue 的数据输入是任意类型的，所以不论是传什么进去都是可以表示的。它们将以 QuickLook 预览的方式被表现出来，一些像 UIImage，UIColor 或者 UIBezierPath 这样的类型已经实现了 QuickLook。当然对于那些没有实现快速预览的 NSObject 子类，也可以通过重写 一个 Playground 通常立即显示简单表达式的结果。数组，字符串，数字等等，会在结果面板把计算后的结果显示出来。那么，随着时间改变的值是如何处理的呢？\n通过使用 XCPCaptureValue() 函数，我们可以随着一系列的迭代建立一个变动值的图。回到我们上面提到的天气例子，让我们来看看按小时计的温度数据，使用 XCPCaptureValue 来在辅助编辑界面以时间线的方式显示 温度的值：\n{% codeblock lang:swift %} import XCPlayground\nfor forecast in forecasts { if let tempString = forecast[\u0026ldquo;temp\u0026rdquo;]?[\u0026ldquo;english\u0026rdquo;] as? String, temperature = tempString.toInt() { XCPCaptureValue(\u0026ldquo;Temperature\u0026rdquo;, temperature) } } {% endcodeblock %}\n另一种可选的方式是, 选择 Editor → Show Result For Current Line 就会捕获当前线的数值并且直接以图表的形势显示在 Playground 流中：\n异步执行（Asynchronous Execution） 不同于大部分 Swift 代码，是作为框架或者应用的一部分，Playgrounds 被当做是 高级代码。Playground 中的高级代码是按照指令接着指令的顺序从上到下执行的。 这种无容器风格的代码执行提供了立即反馈，但是存在着一个问题：在执行到了 Playground 底部后，会立即停止。网络请求，计时器，以及长时间运行的后台队列都会在提供反馈成功或者失败之前被立即终止。 PlaygroundSupport 模块包含一个能够延长该过程的函数： {% codeblock lang:swift %} public var needsIndefiniteExecution: Bool {% endcodeblock %}\n开启异步：默认值为false,当使用liveView代理时，会自动设置为true。当为true时，在高级代码执行完成后，会告诉Xcode继续运行Playground页面。为false时，当代码执行完直接终止。 手动终止：还可以使用PlaygroundPage.finishExecution()手动终止正在运行的Playground。 {% codeblock lang:swift %} import PlaygroundSupport\nPlaygroundPage.current.needsIndefiniteExecution = true\nlet url = NSURL(string: \u0026ldquo;http://httpbin.org/image/png\u0026quot;)! let task = NSURLSession.sharedSession().dataTaskWithURL(url) { data, _, _ in let image = UIImage(data: data) // \u0026hellip;\n//手动终止 PlaygroundPage.current.currentPage.finishExecution() } task.resume() {% endcodeblock %}\n支持Markdown格式的文档 官方文档 除了实验用途，Playgrounds 在展示 Swift 语言的工具和框架中也一样强大。特别文档部分可以作为丰富格式的方式展示出来，以提供对于代码的清晰解释从而展示某个技术或者正确使用某个 Library 的方式。\n不同于Swift代码中的注释文档语法, Swift Playgrounds 使用 Markdown 来显示多格式的文档。 例如： //:：可以指定单行文本说明 /*: Markdown格式内容... */：可以用Markdown格式来显示丰富的文档内容\nxcode切换备注以Markdown格式显示：\n选择Editor → Show Rendered Markup 菜单 在 File Inspector (⌘⌥1) 选中 Render Documentation 复选框。 在xcode8中打开之前版本时，菜单上的Show Rendered Markup会显示为Upgrade playgound...升级菜单项，这样就需要先点击升级菜单项之后，才能激活上述（1）（2）设置项。\n{% codeblock lang:swift %} //: This line will have bold and italic text.\n/*:\nHeaders of All Sizes Lists of Links NSHipster ASCIIwwdc SwiftDoc Images, Too Images in the Resources directory can be referenced locally */\n{% endcodeblock %}\nPlaygrounds 提供了一个我们关于分享和学习 OS X 和 iOS 相关工具的方式的重大改变。Playground 可以展示每一个特性，并且为将来的用户探索和发现你创建的库提供了空间。丢掉你的静态README.md， 换成可互动的README.playground吧，再玩起来！\n","date":"2017-03-01T17:27:16Z","permalink":"https://it-boyer.github.io/post/old/swift/%E4%BA%92%E5%8A%A8%E6%80%A7%E7%9A%84%E6%95%99%E5%AD%A6%E5%B7%A5%E5%85%B7XCPlayground/","section":"post","tags":["playground"],"title":"互动性的教学工具XCPlayground"},{"categories":["学习笔记"],"contents":"创建一个版本库来托管pod索引:pod repo add命令 第一步：在github登录个人账号，创建一个库作为pod索引托管库。也可根据具体情况可以选择：github、CODING、开源中国、Bitbucket以及CSDN等，代码托管平台。 当索引库托管在github私有的仓库时，如果有其他同事共同开发维护，则需要配置Git仓库的权限。 第二步：pod化版本库，使其专门用户管理个人的*podspec索引文件 {% codeblock repo add命令 lang:ruby %}\npod repo add [Private Repo Name] [GitHub HTTPS clone URL] $ pod repo add PodRepo https://github.com/it-boyer/PodRepo.git #输出：\nCloning spec repo PodRepo from https://github.com/it-boyer/PodRepo.git {% endcodeblock %} 此时在本地会生成~/.cocoapods/repos/PodRepo目录，这个目录就可以用来存储你所有的开源包。 每当一个或多个*.podspec文件测试无误时，就可以使用pod repo push命令向私有索引库中提交该文件。 {% codeblock lib create命令 lang:ruby %} $ pod repo push PodRepo LogSwift.podspec #PodRepo是本地Repo名字 后面是podspec名字 {% endcodeblock %} 完成之后这个组件库就添加到私有索引库中，自动生成的pod 库标准结构：\n同时push命令会将新增的索引目录推送至自己的远程仓库中，即索引托管库PodRepo.git中。\n下面详述podspec文件的配置，检测，使用的过程。\n使用模板命令创建Pod工程项目 lib create 初始化Pod模板项目： {% codeblock lib create命令 lang:ruby %} pod lib create LogSwift {% endcodeblock %} 有以下五步命令行交互： {% codeblock 交互 lang:ruby %} What is your email?\nWhat language do you want to use?? [ Swift / ObjC ]\nSwift Would you like to include a demo application with your library? [ Yes / No ] Yes Which testing frameworks will you use? [ Quick / None ] Quick Would you like to do view based testing? [ Yes / No ]\n{% endcodeblock %} 会自动执行pod install命令创建项目并生成依赖。\n添加库文件和资源 例如：把一个网络模块的共有组件放入Pod/Classes中，然后进入Example文件夹执行pod update命令，再打开项目工程可以看到，刚刚添加的组件已经在Pods子工程下Development Pods/PodTestLibrary中了，然后编辑demo工程，测试组件。 测试无误后需要将该项目添加并推送到远端仓库，并编辑podspec文件。\n配置podspec文件及验证命令lib lint 打tag号作为podspec版本号 因为podspec文件中获取Git版本控制的项目还需要tag号，所以我们要打上一个tag {% codeblock 打标签 lang:ruby %} $ git tag -m \u0026ldquo;first release\u0026rdquo; 0.1.0 $ git push \u0026ndash;tags #推送tag到远端仓库 {% endcodeblock %}\n编辑podspec文件 podspec文件是一个Ruby格式： {% codeblock podspec文件 lang:ruby %} Pod::Spec.new do |s| s.name = \u0026ldquo;PodTestLibrary\u0026rdquo; #名称 s.version = \u0026ldquo;0.1.0\u0026rdquo; #版本号 s.summary = \u0026ldquo;Just Testing.\u0026rdquo; #简短介绍，下面是详细介绍 s.description = \u0026laquo;-DESC Testing Private Podspec.\nMarkdown format. Don\u0026rsquo;t worry about the indent, we strip it! DESC s.homepage = \u0026ldquo;https://coding.net/u/boyers/p/podTestLibrary\u0026quot; #主页,这里要填写可以访问到的地址，不然验证不通过 s.screenshots = \u0026ldquo;www.example.com/screenshots_1\u0026quot;, \u0026ldquo;www.example.com/screenshots_2\u0026quot; #截图 s.license = \u0026lsquo;MIT\u0026rsquo; #开源协议 s.author = { \u0026ldquo;boyers\u0026rdquo; =\u0026gt; \u0026ldquo;boyers@foxmail.com\u0026rdquo; } #作者信息 s.source = { :git =\u0026gt; \u0026ldquo;https://coding.net/boyers/podTestLibrary.git\u0026quot;, :tag =\u0026gt; \u0026ldquo;0.1.0\u0026rdquo; } #项目地址，这里不支持ssh的地址，验证不通过，只支持HTTP和HTTPS，最好使用HTTPS\ns.social_media_url = \u0026lsquo;https://twitter.com/\u0026lt;TWITTER_USERNAME\u0026gt;\u0026rsquo; #多媒体介绍地址 s.platform = :ios, \u0026lsquo;7.0\u0026rsquo; #支持的平台及版本 s.requires_arc = true #是否使用ARC，如果指定具体文件，则具体的问题使用ARC\ns.source_files = \u0026lsquo;Pod/Classes//*\u0026rsquo; #代码源文件地址，/表示Classes目录及其子目录下所有文件，如果有多个目录下则用逗号分开，如果需要在项目中分组显示，这里也要做相应的设置 s.resource_bundles = { \u0026lsquo;PodTestLibrary\u0026rsquo; =\u0026gt; [\u0026lsquo;Pod/Assets/.png\u0026rsquo;] } #资源文件地址\ns.public_header_files = \u0026lsquo;Pod/Classes/**/*.h\u0026rsquo; #公开头文件地址 s.frameworks = \u0026lsquo;UIKit\u0026rsquo; #所需的framework，多个用逗号隔开 s.dependency \u0026lsquo;AFNetworking\u0026rsquo;, \u0026lsquo;~\u0026gt; 2.3\u0026rsquo; #依赖关系，该项目所依赖的其他库，如果有多个需要填写多个s.dependency end {% endcodeblock %}\n验证podspec文件可用性 {% codeblock lang:ruby %} $ pod lib lint\n输出： -\u0026gt; PodTestLibrary (0.1.0) PodTestLibrary passed validation. {% endcodeblock %} 说明验证通过了，不过这只是这个podspec文件是合格的，不一定说明这个Pod是可以用的，Pod需要在本地做一下验证。\n将源码托管到远程仓库 通过Cocoapods创建出来的目录本身就在本地的Git管理下，我们需要做的就是给它添加远端仓库，同样去GitHub或其他的Git服务提供商那里创建一个私有的仓库，拿到SSH地址，然后cd到LogSwift目录 {% codeblock 添加到远程仓库 lang:ruby %} $ git add . $ git commit -s -m \u0026ldquo;Initial Commit of Library\u0026rdquo; $ git remote add origin https://coding.net/git/LogSwift.git #添加远端仓库 $ git push origin master #提交到远端仓库 {% endcodeblock %}\n手动配置Pod私库项目支持：spec create {% codeblock lang:ruby %} $ pod spec create LogSwift git@coding.net:boyers/LogSwift.git {% endcodeblock %} 执行完之后，就创建了一个podspec文件，他其中会包含很多内容，可以按照我之前介绍的进行编辑，没用的删掉。编辑完成之后使用验证命令pod lib lint验证一下。\n:path =\u0026gt; 在新项目配置检测podspec文件 在这个项目的Podfile文件中直接指定刚才创建编辑好的podspec文件，看是否可用。\n指定本地依赖的两种方式: {% codeblock Podfile lang:ruby %} platform :ios, \u0026lsquo;7.0\u0026rsquo; pod \u0026lsquo;LogSwift\u0026rsquo;, :path =\u0026gt; \u0026lsquo;/code/Cocoapods/podTest/LogSwift\u0026rsquo; # 指定路径 pod \u0026lsquo;LogSwift\u0026rsquo;, :podspec =\u0026gt; \u0026lsquo;/code/Cocoapods/podTest/LogSwift/LogSwift.podspec\u0026rsquo; # 指定podspec文件 {% endcodeblock %} 指定源码的远程仓库作为依赖 前提时索引文件中指定的tag版本的源码必须推送到远程仓库 {% codeblock Podfile lang:ruby %} platform :ios, \u0026lsquo;7.0\u0026rsquo; pod \u0026lsquo;MusicLrc\u0026rsquo;, :git =\u0026gt; \u0026lsquo;https://github.com/it-boyer/MusicLrcTest.git' {% endcodeblock %} 然后执行pod install命令安装依赖，打开项目工程，可以看到库文件和资源都被加载到Pods子项目中了，不过它们并没有在Pods目录下，而是跟测试项目一样存在于Development Pods/LogSwift中，这是因为我们是在本地测试，而没有把podspec文件添加到Spec Repo中的缘故。\n万事具备，向私有索引库中提交podspec文件：repo push 每当一个或多个*.podspec文件测试无误时，就可以使用pod repo push命令向私有索引库中提交该文件。 {% codeblock lib create命令 lang:ruby %} $ pod repo push PodRepo LogSwift.podspec #PodRepo是本地Repo名字 后面是podspec名字 {% endcodeblock %} 完成之后这个组件库就添加到私有索引库中，自动生成的pod 库标准结构：\n同时push命令会将新增的索引目录推送至自己的远程仓库中，即索引托管库PodRepo.git中。\ntrunk push 添加到Cocoapods的官方索引库 注册trunk，邮箱验证 在注册trunk之前，我们需要确认当前的CocoaPods版本是否足够新: sudo gem install cocoapods 开始注册trunk： {% codeblock lang:bash %} pod trunk register boyer@163.com \u0026lsquo;boyers1250\u0026rsquo; \u0026ndash;verbose {% endcodeblock %} -verbose参数是为了便于输出注册过程中的调试信息。 执行上面的语句后，你的邮箱将会受到一封带有验证链接的邮件，如果没有请去垃圾箱找找，有可能被屏蔽了。点击邮件的链接就完成了trunk注册流程。 使用下面的命令可以向trunk服务器查询自己的注册信息： {% codeblock lang:bash %} pod trunk me {% endcodeblock %}\n通过trunk推送podspec文件 现在我们已经有了自己的podspec文件，但是在推送podspec文件之前你需要确认以下几点：\n确保你的源码已经push到Github上。 确保你所push的代码已经打上\u0026quot;version tag\u0026quot;版本号标签： 只有确保了以上两点，CocoaPods才能更准确地找到你的repo。 现在我们开始通过trunk上传你的podspec文件。先cd到podspec文件所在目录，执行： {% codeblock lang:bash %} pod trunk push WZLBadge.podspec {% endcodeblock %} 执行上面的push操作，就相当于你把你的源代码提交给CocoaPods团队审核了，CocoaPods审核只需要几秒钟或者几分钟就可以完成。 使用远程的私有Pod库 我们的这个组件库就已经制作添加完成了，现在可以pod search命令查到这个库，当使用时配置Podfile依赖文件即可。\npod search 查找库 {% codeblock 查找库 lang:ruby %} $ pod search PodTestLibrary -\u0026gt; PodTestLibrary (0.1.0) Just Testing. pod \u0026lsquo;PodTestLibrary\u0026rsquo;, \u0026lsquo;~\u0026gt; 0.1.0\u0026rsquo;\nHomepage: https://coding.net/u/boyers/p/podTestLibrary Source: https://coding.net/boyers/podTestLibrary.git Versions: 0.1.0 [WTSpecs repo] {% endcodeblock %} 在Podfile文件中配置库依赖 {% codeblock 配置库依赖 lang:ruby %} pod \u0026lsquo;PodTestLibrary\u0026rsquo;, \u0026lsquo;~\u0026gt; 0.1.0\u0026rsquo; {% endcodeblock %} 更新维护podspec文件配置，升级库版本 subspec特性，可以在库原有基础上，添加更多的模块，相应创建了多个子目录。现在尝试添加包括工具类，底层Model及UIKit扩展等。\n添加模块库文件和资源 具体做法是先将源文件添加到Pod/Classes中，然后按照不同的模块对文件目录进行整理，因为我有四个模块，所以在Pod/Classes下有创建了四个子目录\n打tag号作为podspec版本号 因为podspec文件中获取Git版本控制的项目还需要tag号，所以我们要打上一个tag {% codeblock 打标签 lang:ruby %} $ git tag -m \u0026ldquo;first release\u0026rdquo; 0.1.0 $ git push \u0026ndash;tags #推送tag到远端仓库 {% endcodeblock %}\n更新podspec配置文件 当创建了subspec，之前项目整体的依赖dependency:\n源文件:source_files\n头文件:public_header_files\n资源文件:resource 都移动到了各自的subspec中，每个subspec之间也可以有相互的依赖关系，比如UIKitAddition就依赖于CommonTools。 {% codeblock 更新podspec配置文件 lang:ruby %} Pod::Spec.new do |s| s.name = \u0026ldquo;PodTestLibrary\u0026rdquo; s.version = \u0026ldquo;1.0.0\u0026rdquo; s.summary = \u0026ldquo;Just Testing.\u0026rdquo; s.description = \u0026laquo;-DESC Testing Private Podspec.\n* Markdown format. * Don't worry about the indent, we strip it! DESC s.homepage = \u0026ldquo;https://coding.net/u/boyers/p/podTestLibrary\u0026quot;\ns.screenshots = \u0026ldquo;www.example.com/screenshots_1\u0026quot;, \u0026ldquo;www.example.com/screenshots_2\u0026quot; s.license = \u0026lsquo;MIT\u0026rsquo; s.author = { \u0026ldquo;boyers\u0026rdquo; =\u0026gt; \u0026ldquo;boyers@foxmail.com\u0026rdquo; } s.source = { :git =\u0026gt; \u0026ldquo;https://coding.net/boyers/podTestLibrary.git\u0026quot;, :tag =\u0026gt; \u0026ldquo;1.0.0\u0026rdquo; }\ns.social_media_url = \u0026lsquo;https://twitter.com/\u0026lt;TWITTER_USERNAME\u0026gt;\u0026rsquo; s.platform = :ios, \u0026lsquo;7.0\u0026rsquo; s.requires_arc = true\n#s.source_files = \u0026lsquo;Pod/Classes//\u0026rsquo; #s.resource_bundles = { \u0026lsquo;PodTestLibrary\u0026rsquo; =\u0026gt; [\u0026lsquo;Pod/Assets/.png\u0026rsquo;] } #s.public_header_files = \u0026lsquo;Pod/Classes//*.h\u0026rsquo;\ns.subspec \u0026lsquo;NetWorkEngine\u0026rsquo; do |networkEngine| networkEngine.source_files = \u0026lsquo;Pod/Classes/NetworkEngine//*\u0026rsquo; networkEngine.public_header_files = \u0026lsquo;Pod/Classes/NetworkEngine//*.h\u0026rsquo; networkEngine.dependency \u0026lsquo;AFNetworking\u0026rsquo;, \u0026lsquo;~\u0026gt; 2.3\u0026rsquo; end\ns.subspec \u0026lsquo;DataModel\u0026rsquo; do |dataModel| dataModel.source_files = \u0026lsquo;Pod/Classes/DataModel//*\u0026rsquo; dataModel.public_header_files = \u0026lsquo;Pod/Classes/DataModel//*.h\u0026rsquo; end\ns.subspec \u0026lsquo;CommonTools\u0026rsquo; do |commonTools| commonTools.source_files = \u0026lsquo;Pod/Classes/CommonTools//*\u0026rsquo; commonTools.public_header_files = \u0026lsquo;Pod/Classes/CommonTools//*.h\u0026rsquo; commonTools.dependency \u0026lsquo;OpenUDID\u0026rsquo;, \u0026lsquo;~\u0026gt; 1.0.0\u0026rsquo; end\ns.subspec \u0026lsquo;UIKitAddition\u0026rsquo; do |ui| ui.source_files = \u0026lsquo;Pod/Classes/UIKitAddition//*\u0026rsquo; ui.public_header_files = \u0026lsquo;Pod/Classes/UIKitAddition//*.h\u0026rsquo; ui.resource = \u0026ldquo;Pod/Assets/MLSUIKitResource.bundle\u0026rdquo; ui.dependency \u0026lsquo;PodTestLibrary/CommonTools\u0026rsquo; end\ns.frameworks = \u0026lsquo;UIKit\u0026rsquo; #s.dependency \u0026lsquo;AFNetworking\u0026rsquo;, \u0026lsquo;\u0026gt; 2.3\u0026rsquo; #s.dependency \u0026lsquo;OpenUDID\u0026rsquo;, \u0026lsquo;\u0026gt; 1.0.0\u0026rsquo; end {% endcodeblock %} 编辑完成之后，在测试项目里pod update一下，几个子项目都被加进项目工程了，写代码验证无误之后，就可以将这个工程push到远端仓库，并打上新的tag-\u0026gt;1.0.0。\n但是如果你的代码版本号没变(podspec里的version自然也没变)就会提示push失败，即使你更改了podspec的其他地方，pod也会认为这两个文件是同一个。 我目前为止找不到trunk的相关update接口，所以只能顺水推舟，更新源代码版本号（如：1.1.1-\u0026gt;1.1.2），重新push version tag，然后再执行pod trunk push操作。\n","date":"2017-02-28T15:46:16Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E4%BD%BF%E7%94%A8Cocoapods%E5%88%9B%E5%BB%BA%E7%A7%81%E6%9C%89podspec/","section":"post","tags":["pod"],"title":"使用Cocoapods创建私有podspec"},{"categories":["学习笔记"],"contents":"原地址\nUIStackView简单介绍 一个Stack View能够将它所含的View以各种方式沿其轴向进行分布，同时也可以将View沿某个方向等距分布，要隐藏Stack View中的视图，你只需要设置该View的Hidden属性为true，剩下的工作Stack View会自己完成。。 坐标（Axis）、间隔（Spacing）、对齐（Alignment）以及分布（Distribution ）等。 distribution属性：决定Stack View如何沿它轴向的水平方向摆放它的subview，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。 Alignment属性：决定了Stack View如何沿它轴向的垂直方向摆放它的subview，对于一个垂直的Stack View，这个属性可以设置为Fill、Leading、Center和Trailing。 对于水平的Stack View，这个属性则稍有不同： .Top取代了.Leading，.Bottom取代了.Trailing。此外，水平Stack View还多出了两个属性值：.FirstBaseLine和.LastBaseLine。 对于水平的Stack View，这个属性则稍有不同： Fill: Leading: Center: Trailing:\n布局方式对比\n添加一个新的Stack View 点击故事板画布左下角Auto Layout工具栏中的Stack按钮： 另一种解散的方法是选中Stack View，然后点击Editor\\Emebed in\\stack view菜单。\n解散一个废弃的Stack View 首先，选定想解散的Stack View。按下Option键，点击Stack 按钮。这将弹出一个上下文菜单，然后点击Unembed： 另一种解散的方法是选中Stack View，然后点击Editor\\Unemebed菜单。\n使用场景描述 当APP运行中增加或删除一个view时，需要重新调整邻近view的位置布局。 预见困境：\n在故事板中新建一些布局约束连接，以便能够安装或卸载其中的一些约束 使用第三方库来实现 根据任务复杂程度完全用代码实现 也许这个在视图附近的视图树中的所有View都不需要在运行时改变，但当你将新视图添加到故事板时，仍然要想方设法为它挤出空间来。 UIStackView提供了一个对多个视图进行水平或垂直布局的方法。通过对几个属性进行简单设置，比如对齐、分布和间距，可以让我们让其所包含的视图适应于其有效空间。\n实现需求 存在着这几方面的问题:\n问题一：自适应横竖屏 在横屏状态下（command+左箭头旋转为横屏），发现截图中的一排按钮位置无法适应屏幕宽度的变化。这时可以使用UIStackView来帮助实现自动适应横竖屏的效果。\n问题二：控件间留白不紧凑 点击WEATHER旁边的Hide按钮。隐藏了下面的文本内容后，留下了一大块的空白区域。\nStoryboard引入界面 打开Main.storyboard，找到Spot Info View Controller这个Scene。将这些标签和按钮设为不同的背景色，是为了在运行时效果更直观。就是在故事板中，这也有助于看到Stack View属性的改变导致其内部视图的变化。 如果想在运行App时看见这些颜色，在SpotInfoViewController的viewDidLoad()方法中将下列语句注释： {% codeblock swift lang:swift %} // 清空标签和按钮的背景色 for view in backgroundColoredViews { view.backgroundColor = UIColor.clearColor() } {% endcodeblock %}\nSize类便于使用storyboard 在本案例中，故事板中Scene大小不是默认600x600，在这里Simulated Metrics下的Size属性被设置成iPhone 4-inch。Simulated Metrics属性在运行时并没有任何影响——不同设备上视图的大小仍然会自动改变。\n创建水平UIStackView 按钮模块 选中按钮 用Command+左键同时选中Spot Info View Controller底下一排的所有按钮： Stack按钮添加一个新的Stack View 点击故事板画布左下角Auto Layout工具栏中新增的Stack按钮： 这些按钮被嵌到一个新的Stack View中：\n给新的Stack View添加布局约束 要在故事板选取一个充满了子视图的Stack View还是比较难的，介绍两种选择技巧。 3.1 在Outline视图中选取Stack View\n3.2 Shift+右键调出View树 在Stack View 的任意地方按下Shift+右键或者Control+Shift+左键（如果你正在用触控板的话）。这时将弹出一个上下文菜单，列出了位于所点击的地方的View树，你可以在这个菜单中选择Stack View。\n自动布局工具栏中的Pin按钮,添加一个约束 首先勾选Constrain to margins。然后在Stack View四周添加下列约束： {% codeblock swift lang:swift %} Top: 20, Leading: 0, Trailing: 0, Bottom: 0 {% endcodeblock %} 仔细检查top、leading、trailing、bottom中的数字并确保它们的I型柱都被选中。然后点击Add 4 Constraints：\n按钮等间距分布 添加约束后，导致第一个按钮被拉伸：\n使用等宽约束的Spacer View实现 解决这个问题只能使用空白的View来分隔这些按钮，在按钮之间摆放上一些用于分隔空间的 Spacer View。所有的Spacer View都要添加等宽约束，以及许多额外的约束，才能将这些Spacer View布局正确。 这看起来如下图所示。为了直观起见，这些Spacer View的背景色设置成了浅灰色： 如果要在运行时添加一个按钮或者隐藏/删除一个按钮时，要想调整这些Spacer View和约束就要命了。\nDistribution属性：沿轴向水平分布 distribution属性：决定Stack View如何将它的subview沿轴向分布，当属性值是Fill，这表示subview会沿轴向完全占据Stack View。因此，Stack View会拉伸其中一个subview使其填充剩余空间，尤其是水平内容优先级最低的那个，如果所有subview优先级相同，则拉伸第一个subview。 打开Stack View属性面板。将Distribution属性由Fill修改为Equal Spacing： 编译运行，点击某个单元格，旋转模拟器（⌘→）。你将看到最下一排按钮现在按照等间距排列了！\nRating版块 选中RATING标签，以及旁边的显示为几个星形图标的标签： 然后点击Stack按钮将它们嵌到一个Stack View中： 然后点击Pin按钮。勾选Constrain to margins，并添加如下约束： {% codeblock swift lang:swift %} Top: 20, Leading: 0, Bottom: 20 {% endcodeblock %} 打开属性面板，将间距设置为8： 你可能会看到一个 Misplaced Views的布局约束警告，同时星星标签会显示将会被拉伸到视图之外： 有时候Xcode会临时提示一些警告，或者显示Stack View的位置不正确，这些警告会在你添加其他约束后消失。你完全可以忽略这些警告。 要解决这个警告，我们可以修改一下Stack View的Frame然后又改回，或者临时修改它的一条布局约束。 让我们试一下。先将Alignment 属性从Fill修改为Top，然后又改回原来的Fill。你将看到这下星星标签显示正常了： 编译运行，进行测试\n创建垂直的Stack View Xcode会自动根据这两者的位置推断出这将是一个垂直的Stack View，Stack View没有添加任何约束时，会自动适应了两个标签中的最宽的一个的宽度。\nWHY VISIT模块 选中WHY VISIT标签及下面的标签,创建一个垂直的Stack View： 点击Stack 按钮将二者嵌到一个Stack View：\n添加约束 默认，约束是相对于距离最近的对象，对于Bottom约束来说就是距离它15像素的Hide按钮。但我们其实是想让约束相对于WEATHER标签。 选中Stack View，点击Pin按钮。勾选Constrain to margins，设置Top、Leading、Trainling为0。 然后，点击Bottom右边的下拉按钮，从列表中选择WEATHER（curent distance =20）： 最后点击Add 4 Constraints按钮。显示结果如下图所示：\nalignment属性：轴向的垂直方向 Stack View问题，它的右边对齐于View的右边。但是底下的标签仍然是原来的宽度。需要使用alignment属性解决这个问题。 当你测试完所有Alignment值的布局效果后，将Alignment修改为Fill： 将Alignment设置为Fill，表示所有View将沿与Stack View轴向垂直的方向进行全占式分布。这会让WHY VISIT标签扩展它的宽度到100%.\n如果我们只想让底下的标签将宽度扩展到100%怎么办？\n这个问题现在看来还不是多大的问题，因为两个标签在运行时的背景色都是透明的。但对于Weather版块来说就不同了。\n我们将用另外一个Stack View来说明这个问题。\n垂直／水平Stack View嵌套使用 Weather版块 在Weather版块相对复杂一些，因为它多了一个Hide按钮。 要隐藏Stack View中的视图，你只需要设置该View的Hidden属性为true，剩下的工作Stack View会自己完成。这也是我们解决用户隐藏WEATHER标签下文本的主要思路。 一种方法是使用嵌套的Stack View，先将WEATHER标签和Hide按钮嵌到一个水平StackView，再将这个Stack View和标签嵌到一个垂直Stack View。\n垂直stackView 注意Alignment属性负责Stack View轴向垂直的方向上的布局。所以，我们需要将Alignment属性设置为 Bottom：\n水平StackView中出现按钮拉伸标签的问题 注意，WEATHER标签被拉伸为和Hide按钮一样高了。这并不合适，因为这会导致WEATHER标签和下面的文本之间多出了一些空间。 正确的方法是让 Hide 按钮不要和 Weather 版块呆在同一个Stack View中，或者任何别的Stack View中。 这样，在顶层View中还会保留一个subview，你将为它添加一个相对于WEATHER标签的约束——WEATHER标签嵌在Stack View里的。也就是说，你要为位于Stack View之外的按钮加一个约束，这个约束是相对于Stack View内的一个标签！\n垂直stack View1:嵌套WEATHER标签和标签 选中WEATHER标签和标签： 点击 Stack 按钮： 点击Pin 按钮，勾上Constrain to margins，然后添加如下约束： {% codeblock swift lang:swift %} Top: 20, Leading: 0, Trailing: 0, Bottom: 20 {% endcodeblock %} 将Stack View的Alignment设为Fill： 我们需要在 Hide 按钮左边和WEATHER标签右边加一条约束，这样WEATHER 标签的宽度就不会拉满整个Stack View了。\n当然，底下的标签宽度还是需要100%占满的。\n我们是通过将WEATHER标签嵌到一个垂直Stack View 来实现的。注意，垂直Stack View的Alignment 属性可以设置为 .Leading，如果将Stack View拉宽，则它里面的View 会保持左对齐。\n垂直stack View2: 仅嵌套WEATHER标签 从Outline视图中选取WEATHER 标签，或者用Control+Shift+左键的方式选取WEATHER 标签： 然后点击Stack 按钮： 确保Axis 为 Vertical 的情况下，将Alignment 设置为 Leading：\n按钮和WEATHER标签两个约束 从Hide 按钮用右键拖一条新的约束到 WEATHER 标签： 按下Shift键，同时选择Horizontal Spacing 和 Baseline。然后点击 Add Constraints： 编译运行。Hide 按钮的位置现在对了，而且当按下Hide 按钮，位于Stack View 中的标签被隐藏后，下面的视图也会被调整——根本不需要我们进行手动调整。\n顶级 Stack View 在Outline 视图中，用Command+左键选择5个最顶级的 Stack View： 然后点击 Stack 按钮： 点击Pin 按钮，勾上 Constrain to margins，将 4 个边的约束都设为0。然后将Spacing 设置为20，Alignment 设为 Fill。现在故事板会是这个样子： 编译运行： 噢！这个 Hide 按钮又失去了它 的约束！因为包含 WEATHER 标签的Stack View的外边又套了一层 Stack View。这不是什么大问题，就像之前你做过的那样，再重新为它添加约束就是了。\n右键从Hide 按钮拖一条约束到 WEATHER标签，按下 Shift 键，同时选择 Horizontal Spacing 和 Baseline。然后点击 Add Constraints：\n重新调整视图位置 现在，所有的版块都被嵌到一个顶级的 Stack View中了，我们想修改一下 what to see版块的位置，让它位于 weather 版块之后。\n从 Outline 视图中选择中间的的 Stack View，然后将它拖到第一、二个 Stack View 之间。 注意：让箭头稍微偏向你正在拖的Stack View左边一点，以便它能够作为外层 Stack View 的 subview 添加。蓝色的小圆圈应当位于两个 Stack View 之间的左端而不是右端：\n现在，weather版块是从上到下的第三个版块，由于 Hide 按钮它并不是 Stack View的subview，所以它不会参与移动，它的frame当前是不正确的。\n点击 Hide 按钮，选中它：\n然后点击自动布局工具栏中的 Resolve Auto Layout Issues 按钮，选择 Update Frames： 现在 Hide 按钮将回到正确的位置：\n基于配置的 Size 类 最后还有一个任务没有完成。在横屏模式，垂直空间是比较珍贵的，你想将这些版块之间靠得更近一些。要实现这个，你需要判断当垂直Size类为compact时，将顶层 Stack View的 Spacing属性由 20 改成 10.\n选择顶层 Stack View，点击 Spacing 前面的+按钮：\n选择 Any Width \u0026gt; Compact Height：\n在新出现的 wAny hC 一栏中，将 Spacing 设为 10： 编译运行。在竖屏模式下Spacing不会改变。旋转模拟器（⌘←），你会看到各版块之间的间距减少了，现在底部按钮之间的空间也变大了： 如果你没有添加最外层的 Stack View，你仍然可以使用 Size 类将每个版块之间的垂直间距设置为 10，但这就不是仅仅设置一个地方就能够办到的了。\n动画 现在，在隐藏和显示天气信息时仍然会觉得有一些突兀。你将增加一个动画使这个转换变得更平滑。\nStack View完全支持 UIView 动画。也就是说要以动画方式显示/隐藏它所包含的subview，只需要简单地在一个动画块中切换它的 hidden 属性。\n让我们来看看代码怎么实现。打开 SpotInfoViewController.Swift，找到 updateWeatherInfoViews(hideWeatherInfo:animated:)方法。\n将方法的最后一行： {% codeblock swift lang:swift %} weatherInfoLabel.hidden = shouldHideWeatherInfo {% endcodeblock %} 替换为： {% codeblock swift lang:swift %} if animated { UIView.animateWithDuration(0.3) { self.weatherInfoLabel.hidden = shouldHideWeatherInfo } } else { weatherInfoLabel.hidden = shouldHideWeatherInfo } {% endcodeblock %}\n编译运行，点击Hide 按钮或 Show 按钮。是不是加入动画之后看起来要好得多呢？\n除了对 Stack View 中的视图以动画的方式设置 hidden 属性，你也可以对 Stack View 自身的属性使用 UIView 动画，例如 Alignment 属性、 Distribution 属性、 Spacing 属性和 Axis 属性。 开始项目源码 完整项目源码\n总结 ","date":"2017-02-24T18:12:14Z","permalink":"https://it-boyer.github.io/post/old/iOS/UI/UIStackView%E6%95%99%E7%A8%8B%E4%BA%86%E8%A7%A3StackView/","section":"post","tags":["API"],"title":"UIStackView教程了解StackView"},{"categories":["解决方案"],"contents":"修改APP启动图标上的名称，需配置Info.plist文件，增加CFBundleDisplayName属性键值对。 进入到如下界面：\n在Info.plist文件属性列表中搜索\u0026quot;Bundle display name\u0026quot;，如果存在就修改为新APP名称。 如果不存在，在任何一个属性条目下，点击\u0026quot;+\u0026ldquo;按钮，弹出的下拉列表中选择\u0026quot;Bundle display name\u0026rdquo;，再双击\u0026quot;Bundle display name\u0026quot;属性值列，输入新APP名称。\nagvtool自动增加版本号命令行工具 版本号和编译号分别是代表了正式发布版本和内部版本， agvtool 是一个自动增加版本号的命令行工具。\n注意：版本号是给用户看的，用于标明当前的发行版本，并且被存储在 App 的 Info.plist 文件的 CFBundleShortVersionString (Bundle versions string, short) 中。编译号是内部使用的，用于标明未发行或者已内部发行的应用程序，并且它被存储在 Info.plist 文件的 CFBundleVersion (Bundle version) 中。\n注意：如果应用程序包含了多个目标（target）， agvtool 工具将会把所有目标都设置为同一个版本号和编译号。\n设置 Current Project Version 为选定的值 Xcode 工程文件 project.pbxproj 包含了 CURRENT_PROJECT_VERSION (Current Project Version) 编译设定，这个编译设定指定了当前工程的版本。 agvtool 会搜索此编译选项。如果这个值存在就运行，否则不运行，这个值用来更新编译号。\n设置 Versioning System 为 Apple Generic 默认情况下苹果不使用任何版本系统，设置为 Apple Generic 确保 Xcode 包含全部的 agvtool 生成的版本信息。\n注意： Current Project Version 的值必须是整数或者浮点数，新工程最好设置为1。\n设置版本和编译号 agvtool 从 Info.plist 文件搜索版本和编译号。如果存在就更新，不存在就不执行。 确保 CFBundleVersion (Bundle version) 和 CFBundleShortVersionString (Bundle versions string, short) 存在。\n版本号命令 退出 Xcode，在终端下进入到包含 .xcodeproj 工程文件的目录， .xcodeproj 文件包含了 project.pbxproj 文件。\n查看版本号： 1 agvtool what-marketing-version 更新版本号 1 agvtool new-marketing-version \u0026lt;指定的版本号\u0026gt; 编译号命令 将编译号设置为指定版本 1 agvtool new-version -all \u0026lt;指定的版本号\u0026gt; 更新编译号 1 agvtool next-version -all 查看当前编译号 1 agvtool what-version ","date":"2017-02-24T14:23:59Z","permalink":"https://it-boyer.github.io/post/old/iOS/UI/%E6%9B%B4%E6%94%B9%E8%AE%BE%E5%A4%87%E5%B1%8F%E5%B9%95%E4%B8%8A%E6%98%BE%E7%A4%BA%E7%9A%84%E5%BA%94%E7%94%A8%E7%A8%8B%E5%BA%8F%E5%9B%BE%E6%A0%87%E4%B8%8B%E6%96%B9%E7%9A%84%E5%90%8D%E7%A7%B0/","section":"post","tags":["iOS"],"title":"更改设备屏幕上显示的应用程序图标下方的名称"},{"categories":["学习笔记"],"contents":"异步单元测试 在Xcode 6之前的版本里面并没有内置XCTest，只能是在主线程的RunLoop里面使用一个while循环,然后一直等待响应或者直到timeout.\n在Xcode 6里，苹果以XCTestExpection类的方式向XCTest框架里添加了测试期望(test expection)。 XCTest框架中相关的方法：设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。\n常规实现方式 在主线程里，使用while循环每隔10毫秒会执行一次，直到有响应或者5秒之后超出响应时间限制才会跳出：\n{% codeblock lang:swift %} func testAsyncTheOldWay() { let timeoutDate = Date.init(timeIntervalSinceNow: 5.0) var responseHasArrived = false Alamofire.request(\u0026ldquo;https://www.baidu.com\u0026rdquo;).responseData{response in print(\u0026ldquo;获取到的数据长度：(String(data: response.data!, encoding:String.Encoding.utf8)!)\u0026rdquo;) responseHasArrived = true XCTAssert((response.data?.count)! \u0026gt; 0) }\nwhile (responseHasArrived == false \u0026amp;\u0026amp; (timeoutDate.timeIntervalSinceNow \u0026gt; 0)) { CFRunLoopRunInMode(CFRunLoopMode.defaultMode, 0.01, false) } if (responseHasArrived == false) { XCTFail(\u0026quot;Test timed out\u0026quot;) } } {% endcodeblock %}\nXCTest相关API 在Xcode 6里，苹果以XCTestExpection类的方式向XCTest框架里添加了测试期望(test expection)。\nXCTestExpection:高期望(High Expectations)的实现和使用 设置期望，实现期望，通知期望，谓词计算期望等，以及期望的传递。\nexpectation(description:):为XCTest测试单元设置期望 为XCTest单元测试，设置一个测试期望以及错误信息描述，并在某一时刻fulfill实现该期望对象 {% codeblock lang:swift %} //expectation(description: String) -\u0026gt; XCTestExpectation let expection = expectation(description: \u0026ldquo;失败时显示原因\u0026rdquo;) {% endcodeblock %}\nfulfill():调用它表示测试达到期望值 一般在单元测试通过时调用，告知测试已达期望，这一方法替代了responseHasArrived作为Flag的方式 {% codeblock lang:swift %} //- (void)fulfill; expection.fulfill() {% endcodeblock %}\nwaitForExpectations(timeout:handler:):在方法底部设置测试期望的时效 在方法底部指定一个超时，如果测试条件不适合时间范围便会结束执行 {% codeblock lang:swift %} // open func waitForExpectations(timeout: TimeInterval, handler: XCTest.XCWaitCompletionHandler? = nil) waitForExpectations(timeout: 5) { error in print(\u0026ldquo;错误信息:(error?.localizedDescription)\u0026rdquo;) } {% endcodeblock %} 如果完成处理的代码在指定时限里执行并调用了fulfill()方法，那么就说明所有的测试期望在此期间都已经被实现。否则就测试就被打断不再执行\nexpectation(forNotification:object:handler:):通知期望 该方法监听一个通知,如果在规定时间内正确收到通知则测试通过 {% codeblock lang:swift %} //expectation(forNotification notificationName: String, object objectToObserve: Any?, handler: XCTest.XCNotificationExpectationHandler? = nil) -\u0026gt; XCTestExpectation //设置一个测试通知期望 expectation(forNotification: \u0026ldquo;BLDownloadImageNotification\u0026rdquo;, object: nil) {(notification) -\u0026gt; Bool in let userInfo = notification.userInfo as! [String:String] let name = userInfo[\u0026ldquo;name\u0026rdquo;] print(\u0026ldquo;name:(name)\u0026rdquo;) return true } 来定义一个通知并发送通知，来测试： let notif = Notification.Name(rawValue: \u0026ldquo;BLDownloadImageNotification\u0026rdquo;) NotificationCenter.default.post(name: notif, object: self, userInfo: [\u0026ldquo;name\u0026rdquo;:\u0026ldquo;iTBoyer\u0026rdquo;,\u0026ldquo;sex\u0026rdquo;:\u0026ldquo;man\u0026rdquo;])\n//设置延迟多少秒后，如果没有满足测试条件就报错 waitForExpectations(timeout: 3, handler: nil) {% endcodeblock %}\n使用expectation(description:)实现 帮助理解 expectation(forNotification:object:handler:) 方法和 expectation(description:) 的区别 {% codeblock lang:swift %} func testAsynForNotificationWithExpectation() { let expectation = self.expectation(description: \u0026ldquo;BLDownloadImageNotification\u0026rdquo;) let notif = NSNotification.Name(rawValue: \u0026ldquo;BLDownloadImageNotification\u0026rdquo;) let sub = NotificationCenter.default.addObserver(forName: notif, object: nil, queue: nil) { (notification) -\u0026gt; Void in expectation.fulfill() } //发送一个通知 NotificationCenter.default.post(name: notif, object: nil)\n//waitForExpectations waitForExpectations(timeout: 1, handler: nil) //移除通知 NotificationCenter.default.removeObserver(sub) }\n{% endcodeblock %}\nexpectation(for:evaluatedWith:handler:):谓词计算测试法 利用谓词计算，判断button的backgroundImageForState方法，是否正确的获得了backgroundImage，如果20秒内正确获得则通过测试，否则失败 {% codeblock lang:swift %} //open func expectation(for predicate: NSPredicate, evaluatedWith object: Any, handler: XCTest.XCPredicateExpectationHandler? = nil) -\u0026gt; XCTestExpectation func testThatBackgroundImageChanges() { let viewController = OnclickLikeViewController() //viewController.loadView() //不执行viewDidload方法 let _ = viewController.view let button = viewController.button let img = button.backgroundImage(for: .normal) XCTAssertNil(img,\u0026ldquo;此时img不为nil,中止执行\u0026rdquo;) //当img不是nil时，执行断言 let predicate = NSPredicate.init { (anyobject, bindings) -\u0026gt; Bool in // let button = anyobject as! UIButton return button.backgroundImage(for: UIControlState()) != nil } expectation(for: predicate, evaluatedWith: button, handler: nil) waitForExpectations(timeout: 20, handler: nil) } {% endcodeblock %}\n使用expectation(description:)实现 帮助理解 expectation(for:evaluatedWith:handler:) 方法和 expectation(description:) 的区别 {% codeblock lang:swift %} func testThatBackgroundImageChanges() { //设置期望 let expectation = self.expectation(description: \u0026ldquo;backgroundImageForState\u0026rdquo;)\nlet viewController = OnclickLikeViewController() //viewController.loadView() //不执行viewDidload方法 let _ = viewController.view let button = viewController.button let img = button.backgroundImage(for: .normal) XCTAssertNil(img,\u0026quot;此时img不为nil,中止执行\u0026quot;) //当img不是nil时，执行断言 let predicate = NSPredicate.init { (anyobject, bindings) -\u0026gt; Bool in // let button = anyobject as! UIButton return button.backgroundImage(for: UIControlState()) != nil //实现测试期望 expectation.fulfill() } //等待期望实现 waitForExpectations(timeout: 20, handler: nil) }\n{% endcodeblock %}\n传递expectation在目的方法中再fulfill()实现期望 例如将期望封装在字典中，通过通知来传递给异步下载的方法中调用该期望的fulfill()方法，实现单元测试的期望 {% codeblock lang:swift %} */ func testAsynForNotificationWithExpectation2() { let expectation = self.expectation(description: \u0026ldquo;BLDownloadImageNotification\u0026rdquo;)\nlet notif = Notification.Name(rawValue: \u0026quot;BLDownloadImageNotification\u0026quot;) NotificationCenter.default.addObserver(self, selector: #selector(AsyncTheOldWayTest.downLoadImage(_:)), name: notif, object: nil) //将期望封装在字典中传递 let userInf = [\u0026quot;name\u0026quot;:\u0026quot;iTBoyer\u0026quot;,\u0026quot;sex\u0026quot;:\u0026quot;man\u0026quot;,\u0026quot;expectation\u0026quot;:expectation] NotificationCenter.default.post(name: notif, object: self, userInfo: userInf) //等待期望实现 waitForExpectations(timeout: 1, handler: nil) NotificationCenter.default.removeObserver(self) } // func downLoadImage(_ notification:Notification) { // let userInfo = notification.userInfo as! [String:AnyObject] let name = userInfo[\u0026quot;name\u0026quot;] let sex = userInfo[\u0026quot;sex\u0026quot;] print(\u0026quot;name:\\(name), sex = \\(sex)\u0026quot;) let expectation = userInfo[\u0026quot;expectation\u0026quot;] as! XCTestExpectation expectation.fulfill() } } {% endcodeblock %}\n","date":"2017-02-20T23:09:30Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/%E9%AB%98%E6%9C%9F%E6%9C%9B%E5%AE%9E%E7%8E%B0%E5%BC%82%E6%AD%A5%E5%8D%95%E5%85%83%E6%B5%8B%E8%AF%95/","section":"post","tags":["iOS","单元测试"],"title":"高期望实现异步单元测试"},{"categories":["项目总结"],"contents":"{% github it-boyer PresentationsDemo 2cce4c908 width = 30% %}\n触发转场的方式 官方支持的自定义转场 在 UINavigationController 中 push 和 pop; 在 UITabBarController 中切换 Tab; Modal 转场：presentation 和 dismissal，俗称视图控制器的模态显示和消失，仅限于modalPresentationStyle属性为 UIModalPresentationFullScreen 或 UIModalPresentationCustom 这两种模式; UICollectionViewController 的布局转场：仅限于 UICollectionViewController 与 UINavigationController 结合的转场方式，与上面三种都有点不同，不过实现很简单，可跳转至该链接查看。 官方的支持包含了 iOS 中的大部分转场方式，还有一种自定义容器中的转场并没有得到系统的直接支持，不过借助协议这种灵活的方式，我们依然能够实现对自定义容器控制器转场的定制，在压轴环节我们将实现这一点。 相关触发转场的动作 UINavigationController UINavigationController 中所有修改其viewControllers栈中 VC 的方法都可以自定义转场动画： {% codeblock swift lang:swift %} //我们使用的最广泛的 push 和 pop 方法 func pushViewController(_ viewController: UIViewController, animated animated: Bool) func popViewControllerAnimated(_ animated: Bool) -\u0026gt; UIViewController? //不怎么常用的 pop 方法 func popToRootViewControllerAnimated(_ animated: Bool) -\u0026gt; [UIViewController]? func popToRootViewControllerAnimated(_ animated: Bool) -\u0026gt; [UIViewController]? //这个方法有有点特别，是对 VC 栈的整体更新，开启动画后的执行比较复杂，具体参考文档说明。不建议在这种情况下开启转场动画。 func setViewControllers(_ viewControllers: [UIViewController], animated animated: Bool) {% endcodeblock %}\nUITabBarController {% codeblock swift lang:swift %} //注意传递的参数必须是其下的子 VC unowned(unsafe) var selectedViewController: UIViewController? var selectedIndex: Int //和上面类似的整体更新 func setViewControllers(_ viewControllers: [UIViewController]?, animated animated: Bool) {% endcodeblock %}\nModal 转场： {% codeblock swift lang:swift %} // Presentation 转场 func presentViewController(_ viewControllerToPresent: UIViewController, animated flag: Bool, completion completion: (() -\u0026gt; Void)?) // Dismissal 转场 func dismissViewControllerAnimated(_ flag: Bool, completion completion: (() -\u0026gt; Void)?) {% endcodeblock %}\nSegue 在 storyboard 里设置 segue有两种方式：Button to VC，这种在点击 Button 的时候触发转场；VC to VC，这种需要在代码中调用performSegueWithIdentifier:sender:。prepareForSegue:sender:方法是在转场发生前修改转场参数的最后机会。这点对于 Modal 转场比较重要，因为在 storyboard 里 Modal 转场的 Segue 类型不支持选择 Custom 模式，使用 segue 方式触发时必须在prepareForSegue:sender:里修改模式。\niOS 8 的变化 iOS 8 引入了适应性布局，由此添加了两种新的方式来显示一个视图控制器： {% codeblock swift lang:swift %} func showViewController(_ vc: UIViewController, sender sender: AnyObject?) func showDetailViewController(_ vc: UIViewController, sender sender: AnyObject?) {% endcodeblock %} 这两个方法咋看上去是给 UISplitViewController 用的，在 storyboard 里 segue 的候选模式里，直接给出了Show(e.g. Push)和Show Detail(e.g. Replace)这样的提示，以至于我之前一直对这两个 segue 有误解。实际上这两个方法智能判断当前的显示环境来决定如何显示，iOS 8 想统一显示视图控制器的方式，不过引入这两个方法增加了使用的复杂性，来看看这两个方法的使用规则。 这两个方法在 UISplitViewController 上的确是按名字显示的那样去工作的，而在本文关注的控制器上是这样工作的：\nViewController NavigationController TabBarController showViewController:sender: Presentation Push Presentation(by self) showDetailViewController:sender: Presentation Presentation(by self) Presentation(by self) UINavigationController 重写了showViewController:sender:而执行 push 操作，上面的by self意思是用容器 VC 本身而非其下子 VC 去执行 presentation。这两个方法的行为可以通过重写来改变。 当非容器类 VC 内嵌在这两种容器 VC 里时，会通过最近的容器 VC 来执行： VC in NavigationController VC in TabBarController :\u0026mdash;\u0026mdash;- :\u0026mdash;\u0026mdash;- :\u0026mdash;\u0026mdash;\u0026ndash; showViewController:sender: Push(by NavigationController) Presentation(by TabBarController) showDetailViewController:sender: Presentation(by NavigationController) Presentation(by TabBarController) 转场五大工具 iOS 7 以协议的方式开放了自定义转场的 API，协议的好处是不再拘泥于具体的某个类，只要是遵守该协议的对象都能参与转场，非常灵活。转场协议由5种协议组成，在实际中只需要我们提供其中的两个或三个便能实现绝大部分的转场动画：\n转场代理(Transition Delegate)： 有如下三种容器转场代理，对应上面三种类型的转场： {% codeblock lang:swift %} //UINavigationController 的 delegate 属性遵守该协议。 //UITabBarController 的 delegate 属性遵守该协议。 //UIViewController 的 transitioningDelegate 属性遵守该协议。 {% endcodeblock %} 这里除了是 iOS 7 新增的协议，其他两种在 iOS 2 里就存在了，在 iOS 7 时扩充了这两种协议来支持自定义转场。\n动画控制器(Animation Controller)： 最重要的部分，负责添加视图以及执行动画；遵守协议；由我们实现。\n交互控制器(Interaction Controller)： 通过交互手段，通常是手势来驱动动画控制器实现的动画，使得用户能够控制整个过程；遵守协议；系统已经打包好现成的类供我们使用。\n转场环境(Transition Context): 提供转场中需要的数据；遵守协议；由 UIKit 在转场开始前生成并提供给我们提交的动画控制器和交互控制器使用。\n转场协调器(Transition Coordinator)： 可在转场动画发生的同时并行执行其他的动画，其作用与其说协调不如说辅助，主要在 Modal 转场和交互转场取消时使用，其他时候很少用到；遵守协议；由 UIKit 在转场时生成，UIViewController 在 iOS 7 中新增了方法transitionCoordinator()返回一个遵守该协议的对象，且该方法只在该控制器处于转场过程中才返回一个此类对象，不参与转场时返回 nil。\n总结下，5个协议只需要我们操心3个；实现一个最低限度可用的转场动画，我们只需要提供上面五个组件里的两个：转场代理和动画控制器即可，还有一个转场环境是必需的，不过这由系统提供；当进一步实现交互转场时，还需要我们提供交互控制器，也有现成的类供我们使用。\n特殊的 Modal 转场 容器类 VC 的转场里 fromView 和 toView 是 containerView 的子层次的视图，而 Modal 转场里 presentingView 与 containerView 是同层次的视图，只有 presentedView 是 containerView 的子层次视图。\niOS 8引入的UIPresentationController UIPresentationController类，该类接管了 UIViewController 的显示过程，为其提供转场和视图管理支持。在 iOS 8.0 以上的系统里，你可以在 presentation 转场结束后打印视图控制器的结构，会发现 presentedVC 是由一个UIPresentationController对象来显示的，查看视图结构也能看到 presentedView 是 UIView 私有子类的UITtansitionView的子视图，这就是前面 containerView 的真面目. 当UIViewController的modalPresentationStyle属性为.Custom时(不支持.FullScreen)，我们有机会通过控制器的转场代理提供UIPresentationController的子类对 Modal 转场进行进一步的定制。实际上该类也可以在.FullScreen模式下使用，但是会丢失由该类负责的动画，保险起见还是遵循官方的建议，只在.Custom模式下使用该类。 UIPresentationController类赋予 Modal 转场以下特性：\n定制 presentedView 的外观，尺寸以及在 containerView 中添加自定义视图并为这些视图添加动画； 可以选择是否移除 presentingView 可以在不需要动画控制器的情况下单独工作 iOS 8 中的自适应适应性布局 UIPresentationController类提供了如下的方法参与转场，对转场过程实现了更加细致的控制，从命名便可以看出与动画控制器里的animateTransition:的关系： {% codeblock swift lang:swift %} func presentationTransitionWillBegin() func presentationTransitionDidEnd(_ completed: Bool) func dismissalTransitionWillBegin() func dismissalTransitionDidEnd(_ completed: Bool) {% endcodeblock %} 除了 presentingView，UIPresentationController类拥有转场过程中剩下的角色： {% codeblock swift lang:swift %} //指定初始化方法。 init(presentedViewController presentedViewController: UIViewController, presentingViewController presentingViewController: UIViewController) var presentingViewController: UIViewController { get } var presentedViewController: UIViewController { get } var containerView: UIView? { get } //提供给动画控制器使用的视图，默认返回 presentedVC.view，通过重写该方法返回其他视图，但一定要是 presentedVC.view 的上层视图。 func presentedView() -\u0026gt; UIView? {% endcodeblock %} 没有 presentingView 是因为 Custom 模式下 presentingView 不受 containerView 管理，UIPresentationController类并没有改变这一点。iOS 8 扩充了转场环境协议，可以通过viewForKey:方便获取转场的视图，而该方法在 Modal 转场中获取的是presentedView()返回的视图。因此我们可以在子类中将 presentedView 包装在其他视图后重写该方法返回包装后的视图当做 presentedView 在动画控制器中使用。 定制presentedView 外观：重载size方法和frameOfPresentedViewInContainerView属性 重载存储属性：get方法返回登场页面的位置和大小 {% codeblock lang:swift %} override var frameOfPresentedViewInContainerView: CGRect { var presentViewFrame = CGRect.zero let containerBounds = containerView?.bounds //登场控制器内容页面的大小 presentViewFrame.size = size(forChildContentContainer: presentedViewController, withParentContainerSize: (containerBounds?.size)!) presentViewFrame.origin.x = (containerBounds?.size.width)! - presentViewFrame.size.width return presentViewFrame }\n//返回登场控制器内容页面的大小，在这里设置为屏幕宽度的三分之一款 override func size(forChildContentContainer container: UIContentContainer, withParentContainerSize parentSize: CGSize) -\u0026gt; CGSize { return CGSize.init(width:CGFloat(floorf(Float(parentSize.width/3.0))), height: parentSize.height) } {% endcodeblock %}\n过渡动画，转场协调器(Transition Coordinator) 参与角色都准备好了，但有个问题，无法直接访问动画控制器，不知道转场的持续时间，怎么与转场过程同步？这时候前面提到的用处甚少的转场协调器(Transition Coordinator)将在这里派上用场。该对象可通过 UIViewController 的transitionCoordinator()方法获取，这是 iOS 7 为自定义转场新增的 API，该方法只在控制器处于转场过程中才返回一个与当前转场有关的有效对象，其他时候返回 nil。\n转场开始 在containerView中插入过渡视图chromeView 为转场中chromeView过渡视图添加转场动画 presentedViewController.transitionCoordinator转场协调器，添加转场的登场和退场动画 {% codeblock presentationTransitionWillBegin lang:swift %} override func presentationTransitionWillBegin() { chromeView.frame = (self.containerView?.bounds)! chromeView.alpha = 0.0 //在containerView中插入视图chromeView containerView?.insertSubview(chromeView, at:0) //coordinator转场协调器负责转场动画的呈现和dismissal let coordinator = presentedViewController.transitionCoordinator if (coordinator != nil) { //添加登场动画 coordinator!.animate(alongsideTransition: { (context:UIViewControllerTransitionCoordinatorContext!) -\u0026gt; Void in //animate the alpha to 1.0. self.chromeView.alpha = 1.0 }, completion:nil) } else { chromeView.alpha = 1.0 } } {% endcodeblock %} 转场结束 在presentedViewController.transitionCoordinator转场协调器中添加转场的退场动画 {% codeblock dismissalTransitionWillBegin lang:swift %} override func dismissalTransitionWillBegin() { let coordinator = presentedViewController.transitionCoordinator if (coordinator != nil) { //添加退场动画 coordinator!.animate(alongsideTransition: { (context:UIViewControllerTransitionCoordinatorContext!) -\u0026gt; Void in self.chromeView.alpha = 0.0 }, completion:nil) } else { chromeView.alpha = 0.0 } } {% endcodeblock %}\n适配屏幕旋转 在设备旋转的情况下，重置背景视图的外观和登场控制器内容的外观 {% codeblock lang:swift %} override func containerViewWillLayoutSubviews() { chromeView.frame = (containerView?.bounds)! presentedView?.frame = frameOfPresentedViewInContainerView } {% endcodeblock %}\nModal的两种PresentationStyle 设置整个转场动画是否将覆盖全屏幕 .OverFullScreen: 浮动式全屏，即：登场视图下方的视图不会完全被遮挡 .FullScreen : 全覆盖全屏 即：占据全屏来显示登场视图 {% codeblock lang:swift %} //设置整个转场动画是否将覆盖全屏幕 override var shouldPresentInFullscreen: Bool { return true } override var adaptivePresentationStyle: UIModalPresentationStyle { return UIModalPresentationStyle.fullScreen } {% endcodeblock %}\n交互式转场 实现交互化 在非交互转场的基础上将之交互化需要两个条件： 由转场代理提供交互控制器，这是一个遵守协议的对象，不过系统已经打包好了现成的类UIPercentDrivenInteractiveTransition供我们使用。我们不需要做任何配置，仅仅在转场代理的相应方法中提供一个该类实例便能工作。另外交互控制器必须有动画控制器才能工作。 交互控制器还需要交互手段的配合，最常见的是使用手势，或是其他事件，来驱动整个转场进程。\n使用一个变量来标记交互状态配合转场交互 如果在转场代理中提供了交互控制器，而转场发生时并没有方法来驱动转场进程(比如手势)，转场过程将一直处于开始阶段无法结束。 在两个容器控制器NavigationController和TabBarController转场为例：\n在 NavigationController 中点击 NavigationBar 也能实现 pop 返回操作，但此时没有了交互手段的支持，转场过程卡壳； 在 TabBarController 的代理里提供交互控制器存在同样的问题，点击 TabBar 切换页面时也没有实现交互控制。因此仅在确实处于交互状态时才提供交互控制器，可以使用一个变量来标记交互状态，该变量由交互手势来更新状态。 转场动画控制器：向转场中添加视图，执行转场动画 转场 API 是协议的好处是不受限于具体的类，只要对象实现该协议便能参与转场过程，这也带来另外一个好处：封装便于复用，尽管三大转场代理协议的方法不尽相同。 但它们返回的动画控制器遵守的是同一个协议，因此可以将动画控制器封装作为第三方动画控制器在其他控制器的转场过程中使用。 UIViewControllerAnimatedTransitioning代理协议方法，提供了转场所需要的重要数据：\ncontainerView()：运行转场动画的容器视图 转场视图控制器 方法一：viewController(forKey:)：UITransitionContextViewControllerKey枚举值：from，to 方法二：viewForKey(_ key: String) -\u0026gt; UIView? AVAILABLE_IOS(8_0):iOS 8新增 API 用于方便获取参与转场的视图.两个键值：UITransitionContextFromViewKey,UITransitionContextToViewKey. {% codeblock lang:swift %} class ExampleAnimatedTransitioning: NSObject,UIViewControllerAnimatedTransitioning { //used to determine if the presentation animation is presenting (as opposed to dismissing). var isPresentation : Bool = false\n//returns the duration in seconds of the transition animation. func transitionDuration(using transitionContext: UIViewControllerContextTransitioning?) -\u0026gt; TimeInterval { //返回动画时间 return 0.5 } //get the respective views of these view controllers. //Next we get the container view and if the presentation animation is presenting, we add the to view to the container view. func animateTransition(using transitionContext: UIViewControllerContextTransitioning) { //get the from and to view controllers from the UIViewControllerContextTransitioning object. let fromVC = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.from) let toVC = transitionContext.viewController(forKey: UITransitionContextViewControllerKey.to) //determine the start and end positions of the view. let fromView = fromVC?.view let toView = toVC?.view let containerView = transitionContext.containerView if isPresentation { containerView.addSubview(toView!) } //decide on which view controller to animate based on whether the transition is a presentation or dismissal let animatingVC = isPresentation ? toVC : fromVC let animatingView = animatingVC?.view let finalFrameForVC = transitionContext.finalFrame(for: animatingVC!) var initialFrameForVC = finalFrameForVC //This will animate the view from right to left during a presentation and vice versa during dismissal. initialFrameForVC.origin.x += initialFrameForVC.size.width let initialFrame = isPresentation ? initialFrameForVC : finalFrameForVC let finalFrame = isPresentation ? finalFrameForVC : initialFrameForVC animatingView?.frame = initialFrame //根据协议中的方法获取动画的时间。 let duration = transitionDuration(using: transitionContext) UIView.animate(withDuration: duration, delay:0, usingSpringWithDamping:300.0, initialSpringVelocity:5.0, options:UIViewAnimationOptions.allowUserInteraction, animations:{ //we move the view to the final position. animatingView?.frame = finalFrame }, completion:{ (value: Bool) in if !self.isPresentation { //If the transition is a dismissal, we remove the view. fromView?.removeFromSuperview() } //we complete the transition by calling transitionContext.completeTransition() transitionContext.completeTransition(true) }) } // UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: { _ in // let isCancelled = transitionContext.transitionWasCancelled() // transitionContext.completeTransition(!isCancelled) // }) //如果实现了，会在转场动画结束后调用，可以执行一些收尾工作。 func animationEnded(_ transitionCompleted: Bool) { // } } {% endcodeblock %}\n转场代理协议(Transition Delegate) 自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。\n实现转场代理协议方法，整合动画控制器和自定义展示控制器 返回管理用户信息视图控制器如何展示的控制器。前面实现的ExamplePresentationViewController类可同时处理 presentation转场 和 dismissal 转场。 动画控制器为 presentation 和 dismissal 转场分别提供了动画控制器。 UIPresentationController只在 iOS 8中可用，通过available关键字可以解决 API 的版本差异。\n{% codeblock lang:swift %} class ExampleTransitioningDelegate: NSObject,UIViewControllerTransitioningDelegate { //returns a presentation controller that manages the presentation of a view controller. func presentationController(forPresented presented: UIViewController, presenting: UIViewController?, source: UIViewController) -\u0026gt; UIPresentationController? { //presentation动画控制器 let presentationController = ExamplePresentationViewController(presentedViewController:presented, presenting:presenting)\nreturn presentationController } //为presentation转场提供登场转场动画控制器 func animationController(forPresented presented: UIViewController, presenting: UIViewController, source: UIViewController) -\u0026gt; UIViewControllerAnimatedTransitioning? { //登场转场动画控制器 let animator = ExampleAnimatedTransitioning() animator.isPresentation = true return animator } //为dismissal 转场提供退场转场动画控制器 func animationController(forDismissed dismissed: UIViewController) -\u0026gt; UIViewControllerAnimatedTransitioning? { //退场转场动画控制器 let animator = ExampleAnimatedTransitioning() animator.isPresentation = false return animator } } {% endcodeblock %}\n使用自定义的转场的代理 自定义转场的第一步便是提供转场代理，告诉系统使用我们提供的代理而不是系统的默认代理来执行转场。 UIViewControllerTransitioningDelegate转场代理：\n强引用代理变量:强引用的变量来维护该代理 Modal转场代理的特性：由presentedVC自身来遵循转场代理presentedVC.modalPresentationStyle，和前两个容器控制器转场代理不同。 两种支持自定义转场模式：.Custom或.FullScreen,默认值为.FullScreen {% codeblock fromVC.class lang:swift %} //强引用的变量来维护该代理 let exampleTransitionDelegate = ExampleTransitioningDelegate() //create an instance of ExampleViewController which will provide the content to display. let presentedVC = ExampleViewController() presentedVC.modalPresentationStyle = .custom presentedVC.transitioningDelegate = exampleTransitionDelegate //present this view controller. present(toVC, animated: true, completion: nil) {% endcodeblock %}\n两种常规的转场方式 UIView方式:transitionFromView 不需要获取 containerView 以及手动添加 toView 就能实现一个指定类型的转场动画，而缺点则是只能使用指定类型的动画。 {% codeblock lang:swift %} UIView.transitionFromView(fromView, toView: toView, duration: durantion, options: .TransitionCurlDown, completion: { _ in let isCancelled = transitionContext.transitionWasCancelled() transitionContext.completeTransition(!isCancelled) }) {% endcodeblock %}\nUIViewController方式：在子 VC 间转换的方法 该方法用 toVC 的视图转换 fromVC 的视图在父视图中的位置，并且执行animations闭包里的动画。 {% codeblock lang:swift %} transitionFromViewController:toViewController:duration:options:animations:completion: {% endcodeblock %} 该方法仅限于在自定义容器控制器里使用，如果直接使用 UINavigationController 和 UITabBarController 调用该方法执行子VC间转换会抛出异常。\n不过 iOS 7 中这两个容器控制器开放的自定义转场做的是同样的事情，回头再看第一章 Transition 解释，转场协议 API 将这个方法拆分成了上面的几个组件，并且加入了激动人心的交互控制，以便我们能够方便定制转场动画。\n原文\n","date":"2017-02-17T12:26:11Z","permalink":"https://it-boyer.github.io/post/old/iOS/%E8%87%AA%E5%AE%9A%E4%B9%89%E5%B1%95%E7%A4%BA%E5%9E%8B%E6%8E%A7%E5%88%B6%E5%99%A8/","section":"post","tags":["转场","iOS"],"title":"自定义展示型控制器"},{"categories":["项目总结"],"contents":"开始项目 完整项目\nUIAlertController 在iOS8中，提供UIAlertController控制器代替UIAlertView和UIActionSheet两个控件。给用户展示提示信息的新的一种方式。\n优势 能够自适应的（在iPad上，an action sheet style alert will present itself in a popover）， 显示方式：可以轻松切换Action sheets和alert view两种显示样式alert view被以modal态显示presenting视图控制器上，Action sheets被固定在以屏幕底部。 按钮事件实现：使用闭包的方式来处理，相较之前通过实现代理的方式要简单很多。 子控件支持：Alert view支持按钮和输入框两种，Action sheets仅支持按钮一种控件。 不同于以往的两类UIAlertController继承自UIViewController。这意味着可以使用视图控制器提供展示信息的功能。 创建使用UIAlertController 用title，message参数来实例化alertController实例，然后在实例中添加两个闭包的按钮 {% codeblock showAlertWasTapped lang:swift %} @IBAction func showAlertWasTapped(sender: UIButton) { let alertController = UIAlertController(title: \u0026ldquo;Appcoda\u0026rdquo;, message: \u0026ldquo;Message in alert dialog\u0026rdquo;, preferredStyle: UIAlertControllerStyle.Alert)\nlet deleteAction = UIAlertAction(title: \u0026quot;Delete\u0026quot;, style: UIAlertActionStyle.Destructive, handler: {(alert :UIAlertAction!) in println(\u0026quot;Delete button tapped\u0026quot;) }) alertController.addAction(deleteAction) let okAction = UIAlertAction(title: \u0026quot;OK\u0026quot;, style: UIAlertActionStyle.Default, handler: {(alert :UIAlertAction!) in println(\u0026quot;OK button tapped\u0026quot;) }) alertController.addAction(okAction) presentViewController(alertController, animated: true, completion: nil) } {% endcodeblock %} 运行效果：\nUIAlertControllerStyle枚举：Alert切换ActionSheet 在UIAlertController之前，切换alert和action sheet需要重写大量的代码，但现在只需要改变一个枚举值UIAlertControllerStyle.Alert为UIAlertControllerStyle.ActionSheet. {% codeblock UIAlertControllerStyle.ActionSheet lang:swift %} let alertController = UIAlertController(title: \u0026ldquo;Appcoda\u0026rdquo;, message: \u0026ldquo;Message in alert dialog\u0026rdquo;, preferredStyle: UIAlertControllerStyle.ActionSheet) {% endcodeblock %} 在iPhone上，屏幕底部显示一个action sheet。 问题：在iPad上，点击上面的按钮崩溃，需要定义锚点位置。\npopoverPresentationController锚点：sourceView/sourceRect popover controller在alertController视图内展示，需要一个popover箭头指向alertController视图的某一位置。 通过设置sourceView来确定popover箭头位置，这个popover以及popover箭头指向的矩形区域都在这个sourceView上。 在调用presentViewController()之前添加代码： {% codeblock lang:swift %} alertController.popoverPresentationController?.sourceView = view alertController.popoverPresentationController?.sourceRect = sender.frame {% endcodeblock %}\nUIPopoverPresentationController Alert主要用于显示用户的提示信息，当展示的信息很多时，就需要借助popover presentation controller。\n在compact和regular两种屏幕中显示模态视图 在storyboard文件，设置视图的storyboard ID:PopoverViewController，设置模态视图展示样式，展示在compact-width和regular-width的两种设备屏幕上。 实现如下： {% codeblock actionWasTapped lang:swift %} @IBAction func actionWasTapped(sender: UIBarButtonItem) { let storyboard : UIStoryboard = UIStoryboard(name: \u0026ldquo;Main\u0026rdquo;, bundle: nil) let vc = storyboard.instantiateViewControllerWithIdentifier(\u0026ldquo;PopoverViewController\u0026rdquo;) as! UIViewController vc.modalPresentationStyle = UIModalPresentationStyle.Popover let popover: UIPopoverPresentationController = vc.popoverPresentationController! popover.barButtonItem = sender //popover箭头锚的位置 presentViewController(vc, animated: true, completion:nil) } {% endcodeblock %}\n设置锚点四种方式 barButtonItem 先获取该视图控制器的popoverPresentationController控制器，通过popover控制器的barButtonItem属性来设置锚点控件。当弹出时popover箭头就指向这个barButtonItem控件。 通过指定sourceView和sourceRect两个属性，就像前面例子中一样来指定锚点位置。 通过其他属性来实现，例如：permittedArrowDirections，也能够指定锚点。 如果在在展示过程中，无法确定箭头的方向时，就是用默认值：UIPopoverArrowDirection.Any. 在iPad显示： 在iPhone上以模态显示：\n在iPhone设备上dissmiss模态视图 要在iPhone设备上，实现模态视图dissmiss功能，需要借助导航控制器，同时这个模态视图需要遵循UIPopoverPresentationController协议，实现两个代理方法\n实现UIPopoverPresentationController协议 PopoverViewController类定义修改如下: {% codeblock lang:swift %} class PopoverViewController: UIViewController, UIPopoverPresentationControllerDelegate { {% endcodeblock %} 在actionWasTapped()函数中调用presentViewController()之前添加： {% codeblock lang:swift %} popover.delegate = self {% endcodeblock %} 方法一：返回自适应设备的视图展示样式 当APP在compact-width设备上弹出一个视图时调用.这个方法告诉OS系统使用的视图展示样式。 这里OS系统被告知在compact-width设备上，使用全屏的样式展示视图。 {% codeblock adaptivePresentationStyleForPresentationController() lang:swift %} func adaptivePresentationStyleForPresentationController(controller: UIPresentationController) -\u0026gt; UIModalPresentationStyle { return UIModalPresentationStyle.FullScreen } {% endcodeblock %}\n方法二：返回自定义的视图控制器 当前展现的视图和原来的展示方式不同时调用.我们设置这个视图的Popover presentation展示方式，但是我们指定在compact-width设备上，这样它会以full screen样式展示。在这个函数中，样式切换发生时，会return自定义的视图控制器。 {% codeblock presentationController(_:viewControllerForAdaptivePresentationStyle) lang:swift %} func presentationController(controller: UIPresentationController, viewControllerForAdaptivePresentationStyle style: UIModalPresentationStyle) -\u0026gt; UIViewController? { let navigationController = UINavigationController(rootViewController: controller.presentedViewController) let btnDone = UIBarButtonItem(title: \u0026ldquo;Done\u0026rdquo;, style: .Done, target: self, action: \u0026ldquo;dismiss\u0026rdquo;) navigationController.topViewController.navigationItem.rightBarButtonItem = btnDone return navigationController } {% endcodeblock %}\nDone按钮的dismiss事件 在导航控制器中国封装这个视图，在导航条上添加一个Done按钮，点击Donedismiss这个视图 {% codeblock dismiss lang:swift %} func dismiss() { self.dismissViewControllerAnimated(true, completion: nil) } {% endcodeblock %}\n在iPhone上，显示修改后的视图控制器，多出带按钮的导航栏。 在iPad上，视图控制器显示没有导航控制器，因为它不使用全屏幕显示。 如果想让iPhone像iPad一样显示一个Popover，只adaptivePresentationStyleForPresentationController返回： {% codeblock lang:swift %} return UIModalPresentationStyle.None {% endcodeblock %}\n","date":"2017-02-16T17:53:18Z","permalink":"https://it-boyer.github.io/post/old/iOS/iOS%E4%B8%AD%E5%87%A0%E7%A7%8D%E5%B8%B8%E7%94%A8%E7%9A%84%E5%B1%95%E7%A4%BA%E6%8E%A7%E5%88%B6%E5%99%A8%E4%BD%BF%E7%94%A8/","section":"post","tags":["转场"],"title":"整理iOS中几种常用的展示型视图控制器"},{"categories":["学习笔记"],"contents":"文档 JavaScript自动化有一个内置的Objective-C Bridge，使您能够访问文件系统，创建Cocoa应用程序。 Objective-C Bridge的主要接入点是全局属性objc和$。\nFrameworks Foundation framework中的语法默认支持JavaScript自动化。也可以通过使用ObjC.import()方法导入其他Frameworks 和 libraries。 例如，使用Cocoa框架中的NSBeep()函数，需要导入Cocoa框架 {% codeblock lang:js %} ObjC.import(\u0026lsquo;Cocoa\u0026rsquo;) $.NSBeep() {% endcodeblock %} 除了系统框架之外，一些系统库的功能也被暴露出来。这个功能可以通过头文件的名称来暴漏出来（不带.h） 例如：\narpa/inet, asl, copyfile, dispatch, dyld, errno, getopt, glob, grp, ifaddrs, launch, membership, netdb, netinet/in, notify, objc, paths, pwd, readline, removefile, signal, spawn, sqlite3, stdio, stdlib, string, sys/fcntl, sys/file, sys/ioctl, sys/mount, sys/param, sys/resource, sys/socket, sys/stat, sys/sysctl, sys/time, sys/times, sys/types, sys/wait, sys/xattr, syslog, time, unistd, uuid/uuid, vImage, vecLib, vmnet, xpc, 和 zlib. 导入框架时，系统将参考桥接支持文件。除了内置的框架和库，您可以导入任何具有桥接支持的框架，只需要将完整路径传递给框架，如下示例： {% codeblock lang:js %} ObjC.import(\u0026rsquo;/Library/Frameworks/Awesome.framework\u0026rsquo;) {% endcodeblock %}\n数据类型 原始的JavaScript数据类型映射到C数据类型。例如，一个JavaScript字符串映射为char *，而JavaScript整数映射到int。使用objc API返回一个char *时，会得到一个JS 字符串\n原始的JavaScript数据类型将被自动转换为ObjC对象类型，并能作为一个预期的对象类型的参数传递给ObjC方法。 例如，一个JS字符串将被转换为一个NSString对象如果是什么方法签名说应该是输入。\n注意，然而，ObjC方法返回的ObjC对象类型是不会自动转换为原始的JavaScript的数据类型。\n实例化的类和调用方法 所有类都定义为$对象的属性。ObjC对象的方法有两种方式调用，根据是否需要参数的方法。 如果ObjC方法不带参数，然后调用JavaScript属性名访问属性值。这个例子中实例化一个空的字符串。 {% codeblock lang:js %} str = $.NSMutableString.alloc.init {% endcodeblock %} 如果ObjC方法不带参数，根据JSExport规范来命名，通过JavaScript的方法调用（function-typed property）； 对于多参数的方法，Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar); 这个例子说明JavaScript字符串转为NSString然后写入到一个文件 {% codeblock lang:js %} str = $.NSString.alloc.initWithUTF8String(\u0026lsquo;foo\u0026rsquo;) str.writeToFileAtomically(\u0026rsquo;/tmp/foo\u0026rsquo;, true) {% endcodeblock %}\n如果你调用一个方法，如-intValue，返回C数据类型而不是一个对象，然后你会回到原始的JavaScript数据类型。 此示例返回原始的JavaScript的整数，99。 {% codeblock lang:js %} $.NSNumber.numberWithInt(99).intValue {% endcodeblock %}\n访问 ObjC Properties ObjC属性也可以通过JavaScript属性来访问，很像调用无参数方法。 当一个桥接对象属性的被访问时，ObjC属性列表是第一参考，如果列表中存在该名称对应的属性，那么就调用相应属性的getter或setter选择器。如果该名称的ObjC属性不在类中属性的列表中，那么该属性名称就作为方法选择器来调用。 使用自定义getter名定义一个属性，你可以使用属性名 或 getter名，并得到相同的结果。 {% codeblock lang:js %} task = $.NSTask.alloc.init task.running == task.isRunning {% endcodeblock %} 另外，不同的参数方法，桥接对象属性映射到ObjC属性也可以设置为（read/write属性）。下面的两行定义了一个ObjC属性：launchPath。 {% codeblock lang:js %} task.launchPath = \u0026lsquo;/bin/sleep\u0026rsquo; task.setLaunchPath(\u0026rsquo;/bin/sleep\u0026rsquo;) {% endcodeblock %}\n","date":"2017-02-15T17:19:30Z","permalink":"https://it-boyer.github.io/post/old/macOS/JavaScript%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%84%E4%BB%B6OC%E6%A1%A5%E6%8E%A5/","section":"post","tags":[],"title":"JavaScript自动化组件OC桥接"},{"categories":["解决方案"],"contents":"苹果 OS X Yosemite系统把 JavaScript作为 AppleScript的另一选择。Automation 是 OS X 10.10版本中的新特性，苹果在官网发布JavaScript for Automation Release Notes有篇文章介绍了用JavaScript写自动化Automation脚本。 JavaScript凭借其简单的语法，良好的性能，超轻量的框架，极小耦合的模块系统等等优势已经吸引了很多大厂的关注。 再加上JavaScript先天开放且无版权专利纠纷的问题，拥有非常广泛的开发者（开源）群体，苹果将其引入OS X平台代替私有的AppleScript，可能也有着一部分开放性平台的考虑，从而吸引广泛的第三方开发者。 资源 JavaScript OS X App Examples JavaScript for Automation Cookbook\nOSA框架:Open Scripting Architecture OSA组件用于实现MacAPP自动化操作。这些框架组件使用场景包括：Script Editor编辑器，全系统的Script菜单， Run JavaScript Automator命令的操作，applets小程序，命令行osascript工具，NSUserScriptTask API中，还可以运用在其他的OSA组件中例如：AppleScript。这也就包括了Mail规则、Folder操作、Address Book插件、日历闹钟和消息触发器。\n脚本字典 脚本字典详细介绍APP的对象模型。在脚本字典映射到有效的JavaScript标识符遵循一套规范的术语。在Script Editor脚本字典浏览器已经更新到显示术语AppleScript，JavaScript和Objective-C（Scripting Bridge framework）格式。\n打开脚本字典 启动Script Editor (/Applications/Utilities/) \u0026ndash;\u0026gt; File \u0026gt; Open Dictionary or Window \u0026gt; Library。\nobject specifier 在JavaScript自动化主机环境中的大部分对象指的是外部实例，如：其他APP，window或在这些APP的相关数据。当访问一个APP对象或APP中的某个元素的JavaScript属性时，会返回一个新的object specifier，也就是这个对象的specifier 属性。\nobject specifier不是外部实例属性的实际值，是这个对象的引用指针。如果要获取这个属性的实际值，使用get／set方法。\n访问APP 六种方式: {% codeblock By name lang:js %} Application(\u0026lsquo;Mail\u0026rsquo;) {% endcodeblock %}\n{% codeblock By bundle ID lang:js %} Application(\u0026lsquo;com.apple.mail\u0026rsquo;) {% endcodeblock %}\n{% codeblock By path lang:js %} Application(\u0026rsquo;/Applications/Mail.app\u0026rsquo;) {% endcodeblock %}\n{% codeblock By process ID lang:js %} Application(763) {% endcodeblock %}\n{% codeblock On a remote machine lang:js %} Application(\u0026rsquo;eppc://127.0.0.1/Mail\u0026rsquo;) {% endcodeblock %}\n{% codeblock currentApplication lang:js %} Application.currentApplication() {% endcodeblock %}\n语法示例 {% codeblock Access properties lang:js %} Mail.name {% endcodeblock %}\n{% codeblock Access elements lang:js %} Mail.outgoingMessages[0] {% endcodeblock %}\n{% codeblock Call commands lang:js %} Mail.open(\u0026hellip;) {% endcodeblock %}\n{% codeblock Create new objects lang:js %} Mail.OutgoingMessage(\u0026hellip;) {% endcodeblock %}\n属性的get/set方法 点运算符访问脚本对象，是JavaScript语法特性之一。 如上所述，返回的对象是一个object specifier是一个对象的引用，而不是属性实际值。 当访问属性时，会作为一个get函数，返回实际值： {% codeblock lang:js %} subject = Mail.inbox.messages[0].subject() {% endcodeblock %} 当赋值属性时，会作为一个set函数，把参数赋值该属性： {% codeblock lang:js %} Mail.outgoingMessages[0].subject = \u0026lsquo;Hello world\u0026rsquo; {% endcodeblock %} 获取数组中的每个元素属性（在这种情况下，得到邮件收件箱中的每份邮件的标题） {% codeblock lang:js %} subjects = Mail.inbox.messages.subject() {% endcodeblock %}\n元素数组 通过在数组中调用特定元素检索方法，或使用方括号并指定要检索的元素的名称或索引来访问数组中的元素。返回值是对象相关，与自己的属性和元素，引用数组元素。他们可以访问 {% codeblock 索引 lang:js %} window = Mail.windows.at(0) window = Mail.windows[0] {% endcodeblock %} {% codeblock name lang:js %} window = Mail.windows.byName(\u0026lsquo;New Message\u0026rsquo;) window = Mail.windows[\u0026lsquo;New Message\u0026rsquo;] {% endcodeblock %} {% codeblock ID lang:js %} window = Mail.windows.byId(412) {% endcodeblock %}\nNote: 使用ID来访问不是方括号[]而是().\n调用命令 命令被称为函数。 2. 直接参数的函数，该参数作为命令的第一个参数传递。 3. 如果函数需要带参数名的参数，那么这个参数可以接受一个键值对对象。 3. 如果函数需要一个直接参数，就需要传递一个带参数名的参数作为第二个参数。 4. 如果函数不存在直接参数，那么带参数名的参数作为第一个参数传递，并且唯一参数。 5. 直接参数是可选的，可以不用传递任何值，当第一个参数存在参数名时，则传递NULL作为第一个参数。 {% codeblock 无参数命令 lang:js %} message.open() {% endcodeblock %}\n{% codeblock 无参数名的命令 lang:js %} Mail.open(message) {% endcodeblock %}\n{% codeblock 带参数名的命令 lang:js %} response = message.reply({ replayAll: true, openingWindow: false }) {% endcodeblock %}\n{% codeblock Command with direct parameter and named parameters lang:js %} Safari.doJavaScript(\u0026lsquo;alert(\u0026ldquo;Hello world\u0026rdquo;)\u0026rsquo;, { in: Safari.windows[0].tabs[0] }) {% endcodeblock %}\nCreating Objects 通过调用类构造函数初始化属性和数据来创建新对象。 在创建对象时,需要执行的其中步骤：\nmake()方法：调用对象上的make()方法来实例化对象。 push()方法：调用对象数组上的push方法来实例化对象。 在调用这些方法中的一个之前，对象实际上并不存在于应用程序中。 Create a new object. {% codeblock lang:js %} message = Mail.OutgoingMessage().make() {% endcodeblock %}\nCreate a new object with properties. {% codeblock lang:js %} message = Mail.OutgoingMessage({ subject: \u0026lsquo;Hello world\u0026rsquo;, visible: true }) Mail.outgoingMessages.push(message) {% endcodeblock %}\nCreate a new object with data. {% codeblock lang:js %} para = TextEdit.Paragraph({}, \u0026lsquo;Some text\u0026rsquo;) TextEdit.documents[0].paragraphs.push(para) {% endcodeblock %}\n使用对象 一旦你在应用程序中创建一个新的对象（通过调用make或push），可以像任何现有的应用程序对象一样进行交互。 {% codeblock lang:js %} message = Mail.OutgoingMessage().make() message.subject = \u0026lsquo;Hello world\u0026rsquo; {% endcodeblock %}\nScripting Additions 使用脚本添加（脚本插件）来增强应用程序的功能。操作系统有一套标准的脚本添加提供speak text,展示用户交互对话，等。 使用这些，必须明确设置includeStandardAdditions的flag为 true。 {% codeblock lang:js %} app = Application.currentApplication() app.includeStandardAdditions = true app.say(\u0026lsquo;Hello world\u0026rsquo;) app.displayDialog(\u0026lsquo;Please enter your email address\u0026rsquo;, { withTitle: \u0026lsquo;Email\u0026rsquo;, defaultAnswer: \u0026lsquo;your_email@site.com\u0026rsquo; }) {% endcodeblock %}\nApplets 在Script Editor编写脚本并保存为一个应用程序，且可以被双击独立运行的程序称为Applet。 程序支持以下事件处理： 当Applet运行时，run处理事件被调用： {% codeblock lang:js %} function run() {\u0026hellip;} {% endcodeblock %}\n用于拖放操作的openDocuments处理事件程序包配置小程序，当文档被拖放到该小程序上时，这个处理操作将被执行： {% codeblock lang:js %} function openDocuments(docs) {\u0026hellip;} {% endcodeblock %} 传递的参数是一个文件路径字符串数组。 更多样例\nUI Automation 通过编写系统事件应用程序，可以自动化应用程序的用户界面。在脚本编辑器Script Editor中浏览System Events的脚本字典，特别是进程套件Processes Suite，以查看支持此类型自动化的应用程序接口元素的列表。 下面的示例使用UI脚本创建Notes中的新注释。 {% codeblock lang:js %} Notes = Application(\u0026lsquo;Notes\u0026rsquo;) Notes.activate()\ndelay(1) SystemEvents = Application(\u0026lsquo;System Events\u0026rsquo;) Notes = SystemEvents.processes[\u0026lsquo;Notes\u0026rsquo;]\nNotes.windows[0].splitterGroups[0].groups[1].groups[0].buttons[0].click() {% endcodeblock %}\n","date":"2017-02-15T17:19:30Z","permalink":"https://it-boyer.github.io/post/old/macOS/macOS%E6%94%AF%E6%8C%81JavaScript%E8%87%AA%E5%8A%A8%E5%8C%96%E7%BB%84%E4%BB%B6%E5%9F%BA%E7%A1%80/","section":"post","tags":["JS"],"title":"macOS支持JavaScript自动化组件基础"},{"categories":["解决方案"],"contents":"如何使用脚本字典里的命令和对象来与其他的应用进行通讯? 这个教程将向您展示现在使用 AppleScript 来控制别的应用的最佳方式。我也会告诉您一些小技巧以帮助您和您的用户用最小的努力就架设起 AppleScript。\n在自己的APP中编写 编写AppleScript代码 AppleScript 脚本指南 与其他应用进行通讯的脚本一般来说都很短，也容易理解。AppleScript 可以被想做一种传送的机制，而不是一种处理环境。 典型脚本: {% codeblock lang:js %} on chockify(inputString) set resultString to \u0026quot;\u0026quot;\nrepeat with inputStringCharacter in inputString set asciiValue to (ASCII number inputStringCharacter) if (asciiValue \u0026gt; 96 and asciiValue \u0026lt; 123) then set resultString to resultString \u0026amp; (ASCII character (asciiValue - 32)) else if ((asciiValue \u0026gt; 64 and asciiValue \u0026lt; 91) or (asciiValue = 32)) then set resultString to resultString \u0026amp; inputStringCharacter else if (asciiValue \u0026gt; 47 and asciiValue \u0026lt; 58) then set numberStrings to {\u0026quot;ZERO\u0026quot;, \u0026quot;ONE\u0026quot;, \u0026quot;TWO\u0026quot;, \u0026quot;THREE\u0026quot;, \u0026quot;FOR\u0026quot;, \u0026quot;FIVE\u0026quot;, \u0026quot;SIX\u0026quot;, \u0026quot;SEVEN\u0026quot;, \u0026quot;EIGHT\u0026quot;, \u0026quot;NINE\u0026quot;} set itemIndex to asciiValue - 47 set numberString to item itemIndex of numberStrings set resultString to resultString \u0026amp; numberString \u0026amp; \u0026quot; \u0026quot; else if (asciiValue = 33) then set resultString to resultString \u0026amp; \u0026quot; DUH\u0026quot; else if (asciiValue = 63) then set resultString to resultString \u0026amp; \u0026quot; IF YOU KNOW WHAT I MEAN\u0026quot; end if end if end if end if end if end repeat resultString end chockify {% endcodeblock %}\n创建事件描述符 (event descriptor) 导入Carbon.h 它有关于所有的 AppleEvent 的定义。 {% codeblock lang:objc %} #import \u0026lt;Carbon/Carbon.h\u0026gt; // for AppleScript definitions {% endcodeblock %} OC中创建chockify事件描述符 这是可以在你的脚本和应用之间互相传递的一个数据块。可以把它理解成一个封装好的会去执行某个事件的目标，一个将被调用的函数，以及这个函数的参数。使用一个 NSString 作为参数，创建chockify事件描述符： {% codeblock lang:objc %} (NSAppleEventDescriptor *)chockifyEventDescriptorWithString:(NSString *)inputString { // parameter NSAppleEventDescriptor *parameter = [NSAppleEventDescriptor descriptorWithString:inputString]; NSAppleEventDescriptor *parameters = [NSAppleEventDescriptor listDescriptor]; [parameters insertDescriptor:parameter atIndex:1]; // you have to love a language with indices that start at 1 instead of 0\n// target ProcessSerialNumber psn = {0, kCurrentProcess}; NSAppleEventDescriptor *target = [NSAppleEventDescriptor descriptorWithDescriptorType:typeProcessSerialNumber bytes:\u0026amp;psn length:sizeof(ProcessSerialNumber)];\n// function NSAppleEventDescriptor *function = [NSAppleEventDescriptor descriptorWithString:@\u0026ldquo;chockify\u0026rdquo;];\n// event NSAppleEventDescriptor *event = [NSAppleEventDescriptor appleEventWithEventClass:kASAppleScriptSuite eventID:kASSubroutineEvent targetDescriptor:target returnID:kAutoGenerateReturnID transactionID:kAnyTransactionID]; [event setParamDescriptor:function forKeyword:keyASSubroutineName]; [event setParamDescriptor:parameters forKeyword:keyDirectObject];\nreturn event; } {% endcodeblock %}\nOC中加载 AppleScript 通过应用包(Application bundle)的一个 URL 可以创建 NSAppleScript的实例。而反过来，脚本也要和上面创建的 chockify 事件描述符一起使用。 {% codeblock lang:objc %} NSURL *URL = [[NSBundle mainBundle] URLForResource:@\u0026ldquo;Automation\u0026rdquo; withExtension:@\u0026ldquo;scpt\u0026rdquo;]; if (URL) { NSAppleScript *appleScript = [[NSAppleScript alloc] initWithContentsOfURL:URL error:NULL];\nNSAppleEventDescriptor *event = [self chockifyEventDescriptorWithString:[self.chockifyInputTextField stringValue]]; NSDictionary *error = nil; NSAppleEventDescriptor *resultEventDescriptor = [appleScript executeAppleEvent:event error:\u0026amp;error]; if (! resultEventDescriptor) { NSLog(@\u0026quot;%s AppleScript run error = %@\u0026quot;, __PRETTY_FUNCTION__, error); } else { NSString *string = [self stringForResultEventDescriptor:resultEventDescriptor]; [self updateChockifyTextFieldWithString:string]; } } {% endcodeblock %} 如果一切正常的话，你会得到另一个事件描述符。如果出错了，你会得到一个包含了描述错误信息的字典。虽说这个模式和很多其他 Foundation 类很相似，但是返回的错误并不是一个 NSError 的实例。\n调用事件描述符 {% codeblock lang:objc %}\n(NSString *)stringForResultEventDescriptor:(NSAppleEventDescriptor *)resultEventDescriptor { NSString *result = nil; if (resultEventDescriptor) { if ([resultEventDescriptor descriptorType] != kAENullEvent) { if ([resultEventDescriptor descriptorType] == kTXNUnicodeTextData) { result = [resultEventDescriptor stringValue]; } } } return result; } {% endcodeblock %} InputString 输入可以被正确整形输出，并且你现在也看到想在你的应用里运行 AppleScripts 的方法 调用沙盒中脚本代码与访问其他应用 了解APP沙盒限制 如果一段脚本可以轻易地拿到浏览器当前页面上的内容，甚至是在任意标签和窗口运行JavaScript。想象一下如果这些页面里有你的银行账号，或者包含你的信用卡信息什么的。\n对于沙盒应用，Apple 所提倡的是通过用户的需要来驱动安全策略。这意味着是否运行你的脚本完全取决于用户。这些脚本可能是来自互联网，也可能是你应用的一部分。一旦得到了权限，脚本就可以以一种受限的方式与系统其他部分进行交互了。NSUserScriptTask使这一切变得可能。 由此：Apple 引入了一个新的抽象类 NSUserScriptTask,有三个具体的子类实现:\nNSUserUnixTask: 执行 Unix shell 命令 NSUserAutomatorTask: Automator 工作流 NSUserAppleScriptTask:执行AppleScript脚本,脚本是异步执行的,所以脚本不能对用户界面做更新操作。 开始安装运行脚本 怎么向用户请求运行脚本的许可，让你的应用与用户的其他应用更好地工作在一起？ 两种策略:\n帮助用户来存放运行脚本的位置 获取行脚本目录可读写 帮用户存放运行脚本的位置 只能把把这些脚本放到用户的脚本文件夹(User \u0026gt; Library \u0026gt; Application Scripts/bundle identifier/)中，以只读的方式来运行你的脚本。 脚本想要进入这个特定的文件夹的唯一方式就是用用户把它们复制到那里。再者Library 文件夹在 OS X 里默认还是隐藏的。这样对用户都很不友好。 让代码来帮助用户打开这个隐藏文件夹： {% codeblock lang:objc %} NSError *error; NSURL *directoryURL = [[NSFileManager defaultManager] URLForDirectory:NSApplicationScriptsDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:\u0026amp;error]; [[NSWorkspace sharedWorkspace] openURL:directoryURL]; {% endcodeblock %} 通过你的应用的某个控件打开这个文件夹，然后进行编辑。这对于用户自己写的脚本来说是个很好的解决方案。\n设置运行脚本目录的读写权限 在 Xcode 里，你需要更新 Capabilities，让其包括 User Selected File to Read/Write。在 App Sandbox \u0026gt; File Access 里找到相关选项。 用户的意愿是关键，因为你需要获取权限以将脚本添加到文件夹： {% codeblock lang:objc %} NSError *error; NSURL *directoryURL = [[NSFileManager defaultManager] URLForDirectory:NSApplicationScriptsDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:\u0026amp;error]; NSOpenPanel *openPanel = [NSOpenPanel openPanel]; [openPanel setDirectoryURL:directoryURL]; [openPanel setCanChooseDirectories:YES]; [openPanel setCanChooseFiles:NO]; [openPanel setPrompt:@\u0026ldquo;Select Script Folder\u0026rdquo;]; [openPanel setMessage:@\u0026ldquo;Please select the User \u0026gt; Library \u0026gt; Application Scripts \u0026gt; com.iconfactory.Scriptinator folder\u0026rdquo;]; [openPanel beginWithCompletionHandler:^(NSInteger result) { if (result == NSFileHandlingPanelOKButton) { NSURL *selectedURL = [openPanel URL]; if ([selectedURL isEqual:directoryURL]) { NSURL *destinationURL = [selectedURL URLByAppendingPathComponent:@\u0026ldquo;Automation.scpt\u0026rdquo;]; NSFileManager *fileManager = [NSFileManager defaultManager]; NSURL *sourceURL = [[NSBundle mainBundle] URLForResource:@\u0026ldquo;Automation\u0026rdquo; withExtension:@\u0026ldquo;scpt\u0026rdquo;]; NSError *error; BOOL success = [fileManager copyItemAtURL:sourceURL toURL:destinationURL error:\u0026amp;error]; if (success) { NSAlert *alert = [NSAlert alertWithMessageText:@\u0026ldquo;Script Installed\u0026rdquo; defaultButton:@\u0026ldquo;OK\u0026rdquo; alternateButton:nil otherButton:nil informativeTextWithFormat:@\u0026ldquo;The Automation script was installed succcessfully.\u0026rdquo;]; [alert runModal]; } else { NSLog(@\u0026quot;%s error = %@\u0026quot;, PRETTY_FUNCTION, error); if ([error code] == NSFileWriteFileExistsError) { // this is where you could update the script, by removing the old one and copying in a new one } else { // the item couldn\u0026rsquo;t be copied, try again [self performSelector:@selector(installAutomationScript:) withObject:self afterDelay:0.0]; } } } else { // try again because the user changed the folder path [self performSelector:@selector(installAutomationScript:) withObject:self afterDelay:0.0]; } } }]; {% endcodeblock %} 这么一来，应用包中的 Automation.scpt 文件现在暴露在常规的文件系统中了。\n执行脚本任务 使用 NSUserAppleScriptTask 来替代 NSAppleScript，来运行上面创建的事件描述符。 你大概会经常用到这些脚本任务。文档警告说对于给定的类的某个实例， NSUserAppleScriptTask 不应该被执行多次。所以写一个工厂函数来在需要的时候创建任务： {% codeblock 工厂函数 lang:objc %}\n(NSUserAppleScriptTask *)automationScriptTask { NSUserAppleScriptTask *result = nil; NSError *error; NSURL *directoryURL = [[NSFileManager defaultManager] URLForDirectory:NSApplicationScriptsDirectory inDomain:NSUserDomainMask appropriateForURL:nil create:YES error:\u0026amp;error]; if (directoryURL) { NSURL *scriptURL = [directoryURL URLByAppendingPathComponent:@\u0026ldquo;Automation.scpt\u0026rdquo;]; result = [[NSUserAppleScriptTask alloc] initWithURL:scriptURL error:\u0026amp;error]; if (! result) { NSLog(@\u0026quot;%s no AppleScript task error = %@\u0026quot;, PRETTY_FUNCTION, error); } } else { // NOTE: if you\u0026rsquo;re not running in a sandbox, the directory URL will always be nil NSLog(@\u0026quot;%s no Application Scripts folder error = %@\u0026quot;, PRETTY_FUNCTION, error); } return result; } {% endcodeblock %} 如果你正在写一个同时适用于沙盒和非沙盒的 Mac 应用的话，在获取 directoryURL 时你需要特别小心。NSApplicationScriptsDirectory只在沙盒中有效。\n在创建脚本任务后，你需要使用 AppleEvent 并提供一个结束处理来执行它： {% codeblock AppleEvent lang:objc %} NSUserAppleScriptTask *automationScriptTask = [self automationScriptTask]; if (automationScriptTask) { NSAppleEventDescriptor *event = [self safariURLEventDescriptor]; [automationScriptTask executeWithAppleEvent:event completionHandler:^(NSAppleEventDescriptor *resultEventDescriptor, NSError *error) { if (! resultEventDescriptor) { NSLog(@\u0026quot;%s AppleScript task error = %@\u0026quot;, PRETTY_FUNCTION, error); } else { NSURL *URL = [self URLForResultEventDescriptor:resultEventDescriptor]; // NOTE: The completion handler for the script is not run on the main thread. Before you update any UI, you\u0026rsquo;ll need to get // on that thread by using libdispatch or performing a selector. [self performSelectorOnMainThread:@selector(updateURLTextFieldWithURL:) withObject:URL waitUntilDone:NO]; } }]; } {% endcodeblock %} 对于用户写的脚本，用户可能期望你的应用只是简单地\u0026rsquo;运行\u0026rsquo;脚本 (而不去调用事件描述符中指定的函数)。在这种情况下，你可以为 event 传递一个 nil，脚本就会像用户在 Finder 中双击那样的行为进行执行。 NSUserAppleScriptTask脚本是异步执行的，所以你的用户界面并不会被一个 (比较长) 的脚本锁住，在结束后会执行回调处理。\n同步操作 NSAppleScript 和 NSUserAppleScriptTask 有一个微妙的区别：新的机制是异步执行的。对于大部分情况，使用一个结束回调来处理会是一个好得多的方式，因为这样就不会因为执行脚本而阻碍你的应用。 然而有时候如果你想带有依赖地来执行任务的时候，事情就变得有些取巧了。比方说一个任务需要在另一个任务开始之前必须完成。这种情况下你就会想念 NSAppleScript 的同步特性了。 要获得传统方式的行为，一种简单的方法是使用一个信号量(semaphore) 来确保同时只有一个任务运行、在你的类或者应用的初始化方法中，使用 libdispatch 创建一个信号量： {% codeblock lang:objc %} self.appleScriptTaskSemaphore = dispatch_semaphore_create(1); {% endcodeblock %} 接下来在初始化脚本任务之前，简单地等待信号量。当任务完成时，标记相同的这个信号量： {% codeblock lang:objc %} // wait for any previous tasks to complete before starting a new one — remember that you\u0026rsquo;re blocking the main thread here! dispatch_semaphore_wait(self.appleScriptTaskSemaphore, DISPATCH_TIME_FOREVER);\n// run the script task NSAppleEventDescriptor *event = [self openNetworkPreferencesEventDescriptor]; [automationScriptTask executeWithAppleEvent:event completionHandler:^(NSAppleEventDescriptor *resultEventDescriptor, NSError *error) { if (! resultEventDescriptor) { NSLog(@\u0026quot;%s AppleScript task error = %@\u0026quot;, PRETTY_FUNCTION, error); } else { [self performSelectorOnMainThread:@selector(showNetworkAlert) withObject:nil waitUntilDone:NO]; } // the task has completed, so let any pending tasks proceed dispatch_semaphore_signal(self.appleScriptTaskSemaphore); }]; {% endcodeblock %} 再强调一下，除非确实有所需要，否则最好别这么做。\n","date":"2017-02-14T18:25:29Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E9%80%9A%E8%BF%87%E6%B2%99%E7%9B%92%E4%B8%ADJS%E8%84%9A%E6%9C%AC%E8%AE%BF%E9%97%AE%E5%85%B6%E4%BB%96APP/","section":"post","tags":["JS"],"title":"通过沙盒中JS脚本访问其他APP"},{"categories":["学习笔记"],"contents":"一个PDF的基本构建块是Documents本身。Documents通常作为文件存储在磁盘上。 作为文件版本，可以支持元数据标记如作者，创建日期，等等。 一个文件可以加密，需要密码才能查看它。两级加密存在：\n用户级加密：如果用户成功地获得用户级权限，他或她可以查看文档，但可以限制打印或复制文档。 所有者级别加密：获得所有者级别权限的用户可以查看文档并具有完全使用权限。 许多加密的PDF文件有一个“dummy”的用户密码为空字符串。大多数PDF文档解析器（包括PDF套件）自动尝试空字符串密码加密后的文件，如果成功，只显示文档。因此，在技术上加密的文档不一定提示用户口令。 PDF页面 一个PDF文档由若干页面组成。这个页面看起来就像一本物理书页面显示在屏幕上。同时PDF页面可以包含超链接和注释。页面可以支持裁剪，还有其他使用功能：例如隐藏多余的部分（如注册标记）。\nview VS page空间坐标 页面上的大多数对象都是在page空间中指定的，而不是在view空间中。 也就是说，坐标系统是在点（每英寸72点），坐标原点在page左侧底部，而不是view。page空间不关心缩放，显示模式等等。一个有bounds的item，比如说32points，保留这些界限，无论显示大小。 图view和page坐标系比较\nPDFView class包含几个转换方法，将坐标系统从view space的page space，反之亦然。\nPDF Kit Classes PDF Kit套件提供了几个不同功能的类。 PDFView和PDFSelection除外，这些类大致对应着各个对象在PDF格式的规范需求。\nPDFView Class PDFView类，就好比Web工具包的WebView类，源于Application Kit中的NSView类。在项目开发中，你可以使用Interface Builder轻松拖动一个PDFView对象放在一个window中。从/Developer/Extras/Palettes/PDFKit.palette得到调色板。 PDFView可能是PDF Kit中唯一个需要你自定义的的类。在APP中显示PDF数据，允许用户选择文档内容和导航浏览PDF文档，设置缩放级别，复制文本内容到剪贴板。用户可以拖放PDF文档到PDFView。 PDFView能通过调用其他PDF实用类来实现其大部分功能。如果要添加特殊功能，则需要用户自定义实用类的子类来扩展其特殊功能。 Utility classes as used by PDFView\nPDF Kit Utility Classes PDF套件工具类提供一种混合的Foundation-like和Application Kit-like的行为。他们有类似的NSString类和NSString Additions方法。这些类都系橙自NSObject\nPDF Document PDFDocument是PDF kit工具类中重要类，代表着PDF data或PDF文件。其他实用工具类一般都在PDFDocument方法中的实例化。是PDFPage和PDFOutline；或相关支持操作：PDFSelection和PDFDestination。 你PDFDocument对象初始化，需要一个PDF数据或一个指向PDF文件的URL。实例化之后就可以访问页数，添加或删除页面，对所选内容为NSString对象进行查找或分析。\nPDFPage PDFPage代表一个PDF文档的页面。你的应用程序获取一个PDFPage对象必须通过从PDFDocument对象来实例化。PDFPage对象是用户所看到的屏幕，和一个view可以同时显示多个page。你可以使用PDFPage把PDF文档内容渲染到屏幕上，添加注释，计数字符串，定义选择，获取一个page中的文本内容作为NSString对象或NSAttributedString对象。\nPDFOutline 除了显示实际的文件内容，PDF Kit也能呈现PDFOutline信息，前提是PDF文档中存在目录结构。在目录结构中，一个PDFOutline对象代表一个父目录或子目录。 目录是由一个层次的PDFOutline对象组层。顶层是根目录对象，它仅作为其他目录对象的容器。用户的根目录是不可见的。\nPDFSelection 一个PDFSelection对象包含一个跨PDF文档中文本。你不要直接创建PDFSelection。PDFSelection对象是作为返回值来实例化的。例如：通过调用PDFPage或PDFDocument对象中的selection方法，并从成功搜索的返回值来实例化PDFSelection对象。 在同时显示多个PDFPage的PDFView中，PDFSelection可以是不连续的，或两者兼具的。例如，可以选择在一个单柱连续两列页面的文本。可以在任何方向从一个选择区, 合并选择区, 或扩展选择区中得到文本和网页覆盖。\nPDFAnnotation 一个PDFAnnotation对象可以表示多种内容以外，在一个PDF文件的主要文本内容：链接、表单元素，突出圈子，等等。每个注释与页面上的特定位置相关，并且可以与用户提供交互性。 PDFAnnotation是如图所示的具体类的抽象类。各种具体类代表PDF Kit支持的注释类型。\nPDFBorder PDFBorder对象封装的拉伸PDFAnnotation对象边框的行为。可以定义一个PDF的bord线的风格属性（例如，固体，破灭，或斜面），bord线的宽度，和圆角半径。\n过期:从/Developer/Extras/Palettes/PDFKit.palette得到调色板。 Here\u0026rsquo;s what Apple says about it: {% blockquote 老文档 http://developer.apple.com/library/mac/#documentation/GraphicsImaging/Conceptual/PDFKitGuide/PDFKit_Prog_Tasks/PDFKit_Prog_Tasks.html PDFKit_Prog_Tasks %} \u0026ldquo;To add the PDFKit palette in Interface Builder, select the Palettes tab in the Preferences panel. Click the Add button, navigate to the /Developer/Extras/Palettes folder, and select the PDFKit palette. Next, select the Customize Toolbar menu item in the Tools/Palettes menu and drag the PDFKit palette to the toolbar to make it visible.\u0026rdquo; {% endblockquote %} So: there\u0026rsquo;s no Palettes tab anywhere in the Preferences panel and the Xcode Help return a blank when searching for it. There\u0026rsquo;s no PDFKit.palette file anywhere on my HD (says Spotlight). I guess these instructions are for an older version of XCode but it\u0026rsquo;s all Apple seemed to have on it\u0026hellip;\n","date":"2017-02-14T14:29:18Z","permalink":"https://it-boyer.github.io/post/old/macOS/macOS%E4%B9%8BPDFKit%E5%9F%BA%E7%A1%80/","section":"post","tags":["PDF"],"title":"macOS之PDFKit基础"},{"categories":["解决方案"],"contents":"Fabric Fabric 是Twitter的移动应用开发平台，一个模块化、跨平台的移动开发套件，该博文主要研究crashlytics在app中的运用。 注册新的账户登录，审核通过时间为几个小时或者1到2天不等。然后注册时候输入的邮箱就会收到如下的邀请涵 浏览官方文档\ncrashlytics支持macOS 对macOS的支持中出现的问题 问题：NSApplicationCrashOnExceptions is not set. This will result in poor top-level uncaught exception reporting 官方解释： {% blockquote 官方文档 https://docs.fabric.io/apple/crashlytics/os-x.html#macos-support macOS Support %} Uncaught Exceptions Intercepting and reporting uncaught exceptions on macOS is more complex than it is on iOS. On macOS, AppKit will catch exceptions thrown on the main thread, preventing the application from crashing, but also preventing Crashlytics from reporting them. To make matters worse, Apple’s frameworks are not exception safe. This means that while AppKit will prevent your app from crashing, it will also likely corrupt your process’s state, often including AppKit itself. Typically, once an exception involving UI interaction is thrown, it will prevent your app from working correctly from that moment on. Thankfully, AppKit has a little-known feature you can turn on to make the behavior much more predictable. We strongly recommend that you do the following in your application, right before you initialize Crashlytics. {% codeblock lang:objc %} [[NSUserDefaults standardUserDefaults] registerDefaults:@{ @\u0026ldquo;NSApplicationCrashOnExceptions\u0026rdquo;: @YES }]; {% endcodeblock %}\nThis will make your application’s behavior much closer to iOS. It will mean that your app will crash on uncaught exceptions, and will also allow Crashlytics to report them with useful stack traces. It will also give you the ability to override this behavior with the user defaults system, even on per-user basis. Of course, this is all optional. Crashlytics will warn about NSApplicationCrashOnExceptions not being set, but will otherwise preserve normal AppKit behavior by default. {% endblockquote %} 拦截和报告未捕获的异常在MacOS比iOS更复杂。在MacOS，AppKit会抓住扔在主线程异常，防止应用程序崩溃，也防止crashlytics报告他们。更糟糕的是，Apple’s frameworks也不例外。这意味着AppKit可以防止你的应用程序崩溃，也可能破坏你的进程的状态，包括AppKit本身。通常情况下，一旦涉及到用户界面交互的异常被抛出，它将阻止您的应用程序从正确的工作从那一刻起。 以上情况，可以通过设置：NSApplicationCrashOnExceptions 改变系统默认的值，达到像iOS端一样抓去异常。如果没有设置会提示：NSApplicationCrashOnExceptions not set\nCause a Test Crash教程 崩溃日志是在重启APP程序的同时进行的，要确保程序在前台全屏显示。 Xcode调试器会阻止我们捕捉崩溃报告，所以在抓取崩溃报告时，要保证在非调试状态下进行。如果你的移动设备连接到Mac机上，Xcode仍然可以进入调试状态。\nrun在模拟器上安装运行APP 点击Stop断开Xcode和模拟器，确保在非调试状态 在模拟器上启动APP，并执行崩溃操作 在Xcode上点击run 在Xcode的控制台console中输出显示奔溃报告，以及上传日志的相关提示。 macOS系统中的日志目录： 运行日志目录：/private/var/log/system.log 奔溃日志目录：/Users/pyc/Library/Logs/DiagnosticReports/APPNAME_2016-11-10-165115.crash {% blockquote 官方文档 https://docs.fabric.io/apple/crashlytics/test-crash.html Cause a Test Crash教程 %} It’s possible, but rare, that we are missing a dSYM to symbolicate any crash reports. There will be an alert on your dashboard if this is the case. Click through to upload the missing dSYM. Keep in mind that exceptions are not guaranteed to crash. The full code path, including code in system libraries, matters here. If you aren’t seeing the dSYM alert, you can go to your app’s settings page, and append “/mappings” to the URL to reach it, e.g. https://fabric.io/settings/apps/some_app_id/mappings {% endblockquote %}\n","date":"2017-02-14T11:14:35Z","permalink":"https://it-boyer.github.io/post/old/macOS/Fabric%E5%AF%B9macOS%E7%B3%BB%E7%BB%9F%E7%9A%84%E6%94%AF%E6%8C%81%E8%B0%83%E7%A0%94/","section":"post","tags":["SDK"],"title":"Fabric对macOS系统的支持"},{"categories":["学习笔记"],"contents":"阅读书籍 5种图表解决工作中的12大难题 你的第一本思维导图操作书 5分钟手绘彩色圆珠笔涂鸦集 如果阅读一本书 使用思维导图的场景无处不在，无论是做产品还是做设计，我们都需要清晰的思路，明确自己需要做些什么，最后需要达到什么效果，这时候，如果有一张清晰的思维导图，就能很快的理清自己的思路。作为互联网公司自称是产品型设计师（也就是既需要帮助老板整理需求梳理产品，也要设计漂亮的界面）的我更是如此。\n目的：通过学习在该文章中讲到的开发设计案例，站在项目开发角度，了解从速记到思维导图再到实际开发的过程。 从产品、设计等方面谈谈我是如何运用思维导图的。\n需求分析——完善最初的想法 一般老板只会告诉我们大概需要一个什么东西，具体的细节还需要我们去整理。这时候，我会把大概涉及到的基本点写在纸上，想到一条写一条，特别是一些需要注意的地方。\n需求速记法 先用纸笔速记的方式，把临时能想到的点记录下来 在纸上列得差不多了，再新建一个 XMind 文档，把之前列的一些点一一转到电脑上，然后整理分类。\n功能结构图案例 码市逻辑图 通过思维导图能够一目了然的看到码市的功能 网站功能逻辑图 通过功能主干图直观显示了一个网站或者 APP 整体大功能组成部分，一般在写产品需求文档时需要的功能逻辑图。 产品设计——通过画原型来完善功能结构 梳理功能结构和画原型是产品设计中相互迭代的过程，在画原型时会具体到每个元素的交互过程，一旦发现功能结构导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。\n悬赏功能结构图 为产品原型图考虑，在梳理整理产品功能结构图时，尽可能包括页面上所有需要展示的内容以及基本的交互流程等。 下面这个图是码市功能结构中的发布悬赏功能部分： 有了功能结构图，就可以一一对照来做原型了。\n原型图 正如前面所说：梳理功能结构和画原型是产品设计中相互迭代的过程，在画原型时会具体到每个元素的交互过程，一旦发现功能导图的不合理，就要及时调整思路，做到一边画原型一边更新功能结构。 然后得到下面的原型：\n写文章时用到的思维导图 原文 把想到的先列出来，慢慢整理调整，梳理出写作思路。 演变过程：\n其他 微信推出应用号的处境： ","date":"2017-02-13T17:11:26Z","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/%E6%80%9D%E7%BB%B4%E5%AF%BC%E5%9B%BE%E4%B9%8B%E5%BC%80%E5%8F%91%E5%AE%9E%E8%B7%B5%E7%AF%87/","section":"post","tags":["管理"],"title":"思维导图之开发实践篇"},{"categories":["学习笔记"],"contents":"将JSON数据序列化为代码实例 定义一个继承自 JSExport 子协议 PersonJSExports 定义一个遵守PersonJSExports协议的Person数据模 使用 JavaScript 把JSON转为类并实例化对象 都有一个完整的 JVM 在那儿了，谁还需要 NSJSONSerialization？ JSExport语言互通协议 JavaScript可以脱离prototype继承完全用JSON来定义对象，但是Objective-C编程不能脱离类和继承。所以JavaScriptCore就提供了JSExport作为两种语言的互通协议。 JSExport中没有预定义任何方法，但是所有继承JSExport的协议中定义的方法即协议方法，都可以在JSContext中被调用。\nJSExportAs 宏: 指定方法在JS中调用的名称 对于多参数的方法，JavaScriptCore的转换方式将Objective-C的方法每个部分都合并在一起，冒号后的字母变为大写并移除冒号。比如下边协议中的方法，在JavaScript调用就是：doFooWithBar(foo, bar); {% codeblock lang:objc %} @protocol MultiArgs (void)doFoo:(id)foo withBar:(id)bar; @end {% endcodeblock %} 如果希望方法在JavaScript中有一个比较短的名字，就需要用的JSExport.h中提供的宏： {% codeblock JSExport.h lang:objc %} JSExportAs(PropertyName, Selector) {% endcodeblock %} {% codeblock JSExportAs的官方宏定义 lang:objc xcdoc://?url=developer.apple.com/library/etc/redirect/xcode/ios/1151/documentation/JavaScriptCore/Reference/JSExport_Ref/index.html %} #define JSExportAs(PropertyName, Selector) @optional Selector JS_EXPORT_AS##PropertyName:(id)argument; @required Selector #endif {% endcodeblock %} 如 setX:Y:Z方法，我们可以给他重命名，让 JS 中通过 set3D(x,y,z) 来调用 {% codeblock 使用方法 lang:objc %} JSExportAs(set3D,\n(void)setX:(id)x Y:(id)y Z:(id)z ); //调用 set3D(x,y,z) {% endcodeblock %} 定义PersonJSExports协议和create协议方法（类方法） Person 类实现了 PersonJSExports 协议，该协议规定哪些属性可以在 JavaScript中可用。 在JavaScript语境中，不能像：var person = new Person()来初始化实例，可以在定义PersonJSExports协议方法时，添加一个协议方法来弥补这一点。见下例create...类方法： {% codeblock lang:swift %} // Custom protocol must be declared with @objc @objc protocol PersonJSExports : JSExport { //属性 var firstName: String { get set } var lastName: String { get set } var birthYear: NSNumber? { get set } //方法 func getFullName() -\u0026gt; String\n/// 在JavaScript中调用这个类方法 class func createWithFirstName(firstName: String, lastName: String) -\u0026gt; Person }\n定义Person模型 定义一个遵守PersonJSExports协议的Person数据模 // Custom class must inherit from NSObject @objc class Person : NSObject, PersonJSExports { // JS协议属性必须声明为dynamic dynamic var firstName: String dynamic var lastName: String dynamic var birthYear: NSNumber?\ninit(firstName: String, lastName: String) { self.firstName = firstName self.lastName = lastName } //JS协议类方法 class func createWithFirstName(firstName: String, lastName: String) -\u0026gt; Person { return Person(firstName: firstName, lastName: lastName) } //JS协议方法 func getFullName() -\u0026gt; String { return \u0026quot;\\(firstName) \\(lastName)\u0026quot; } } {% endcodeblock %}\nJSContext 配置 之前，我们可以用我们已经创建的 Person 类，我们需要将其导出到 JavaScript 环境。我们也将借此导入Mustache JS library，我们将应用模板到我们的 Person 对象。 {% codeblock lang:swift %} // export Person class，JS中以该Person标示符作为类名使用 context.setObject(Person.self, forKeyedSubscript: \u0026ldquo;Person\u0026rdquo;)\n// load Mustache.js if let mustacheJSString = String(contentsOfFile:\u0026hellip;, encoding:NSUTF8StringEncoding, error:nil) { context.evaluateScript(mustacheJSString) } {% endcodeblock %}\nJavaScript 数据和进程 下面就来看看我们简单的 JSON 例子，这段代码将创建新的 Person 实例。 数据： {% codeblock Persons.json lang:json %} [ { \u0026ldquo;first\u0026rdquo;: \u0026ldquo;Grace\u0026rdquo;, \u0026ldquo;last\u0026rdquo;: \u0026ldquo;Hopper\u0026rdquo;, \u0026ldquo;year\u0026rdquo;: 1906 }, { \u0026ldquo;first\u0026rdquo;: \u0026ldquo;Ada\u0026rdquo;, \u0026ldquo;last\u0026rdquo;: \u0026ldquo;Lovelace\u0026rdquo;, \u0026ldquo;year\u0026rdquo;: 1815 }, { \u0026ldquo;first\u0026rdquo;: \u0026ldquo;Margaret\u0026rdquo;, \u0026ldquo;last\u0026rdquo;: \u0026ldquo;Hamilton\u0026rdquo;, \u0026ldquo;year\u0026rdquo;: 1936 } ] {% endcodeblock %} 创建新的 Person 实例： {% codeblock loadPeople.js lang:js %} var loadPeopleFromJSON = function(jsonString) { var data = JSON.parse(jsonString); var people = []; for (i = 0; i \u0026lt; data.length; i++) { //在swift中的js协议方法：createWithFirstName:lastName: var person = Person.createWithFirstNameLastName(data[i].first, data[i].last); person.birthYear = data[i].year; //push:添加到数组中 people.push(person); } //返回该对象 return people; } {% endcodeblock %} JSContext加载装换loadPeople.js脚本 加载js脚本之后，loadPeopleFromJSON即可作为下标被context调用该方法: {% codeblock 加载loadPeople.js lang:swift %} // load loadPeople.js if let loadPeople = String(contentsOfFile:\u0026hellip;, encoding:NSUTF8StringEncoding, error:nil) { //加载js脚本之后，loadPeopleFromJSON即可作为下标被context调用该方法 context.evaluateScript(loadPeople) } {% endcodeblock %}\n注意：JavaScriptCore 转换的 Objective-C / Swift 方法名是 JavaScript 兼容的。由于 JavaScript 没有参数 名称，任何外部参数名称都会被转换为驼峰形式并且附加到函数名后。在这个例子中，Objective-C 的方法 createWithFirstName:lastName: 变成了在JavaScript中的 createWithFirstNameLastName()。\n使用Mustache 模板 渲染 Mustache 是一个很强大的 template 引擎，可以通过解析 json 来绑定并渲染占位符。如果你做过一些前端开发的话，会知道这是一种很常用的 HTML 绑定 Model 的做法，GRMustache.swift 是这个框架的 Swift 实现。 mustache模板引擎 Mustache 的 Swift 语言实现版本 mustache的特点就是很语法很简单，主要语法如下: 1. {{ name }} 打印变量，默认是escape过的，如果不要escape,用3个分隔符 {{{ name }}}，或者用 {{ \u0026amp;name }}，这个和分隔符无关 2. {{#person}}…{{/person}} 区块，4种方式 person 是真假值，决定是否输出 person 是list of array，会循环展开 for x in person:section.render(\u0026lsquo;xxx) person 是匿名函数/object, 区块包裹的html 会作为参数传递进去 person 是dict，直接打印 dict[key] 3. {{^person}}…{{/person}，反向区块 4. {{！name }} 注释 5. {{\u0026gt; box }} 载入子模块\n加载 JSON 数据，调用 JSContext 将数据解析成 Person 对象的数组，并用 Mustache 模板呈现每个 Person： {% codeblock lang:swift %} // 从文件Persons.json中加载json数据 if let peopleJSON = NSString(contentsOfFile:\u0026hellip;, encoding: NSUTF8StringEncoding, error: nil) { // 获取js中定义的loadPeopleFromJSON的方法 let load = context.objectForKeyedSubscript(\u0026ldquo;loadPeopleFromJSON\u0026rdquo;) // 通过调用load方法将JSON 数据解析成Person 对象的数组 if let people = load.callWithArguments([peopleJSON]).toArray() as? [Person] { // get rendering function and create template let mustacheRender = context.objectForKeyedSubscript(\u0026ldquo;Mustache\u0026rdquo;).objectForKeyedSubscript(\u0026ldquo;render\u0026rdquo;) let template = \u0026ldquo;{{getFullName}}, born {{birthYear}}\u0026rdquo;\n// loop through people and render Person object as string for person in people { println(mustacheRender.callWithArguments([template, person])) } } }\n// Output: // Grace Hopper, born 1906 // Ada Lovelace, born 1815 // Margaret Hamilton, born 1936 {% endcodeblock %} JavaScript 代码段可能是附带应用一起发布的基本的用户定义的插件。\n","date":"2017-02-12T14:41:35Z","permalink":"https://it-boyer.github.io/post/old/swift/%E4%BD%BF%E7%94%A8JavaScript%E6%8A%8AJSON%E6%95%B0%E6%8D%AE%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1/","section":"post","tags":["swift"],"title":"使用JavaScript把JSON数据定义对象"},{"categories":["解决方案"],"contents":"OS X Mavericks 和 iOS 7 引入了 JavaScriptCore 库，它把 WebKit 的 JavaScript 引擎用 Objective-C 封装，提供了简单，快速以及安全的方式接入世界上最流行的语言。不管你爱它还是恨它，JavaScript 的普遍存在使得程序员、工具以及融合到 OS X 和 iOS 里这样超快的虚拟机中资源的使用都大幅增长。\n如何从 JavaScript 环境中提取值以及如何调用其中定义的函数? 那么反向呢？怎样从 JavaScript 访问我们在 Objective-C 或 Swift 定义的对象和方法？ swift通过JSContext调用JavaScript 如何从JavaScript 环境中提取值以及如何调用其中定义的函数?\n全局实例JSContext：运行JavaScript代码的环境 全局实例JSContext作用就像在浏览器内运行的一个JavaScript脚本，JSContext 类似于 window。 通过JSContext实例运行JavaScript代码创建变量，做计算，定义方法： {% codeblock lang:swift %} let context = JSContext() //创建全局环境 context.evaluateScript(\u0026ldquo;var num = 5 + 5\u0026rdquo;) //计算 context.evaluateScript(\u0026ldquo;var names = [\u0026lsquo;Grace\u0026rsquo;, \u0026lsquo;Ada\u0026rsquo;, \u0026lsquo;Margaret\u0026rsquo;]\u0026rdquo;) //定义变量 context.evaluateScript(\u0026ldquo;var triple = function(value) { return value * 3 }\u0026rdquo;) //定义方法 let tripleNum: JSValue = context.evaluateScript(\u0026ldquo;triple(num)\u0026rdquo;)\n{% endcodeblock %}\n动态类型JSValue:包裹JSContext环境下每一个可能的JS值 JavaScript 是动态语言，所以动态类型JSValue包裹JSContext环境中任何可能的JS值，字符串和数字；数组、对象和方法；甚至错误和特殊的 JavaScript 值诸如 null 和 undefined。 获取tripleNum值： {% codeblock lang:swift %} println(\u0026ldquo;Tripled: (tripleNum.toInt32())\u0026rdquo;) {% endcodeblock %} JSValue 包括一系列方法用于访问其可能的值以保证有正确的 Foundation 基本类型 包括：\n下标取值：访问JSContext环境下的任何值 JSContext 和 JSValue 实例可以使用下标的方式访问之前创建的 context 的任何值。\nJSContext：需要一个字符串下标 JSValue：允许使用字符串或整数标来得到里面的对象和数组 JSContext下标取值 swift语法 {% codeblock 未映射成[]的原始方法 lang:swift http://nshipster.cn/object-subscripting/ objectAtKeyedSubscript()和objectAtIndexedSubscript() %} let names = context.objectForKeyedSubscript(\u0026ldquo;names\u0026rdquo;) //JSContext字符串下标原始方法 {% endcodeblock %} JSValue整数下标原始方法 {% codeblock 未映射成[]的原始方法 lang:swift http://nshipster.cn/object-subscripting/ objectAtKeyedSubscript()和objectAtIndexedSubscript() %} let initialName = names.objectAtIndexedSubscript(0) //JSValue整数下标原始方法 println(\u0026ldquo;The first name: (initialName.toString())\u0026rdquo;) //JSValue method // The first name: Grace {% endcodeblock %}\n在这里，Objective-C 代码可以利用下标表示法，如下例：context[@\u0026ldquo;names\u0026rdquo;]，names[0]，[initialName toString]，Swift 目前只公开原始方法:objectAtKeyedSubscript() 和 objectAtIndexedSubscript()来让下标成为可能。\ncallWithArguments调用JS方法：只需传入Foundation基本类型参数 上述JavaScript代码中，JSValue包装了一个triple函数，在Objective-C / Swift 代码中可以使用 Foundation基本类型作为参数来直接调用该函数。再次，JavaScriptCore 很轻松的处理了这个桥接： {% codeblock lang:swift %}\nlet tripleFunction = context.objectForKeyedSubscript(\u0026ldquo;triple\u0026rdquo;) //下标取值 let result = tripleFunction.callWithArguments([5]) //传入基本类型参数直接调用 println(\u0026ldquo;Five tripled: (result.toInt32())\u0026rdquo;) {% endcodeblock %}\nexceptionHandler错误处理 exceptionHandler 是一个接收JSContext 引用和异常本身的回调处理的闭包。 通过设置上下文的 exceptionHandler 属性，可以观察和记录语法，类型以及运行时错误: {% codeblock lang:swift %} context.exceptionHandler = { context, exception in println(\u0026ldquo;JS Error: (exception)\u0026rdquo;) }\ncontext.evaluateScript(\u0026ldquo;function multiply(value1, value2) { return value1 * value2 \u0026ldquo;) // JS Error: SyntaxError: Unexpected end of script {% endcodeblock %} {% codeblock lang:objc %} context.exceptionHandler = ^(JSContext *context, JSValue *exception) { NSLog(@\u0026ldquo;JS Error: %@\u0026rdquo;, exception); };\n[context evaluateScript:@\u0026ldquo;function multiply(value1, value2) { return value1 * value2 \u0026ldquo;]; // JS Error: SyntaxError: Unexpected end of script {% endcodeblock %}\nJavaScript 通过JSContext调用 swift／OC 怎样从 JavaScript 访问我们在 Objective-C 或 Swift 定义的对象和方法？ 让 JSContext 访问我们的本地客户端代码的方式主要有两种：\nblock块键值对：把OC中的block块赋值给JSContext的一个标示键，该标识键的JSValue可以通过callWithArguments调用. JSExport 协议。 block块 键值对:该block键的JSValue通过callWithArguments调用 当一个 Objective-C block 被赋给 JSContext 里的一个标识符，JavaScriptCore 会自动的把 block 封装在 JavaScript 函数里，并以该标示符作为函数名来调用该block的实现。这使得在 JavaScript 中可以简单的使用 Foundation 和 Cocoa类，所有的桥接都为你做好了。 CFStringTransform处理语言的强大威力\n在 JSContext 中使用 Swift 闭包需要注意两点:\n与 @objc_block 属性一起声明 使用Swift中的unsafeBitCast()函数，把对象转换为AnyObject {% codeblock lang:swift %} let simplifyString: @objc_block String -\u0026gt; String = { input in var mutableString = NSMutableString(string: input) as CFMutableStringRef CFStringTransform(mutableString, nil, kCFStringTransformToLatin, Boolean(0)) CFStringTransform(mutableString, nil, kCFStringTransformStripCombiningMarks, Boolean(0)) return mutableString } context.setObject(unsafeBitCast(simplifyString, AnyObject.self), forKeyedSubscript: \u0026ldquo;simplifyString\u0026rdquo;) //通过simplifyString标示符来调用block的实现 println(context.evaluateScript(\u0026ldquo;simplifyString(\u0026lsquo;안녕하새요!\u0026rsquo;)\u0026rdquo;)) // annyeonghasaeyo! {% endcodeblock %}\n{% codeblock lang:objc %} //给标示符赋值一个oc-block，该标示符会被自动装换为JavaScript函数 context[@\u0026ldquo;simplifyString\u0026rdquo;] = ^(NSString *input) { NSMutableString *mutableString = [input mutableCopy]; CFStringTransform((__bridge CFMutableStringRef)mutableString, NULL, kCFStringTransformToLatin, NO); CFStringTransform((__bridge CFMutableStringRef)mutableString, NULL, kCFStringTransformStripCombiningMarks, NO); return mutableString; };\n//通过simplifyString标示符来调用block的实现 NSLog(@\u0026rdquo;%@\u0026rdquo;, [context evaluateScript:@\u0026ldquo;simplifyString(\u0026lsquo;안녕하새요!\u0026rsquo;)\u0026rdquo;]); {% endcodeblock %}\n内存管理 由于 block 可以保有变量引用，而且 JSContext 也强引用它所有的变量，为了避免强引用循环需要特别小心。 避免保有JSContext 或一个 block 里的任何 JSValue。相反，使用 [JSContext currentContext] 得到当前上下文，并把你需要的任何值用参数传递。\nJSExport 协议 在继承JSExport 协议的子协议里声明的属性，实例方法还是类方法，都会自动暴漏给JavaScript代码来调用。\n","date":"2017-02-12T13:34:06Z","permalink":"https://it-boyer.github.io/post/old/swift/JavaScriptCore%E5%AE%9E%E7%8E%B0swift%E6%B7%B7%E7%BC%96/","section":"post","tags":["JS","macOS"],"title":"Java​Script​Core实现swift混编"},{"categories":["解决方案"],"contents":"经历：将代码全提交到默认的head分支中，切换分支后，无法找到分支的严重后果： 目的：在当前分支上，将代码恢复到一个历史的提交版本上。\n暴力的方式 如果仓库是自己在用（不影响别人），那么可以使用 git reset --hard \u0026lt;target_commit_id\u0026gt; 来恢复到指定的提交，再用 git push -f 来强制更新远程的分支指针。为了保证万一需要找回历史提交，我们可以先打一个 tag 来备份。\n第一步：查看本地的索引的提交日志： {% codeblock lang:shell %} $ git reflog a1d09fd HEAD@{0}: checkout: moving from all to master a1d09fd HEAD@{1}: checkout: moving from master to all a1d09fd HEAD@{2}: checkout: moving from HEAD to master a1d09fd HEAD@{3}: checkout: moving from all to HEAD {% endcodeblock %} 第二步：根据上面的sh2值，回滚： {% codeblock lang:shell %} git reset —hard a1d09fd {% endcodeblock %} 这样就可以找回代码. 温柔的方式 {% codeblock lang:shell %} #回滚 git reset —hard a1d09fd #将当前代码切换回最新的提交 git reset \u0026ndash;soft origin/source {% endcodeblock %} 此时工作区变成了历史的提交内容，这个时候用 git add 和 git commit 即可.\n后悔药 舍弃上一次工作区的更改\ngit checkout . 舍弃暂存区的更改\ngit reset --hard 恢复上一次提交的内容到工作区\ngit reset -- .\ngit reset filename 先提交后再恢复到上一次提交的状态\ngit revert id\ngit revert HEAD 修改提交的日志分两步\ngit commit -am \u0026quot;日志信息\u0026quot;\ngit commit -amend ","date":"2017-02-10T18:19:48Z","permalink":"https://it-boyer.github.io/post/old/git/%E7%94%A8Git%E5%B0%86%E4%BB%A3%E7%A0%81%E6%81%A2%E5%A4%8D%E5%88%B0%E4%B8%80%E4%B8%AA%E5%8E%86%E5%8F%B2%E7%9A%84%E7%89%88%E6%9C%AC/","section":"post","tags":["git"],"title":"用Git将代码恢复到一个历史的版本"},{"categories":["解决方案"],"contents":"Bilibili Mac Client 一款基于mpv和ffmpeg底层库实现的播放器.\n项目依赖库 编译在项目中所需的相关依赖库\n下载资源 下载mpv-build {% codeblock lang:git %} git clone https://github.com/mpv-player/mpv-build.git {% endcodeblock %}\n执行下载ffmpeg, libass 和mpv资源，同时完成编译的命令： {% codeblock lang:bash %} cd mpv-build/ ./rebuild -j4\n{% endcodeblock %}\n使用参数 “\u0026ndash;enable-shared ” 可以开启 ffmpeg 的动态版本: {% codeblock lang:bash %} cd ffmpeg/ ./configure \u0026ndash;enable-shared {% endcodeblock %}\n安装ffmpeg {% codeblock lang:bash %} 在ffmpeg目录下执行： make make install {% endcodeblock %}\n开始编译mpv动态依赖库： 开启libmpv动态库的支持： {% codeblock lang:bash %} cd ../mpv/ ./waf configure \u0026ndash;enable-libmpv-shared \u0026ndash;disable-libass ./waf build {% endcodeblock %} 变更去除static参数：./waf configure \u0026ndash;enable-static-build \u0026ndash;enable-libmpv-shared \u0026ndash;disable-libass\n集成到项目中 指定libmpv.dylib相对路径 直接编译出来的库会是绝对路径，需要先通过install_name_tool 修改 相对路径： {% codeblock lang:shell %} cd build/ install_name_tool -id \u0026ldquo;@executable_path/lib/libmpv.dylib\u0026rdquo; libmpv.dylib {% endcodeblock %}\n聚合ffmpeg相关依赖包 执行 mpvtools/dylib-unhell ，目标是 libmpv.dylib {% codeblock lang:bash %} TOOLS/dylib-unhell.py libmpv.dylib {% endcodeblock %} 这样会多出一个 lib文件夹，里面会出现变为相对路径的文件，复制导入到项目即可。\n相对路径脚本学习 使用otool -L 和install_name_tool完成了一系列操作： {% codeblock lang:bash %} install_name_tool -change install_name_tool -id {% endcodeblock %} 扩展一： {% codeblock lang:shell %} #!bin/sh mkdir \u0026ldquo;$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/dylib\u0026rdquo; cp -f /your/path/to/xcode_project_name/dylib/*.dylib \u0026ldquo;$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/dylib/\u0026rdquo;\necho \u0026ldquo;\u0026mdash;\u0026mdash;\u0026ndash;$(pwd)\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026rdquo; cur_dir=\u0026quot;$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/lib\u0026quot; cd ${cur_dir} echo \u0026ldquo;\u0026ndash;进入$(pwd)\u0026ndash;\u0026rdquo;\nfor dirlist in $(ls ${cur_dir}) #查看它们的 rpath otool -L ${dirlist} #制作相对路径 #方法一 install_name_tool -change /usr/local/lib/${dirlist} @executable_path/lib/${dirlist} \u0026ldquo;$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/$PRODUCT_NAME\u0026rdquo; #方法二 install_name_tool -id \u0026ldquo;@executable_path/lib/${dirlist}\u0026rdquo; ${dirlist} do\ndone\n{% endcodeblock %}\n扩展二 {% codeblock lang:shell %} echo \u0026ldquo;\u0026mdash;\u0026mdash;\u0026ndash;$(pwd)\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;\u0026mdash;-\u0026rdquo; cur_dir=\u0026quot;$TARGET_BUILD_DIR/$PRODUCT_NAME.app/Contents/MacOS/lib\u0026quot; cd ${cur_dir} echo \u0026ldquo;\u0026ndash;进入$(pwd)\u0026ndash;\u0026rdquo; lib=\u0026ldquo;libmediainfo.0.dylib\u0026rdquo; #-f 参数判断 $file 是否存在 if [ -f \u0026ldquo;$lib\u0026rdquo; ]; then otool -L ${lib} install_name_tool -id \u0026ldquo;@executable_path/lib/${lib}\u0026rdquo; ${lib} otool -L ${lib} fi {% endcodeblock %}\n","date":"2017-02-10T10:45:03Z","permalink":"https://it-boyer.github.io/post/old/%E7%BC%96%E8%AF%91/bilibili%E4%B9%8BMac%E7%89%88ffmpeg%E4%BE%9D%E8%B5%96%E7%BC%96%E8%AF%91/","section":"post","tags":["ffmpeg","直播","macos"],"title":"bilibiliForMac版之mpv依赖编译"},{"categories":["解决方案"],"contents":"第一步：在任意目录创建调试crash的目录\n第二步：将之前Archive的文件copy到crash目录里面,其中包括两个文件.app和.app.dSYM\n第三步：将symbolicatecrash工具copy到crash目录\n1 find /Applications/Xcode.app -name symbolicatecrash -type f 2.用命令将symbolicatecrash拷贝到桌面的crash文件夹里面，与.app和.app.dSYM放一起 拷贝到crash目录：\n1 cp /Applications/Xcode.app/.../symbolicatecrash /Users/Desktop/crash 第四步：执行symbolicatecrash 1.打开终端用命令切换到桌面的crash目录下：\n1 cd /Users/你的电脑名称/Desktop/crash 2.执行命令\n1 ./symbolicatecrash /Users/Desktop/crash/PBB.crash /Users/Desktop/crash/Control.app.dSYM \u0026gt; Control_symbol.crash 这时候终端有可能会出现：Error: \u0026quot;DEVELOPER_DIR\u0026quot; is not defined at ./symbolicatecrash line 60.\n3.输入命令：\n1 export DEVELOPER_DIR=\u0026#34;/Applications/XCode.app/Contents/Developer\u0026#34; 4.再执行 2.的命令行\n5.将终端完成以后，在crash文件夹里面会多出一个文件Control_symbol.crash。\n1 Unsupported crash log version: 12 at ./symbolicatecrash line 614. 第五步：\n1 dwarfdump --lookup 0x000cf358 --arch armv7 appname.app.dSYM/ ","date":"2017-02-07T12:38:58Z","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/Crash%E6%96%87%E4%BB%B6%E5%88%86%E6%9E%90%E6%96%B9%E6%B3%95/","section":"post","tags":["调试"],"title":"Crash文件分析方法"},{"categories":["解决方案"],"contents":"在以前的 OS X 系统中，给你的 App 在运行时动态载入可执行代码比较困难。现在可以通过NSBundle和 plug-ins插件,可以很方便的向原有APP中添加新功能点。\n目的：在一个修改过的 TextEdit 里面加入加载 bundle 的功能\n包 (Bundles) 和接口 (Interfaces) 如果你打开 Xcode8 创建一个新项目，会看见 OS X 所有可以编写APP插件的模版，例如： Screen Savers 到 Image Units等。 在Framework \u0026amp; Library中的 Bundle 条目。我会在今天探索一个非常简单的的项目，那就是在一个修改过的 TextEdit 里面加入加载 bundle 的功能。 bundle 模版项目与APP项目比较：\n一个 Contents 目录，里面包含了 Info.plist 和 Resource 目录。 如果你在你的项目下加入了新的类，你可以看见包含一个可执行文件的 MacOS 目录。 Bundle 工程里缺少的一个东西是 main() 函数。它是被宿主App 调用执行的。 为 TextEdit 加入 Plugin 支持 两种插件的方式: 第一个:用最少的工作来为你的 app 加入插件支持，希望让你知道实现这个有多简单。 第二个:技术有点复杂，它展现来一个为你的 app 加入插件的合理的方式，这可以使你不会在未来陷入到被锁死在某一种实现的窘境中。 本文章的项目文件仍然会放在 GitHub 供大家参考。\n在 TextEdit 中扫描 Bundle 请打开 \u0026ldquo;01 TextEdit\u0026rdquo; 目录下面的 TextEdit.xcodeproj 工程，同时浏览它里面包含的代码。 TextEdit 里面有三个简单的组成部分：扫描 bundle，加载 bundle，调用 bundle 的 UI loadPlugins 方法： 打开 Controller.m，你可以看见 -(void)loadPlugins 方法 (它在 applicationDidFinishLaunching: 中被调用)。\n扩展插件菜单：在界面菜单右侧加入了一个新的 NSMenuItem，为调用插件提供一个入口（通常你会在 MainMenu.xib 做这件事情并且链接 outlets，但是我们这次偷下懒）。 扫描插件目录：获得插件目录（在 ~/Library/Application Support/Text Edit/Plug-Ins/ ）下，并且扫描这个目录。 {% codeblock lang:objc %} NSString *pluginsFolder = [self pluginsFolder]; NSFileManager *fm = [NSFileManager defaultManager]; NSError *outErr; for (NSString *item in [fm contentsOfDirectoryAtPath:pluginsFolder error:\u0026amp;outErr]) { if (![item hasSuffix:@\u0026quot;.bundle\u0026quot;]) { continue; } NSString *bundlePath = [pluginsFolder stringByAppendingPathComponent:item]; NSBundle *b = [NSBundle bundleWithPath:bundlePath]; if (!b) { NSLog(@\u0026ldquo;Could not make a bundle from %@\u0026rdquo;, bundlePath); continue; } //获取实现插件代理协议方法的类 id plugin = [[b principalClass] new]; NSMenuItem *item = [pluginsMenu addItemWithTitle:[plugin menuItemTitle] action:@selector(pluginMenuItemCalledAction:) keyEquivalent:@\u0026quot;\u0026quot;]; [item setRepresentedObject:plugin]; } {% endcodeblock %} 注：扫描插件目录，确保得到的是一个 .bundle 文件，然后用 NSBundle 载入你找到的 bundle 并且实例化里面的类。\n插件代理 你会注意到一个 TextEditPlugin 的 protocol 的引用。在 TextEditMisc.h 能找它的定义: {% codeblock 声明代理协议 lang:objc %} @protocol TextEditPlugin (NSString*)menuItemTitle; (void)actionCalledWithTextView:(NSTextView*)textView inDocument:(id)document; @end {% endcodeblock %} 这说明你实例化的类需要响应这两个方法。你可以验证这个类是否响应这两个方法。 NSPrincipalClass键:值\u0026ndash;实现插件代理协议方法的类名称 在 bundle 里面调用的 principalClass 方法是什么呢？ 当你创建一个 Bundle 的时候，你可以在里面创建一个或者多个类，同时你需要让 TextEdit 知道哪一个类需要被实例化。为了帮助宿主 App 调用，你可以在 Info.plist 文件加入一个 NSPrincipalClass 的键，同时设置它的值为实现插件方法的类的名字。你可以用 [NSBundle principalClass] 方便地从 NSPrincipalClass 的值里面寻找并创建这个类。\n添加扩展插件菜单的响应事件 在 Plug-Ins 菜单加入一个新的按钮，设置 action 为 pluginMenuItemCalledAction:，并且设置它表示你已经实例化的对象。\n如果在 menu item 里面没有设置一个target，即目标是nil，那么它会寻找响应链，来寻找第一个实现 pluginMenuItemCalledAction: 方法的对象。如果它找不到，那么这个菜单选项将会不能用。 举一个例子，实现 pluginMenuItemCalledAction 的最好的地方是在 Document 的 window controller 类中。打开 DocumentWindowController.m，然后定位到pluginMenuItemCalledAction {% codeblock lang:objc %}\n(void)pluginMenuItemCalledAction:(id)sender { id plugin = [sender representedObject]; [plugin actionCalledWithTextView:[self firstTextView] inDocument:[self document]]; } {% endcodeblock %} 代码本身很清晰，搜集插件实例，调用 actionCalledWithTextView:inDocument: 方法（被定义在 protocol 里面的），运行你插件里面的代码。\n制作插件 新建模版项目 打开 \u0026ldquo;01 MarkYellow\u0026rdquo; 工程看一下。这是一个 Xcode (通过OS X ▸ Framework \u0026amp; Library ▸ Bundle template 建立) 的标准工程，里面只添加了一个类：TEMarkYellow。 设置NSPrincipalClass键值 如果你打开 MarkYellow-Info.plist，你可以看到 NSPrincipalClass 的值设置成了上面提到的 TEMarkYellow。 实现协议代理 接着，打开 TEMarkYellow.m，你将会看见定义在协议里面的方法。 第一个方法（menuItemTitle）返回插件的名字，最为入口名显示在 menu 里面。 第二个方法 (actionCalledWithTextView:inDocument:)，把所有选中的文字变成黄色的背景。 {% codeblock 改变字体颜色 lang:objc %} (void)actionCalledWithTextView:(NSTextView*)textView inDocument:(id)document { if ([textView selectedRange].length) { NSMutableAttributedString *ats = [[[textView textStorage] attributedSubstringFromRange:[textView selectedRange]] mutableCopy]; [ats addAttribute:NSBackgroundColorAttributeName value:[NSColor yellowColor] range:NSMakeRange(0, [ats length])]; // 先测试text view是否能改变文字内容，这样可以自动做正确的撤销操作。 By asking the text view if you can change the text first, it will automatically do the right thing to enable undoing of attribute changes if ([textView shouldChangeTextInRange:[textView selectedRange] replacementString:[ats string]]) { [[textView textStorage] replaceCharactersInRange:[textView selectedRange] withAttributedString:ats]; [textView didChangeText]; } } } {% endcodeblock %} 集成插件 运行 TextEdit （它会创建Plug-Ins目录），然后构建 MarkYellow 工程。把 MarkYellow.bundle 丢到你的 ~/Library/Application Support/Text Edit/Plug-Ins/ 目录下面，重启你的 TextEdit 应用。 一切看起来都很好，扫描，加载，插入一个菜单，然后，当你使用菜单项的时候，传递到参数到插件里面。试一试，点击 Plug-Ins ▸ Mark Selected Text Yellow，选择的文字的背景颜色就变成黄色的了。\nXCode8版本问题 Xcode8 不再支持Application Plug-in插件 XCode8.2.1继续使用xcode插件 这个是因为苹果解决xcode ghost，把插件屏蔽了。 解决方法 sudo /usr/libexec/xpccachectl 然后必须重启电脑后生效.\n","date":"2017-02-07T12:38:58Z","permalink":"https://it-boyer.github.io/post/old/macOS/%E5%BC%80%E5%8F%91Mac%E4%B8%8A%E7%9A%84App%E6%8F%92%E4%BB%B6/","section":"post","tags":["macOS"],"title":"开发Mac上的App插件"},{"categories":["博客站务"],"contents":"标签插件和 Front-matter 中的标签不同，它们是用于在文章中快速插入特定内容的插件。\n引用块 在文章中插入引言，可包含作者、来源和标题。\n别号： quote 1 2 3 {% blockquote [author[, source]] [link] [source_link_title] %} content {% endblockquote %} 样例 无参普通blockquote 1 2 3 {% blockquote %} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. {% endblockquote %} {% blockquote %} Lorem ipsum dolor sit amet, consectetur adipiscing elit. Pellentesque hendrerit lacus ut purus iaculis feugiat. Sed nec tempor elit, quis aliquam neque. Curabitur sed diam eget dolor fermentum semper at eu lorem. {% endblockquote %}\n引用书上的句子 1 2 3 {% blockquote David Levithan, Wide Awake %} Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. {% endblockquote %} {% blockquote boyer huo , Wide Awake %} Do not just seek happiness for yourself. Seek happiness for all. Through kindness. Through mercy. {% endblockquote %}\n引用 Twitter 1 2 3 {% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %} NEW: DevDocs now comes with syntax highlighting. http://devdocs.io {% endblockquote %} {% blockquote @DevDocs https://twitter.com/devdocs/status/356095192085962752 %} NEW: DevDocs now comes with syntax highlighting. http://devdocs.io {% endblockquote %}\n引用网络上的文章 1 2 3 {% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %} Every interaction is both precious and an opportunity to delight. {% endblockquote %} {% blockquote Seth Godin http://sethgodin.typepad.com/seths_blog/2009/07/welcome-to-island-marketing.html Welcome to Island Marketing %} Every interaction is both precious and an opportunity to delight. {% endblockquote %}\n代码块 在文章中插入代码。\n别名:code 1 2 3 {% codeblock [title] [lang:language] [url] [link text] %} code snippet {% endcodeblock %} 样例 普通的代码块 1 2 3 {% codeblock %} alert(\u0026#39;Hello World!\u0026#39;); {% endcodeblock %} {% codeblock %} alert(\u0026lsquo;Hello World!\u0026rsquo;); {% endcodeblock %}\n指定语言 1 2 3 {% codeblock lang:objc %} [rectangle setX: 10 y: 10 width: 20 height: 20]; {% endcodeblock %} {% codeblock lang:objc %} [rectangle setX: 10 y: 10 width: 20 height: 20]; {% endcodeblock %}\n附加说明 1 2 3 {% codeblock Array.map %} array.map(callback[, thisArg]) {% endcodeblock %} {% codeblock Array.map %} Array.map array.map(callback[, thisArg]) {% endcodeblock %}\n附加说明和网址 1 2 3 4 {% codeblock _.compact http://underscorejs.org/#compact Underscore.js %} _.compact([0, 1, false, 2, \u0026#39;\u0026#39;, 3]); =\u0026gt; [1, 2, 3] {% endcodeblock %} {% codeblock _.compact http://underscorejs.org/#compact Underscore.js %} _.compactUnderscore.js _.compact([0, 1, false, 2, \u0026lsquo;\u0026rsquo;, 3]); =\u0026gt; [1, 2, 3] {% endcodeblock %}\n反引号代码块 (MD语法) 样例 行内代码块 1 行内 `code 块 ` 缩进代码块 1 2 3 4 // Some comments line 1 of code line 2 of code line 3 of code 多行代码块 1 2 3 4 5 ``` [language] [title] [url] [link text] 代码块 `` ` 表格 样例 默认左对齐 1 2 3 |参数|描述|默认值| |-------|-------|----------| |文本内容 |文本内容| 文本内容 | 参数 描述 默认值 layout 布局 title 标题 date 建立日期 文件建立日期 updated 更新日期 文件更新日期 comments 开启文章的评论功能 true tags 标签（不适用于分页） categories 分类（不适用于分页） permalink 覆盖文章网址 向右对齐 1 2 3 |参数|描述|默认值| |-------:|-------:|-------:| | 文本内容 | 文本内容 | 文本内容| 三种布局 路径:(储存到路径文件夹) post source/_posts page source draft source/_drafts 向左对齐 1 2 3 |参数|描述|默认值| |:------|:------|:------| | 文本内容 | 文本内容 | 文本内容| 日期变量 描述:（可以通过日期来管理文章） :title 标题（小写，空格将会被替换为短杠） :year 建立的年份，比如， 2015 :month 建立的月份（有前导零），比如， 04 :i_month 建立的月份（无前导零），比如， 4 :day 建立的日期（有前导零），比如， 07 :i_day 建立的日期（无前导零），比如， 7 居中对齐 1 2 3 |参数|描述|默认值| |:------:|:------:|:------:| | 文本内容 | 文本内容 | 文本内容| 变量 描述 layout 布局当:false不加任何布局样式 title 标题 date 文件建立日期 Pull Quote 在文章中插入 Pull quote。\n1 2 3 {% pullquote [class] %} content {% endpullquote %} jsFiddle 官网 在文章中嵌入 jsFiddle 在线的shell编辑器,可以供我们在线测试html、js、和css代码。\n1 {% jsfiddle shorttag [tabs] [skin] [width] [height] %} Gist 在文章中嵌入 Gist\n1 {% gist gist_id [filename] %} filename: 可选，当不指定文件名时，嵌入显示gist_id下所有文件。\n一个gist可能存在多个文件：\n1 https://gist.github.com/dergachev/4627207#file-gif-screencast-osx-md 4627207：表示gist_id ，#file-后边内容：表示Gist中某个文件名\n如下:指定文章中嵌入ecba275d5e4404678354中的NSAttributeString相关方法.m内容。\n1 {% gist ecba275d5e4404678354 NSAttributeString相关方法.m %} iframe 在文章中插入 iframe。\n1 {% iframe url [width] [height] %} 插入图片 样例 Hexo语法 在文章中插入指定大小的图片。\n1 {% img [class names] /path/to/image [width] [height] [title text [alt text]] %} MD语法 原图+toolTip 1 ![boyer logo](http://boyers.coding.me/img/logo.png \u0026#34;这是我的logo图片\u0026#34;) 注脚语法 可以在稍後的文件中再定义图片地址\n1 2 ![boyer logo][logo] [logo]: http://boyers.coding.me/img/logo.png \u0026#34;这是我的logo图片\u0026#34; ![boyer logo][logo] [logo]: http://boyers.coding.me/img/logo.png \u0026ldquo;这是我的logo图片\u0026rdquo;\n指定图片大小 1 ![boyer logo](http://boyers.coding.me/img/logo.png [200] [200] \u0026#34;这是我的logo图片\u0026#34;) ![boyer logo](http://boyers.coding.me/img/logo.png [200] [200] \u0026ldquo;这是我的logo图片\u0026rdquo;)\n超链接 样例 Hexo语法 在文章中插入链接，并自动给外部链接添加 target=\u0026quot;_blank\u0026quot; 属性。\n1 {% link text url [external] [title] %} MD语法 智能识别超链接 1 http://boyers.coding.me http://boyers.coding.me\n文本式 1 [boyer Blog](http://boyers.coding.me) boyer Blog\ntoolTip式 1 [boyer Blog](http://boyers.coding.me \u0026#34;这是我的博客首页\u0026#34;) boyer Blog\nInclude Code 插入 source 文件夹内的代码文件(.m/json/xml等)。\n1 {% include_code [title] [lang:language] path/to/file %} Youtube 在文章中插入 Youtube 视频。\n1 {% youtube video_id %} Vimeo 在文章中插入 Vimeo 视频。\n1 {% vimeo video_id %} 引用文章 根据服务器根目录分为两种方式：\n1 2 {% post_path slug %} {% post_link slug [title] %} 以Docker使用博客为例\n相对路径 1 {% post_path Docker使用 %} 相对于服务器根目录的位置： {% post_path Docker使用 %} 绝对路径 1 {% post_link Docker使用 Docker使用 %} 本博中其他文章的超链接： {% post_link Docker使用 Docker使用 %} 引用资源 引用文章的资源。 Assets指的是那些不在source目录下的资源，比如图片、CSS文件或者Javascript文件。Hexo提供一种更方便的方法来管理这些资源（Assets）。想使其生效，首先修改 post_asset_folder 字段的设置，将其值改为 true 。 当生效后，在你创建文章的时候，Hexo会创建一个同名目录，你可以将该文章关联的资源全部放到该目录下。这样就可以更加方便的使用它们了。 使用方法就是上面介绍过的标签插件。\n1 2 3 {% asset_path slug %} {% asset_img slug [title] %} {% asset_link slug [title] %} Raw 一些内容不想被主题渲染，可以使用该插件呈现原始状态。 如果您想在文章中插入 Swig 标签，可以尝试使用 Raw 标签，以免发生解析异常。\n1 2 3 {% raw %} content {% endraw %} ","date":"2017-01-23T15:17:33Z","permalink":"https://it-boyer.github.io/post/old/hexo/Hexo%E6%A0%87%E7%AD%BE%E6%8F%92%E4%BB%B6/","section":"post","tags":["hexo"],"title":"Hexo标签插件"},{"categories":["解决方案"],"contents":"鸣谢 hi-pda dtgc Kindle115 综合类 青风乘翼 最近出版的译著 更新中 周旋久 按字母排列的书籍 提取码：djhp F、H、J、R字母 提取码 39bd S、T、Y字母 提取码 42b1 烫伤关东煮 约1t以上 20160302更新 18810815415 精排版书籍 （可能是豆瓣读书编辑） liantingv70657 炜博happy 更新中 guyuemuziye6@gmail.com 旅游原版书 （微博号逼影共享，解压密码bygx） 枫729882492 电子书资源外链发布站 赤霓 nnuuij11111 风扒皮1503 zphstar skmjtptwr 327995970ou xunys ohhe 没我找不到的电子书 （此人吹牛居多，书籍不全） 搜珍玉鏡 菜是菜菜 13805758171 yun360419811 虚昧斋 分享新书 可私信求书 唯我君行 中医、VB haoyou43 mobi epub 格式书籍 350+ 更新中 liguobing55 txt合集 青辰VOW 部分全站打包等 苏菇莨百度盘书（BTSync） 约56G 至20160222关闭前 感谢：maldiniymx B3EWLQK7C6O6RK3CU5CG3PZUYDUJLMYCP B25G263OSC7ZAXPLCZESSL3DFJOHK6UQ3 wizardforcel 杂项书籍 豆瓣图书top250 当当epub7000本 卡夫卡全集和哈佛管理 知乎话题、专栏、收藏 知日系列 知乎盐系列 图说天下系列 kindle人资源打包 精品区11G+自购区31G+自制区10G+66G programthink 文学历史类、社科类 零度小然 稀有现代书历史籍 youngharrylg 中华人民共和国前三十年历史 南阳高卧 近现代大家 doppel88 各国文学 坊書流元 语言学 高贵的容克领主 历史 dfdean 文学 名家文集 rainthounder 文史高清pdg版图书 翟子昂 中国古文字学 longhuarenn 历史 Lyra1900 iilikes 古籍类 Ac_heron 古典文学 dadssfree 大批量文史书籍 (约1.3t) qq312145694 古文史资料 （大约1t以上） 洋风汉魂 日本文史资料原版 （大约1t以上） 久舞而凄 精选精美古籍 （大约500G以上,更新中） 逍遥449824194 古籍 事无所成只因懒 古籍 钱建文 古籍 风家纪录片3 子乌书简全站打包 20130507 密码：qjq8 小说 wizardforcel 小说 莫迪亚诺作品集 王小波全集 阿加莎·克里斯蒂作品集 周浩晖作品集 医学类、心理学类 于柏清二 中医 bdywuxinghua 中医丛书 yyzsm99 心理学 异硫氰酸烯丙酯 医学 一蹀盐 呼吸医学 cnchenlian 康复医学 Zita 解剖学 图谱 LV终结者 制药技术 （物化资料夹里） 136603yin 性科学为特色 偏综合 心理学交际学电子书合集13本 hhhzihao 心理学 佛学类 CBETA_TW 中華電子佛典協會分享佛教书籍 dufojing 佛教书籍 senmy08 佛教书籍 数理学科类 小兆一凡 数学 我就叫混沌 华章数学译丛 百度云 华章数学译丛 微盘 图灵数学·统计学丛书 百度云 图灵数学·统计学丛书 微盘 生物学类（动物、植物、野外生存等） ChentaoTony1 昆虫学 jkdpgh 野外生存 动物志 麦子 生物学 动物学 xiayang405 精神病学、细胞生物学 li__cheng__ 中国植物志、各地区植物志 山刺玫 植物学 绿色营上海小组 植物学 计算机技术类 lxghost IT （xiaoshuwu.net） wintelsui IT 明月无风 耍大刀xyz PS书籍 hcbbt IT salttiger IT wizardforcel IT 非IT工业技术类 南航飞动研学群 航空航天 星河舰队司令 武器 wxjoldgoat 武器 cfhcjg 军事资料 以逸待劳hk 航天资料 语言学习类 学派英语团队 英语学习 英语学习资料 经管 商业类电子书 艺术类 （摄影、音乐、绘画等） 吸血鬼123牛仔 音乐 xslp2004 摄影 yu鈥唋ei 中国绘画 新浪微博@于双子鱼 分享私密文件 杂志类 qingge16 杂志 （含部分最新书） yanxishe 杂志 liuafenliu 台湾地区优质财经杂志（天下雜誌/遠見雜誌/商業周刊/經理人月刊） 更新中 foodservice 台湾地区优质财经杂志（天下雜誌/遠見雜誌/商業周刊/經理人月刊） 似乎是台湾地区人 更新到201410 原版书类 好想一次过 原版外文书 12879本Kindle英文原版电子书 经典、畅销英文原著100本 相关链接 计算机书籍控 脚本之家电子书 小书屋 稀酷客 读远 SaltTiger it-ebooks.cn it-ebooks.info it-ebooks.org it-ebooks.com ebooks-it.net wowebook.org bookdl.com bookzz.org allitebooks.com ","date":"2017-01-23T12:49:49Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/Kindle%E8%B5%84%E6%BA%90/","section":"post","tags":["图书","资源"],"title":"Kindle114 资源集[转]"},{"categories":["解决方案"],"contents":"Kindle伴侣精品书库 Kindle伴原文 Resilio Sync同步密钥 {% codeblock lang:basnh %} BOC3NIGPF2DOKETOF2FAHXJXE2HF24QWC {% endcodeblock %}\n精品书库 精品库 {% iframe https://kindlefere.github.io/share/ebook/ 800 400 %}\n每周一书 每周一书 {% iframe https://kindlefere.github.io/share/weekly/index.html 800 400 %}\n国外书籍 国外精选 {% iframe https://kindlefere.github.io/share/ebook-en/index.html 800 400 %}\nResilio Sync 原地址详解\n实现原理 Resilio Sync 这款软件的优点上面已经说了一些，就是不依赖中心服务器，所有的文件都分布在用密钥连接在一起的电脑上。这里重点说一下小伙伴们关心的缺点。\n缺点一：免费版只能强制同步所有文件，比如书库的大小有 5G，只能将这 5G 的电子书全部同步到你的电脑上，这需要你有一块足够大的硬盘。除非你升级到收费版（每年 100 元）实现选择性同步。\n缺点二：因为没有中心服务器，所以下载的速度依赖于每个电脑的上传速度，和中心服务器的分享方式相反，人越多同步的速度就越快，反之，人越少同步的速度就越慢。\n在IgnoreList文件中忽略不想同步的文件 BitTorrent Sync还支持文件过滤，如果你有一些文件不想被同步，你可以通过配置IgnoreList实现。\nIgnoreList是一个UTF-8编码的txt文件，里面你可以定义单个文件，路径，以及规则，他支持简单的“？”和“*”匹配。\n1 2 cd 同步目录/.sync／ cat IgnoreList \u0026gt;# IgnoreList is a UTF-8 encoded .txt file that helps you specify single files, paths and rules \u0026gt;# for ignoring during the synchronization job. It supports \u0026quot;?\u0026quot; and \u0026quot;*\u0026quot; wildcard symbols. # # # OS generated files # .DS_Store .Spotlight-V100 .Trashes ehthumbs.db desktop.ini Thumbs.db # Temporary files # ~* *~ .~lock.* *.part *.crdownload @eaDir @SynoResource .@__thumb 高级设置相关说明 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 disk_low_priority：true 设置在磁盘上操作文件的优先级，如果设置为false，在同步文件时读写文件将会采用最高速度和优先级，不过这样会影响其他应用的性能。 folder_rescan_interval：600 设置扫描目录的时间间隔，单位为秒 lan_encrypt_data：true 如果设置为ture，则在本地网络传输时会采用加密传输。 lan_use_tcp：false 如果设置为ture，在本地网络同步会采用tcp传输，而不是采用udp传输。注意：在LAN中禁止加密并采用tcp传输，会增加传输速度。 rate_limit_local_peers：false 申请在本地网络的peers直接限速传输，默认没有在LAN里面限速 send_buf_size：5 在发送文件时可以使用的发送缓存，可以设置1~100M recv_buf_size：5 在接收文件时可以使用的接收缓存，可以设置1~100M sync_max_time_diff：600 同步的设备之间的时间差别 sync_trash_ttl：30 设置多少天之后自动删除.SyncArchive目录中的文件 max_file_size_diff_for_patching：1000 max_file_size_for_versioning：1000 版本控制的一个参数，不了解... 常见问题汇总 添加同步链接后为什么找不到节点？ 如果是刚添加同步密钥或链接，请稍等片刻。如果很长时间仍然找不到节点无法同步，请尝试：把已经添加的同步目录删除，在 Sync 界面上谭家的同步断开，然后重新添加同步密钥或同步链接。\n提示“与 x 个用户的时间差”怎么办？ 如果系统的时间严重不准会导致 BT Sync 无法正常工作。如果 Sync 软件提示的事您的电脑有时间差，请确保开启自动时间同步，如果时间同步没问题，请先退出 Sync 软件重新开启。如果提醒其他人有时间差，请忽略。\n为什么同步的电子书比目录标示的大？ 书库在维护的过程中会删除一些质量较差和重复的电子书，如果被删除的电子书已经同步到你的电脑上，就会被 Sync 自动备份下来。备份位置在同步目录下的隐藏文件夹 .sync/Archive 中，在 Sync 软件中右键点击同步文件夹，在弹出的菜单中点击“打开存档文件”即可打开。\n默认情况下，此目录中的文件 30 天后会自动删除。书库中删除的文件没有保留的必要，为了避免备份文件占用空间，可以禁用此功能。先把 Archive 文件夹删除，然后在 Sync 软件中右键点击同步文件夹，在弹出的菜单中点击“首选项”，取消“在文件夹存档中存储已删除的文件”前面的勾选即可。\n开启 Sync 后电脑变得很卡怎么办？ 因为 Sync 传输数据时需要读写硬盘，这可能会导致电脑其它的数据读取变慢，解决方法就是设置限速，让同步细水长流。打开 Sync 的软件的“首选项”，在“高级”选项卡中找到“限制接收速率”和“限制发送速率”，输入一个合适的值即可。另外，如果正在做其他工作，建议暂停或暂时退出 Sync 软件。\n另外，在“高级”界面里，点击底部的“打开高级用户偏好设置”，把“disk_low_priority”这项设置为 true 也可以缓解卡顿的现象。其中“rate_limit_local_peers”是设置在磁盘上操作文件的优先级，默认为 false，在同步文件时读写文件将会采用最高速度和优先级，所以会影响其他应用的性能。\n重新添加能继续用之前的同步目录吗？ 有时因为某种原因，导致添加到 Resilio Sync 的同步丢失，需要重新添加密钥，这种情况下，是可以继续使用之前的同步目录的，只需要在重新添加密钥选择同步目录的时候，选择原来的目录即可。\n","date":"2017-01-23T12:49:49Z","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/Kindle%E4%B9%8BResilioSync%E7%B4%A2%E5%BC%95/","section":"post","tags":["资源"],"title":"Kindle之ResilioSync索引"},{"categories":["学习笔记"],"contents":"总结了AR开发的平台汇总，AR视频经典教程，AR主流资讯网站，Vuforia，EasyAR一些实例教程以及AR精选应用。\nAR 平台 Vuforia\u0026ndash;不用多说，最流行的AR应用开发引擎。 EasyAR－－EasyAR是国内最专业的AR引擎,是国内首款投入应用的AR SDK。EasyAR是好用且免费的增强现实(Augmented Reality)开发者引擎。 HiAR\u0026ndash;HiAR 增强现实开发平台 HiAR 是亮风台信息科技打造的新一代移动增强现实(AR)开发平台,提供一整套世界领先的增强现实(AR)技术服务。 太虚AR－－成都米有网络科技有限公司自主研发集成于Unity3d实现增强现实的SDK开发包,虚拟现实SDK太虚官方网站。 Wikitude\u0026ndash;Wikitude是一家专门从事智能手机增强现实的应用，分别出品了两款应用Wikitude drive与Wikitude World Browser。 Inter RealSense\u0026ndash;RealSense 3D是一套感知计算解决方案,包括世界上最小的3D摄像头,模块比两个硬币摞起来还薄,除了硬件外,英特尔还将提供驱动及软件等全套开发工具 ICreator\u0026ndash;依托于iCreator 3D, VR引擎,模型师可以快速创建交互式3D, VR内容,并支持微信平台传播,也为模型师提供可视化3D模型交易功能。 天眼－－天眼AR包括天眼云平台和天眼AR浏览器,用户需在天眼云平台完成“AR内容”制作,然后在天眼AR浏览器查看效果。 Google Tango\u0026ndash;小编重点推荐。运动追踪(Motion Tracking)，深度感知(Depth Perception)和区域学习(Area Learning)。\nAR 视频教程 Hololens 开发教程 增强现实技术分享 AR房地产 AR - 双卡互动 AR涂涂乐 Hololens 开发 Vuforia 公开课 Intel realSense制作面部捕捉小游戏 HiAR 视频播放 HiAR 水晶球 HiAR 瞬间拥有Apple Watch Vuforia 入门－基础－进阶\nAR 网站 AR酱\u0026ndash;发现闪闪发光的AR从业者|增强现实|混合现实|虚拟现实 增强现实－－增强现实中国ARinChina 是中国最大的专注于AR增强现实技术行业的门户网站。 AR 学院－－增强现实|虚拟现实技术交流社区、综合门户 AR 村－－提供最新最快的AR增强现实信息,最权威的AR增强现实解读与产品发布. 柚子AR－－柚子AR打造专业的增强现实技术领域门户网站,提供AR资讯、AR技术、AR视频、AR游戏、AR设备等相关知识教程,柚子AR,打造增强现实行业交流聚集地。 ChinaAR－－中国AR网,是国内第一家打造增强现实技术交流的一个自媒体平台!意在打造中国AR爱好者对AR技术的交流与学习的一个平台 AR 中国－－AR中国是专注于增强现实技术的新闻门户网站 AR 技术网 Realseer\n增强现实视频合辑 增强现实技术1-31篇技术视频教程合集\nVuforai 教程精选 Vuforia 公开课－－包括Vuforia 环境搭建，多图识别，单页翻页效果，模型自动旋转\u0026hellip; VUforia 视频合辑 Vuforia 官方教程 Vuforia 论坛 Vuforia 论坛 Vufoira 涂涂乐文章教程－－讲解详细 Vuforia 实现物体阴影特效 Vuforia 多图识别 Vuforia 脱卡 Vuforia SDK\u0026mdash;- AR开发vuforia实现拍照截屏功能\nEasyAR教程精选 Leap Motion+EasyAR AR手势开发教程 AR从入门到精通开发系列教程(1)\u0026mdash;搭建开发环境 AR从入门到精通开发系列教程(2)\u0026ndash;创建模型并互动 EasyAR 公开课 EasyAR 文档 EasyAR官方Sample之涂涂乐 EasyAR 论坛 带你开发类似Pokemon Go的AR游戏(1) 带你开发类似Pokemon Go的AR游戏(2)\nHiAR 教程 HiAR 官方文档－－看完之后就掌握的大概了，官方文档很详细了。 HiAR 论坛 HiAR 论坛 HiAR SDK 教学视频\n其他平台教程 太虚AR教程 太虚AR学习 Metaio 学习 Wikitude 公开课 太虚AR公开课\nGoogle tango教程 Tango SDK 下载（提取码：sh18） 跟着Shrek Team学tango Project Tango 知识原理 Google Tango 项目\nAR 技术文章 两家AR专利大厂在AR硬件方面的探索 增强现实技术及其应用 全球首份VR/AR医疗健康产业应用创新报告\nAR 精选论文 基于ARM和OpenCV的增强现实平台研究 基于Android的增强现实技术研究与实现 增强现实应用技术研究 基于ARTOOLKIT的增强现实技术在恐龙博物馆中的应用研究 基于增强现实技术的虚拟留言墙系统的设计与实现 基于智能移动终端的移动增强现实应用研究与实现 基于unity3d的移动增强现实技术与应用研究分析 增强现实中标记设计与识别方法研究 户外增强现实gis的应用研究 手持式增强现实神经导航关键技术研究及其系统建立 基于ARToolKit平台的增强现实人机交互系统的若干问题研究 基于ARToolkit的汉字识别系统的设计与实现 基于ARToolKit的增强现实技术在恐龙博物馆中的应用研究\nAR应用精选 视+AR－－搭载独立开发的EasyAR引擎，全新视+2.0强势来袭！包罗丰富ar内容的增强现实浏览器，等你来体验！ AR\u0026ndash;这是一款增强现实AR的应用，主要分为三部分：LOL人物展示（带有经典音效），太空大战，手势交互（可以旋转与缩放）。突破现在AR格局，给玩家带来更多的乐趣。你只需一张个人身份证的反面，便会通过AR得到一个精彩的世界！ 小熊尼奥产品 增强现实优秀应用－－大部分是国外的。 十一用12个案例SoLoMo，AR+LBS 让你脑洞大开的AR技术应用 13款最叫绝的增强现实应用 9款超赞的AR教育APP 参考原文\n","date":"2017-01-22T18:55:21Z","permalink":"https://it-boyer.github.io/post/old/swift/AR%E5%BC%80%E5%8F%91%E8%B5%84%E6%96%99%E6%B1%87/","section":"post","tags":["AR"],"title":"AR 开发资料汇"},{"categories":["学习笔记"],"contents":"此文档是Apple平台开发所使用语言的主流学习资源\niOS开发者博客 使用 iOSBlogCN添加或者订阅 从社区学习知识 iOS技术周报 objc中国 cocoachina Swift社区 从iOS面试题总结 iOS有用的面试题\n建议－学习iOS之前快速预览一下 MAC开发环境配置\n什么是Swift，如何评价 Swift 语言？\n了解一下Objective-C是什么\niOS开发60分钟入门\nStart Developing iOS Apps Today\n从零开始学iOS开发的15条建议\n自学iOS开发的一些经验\n学习路线\n语言学习 这里包括了Swift，Objective-C，C，C++\n中文版 Apple 官方 Swift 教程《The Swift Programming Language》1.2\n中文版 Apple 官方 Swift 教程《The Swift Programming Language》2.0\nThe Official raywenderlich.com Swift Style Guide\nThe Official raywenderlich.com Swift Style Guide 中文版\nUsing Swift with Cocoa and Objective-C中文手册\nC 语言常见问题集\nGoogle Objective-C Style Guide 中文版\nGoogle C++ Style Guide 中文版\n禅与 Objective-C 编程艺术 （Zen and the Art of the Objective-C Craftsmanship 中文翻译\n免费视频资源 玩儿转Swift\n征战Objective-C\n斯坦福大学公开课：iOS 7应用开发\n斯坦福大学公开课：Swift开发iOS 8应用－中文字幕\n斯坦福大学公开课：Swift开发iOS 8应用\nWWDC 2015 Video 英文字幕 (共104个)\nWWDC2015下载链接\n精粹 一些 iOS / Web 开发相关的翻译或原创博客文章\niOS-Core-Animation-Advanced-Techniques\nobjc.io中文翻译版本\n这份指南汇集了Swift语言主流学习资源，并以开发者的视角整理编排\nA curated list of awesome iOS UI/UX libraries\niOS8-Day-by-Day blog series\niOS9 Day-by-Day blog series\nmatteocrippa/awesome-swift\nWolg/awesome-swift\nawesome-ios\nSwift | Objective-C | C/C++ | 设计 资源集合 Alamofire网络库基础教程\nC 语言中的指针和内存泄漏\nC/C++编程的现代习惯\nSwift指针的使用\nSwift tips\nStudy\niOS心得\nA curated list of delightful iOS resources.\n优秀外文翻译资源集合\n详解Swift中的iOS设计模式\n在iOS8 下用Swift 创建自定义的键盘\nSwift和自动引用计数(ARC)整理之强，弱和无主引用\n自己动手写一个 iOS 网络请求库（一）—— NSURLSession 初探\nReactiveCocoa 3.0 初窥\nSwift 2 有哪些新特性\n如何使用Instruments诊断App（Swift版）：起步\n理解 ARC 下的循环引用\nSwift 2.0初探\n2013 CocoaChina微信精选之技术汇\n理解 Objective-C 的 ARC\niOS开发的一些奇巧淫技\n我推荐的一些iOS开发书单 叶孤城___\niOS性能优化\niOS 调试核对清单\niOS APP 测试点摘要\nGCD使用经验与技巧浅谈\niOS 开发实践之 Auto Layout\nI Found You! 正则表达式!\niOS 开发中的消息传递机制\niOS扫一扫功能开发\n给游戏开发者们的 7 个制作建议\niOS另类的内存管理\niOS runloop\n正确使用Block避免Cycle Retain和Crash\n为GCD队列绑定NSObject类型上下文数据-利用__bridge_retained(transfer)转移内存管理权\niOS事件分发机制（一） hit-Testing\niOS事件分发机制（二）：The Responder Chain\niOS富文本组件的实现—DTCoreText源码解析 渲染篇\niOS富文本组件的实现—DTCoreText源码解析 数据篇\nGCD概述、语法以及好的示例\n通过减少动态派送提升性能\nNSString属性什么时候用copy，什么时候用strong?\nNSRecursiveLock递归锁的使用\n在iOS上以root身份运行守护进程\niOS开发中两个常见问题的处理\niOS 8增强的自动布局功能\nTheos介绍\niOS中几种定时器 - 控制了时间，就控制了一切\niOS view的frame和bounds之区别（位置和大小）\niOS应用程序的生命周期\n2015 Objective-C 三大新特性 | 干货\n“自释放”在iOS开发中的应用\n关注被忽略的 Objective-C、Swift 和 Cocoa 特性\nSwift开发游戏步骤\n关于iOS编码规范\nObjective-C开发编码规范（一）\nObjective-C开发编码规范（二）\nSwift扩展的三个微妙细节\nObjective-C类成员变量深度剖析\nSwift基础(一)\niOS7人机界面指南\niphone6 屏幕设计揭秘\nmobile设计\niOS常用框架\niOS面试基础知识36题\nGitHub 上排名前 50 的 Objective-C 项目简介\n一些知名App用到的第三方库汇总\nGithub优秀开源项目大全-iOS\n[iOS单元测试系列]单元测试框架选型\n购物商城的Demo\n斯坦福大学公开课：iOS 7 应用开发 Demo\niOS-Swift-Demos\niOS 无障碍开发指导\nTestingWithXcode中文文档\n苹果Xcode帮助文档阅读指南\niOS项目的持续集成与管理\n（译）WebViewJavascriptBridge－Obj-C和JavaScript互通消息的桥梁\n截获导航控制器系统返回按钮的点击pop及右滑pop事件\nUITableView常用属性和方法\nSwift新特性 \u0026ndash; 访问控制（Access Control）\nViewController Programming Guide 笔记（一）\nHTTP Live Streaming直播(iOS直播)技术分析与实现\nMantle 初步使用\n使用CAReplicatorLayer创建动画\niOS动画——ViewAnimations\niOS动画——Layer Animations\n收集整理了下iOS平台下比较主流炫酷的几款动画框架\nMasonry介绍与使用实践(快速上手Autolayout)\niOS学习之Autolayout\n如何实现一个不规则排列的图片布局算法 | 干货\n响应式视图\n微软前员工：开发Apple Watch应用的27个技巧\nApple Watch开发初探\nApple Watch开发专题\n深入理解Objective-C：方法缓存\n优化UITableViewCell高度计算的那些事\n一个完整的Core Data应用\niOS安全系列之一：HTTPS\nblock基础篇\nblock终极篇\n关于iOS多线程，你看我就够了\nObjective-C Run time 轻松学习之三——IMP指针的作用\n轻松学习之二——iOS利用Runtime自定义控制器POP手势动画\nCocoa Runtime系统知识整理\n理解 Objective-C Runtime\nObjective-C isa 指针 与 runtime 机制\nObjective-C Runtime\nObjective-C Runtime\nObjective-C特性：Runtime\n项目结构经验 iOS 项目的目录结构能看出你的开发经验\niOS项目架构探索\niOS应用架构谈系列\n学习UI iOS组件之UIScrollView详解\nUIScrollView 实践经验\n参考原文\n","date":"2017-01-22T18:55:21Z","permalink":"https://it-boyer.github.io/post/old/swift/AwsomeAppleDevelopGuide/","section":"post","tags":["iOS","资源"],"title":"Awsome Apple Develop Guide[转]"},{"categories":["学习笔记"],"contents":"iOS有用的面试题大集合 面试题从何处得来 招聘一个靠谱的 iOS 知乎－如何面试 iOS 工程师？ 阅读面试题之前 在正式开始之前，我期望你能对iOS/Mac OS X平台开发有所了解，在iOS开发中已经很少需要自己写复杂的算法了，一般情况下很少会在面试中出现算法的考核，如果你了解一些基础的算法，还是有帮助的。\nNow！！请使用ARC\n什么是iOS开发 iOS是iPhone iPad等手持设备的操作系统，所谓的iOS开发就是开发运行在iOS系统上的应用或者游戏，比如支付宝，微信，微博等，当然这也包括了iPad版的应用，iOS开发可以归纳到移动开发领域。\n有时候面试官是那种\u0026rsquo;脑残粉\u0026rsquo;，了解一下Apple的发展历史，可能比较聊的开。\n苹果Mac计算机31年发展历程回顾\n苹果公司\n苹果公司在知乎上的话题\n乔布斯个人传记\n拼写正确的重要性 有些面试官可能更注重细节，所以，拼写的单词一定要对，比如iOS，Xcode，iPhone，Objective-C，JSON等，良好的拼写习惯，会让面试官觉得你细心靠谱。\nSwift和Objective-C的比较 仁者见仁智者见智，从个人的使用角度上来看，Swift在某些情况上比Objective-C更加的严谨了，入门非常简单，但是想开发应用，还是需要学习cocoa框架，这玩意路子还是Objective-C的，所以有基础可能更好的理解Swift在iOS/Mac OS X 中的开发和应用。\n知乎原文\n了解Watch OS Watch OS是苹果公司推出的应用在手表上的一个操作系统，Watch OS 1.0需要跟iPhone相结合才能工作。\nApple Watch\nWatch OS 2.0 开发概述\niOS面试 property 后面可以有哪些修饰符 读写修饰符 readwrite | readonly\nreadwrite Xcode会帮助我们创建setter，getter方法，readonly Xcode只会帮助我们创建getter方法，不会创建setter方法。\nsetter相关的修饰符 assign | retain | copy\n2.1 setter相关的修饰符表明了setter方法该如何实现，assign用于基本数据类型NSInteger，CGFloat，C数据类型int，float，id类型等，这个符号不会涉及内存管理，但是如果是对象类使用了它，可能会导致内存泄漏或者EXC_BAD_ACCESS错误。\n2.2 retain用于对象类的内存管理，如果基本数据类型使用它，Xcode会直接报错。当对象类使用此修饰符时，setter方法的实现是先release一次，然后再对新的对象做一次retain操作。\n2.3 copy主要用于NSString，用于内容复制。\n原子性修饰符 atomic | nonatomic\natomic 表示线程安全\nnonatomic 表示非线程安全，使用此修饰符会提高性能\ngetter，setter修饰符\n这两个修饰符用于设置生成的getter，setter的方法名\nstrong，weak修饰符（ARC） 在ARC中内存管理都只需要使用这两个修饰符，而且strong是默认全局的，只要你写了Objective-C的对象，不自己添加weak的话，默认就是strong。 5.1 strong表示这个对象的拥有者 一个对象可以有多个拥有者，strong就是用来表示对这个对象的拥有。比如在往NSMutableArray中添加Objective-C对象，当你从数组中删除时，这个对象并不会释放。需要你手动设置为nil，或者在控制器的生命周期内，由系统来释放。 5.2 weak指针变量仍然可以指向一个对象，但不是这个对象的拥有者 weak修饰的指针变量也可以指向对象，但不是这个对象的实际拥有者，也就是说weak修饰的指针变量如果想要释放，需要strong修饰的指针变量设置为nil，weak修饰的指针变量也会是一个nil，它指向的对象已经没有了，还需要设置weak修饰的指针变量为nil。\nnonnull nullable null_resettable\nXcode 6.3推出的nullability annotations，主要是为了更好的Swift与Objective-C混编，在Swift中有可选型的概念!,?，但是Objective-C中木有这玩意，于是Xcode 6.3中才有了这个， 从字面可以看出: nonnull 表示对象不应该为空，如果是这个修饰符对应的就是Swift中已经解包的对象或者! nullable表示可以为nil或者NULL,对应是Swift中的可选? null_resettable则是表达属性的空属性，该属性setter访问器允许将其设置为nil（设置该属性为默认值），但是它的getter访问器不会提供一个nil值（因为它提供了默认值），有一个这样的属性如UIView’s tintColor，如果没有tint颜色指定时它会提供一个默认的tint颜色值，对应的Swift使用是var tintColor:UIColor!\n实战 使用 weak 关键字，相比 assign 有什么不同 一般情况下使用weak是避免循环引用，因为它不是对象的拥有者。而assign则是用于基本数据类型，或者C类型，而且assign是直接赋值，可能会导致一个问题。比如我想a和b共用一块内存，a是用assign修饰的，a = b，现在a使用的目的已经完成，我想释放这个内存，但是a并不知道b到底用没用完，如果此时a释放内存，而b还在使用，那么会导致应用程序crash，使用weak就能避免这样的问题。 怎么用 copy 关键字 copy拷贝的是内容,retain是拷贝的指针 * 以string为例,如果string的属性为copy的话,那么传入参数为NSString的话,即为不可变string,retain,copy效果一样. * 如果传入参数是mutable的话,那么copy拷贝内容,源随意变化不影响该属性的值.retain拷贝指针,源变化则属性值着变化,因为属性和源指向如何使用呢,通常在需要拷贝内容,但是副本和源不要互相影响的情况下使用.* 同一内存地址. * 例如array/dictionary中,可能会需要一个副本来做一些操作(筛选,排序等),但是并不希望影响原始值,则可以使用copy @property (copy) NSMutableArray *array; 这样写有什么问题吗 因为用了copy, 内部会深拷贝一次, 指针实际指向的是NSArray, 所以如果调用removeObject和addObject方法的话, 会unRecognized selector 如何让自己的类用 copy 修饰符？如何重写带 copy 关键字的 setter？ 当一个对象发生改变时不影响另外一个对象，这里就需要使用copy关键字了，实现NSCopying协议，重写- (id)copyWithZone:(NSZone *)zone方法。 {% codeblock lang:objc %} (void)setName:(NSString *)name { if(_name != name) { _name = [name copy]; } } {% endcodeblock %} @protocol 和 category 中如何使用 @property @protocol可以通过关键字:@synthesize或者在继承的类里面重新定义一次该属性(extension里面定义是不行的) category通过关联:objc_setAssociatedObject/objc_getAssociatedObject @property 的本质是什么？ivar、getter、setter 是如何生成并添加到这个类中的 @property本质是定义一个objc_property结构体 如何生成目前不清楚 weak属性需要在dealloc中置nil么 不需要，因为weak会自动设置nil @synthesize和@dynamic分别有什么作用 关于@synthesize（现在已经不需要在写这个属性了，它是用来生成getter和setter方法） @dynamic 就是要告诉编译器getter和setter方法会在程序运行或者用到动态绑定的方式，以便让编译器通过编译，这个主要要在NSManagerObject上。 ARC下，不显式指定任何属性关键字时，默认的关键字都有哪些 在默认情况下，所有的实例变量和局部变量都是strong类型的。 用@property声明的NSString（或NSArray，NSDictionary）经常使用copy关键字，为什么？如果改用strong关键字，可能造成什么问题 因为不想改变了其中的值后把原来的值也跟着改变了，用了strong后会出现这样的状况。 什么是ARC 请阅读，然后随便谈谈你的理解即可。 ARC是为了解决下面几个问题 当我们要释放一个堆内存时，首先要确定指向这个堆空间的指针都被release了。（避免提前释放） 释放指针指向的堆空间，首先要确定哪些指针指向同一个堆，这些指针只能释放一次。（MRC下即谁创建，谁释放，避免重复释放） 模块化操作时，对象可能被多个模块创建和使用，不能确定最后由谁去释放。 多线程操作时，不确定哪个线程最后使用完毕 手把手教你ARC——iOS/Mac开发ARC入门和使用 理解 Objective-C 的 ARC 请解释以下keywords的区别： assign vs weak, block vs weak assign适用于基本数据类型，weak是适用于NSObject对象，并且是一个弱引用。 assign其实也可以用来修饰对象，那么我们为什么不用它呢？ 因为被assign修饰的对象在释放之后，指针的地址还是存在的，也就是说指针并没有被置为nil。如果在后续的内存分配中，刚好分到了这块地址，程序就会崩溃掉。 weak修饰的对象在释放之后，指针地址会被置为nil。所以现在一般弱引用就是用weak。 block是用来修饰一个变量，这个变量就可以在block中被修改，使用block修饰的变量在block代码快中会被retain（ARC下，MRC下不会retain） weak：使用weak修饰的变量不会在block代码块中被retain同时，在ARC下，要避免block出现循环引用 weak typedof(self)weakSelf = self __block在arc和非arc下含义一样吗 是不一样的，ARC会retain，非ARC不会。 描述一个你遇到过的retain cycle例子 在viewController中避免循环引用 {% codeblock lang:objc %} [ downloadData:^(id responseData){ _data = responseData; }]; {% endcodeblock %}\n解决办法 {% codeblock lang:objc %} __weak ViewController *weakSelf = self; [ downloadData:^(id responseData){ weakSelf.data = responseData; }]; {% endcodeblock %} +(void)load; +(void)initialize;有什么用处 在Objective-C中，runtime会自动调用每个类的两个方法。+load会在类初始加载时调用，+initialize会在第一次调用类的类方法或实例方法之前被调用。这两个方法是可选的，且只有在实现了它们时才会被调用。 共同点：两个方法都只会被调用一次。 UIView和CALayer有什么关系 UIView是iOS界面元素的基础，所有的界面元素都继承于它。它本身是由CoreAnimation来实现的，它真正绘图的部分是由一个CALayer的类来管理的，UIView本身更像是一个CALayer的管理器。 UIView都存在一个layer属性，可以访问到CALayer的实例。 UIView的CALayer类也存在一个view树结构，可以像UIView一样进行添加 UIView的layer树在系统内部，由系统来维护，它存在着三棵树，分别是逻辑树，动画树，显示树 如何高性能的给UIImageView加个圆角 使用贝塞尔曲线来切割图片 使用Quartz2D直接绘制图片 使用drawRect有什么影响 drawRect方法依赖Core Graphics框架来进行自定义的绘制，但这种方法主要的缺点就是它处理touch事件的方式：每次按钮被点击后，都会用setNeddsDisplay进行强制重绘；而且不止一次，每次单点事件触发两次执行。这样的话从性能的角度来说，对CPU和内存来说都是欠佳的。 SDWebImage里面给UIImageView加载图片的逻辑是什么样的 详情看最新版SDWebImage的使用 麻烦你设计个简单的图片内存缓存器 图片的内存缓存，可以考虑将图片数据保存到一个数据模型中，所以在程序运行时这个模型都存在内存中，一定要具备移除策略，即释放数据模型。 讲讲你用Instrument优化动画性能的经历 怎么使用instrument loadView是干嘛用的 当你访问一个ViewController的view属性时，如果此时view的值是nil，那么，ViewController就会自动调用loadView这个方法。这个方法就会加载或者创建一个view对象，赋值给view属性。 loadView默认做的事情是：如果此ViewController存在一个对应的nib文件，那么就加载这个nib。否则，就创建一个UIView对象。 如果你用Interface Builder来创建界面，那么不应该重载这个方法。 如果你想自己创建view对象，那么可以重载这个方法。此时你需要自己给view属性赋值。你自定义的方法不应该调用super。如果你需要对view做一些其他的定制操作，在viewDidLoad里面去做。 iOS 的loadView 及使用loadView中初始化View注意的问题 用过CoreData或者SQLite吗？读写是分线程的吗？遇到过死锁没？咋解决的 参考CoreData与SQLite的线程安全 GCD里面有哪几种Queue？你自己建立过串行queue吗？背后的线程模型是什么样的 主队列 dispatch_main_queue(); 串行 ，更新UI 全局队列 dispatch_global_queue(); 并行，四个优先级：background，low，default，high 自定义队列 dispatch_queue_t queue; 可以自定义是并行：DISPATCH_QUEUE_CONCURRENT或者串行DISPATCH_QUEUE_SERIAL 为什么其他语言里叫函数调用， Objective-C里则是给对象发消息（或者谈下对runtime的理解） 网上关于runtime的资料非常多，其实这方面在平时的开发中使用非常非常之少，底层的黑魔法。 Objective-C特性：Runtime Objective-C Runtime 什么是method swizzling 在Objective-C中调用一个方法，其实是向一个对象发送消息，查找消息的唯一依据是selector的名字。利用Objective-C的动态特性，可以实现在运行时偷换selector对应的方法实现，达到给方法挂钩的目的。 详细的案例 runtime 如何实现 weak 属性 {% codeblock lang:objc %} OBJC_ASSOCIATION_ASSIGN OBJC_ASSOCIATION_RETAIN_NONATOMIC OBJC_ASSOCIATION_COPY_NONATOMIC OBJC_ASSOCIATION_RETAIN OBJC_ASSOCIATION_COPY objc_setAssociatedObject(self, \u0026amp;myKey, anObject, OBJC_ASSOCIATION_RETAIN); {% endcodeblock %} 可以自定义weak来实现内存管理，Apple已经为我们准备了常量。 参考 Associated Objects Objective-C Runtime 运行时之二：成员变量与属性 objc中向一个nil对象发送消息将会发生什么 objc的特性是允许对一个 nil 对象发送消息不会 Crash，因为会被忽略掉。 什么时候会报unrecognized selector的异常 调用一个不存在的方法 objc中向一个对象发送消息[obj foo]和objc_msgSend()函数之间有什么关系 {% codeblock lang:objc %} [obj foo]; //编译时会变成 objc_msgSend(obj,@selector(foo)); [obj foo:parameter]; //编译时会变成 objc_msgSend(obj,@selector(foo:),parameter); {% endcodeblock %} 31. 一个objc对象如何进行内存布局 可参考Objective-C内存布局 32. 一个objc对象的isa的指针指向什么？有什么作用？ isa是一个Class 类型的指针. 每个实例对象有个isa的指针,他指向对象的类，而Class里也有个isa的指针, 指向meteClass(元类)。元类保存了类方法的列表。当类方法被调用时，先会从本身查找类方法的实现，如果没有，元类会向他父类查找该方法。同时注意的是：元类（meteClass）也是类，它也是对象。元类也有isa指针,它的isa指针最终指向的是一个根元类(root meteClass).根元类的isa指针指向本身，这样形成了一个封闭的内循环。 33. 下面的代码输出什么 {% codeblock lang:objc %} @implementation Son : Father\n(id)init { self = [super init]; if (self) { NSLog(@\u0026quot;%@\u0026quot;, NSStringFromClass([self class])); NSLog(@\u0026quot;%@\u0026quot;, NSStringFromClass([super class])); } return self; } @end {% endcodeblock %} 输出Son runtime如何通过selector找到对应的IMP地址 id (*IMP)(id, SEL, \u0026hellip;) 这个函数使用当前CPU架构实现的标准的C调用约定。第一个参数是指向self的指针(如果是实例方法，则是类实例的内存地址；如果是类方法，则是指向元类的指针)，第二个参数是方法选择器(selector)，接下来是方法的实际参数列表。 前面介绍过的SEL就是为了查找方法的最终实现IMP的。由于每个方法对应唯一的SEL，因此我们可以通过SEL方便快速准确地获得它所对应的IMP，查找过程将在下面讨论。取得IMP后，我们就获得了执行这个方法代码的入口点，此时，我们就可以像调用普通的C语言函数一样来使用这个函数指针了。 通过取得IMP，我们可以跳过Runtime的消息传递机制，直接执行IMP指向的函数实现，这样省去了Runtime消息传递过程中所做的一系列查找操作，会比直接向对象发送消息高效一些。 Hybrid 混合开发 ","date":"2017-01-22T18:55:21Z","permalink":"https://it-boyer.github.io/post/old/swift/iOS%E9%9D%A2%E8%AF%95%E9%A2%98%E5%A4%A7%E9%9B%86%E5%90%88/","section":"post","tags":["iOS","资源"],"title":"iOS面试题大集合[转]"},{"categories":["学习笔记"],"contents":"视频服务 直播LVB\n开发指南 移动直播MLVB\n开发指南 移动直播是一套移动终端直播解决方案的集合，它以免费源码的形式向您展示：如何利用腾讯云直播(LVB)、点播(VOD)、云通信(IM) 和 对象存储(COS)等几项服务组合构建出适合您的直播解决方案。 快速集成方案 {% img 导图 https://mc.qcloudimg.com/static/img/92a464fc26bbe52fea8816f8e6061ef3/image.jpg 100% 200 集成导图 图片 %} 如果您想要在自己的 APP 里集成直播推流和播放功能，下面三步就能达成目标：\n开通直播服务 文档 集成 RTMP SDK RTMP SDK - iOS 平台播放 对接直播流管理 云端API - 如何获取推流URL？ 云端API - 如何构建房间列表？ 云端API - 如何管理直播流？ 小直播是有腾讯云研发团队提供的一套开源源码集，致力于以 DEMO 的形式向您展示：如何利用腾讯云直播(LVB)、点播(VOD)、云通信(IM) 和 对象存储(COS)等几项服务组合构建出适合您的直播解决方案。 ","date":"2017-01-22T18:55:21Z","permalink":"https://it-boyer.github.io/post/old/%E5%85%B6%E4%BB%96/%E8%85%BE%E8%AE%AF%E4%BA%91%E4%B9%8B%E5%B0%8F%E7%9B%B4%E6%92%AD%E5%BC%80%E5%8F%91/","section":"post","tags":["直播"],"title":"腾讯云之小直播开发"},{"categories":["解决方案"],"contents":"SVN was a great advance in its day, but it’s now clear that distributed version control systems are the way forward and that Git is the de facto standard. Having helped many clients migrate from SVN to Git, here are my notes for a pain-free transition that will preserve the tags and branches in your SVN repository.\n首先导入一个本地存储库 在本地创建一个存储库的目录 {% codeblock 新建目录 lang:bash http://www.sailmaker.co.uk/blog/2013/05/05/migrating-from-svn-to-git-preserving-branches-and-tags-3/#import-staging Create a local staging directory%} cd ~ mkdir staging cd staging {% endcodeblock %}\n注：staging 可以用任何你喜欢的字符串命名，也可以放在本地的任何目录中。\n初始化git svn 使用SVN标准库结构初始化 {% codeblock 标准初始化 lang:bash %} git svn init SVNRepo_ROOT_URL \u0026ndash;stdlayout \u0026ndash;prefix=svn/ {% endcodeblock %} SVNRepo_ROOT_URL: 这里svn_url是完全限定的URL下的标准目录，其目录下包括三个目录：trunk，branches， tags。 --prefix: 强烈建议使用svn/作为分支和标签的前缀：设置为 --prefix=svn/. 这样有助于防止Git用户混淆原声的Git分支和标签。\n使用SVN自定义库结构初始化 使用非标准的svn layout 来新建svn库，即可以根据自己喜好来自定义分支，标签目录： {% codeblock 非标准化 lang:bash %} git svn init SVN_URL -T Trunk -b Branches -t Tags \u0026ndash;prefix=svn/ {% endcodeblock %}\n查看配置信息 review命令 {% codeblock lang:bash %} review the config {% endcodeblock %} 会有以下信息输出： {% codeblock lang:bash %} svn-remote.svn.url=svn://svn.example.com svn-remote.svn.fetch=some/path/trunk:refs/remotes/svn/trunk svn-remote.svn.tags=some/path/tags/:refs/remotes/svn/tags/ {% endcodeblock %} 高级用户可以在执行之前，修改相关配置。 git config命令 {% codeblock lang:git %} git config \u0026ndash;local \u0026ndash;list 输出： core.repositoryformatversion=0 core.filemode=true core.bare=false core.logallrefupdates=true core.ignorecase=true core.precomposeunicode=true svn-remote.svn.url=https://huoshuguang@192.168.85.6/svn/PBBReader_Mac svn-remote.svn.fetch=trunk:refs/remotes/origin/trunk svn-remote.svn.branches=branches/:refs/remotes/origin/ svn-remote.svn.tags=tags/:refs/remotes/origin/tags/ remote.PBBReader.url=https://git.oschina.net/iTBoyer/PBBReader.git remote.PBBReader.fetch=+refs/heads/:refs/remotes/PBBReader/ branch.master.remote=PBBReader branch.master.merge=refs/heads/master remote.server.url=https://server.local/git/PBBReader.git remote.server.fetch=+refs/heads/:refs/remotes/server/ branch.v34.remote=PBBReader branch.v34.merge=refs/heads/v28 {% endcodeblock %}\n从远程SVN服务器拉取代码到新建的本地存储库 {% codeblock 拉取 lang:bash %} git svn fetch {% endcodeblock %}\n查看本地库状态 status {% codeblock status lang:bash %} git status {% endcodeblock %} 输出： {% codeblock 内容 lang:bash %}\nOn branch master nothing to commit (working directory clean) {% endcodeblock %}\n查看分支信息 {% codeblock branch lang:bash %} git branch -a {% endcodeblock %} 输出: {% codeblock lang:bash %}\nmaster remotes/svn/tags/0.1.0 remotes/svn/trunk {% endcodeblock %} 注意：SVN标记和分支（在这种情况下，没有任何分支机构）仅作为远程引用存在。\nSVN分支和标签转为本地git仓库中的标签和分支 SVN分支迁移 把远程svn分支转换为本地git仓库中的分支： {% codeblock 分支转分支 lang:bash %} for branch in git branch -r | grep \u0026quot;branches/\u0026quot; | sed 's/ branches\\///'; do git branch $branch refs/remotes/$branch done {% endcodeblock %}\nSVN标签迁移 把远程svn标签转换为本地git仓库中的标签 : {% codeblock tags转换tags lang:bash %} for tag in git branch -r | grep \u0026quot;tags/\u0026quot; | sed 's/ tags\\///'; do git tag -a -m\u0026quot;Converting SVN tags\u0026quot; $tag refs/remotes/$tag done {% endcodeblock %} SVN标签转为本地git分支 把远程svn标签转换为本地git仓库中的分支: {% codeblock 标签转分支 lang:bash %} for tag in git branch -r | grep \u0026quot;tags/\u0026quot; | sed 's/ tags\\///'; do git branch $tag refs/remotes/$tag done {% endcodeblock %} 在本地测试git命令push和clone操作 在推送到正式远程库之前，可以通过向本地git库中推送和clone操作。\n创建一个临时的git库，用于测试push和clone测试 在git中的说法，bare库是一个不存在工作空间备份的库。 {% codeblock bare创建 lang:bash %} cd ~ mkdir test cd test git init \u0026ndash;bare {% endcodeblock %} 这样，在~/test就生成了一个baregit库。\npush 测试 {% codeblock lang:bash %} cd ~/staging git remote add test ~/test git push \u0026ndash;all test git push \u0026ndash;tags test {% endcodeblock %} 把~/test的放在反引号中，反引号在命令行中会~自动补全为一个绝对路径。如果你给一个绝对路径或URL，可以省略反引号。 尽管它的名字，--all选项不推送tags，所以需要对标签单独push操作。\nclone 测试 {% codeblock lang:bash %} cd ~ mkdir aclone cd aclone git clone ~/test {% endcodeblock %} There should now be a clone with a working copy in ~/aclone/test. 在~/aclone/test目录中将会clone出一个工作空间备份，检查确保一切OK，这样就可以向正式服务器上推送。\nPush到正式git库中 如果你是正式库服务器（github，coding）的管理员，为本地git库设置一个空的git库。 以Unfuddle为例,路径如下： git@example.unfuddle.com:example/blah.git {% codeblock lang:bash %} cd ~/staging git remote add unfuddle REAL_HOST_URL git push \u0026ndash;all unfuddle git push \u0026ndash;tags unfuddle {% endcodeblock %} 在上面的例子中，制定了远程名：unfuddle而不是默认的origin。当然，你可以使用任何你喜欢的名字。\n清理操作 删除临时git库 {% codeblock lang:bash %} cd ~/staging git remote rm test {% endcodeblock %} staging库忽略test远程仓库.\n清除clone生成的库 {% codeblock lang:bash %} cd ~ rm -rf aclone rm -rf test {% endcodeblock %}\nEither keep or delete the staging repo 如果需要Git和SVN之间频繁交互，建议保留staging库这会节省你非常耗时的初始化： {% codeblock lang:bash %} git svn fetch {% endcodeblock %} 如果你确信svn是报废的，你可以删除： {% codeblock lang:bash %} cd ~ rm -rf staging {% endcodeblock %} 题外小贴士 在局域网内访问server搭建服务器提供的git服务： {% codeblock 小贴士 lang:bash https://confluence.atlassian.com/fishkb/unable-to-clone-git-repository-due-to-self-signed-certificate-376838977.html SSL证书问题 %} $ git clone https://\u0026hellip;/git/mupdf.git 错误：fatal: unable to access \u0026lsquo;https://\u0026hellip;./git/mupdf.git/\u0026rsquo;: SSL certificate problem: Invalid certificate chain {% endcodeblock %} 解决： {% codeblock lang:bash %} git config \u0026ndash;global http.sslVerify false {% endcodeblock %}\n","date":"2017-01-18T12:21:46Z","permalink":"https://it-boyer.github.io/post/old/git/%E8%BF%81%E7%A7%BBSVN%E5%BA%93%E5%88%B0git%E5%BA%93%E4%BF%9D%E7%95%99branchs%E5%92%8Ctags/","section":"post","tags":["git"],"title":"迁移SVN库到git库保留branchs和tags"},{"categories":["学习笔记"],"contents":"Error handling is the process of responding to and recovering from error conditions in your program. Swift provides first-class support for throwing, catching, propagating, and manipulating recoverable errors at runtime. Some operations aren’t guaranteed to always complete execution or produce a useful output. Optionals are used to represent the absence of a value, but when an operation fails, it’s often useful to understand what caused the failure, so that your code can respond accordingly. As an example, consider the task of reading and processing data from a file on disk. There are a number of ways this task can fail, including the file not existing at the specified path, the file not having read permissions, or the file not being encoded in a compatible format. Distinguishing among these different situations allows a program to resolve some errors and to communicate to the user any errors it can’t resolve. 举例，在读取和处理磁盘上的一个文件的数据时，会有有许多方法失败，包括指定的文件路径找不到，没有文件的读取权限，或文件编码格式不兼容。在这些不同情况下，就可以让程序提示用户导致程序无法执行的具体原因。\nRepresenting and Throwing Errors In Swift, errors are represented by values of types that conform to the Error protocol. This empty protocol indicates that a type can be used for error handling. 在swift中，错误类型是遵循Error 协议。\nSwift enumerations are particularly well suited to modeling a group of related error conditions, with associated values allowing for additional information about the nature of an error to be communicated. For example, here’s how you might represent the error conditions of operating a vending machine inside a game: swift枚举类型特别适合为一组错误条件建模，用来关联导致错误的真正原因的相关信息。例如： 一个在操作一台游戏机时的会出现的错误枚举类：\n1 2 3 4 5 enum VendingMachineError: Error { case invalidSelection case insufficientFunds(coinsNeeded: Int) case outOfStock } Throwing an error lets you indicate that something unexpected happened and the normal flow of execution can’t continue. You use a throw statement to throw an error. For example, the following code throws an error to indicate that five additional coins are needed by the vending machine: 抛出错误说明游戏出现异常，导致其他操作无法进行。这是需要通过Throw语句来抛出这个错误。例如，以下代码抛出了一个错误表明需要five：\n1 throw VendingMachineError.insufficientFunds(coinsNeeded: 5) Handling Errors When an error is thrown, some surrounding piece of code must be responsible for handling the error—for example, by correcting the problem, trying an alternative approach, or informing the user of the failure. 当错误抛出后，这段代码必须来处理这个错误。例如：通过纠正问题，尝试其他方式实现，或通知用户的失败。\nThere are four ways to handle errors in Swift. You can propagate the error from a function to the code that calls that function, handle the error using a do-catch statement, handle the error as an optional value, or assert that the error will not occur. Each approach is described in a section below. 在swift中有四种处理错误机制: 1. 向调用方法中传递这个错误 2. 使用do-catch语句处理 3. 把错误设置为可选型 4.断言不会出现异常的情况下，使用try!禁止异常抛出\nWhen a function throws an error, it changes the flow of your program, so it’s important that you can quickly identify places in your code that can throw errors. To identify these places in your code, write the try keyword—or the try? or try! variation—before a piece of code that calls a function, method, or initializer that can throw an error. These keywords are described in the sections below. 当一个方法抛出错误时，会打断程序正常的工作流，必须快速定位到可能抛出错误的代码。可以使用关键字try 要注意 try?或try!之间的差异。在调用一个函数，方法或者构造器之前，来抛出异常。\nPropagating Errors Using Throwing Functions To indicate that a function, method, or initializer can throw an error, you write the throws keyword in the function’s declaration after its parameters. A function marked with throws is called a throwing function. If the function specifies a return type, you write the throwskeyword before the return arrow (-\u0026gt;). 函数，方法或构造器都可以抛出异常，只需要在声明它们时添加关键字：throws即可，这种方法被称为throws函数，throws关键字位置在参数之后，返回值(-\u0026gt;)之前\nA throwing function propagates errors that are thrown inside of it to the scope from which it’s called. 抛出函数会把错误抛给调用它的函数周期中去。\nOnly throwing functions can propagate errors. Any errors thrown inside a nonthrowing function must be handled inside the function. 只有抛出函数能传递错误，如果不是抛出函数，它自己必须处理掉任何抛进来的错误。\nIn the example below, the VendingMachine class has a vend(itemNamed:) method that throws an appropriate VendingMachineError if the requested item is not available, is out of stock, or has a cost that exceeds the current deposited amount: 在下面的例子中，对某个请求内容不可用时，自动售货机会通过vend(itemNamed:)方法抛出一个对应的VendingMachineError错误，缺货或超过目前的存款金额成本：\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30 struct Item { var price: Int var count: Int } class VendingMachine { var inventory = [ \u0026#34;Candy Bar\u0026#34;: Item(price: 12, count: 7), \u0026#34;Chips\u0026#34;: Item(price: 10, count: 4), \u0026#34;Pretzels\u0026#34;: Item(price: 7, count: 11) ] var coinsDeposited = 0 func vend(itemNamed name: String) throws { guard let item = inventory[name] else { throw VendingMachineError.invalidSelection } guard item.count \u0026gt; 0 else { throw VendingMachineError.outOfStock } guard item.price \u0026lt;= coinsDeposited else { throw VendingMachineError.insufficientFunds(coinsNeeded: item.price - coinsDeposited) } coinsDeposited -= item.price var newItem = item newItem.count -= 1 inventory[name] = newItem print(\u0026#34;Dispensing \\(name)\u0026#34;) } } The implementation of the vend(itemNamed:) method uses guard statements to exit the method early and throw appropriate errors if any of the requirements for purchasing a snack aren’t met. Because a throw statement immediately transfers program control, an item will be vended only if all of these requirements are met. vend(itemNamed:)方法的实现中使用 guard语句来判断，当在购买操作不符合相应条件会直接抛出相应的错误，来打断该方法的其他操作。因为throw语句会立即转移程序控制权，保证了机器仅出售满足所有条件的物品。\nBecause the vend(itemNamed:) method propagates any errors it throws, any code that calls this method must either handle the errors—using a do-catch statement, try?, or try!—or continue to propagate them. For example, the buyFavoriteSnack(person:vendingMachine:) in the example below is also a throwing function, and any errors that the vend(itemNamed:) method throws will propagate up to the point where the buyFavoriteSnack(person:vendingMachine:) function is called. 因为vend(itemNamed:)的方法抛出所有错误，所以调用该方法的函数必须处理错误（ do-catch, try?, or try!处理，或使用try向上抛出）。\n例如，buyFavoriteSnack(person:vendingMachine:)也是一个抛出函数，从vend(itemNamed:)方法接受到的所有错误，都会被会buyFavoriteSnack(person:vendingMachine:)继续抛给调用它的函数中。\n1 2 3 4 5 6 7 8 9 10 let favoriteSnacks = [ \u0026#34;Alice\u0026#34;: \u0026#34;Chips\u0026#34;, \u0026#34;Bob\u0026#34;: \u0026#34;Licorice\u0026#34;, \u0026#34;Eve\u0026#34;: \u0026#34;Pretzels\u0026#34;, ] func buyFavoriteSnack(person: String, vendingMachine: VendingMachine) throws { let snackName = favoriteSnacks[person] ?? \u0026#34;Candy Bar\u0026#34; try vendingMachine.vend(itemNamed: snackName) } In this example, the buyFavoriteSnack(person: vendingMachine:) function looks up a given person’s favorite snack and tries to buy it for them by calling the vend(itemNamed:) method. Because the vend(itemNamed:) method can throw an error, it’s called with the trykeyword in front of it. buyFavoriteSnack(person: vendingMachine:) 函数查找买家中意的snake，并vend(itemNamed:)调用尝试购买。使用在方法前使用try关键字来抛出异常，并向上传递。\nThrowing initializers can propagate errors in the same way as throwing functions. For example, the initializer for the PurchasedSnackstructure in the listing below calls a throwing function as part of the initialization process, and it handles any errors that it encounters by propagating them to its caller. 抛出构造器也能向抛出函数一样传递错误，例如：PurchasedSnackstructure的构造器中调用了抛出函数：vend(itemNamed:)，抛出构造器可以通过向上传递来处理这些错误。\n1 2 3 4 5 6 7 8 struct PurchasedSnack { let name: String init(name: String, vendingMachine: VendingMachine) throws { try vendingMachine.vend(itemNamed: name) self.name = name } } Handling Errors Using Do-Catch You use a do-catch statement to handle errors by running a block of code. If an error is thrown by the code in the do clause, it is matched against the catch clauses to determine which one of them can handle the error. 使用do-catch语句通过运行代码块来处理错误。在do分句中如果抛出了一个错误，那么就可以在catch分句中进行处理的匹配到错误 Here is the general form of a do-catch statement:\n1 2 3 4 5 6 7 8 do { try expression statements } catch pattern 1 { statements } catch pattern 2 where condition { statements } You write a pattern after catch to indicate what errors that clause can handle. If a catch clause doesn’t have a pattern, the clause matches any error and binds the error to a local constant named error. For more information about pattern matching, see Patterns. 在关键字catch后边跟随匹配模式，这个catch分句就会处理匹配到的错误，如果关键字catch分句没有任何匹配模式，那么这个分句将会匹配到所有错误，并把这些错误信息赋值给系统常量error。\nThe catch clauses don’t have to handle every possible error that the code in its do clause can throw. If none of the catch clauses handle the error, the error propagates to the surrounding scope. However, the error must be handled by some surrounding scope—either by an enclosing do-catch clause that handles the error or by being inside a throwing function. For example, the following code handles all three cases of the VendingMachineError enumeration, but all other errors have to be handled by its surrounding scope: catch分句不必对do分句中的代码可能抛出每一个的错误，如果某个错误没有被catch分句匹配到处理，这个错误将会传递到调用它的函数周期中，这个错误必须在这个函数周期中处理，或通过do-catch语句来处理，或通过内部的抛出函数处理。\n例如，下面的代码处理VendingMachineError枚举类中的三个错误cases，但其他的错误都是由其周边范围处理：\n1 2 3 4 5 6 7 8 9 10 11 12 var vendingMachine = VendingMachine() vendingMachine.coinsDeposited = 8 do { try buyFavoriteSnack(person: \u0026#34;Alice\u0026#34;, vendingMachine: vendingMachine) } catch VendingMachineError.invalidSelection { print(\u0026#34;Invalid Selection.\u0026#34;) } catch VendingMachineError.outOfStock { print(\u0026#34;Out of Stock.\u0026#34;) } catch VendingMachineError.insufficientFunds(let coinsNeeded) { print(\u0026#34;Insufficient funds. Please insert an additional \\(coinsNeeded) coins.\u0026#34;) } // Prints \u0026#34;Insufficient funds. Please insert an additional 2 coins.\u0026#34; In the above example, the buyFavoriteSnack(person:vendingMachine:) function is called in a try expression, because it can throw an error. If an error is thrown, execution immediately transfers to the catch clauses, which decide whether to allow propagation to continue. If no error is thrown, the remaining statements in the do statement are executed. 在上述代码中因为buyFavoriteSnack(person:vendingMachine:)函数会抛出错误异常，所以要在try表达式中调用。如果抛出异常就会立马执行是否继续传递的catch分句，如果没有抛出异常，会保持do分句中的代码正常进行。\nConverting Errors to Optional Values You use try? to handle an error by converting it to an optional value. If an error is thrown while evaluating the try? expression, the value of the expression is nil. For example, in the following code x and y have the same value and behavior: 使用try?表达式处理错误，是通过把错误转换为可选值(?)类型处理。在try?表达式中出现抛出错误时，这个表达式的值=nil。\n1 2 3 4 5 6 7 8 9 10 func someThrowingFunction() throws -\u0026gt; Int { // ... } let x = try? someThrowingFunction() let y: Int? do { y = try someThrowingFunction() } catch { y = nil } If someThrowingFunction() throws an error, the value of x and y is nil. Otherwise, the value of x and y is the value that the function returned. Note that x and y are an optional of whatever type someThrowingFunction() returns. Here the function returns an integer, so xand y are optional integers. 如果函数someThrowingFunction()抛出异常，x,y = nil，否则:x,y就时函数return的值。\n注意：x,y是一个可选的someThrowingFunction()返回类型。在这里函数返回integer，那么x,y是可选的integer类型。\nUsing try? lets you write concise error handling code when you want to handle all errors in the same way. For example, the following code uses several approaches to fetch data, or returns nil if all of the approaches fail. 当用这种方式来处理所有错误时，使用try?表达式能写更简洁的错误处理代码，例如：下面的代码使用几种方法来获取数据，如果这些方法失败就会返回nil。\n1 2 3 4 5 func fetchData() -\u0026gt; Data? { if let data = try? fetchDataFromDisk() { return data } if let data = try? fetchDataFromServer() { return data } return nil } Disabling Error Propagation Sometimes you know a throwing function or method won’t, in fact, throw an error at runtime. On those occasions, you can write try! before the expression to disable error propagation and wrap the call in a runtime assertion that no error will be thrown. If an error actually is thrown, you’ll get a runtime error. 有时你认为不会出现异常的抛出函数或方法，但事实上，却在运行时抛出异常了。在其他情况下，可以使用try!表达式来禁止错误传递，并且十分肯定断言在运行时不会有异常抛出。如果有异常抛出，就会得到一个运行时错误。\nFor example, the following code uses a loadImage(atPath:) function, which loads the image resource at a given path or throws an error if the image can’t be loaded. In this case, because the image is shipped with the application, no error will be thrown at runtime, so it is appropriate to disable error propagation. 例如：使用loadImage(atPath:)函数要么通过这个路径加载image，要么image加载失败抛出一个错误。在这种情况下，因为image在app资源目录resources中，所以在运行时肯定不会有异常抛出。因此可以使用try!禁止错误传递。\n1 let photo = try! loadImage(atPath: \u0026#34;./Resources/John Appleseed.jpg\u0026#34;) Specifying Cleanup Actions You use a defer statement to execute a set of statements just before code execution leaves the current block of code. This statement lets you do any necessary cleanup that should be performed regardless of how execution leaves the current block of code—whether it leaves because an error was thrown or because of a statement such as return or break. For example, you can use a defer statement to ensure that file descriptors are closed and manually allocated memory is freed. 在代码执行离开当前代码块之前，使用一个“defer语句”来执行一组语句。defer语句让做一些必要的清理操作，在执行如何离开当前代码块：因为抛出异常或者因为return，break语句导致。例如：使用defer语句执行关闭文件和内存的释放操作，来确保清理操作完成。\nA defer statement defers execution until the current scope is exited. This statement consists of the defer keyword and the statements to be executed later. The deferred statements may not contain any code that would transfer control out of the statements, such as a break or a return statement, or by throwing an error. Deferred actions are executed in reverse order of how they are specified—that is, the code in the first defer statement executes after code in the second, and so on. defer语句推迟在直到当前作用域推出时，再执行。defer语句由defer关键字和一些清理操作语句组成。defer语句不包含transfer control out of the statements例如（return，break，throw）等。\ndefer延迟操作是按照指定的顺序执行的，就是先执行最后一个defer语句中的代码之后，再执行第倒数第二个defer语句的代码，以此类推，倒叙清理退场。\n1 2 3 4 5 6 7 8 9 10 11 12 13 func processFile(filename: String) throws { if exists(filename) { let file = open(filename) defer { close(file) } while let line = try file.readline() { // Work with the file. } // close(file) is called here, at the end of the scope. } } The above example uses a defer statement to ensure that the open(_:) function has a corresponding call to close(_:). 使用defer语句，确保了在open的同时与之相关的还有close。\nYou can use a defer statement even when no error handling code is involved. 即使在没有涉及错误处理代码的时候，也可以使用“延迟”语句。\n","date":"2017-01-11T17:04:21Z","permalink":"https://it-boyer.github.io/post/old/swift/%E9%94%99%E8%AF%AF%E5%A4%84%E7%90%86/","section":"post","tags":["swift"],"title":"swift错误处理"},{"categories":["解决方案"],"contents":"build setting预编译位置 Preprocessor Macros Other Swift Flags 为生产和开发target配置预处理宏/编译器标识。之后我们就可以使用该标识在我们的代码来检测应用程序正在运行的版本。\nObjective-C项目中Preprocessor Macros 配置 添加位置：选择项目中对应的target名-\u0026gt;在Build Settings下Apple LLVM 7.0 - Preprocessing-\u0026gt;Preprocessor Macros。 添加变量：在Rebug和Release区域添加一个变量DEVELOPMENT 对应target1: 设DEVELOPMENT=1表示开发版 对应target2: 设DEVELOPMENT=0表示生产版\n使用 根据已配置的宏DEV_VERSION，我们可以在代码中利用它动态地编译项目。下面是一个简单的例子： Objective-C中使用＃if检查DEVELOPMENT的环境，并相应的设置URLs/ API密钥。\n1 2 3 4 5 6 7 #if DEVELOPMENT #define SERVER_URL @\u0026#34;http://dev.server.com/api/\u0026#34; #define API_TOKEN @\u0026#34;DI2023409jf90ew\u0026#34; #else #define SERVER_URL @\u0026#34;http://prod.server.com/api/\u0026#34; #define API_TOKEN @\u0026#34;71a629j0f090232\u0026#34; #endif Swift中Other Swift Flags 对于swift的项目，编译器不再支持预处理指令。作为替代，它使用编译时的属性和build配置。\n配置 选中开发target，添加一个标识表示开发版本 选中target -\u0026gt; Build Setting-\u0026gt;Swift Compiler - Custom Flags-\u0026gt;将值设为-DDEVELOPMENT表示这个target作为开发版本。\n使用 Swift中你仍然可以使用#if判定build的参数动态编译。然而，除了使用#define定义基本常量，在swift中我们也可以用let定义一个全局常量。\n1 2 3 4 5 6 7 #if DEVELOPMENT let SERVER_URL = \u0026#34;http://dev.server.com/api/\u0026#34; let API_TOKEN = \u0026#34;DI2023409jf90ew\u0026#34; #else let SERVER_URL = \u0026#34;http://prod.server.com/api/\u0026#34; let API_TOKEN = \u0026#34;71a629j0f090232\u0026#34; #endif 参照\n","date":"2017-01-11T13:49:33Z","permalink":"https://it-boyer.github.io/post/old/iOS/%E5%9C%A8OC%E5%92%8Cswift%E4%B8%AD%E5%8C%BA%E5%88%86%E5%A4%9A%E4%B8%AAtargets/","section":"post","tags":["xcode"],"title":"在OC和swift中区分多个targets"},{"categories":["学习笔记"],"contents":"Swift 语言指南 @SwiftLanguage 更新于 2016-6-6，更新内容详见 Issue 55。往期更新回顾详见《收录周报》\n这份指南汇集了 Swift 语言主流学习资源，并以开发者的视角整理编排。对于精选项目及文章，可直接访问《Swift 项目精选》和《Swift 文章精选》。还有开发者们自己维护的《开发者、项目、最佳实践》。当然也不能错过那些活跃、优秀的《开发者个人资料页》。\n入门指引 苹果为 Swift（中文介绍）开发者提供的官方文档入口，包括 概述，博客（中文镜像）及 开发资源。其中以下几份文档（Swift 2.1）为入门级必备（iBooks 版）：\nSwift Programming Language（中文版｜PDF 版 By SwiftGG翻译组）\nStart Developing iOS Apps\nUsing Swift with Cocoa and Objective-C（中文版 By @CocoaChina）\n苹果同时也维护着相应 Beta 版（Swift 2.2）文档：Swift Programming Language，Start Developing iOS Apps，Using Swift with Cocoa and Objective-C。\n学习实践的角度，标准库示例代码 Swift Standard Library.playground 是很棒的学习伴侣。\n教程方面，苹果力荐了斯坦福课程 Stanford University: Developing iOS 8 Apps with Swift（中文字幕版 By @网易公开课）\n除以上所涉及入门级文档，iOS Developer Library 还为开发者提供了更庞大、系统化的开发文档支持。\n以下列举了几份已有第三方中文翻译文档：\nAPI Design Guidelines（中文版 By @SwiftGG翻译组） App Extension Programming Guide（中译镜像） iOS Human Interface Guidelines（中文版｜PDF 版 By @腾讯ISUX） HomeKit Developer Guide（中文版 By @CocoaChina） 值得称道的还有：苹果为 Apple TV Tech Talks 和 WWDC 2015 的视频添加简体中文字幕，从而方便中国开发者观看来自官方的权威技术分享。\n有关于 Swift 开源及跨平台开发，可以关注 swift.org\n教程文章 开源项目 推荐网站 苹果官方\nSwift：Swift 概述、博客以及开发资源。\nswift.org：开源后独立出来的 Swift 开源社区。\nGitHub:apple：苹果在 GitHub 上的开源项目。\nGitHub:apple/swift：swift 语言在 GitHub 上的开源项目。\nksm/SwiftInFlux：作者（Karol Mazur）将 Apple Developer Forums 上有关 Swift 特性、缺陷及变更讨论分类汇总并更新到 GitHub，具有很好的可读性。从中可以一窥 Swift 缺陷及未来潜在地变化。最关键地是有 Chris Lattner 及核心团队答疑解惑。\nraywenderlich.com(中文版)：由Ray Wenderlich创建，专注于开发高质量编程指南（近期优质Swift文章及视频教程不断），著名的iOS/OS X博客及开发教程网站，非常适合新手学习。近期第一时间出了三本 Swift 新书。\nNatasha The Robot： 时髦码农不容错过的 Swift 开发实战教程类网站。为了简化学习复杂性，每一篇文章涵盖技术点单一又独立，配以开发步骤、运行结果以及代码等标准方式教授。难能可贵的是，它往往出品“追剧式”（最新开发特性或API跟进式）教程，实在是开发者必藏精品网站。\nNShipster (中译版：@刘镇夫，April Peng，@李乐佳，@程序员付恒 等翻译)：著名开源作者 Matt Thompson 创建的开发技术博客网站，他开发了 AFNetworking 网络库，也是非常多产的开源作者。更多了解参考：《COCOA 潮人 MATTT THOMPSON》 By @程序员付恒\njamesonquave.com：移动开发者，优秀个人博客（近期文章同样关注于Swift 语言，写得很优质）。同时他将于8/30发布一本新书《Developing iOS 8 Apps in Swift》 (Learn To Make Real World iOS 8 Apps)及视频教程。\nobjc.io(中译版 By @onevcat 及其朋友们)：\u0026ldquo;关于 Objective-C 最佳实践和先进技术的期刊。 由 Chris Eidhof, Daniel Eggert 和 Florian Kugler 成立于柏林。我们成立 objc.io 的目的是针对深入的、跟所有 iOS 和 OS X 开发者相关的技术话题创造一个正式的平台。“\niOSCreator：这类开发指引式教程对于初学者来讲，是直接明了的有效学习资源。推荐者@荧星诉语\niOS Dev Weekly：收录一周以来 iOS 开发资讯链接，并于周五发布。由 Dave Verwer 创办，他是一位 iPhone 和 iPad 开发者以及培训师。\nAppcoda.com：质量很高的一个 iOS 开发教程站，其中iOS Programming Course这个专题很适合刚接触 iOS 开发的新手学习。\n中文 iOS/Mac 开发博客列表：By @唐巧_body\ndevtalking.com：高产的中译博客。翻译了官方博客 Swift Blog - Apple Developer,《App Extension Programming Guide》。参与翻译了《Swift Programming Language》等。\nSwiftGG：一个走心的 Swift 翻译组，由《The Swift Programming Language》中文版翻译团队原班人马组成， 翻译的文章来源于国外的优秀 Swift 网站和博客，且全部获得作者和网站授权。\nSwift Weekly Brief：“这个博客现在每周会将Swift开源中的重要讨论和提交整理成Open source Swift weekly brief，这对一线开发者尽早了解这门语言的动态情报很有帮助。By @崔康总编 ”。来源：Jesse Squires\nSwift Developer Weekly:这个网站每周推送最新的技术文章和书本推荐到你的email，由Phil Wright创办。\niosdevtips.co：iOS Development Tips\n资源合集\n以下是其它开发者社区或 Swift 爱好者整理的有关 Swift 语言学习的资源列表。\nSwiftEducation：“这是建立在 GitHub 上的一个 Swift 学习资料汇集，包括了有关幻灯和多个练手的应用程序源码。By @极客头条”。的确有不少基础实用的好教程。这对于基础学起的同学有福了。 Awesome-Swift-Education：整理地如此美妙的学习资源，实在让人太欢喜了。 iOS Cookies：分类合理、排序靠谱的 Swift 开源类库集合。 matteocrippa/awesome-swift：这个版本的 Swift 资源集合内容丰富，分类也不错。作者：Matteo Crippa 适合iOS开发者的 15 大网站推荐：的确很全、很主流的国外 iOS 开发者网站。 掘金 Swift 版块 码农周刊 －《Swift 特刊》 CocoaChina －《Swift 新手入门汇集帖》 CSDN_CODE －《Swift 编程语言资料大合集》 InfoQ －《学习苹果 Swift 语言的一些在线资源（英文）》 刘兰涛 －《Swift 学习资源》 By @懒桃儿吃桃儿 learnswift.tips：国外主流 Swift 学习资源集合。 Awesome iOS：一个 iOS 的各类优秀的开源项目集合。真不错！可惜Swift开源项目资源不足。 iOS Developer Tips：还是有关 iOS 的开发资源及文章合集。 Wolg/awesome-swift：一位俄罗斯朋友分类整理的 Swift 资源列表（有持续更新）。 Aufree/trip-to-iOS：显然作者很用心的做了非常深入的整理。它对于开发者拓展学习范围及开发知识面非常有益。 Robin Eggenkamp - Awesome Swift：“一个收集了很多 Swift 开发资源的网站”。 iOS 开发技术前线：“一个定期翻译、发布国内外iOS优质的技术、开源库、软件架构设计、测试等文章的开源项目”。主要翻译来源 Ray Wenderlich，App Coda，Medium。来源：@开发技术前线 11个超棒的 iOS 开发学习网站：还算比较主流的归纳。不过，缺了raywenderlich.com 和 ioscreator.com 这两个重量级教程网站实在是不应该啊。 开发工具 1. 编程工具 Xcode 下载：苹果应用集成开发环境。支持 C/C++, Objective C, Swift 等。不用购买开发者计划，直接下载。 Textmate：Mac OS X 上一个可高度自定义的编辑器，尤其在我想做出一个快速改变但又不想等待 Xcode 加载的时候。该工具目前已经开源 Mou ($)：OS X 上一款 Markdown 的编辑器。非常适用于编写自述文件、变更日志以及其他方面的内容。作者：罗晨 Sublime Text ($)：Mac OS X 上另一款非常受欢迎的轻量级，可高度自定义的编辑器。 RunSwift:正在犹豫是否入手苹果电脑开始一段 Swift 编程旅程的同学们，或仅仅为了试验一段简单 Swift 代码又懒得打开 Xcode，可以试试这款 Web 版 Swift 编译环境 RunSwift。 InfinitApps - Bezel：“嫌 Xcode 6 目前提供的 Watch 模拟器不够直观？Bezel 是一个用于视觉预览 WatchKit 所开发程序效果的小工具，前提是你安装了 xScope 软件（Mac端）或 xScopeMirror（iPhone端）。 By @WatchKit开发” Markdown -\u0026gt; Playground：该开源项目可将内含有 Swift 代码的 Markdown 自动转换为 Xcode Playgrounds 文件。喜欢用 Markdown 编辑的同学很激动吧。P.S. 这款工具写于 NodeJS，原因作者有交待。 iOS/Mac Autolayout Constraints：这个工具不错，很直观，布局时可以省不少工夫。推荐者：@荧星诉语 在线生成 AppStore 审核用截图：便捷的生产力工具。免费，易操作，可自定义。 IBM Swift Sandbox：IBM的在线Swift网站，需要翻墙。 SwiftStub：另外一个Swift在线练习网站。 2. 代码管理 GitHub：声望日盛的资源分享之地。 GitHub for Mac：一个设计的非常美观的 git 客户端，不能取代你从命令行获得的所有功能，但使用起来非常简单。 GitCafe：GitCafe is a source code hosting service based on version control system Git。国内的代码托管服务，基于 Git，值得一提的是最近也推出了和 GitHub Pages 类似的服务 Gitcafe Pages。因为是在国内，所以相比较 GitHub 有速度优势，在网络环境差的情况下也许可以作为 GitHub 的备用。 Bitbucket：国外的代码托管服务，不同于 GitHub 的是，Bitbucket 可以免费建立 private 项目。 Git：分布式版本控制系统和源码管理系统，其优点是：快和简单易用。对于新手来说，可在此查看免费电子书籍。 SourceTree：A free Git \u0026amp; Mercurial client for Windows or Mac.免费的Git和Mercurial客户端，当然也可以配合Bitbucket使用。 3. Xcode 插件 CocoaPods：第三方库的管理利器，允许你简单地把第三方库整合进自己的应用中。对我个人来说，我基本上每个项目都使用 CocoaPods。 CocoaPods Xcode Plugin：一款 Xcode 插件，允许你直接从 Xcode 管理 CocoaPod 依赖。 onevcat/VVDocumenter-Xcode：快捷注释 Xcode 插件。By @onevcat ColorSense：一款显示颜色数值的插件，还可以直接通过系统的ColorPicker来自动生成对应颜色代码 Xcode 优秀插件整理:持续保持整理更新的 Xcode 插件整理 By @ddapps CodeEagle/SwiftCodeSnippets：自动下载指定 Xcode Snippet 源的 Xcode Plugin。项目缺省提供 Snippet 代码源 burczyk/XcodeSwiftSnippets 。 realm/SwiftLint：Realm 采用 Swift 编写的基于 GitHub\u0026rsquo;s Swift Style Guide 规则的检查工具。除了命令行运行方式，也提供集成 Xcode 的方法。对于新团队，这样的工具可以自动约束大家遵循编程规范。 XCode 升级后插件失效的原理与修复办法：由一条命令引发的分析文章。@_TongJZ feinstruktur/CoPilot：通过此插件，Xcode 可以协同编程了（采用 WebSocket 通讯）。如此强大的“黑工具”，不爱它能行吗。演示视频 Carthage：新兴起的去中心化的依赖管理器，目标是用最简单的方式来管理Cocoa第三方框架。优势很明显，但是也有不足，看后面的发展吧。 4. 管理工具 swiftenv：Swift 版本管理器。类似 rvm（Ruby）, nvm（Node.js）。 HomeBrew：OS X 上非常出色的包管理工具。 Transmit ($)：一个Mac OS X 上 FTP 客户端，有着非常漂亮的用户界面和有用的功能。 5. 调试工具 mattt/fuckingclangwarnings.com：警告与语义对照表。以后再也不用为 Xcode 各种警告纠结啦！By @foogry 6. 设计工具 sketch：更适合开发应用的矢量设计工具。通过插件还支持与代码协同工作。推荐书籍：Learn Sketch 3 PaintCode :PaintCode是Apple Designer入门APP开发最合适的辅助工具之一，她可以把你绘制的矢量UI自动转化为适用于iOS/OS X的Objective-C代码。 7. 发布工具 Frabic fastlane Xcode Server 7. 开源项目 RESideMenu侧滑布局类库,支持左右滑动，滑动距离; IQKeyboardManager易于集成，支持设备的方向，可通过类的方法来启用和禁用键盘管理器； ACPDownload实现类似AppStore下载状态样式； TCBlobDownload支持后台线程执行大文件下载任务，暂停和重新恢复下载； MobShareSDK实现微信朋友，朋友圈分享; BlocksKit没有创建新的宏，函数，方法和类，仅对Cocoa基础类的一个扩展，是取代了通常的delegate用法; SDWebImage图片缓存的框架; MJRefresh下拉刷新上拉加载更多MJRefresh类库; ToastAndroid风格的Toast控件,用户提示便捷得体； IQLabelView对文本控件覆盖，缩放和旋转； AFNetworking RestKit处理web服务api,解析JSON映射响应对象； Masonry一个轻量级的布局框架,拥有自己的描述语法，采用更优雅的链式语法封装自动布局； *Perfect 服务器\n媒体报道 开放平台 Apple Watch 指南 ","date":"2017-01-03T17:05:20Z","permalink":"https://it-boyer.github.io/post/old/swift/SwiftGuide/","section":"post","tags":["swift","iOS"],"title":"Swift 语言指南[转]"},{"categories":["学习笔记"],"contents":"安装Docker for Mac 在Mac上运行Docker。系统要求，OS X 10.10.3 或者更高版本，至少4G内存，4.3.30版本以前的VirtualBox会与Docker for Mac产生冲突，所以请卸载旧版本的VitrualBox。\n1 2 3 4 5 6 7 echo \u0026#39;下载dmg...\u0026#39; curl -o Docker.dmg https://dn-dao-github-mirror.qbox.me/docker/install/mac/Docker.dmg #安装Docker.dmg MOUNTDIR=$(echo `hdiutil mount Docker.dmg | tail -1 \\ | awk \u0026#39;{$1=$2=\u0026#34;\u0026#34;; print $0}\u0026#39;` | xargs -0 echo) \\ \u0026amp;\u0026amp; cd ${MOUNTDIR} \u0026amp;\u0026amp; cp -R Docker.app /Applications/ \\ \u0026amp;\u0026amp; open /Applications/Docker.app 配置 Docker 加速器镜像源 国内加速器 右键点击桌面顶栏的 docker 图标，选择 Preferences ，在 Advanced 标签下的 Registry mirrors 列表中加入下面的镜像地址:\n1 http://f1361db2.m.daocloud.io 点击 Apply \u0026amp; Restart 按钮使设置生效。\n安装主机监控程序加速器 登录到 DaoCloud 控制台，点击「我的集群」按钮，在「接入自有主机」界面，点击 Mac 按钮。 安装DockerToolbox，是一个完整的开发组件，通过安装和配置DaoCloud加速器 v2，提升下载 Docker Hub 镜像的速度。 1 2 3 4 //下载pkg curl -o DockerToolbox.pkg https://github.com/docker/toolbox/releases/download/v18.09.0/DockerToolbox-18.09.0.pkg //安装pkg sudo installer -pkg DockerToolbox.pkg -target / 安装Toolbox好了，下一步： $ docker-machine start default启动 Docker. 当执行后提示：Host does not exist: \u0026quot;default\u0026quot; {% codeblock docker-machine create http://stackoverflow.com/a/38602630 stackoverflow %} docker-machine create -d virtualbox default {% endcodeblock %} 在 Docker 主机 DaoCloud 加速器的组件包： 1 curl -sSL https://get.daocloud.io/daomonit/install.sh | sh -s d0312f829e9807ee0bf157****** 启动组件包,会在「安装主机监控程序」的 DaoCloud 控制台页面下方显示一台已经接入的主机。 执行Dao Pull命令,高速下载Docker Hub镜像文件 这台 Docker 主机已经被接入 DaoCloud 平台，用户可以在 DaoCloud 控制台的「我的集群」页面发现这台主机，可以执行管理和部署应用的操作。 从Docker Hub 仓库中获取一个镜像 Docker 使用类似 git 的方式管理镜像。通过基本的镜像可以定制创建出来不同种应用的 Docker 镜像。Docker Hub 是 Docker 官方提供的镜像中心。在这里可以很方便地找到各类应用、环境的镜像。由于 Docker 使用联合文件系统，所以镜像就像是夹心饼干一样一层层构成，相同底层的镜像可以共享。所以 Docker 还是相当节约磁盘空间的。要使用一 个镜像，需要先从远程的镜像注册中心拉取，这点非常类似 git。\n1 docker pull ubuntu Docker 命令创建管理容器 获取镜像的两种方式 1. docker pull命令 1 2 docker search perfectlysoft/ubuntu docker pull perfectlysoft/ubuntu 2. docker import命令 1 docker import myubuntu.tar.gz 通过镜像创建容器 创建一个容器有两种方式：\n1 2 docker create 镜像名 docker run 镜像名 //立即启动容器 等价于：create + start 命令组合 进入容器终端控制台如下：\n1 2 3 root@ec72dc76502e:/# ls app boot etc lib media opt root sbin sys usr bin dev home lib64 mnt proc run srv tmp var docker run images命令 样例1 执行run images，并将 Ubuntu 的 Shell 作为入口，进入Docker容器环境操作 1 docker run -it ubuntu:latest sh -c \u0026#39;/bin/bash\u0026#39; 样例2 执行docker start -i 容器命令进入容器环境 1 docker start -i 容器ID/容器名 从KitematicGUI进入容器环境 1 bash -c \u0026#34;clear \u0026amp;\u0026amp; docker exec -it perfectswift sh\u0026#34; 参数 -i 表示这是一个交互容器，会把当前标准输入重定向到容器的标准输入中，而不是终止程序运行 -t 指为这个容器分配一个终端\n这时候我们成功创建了一个 Ubuntu 的容器，并将当前终端连接为这个 Ubuntu 的 bash shell。这时候就可以愉快地使用 Ubuntu 的相关命令了。\nps 查看容器状态 在容器运行期间，我们可以通过 docker ps 命令看到所有当前正在运行的容器。 添加-a参数可以看到所有创建的容器：\n1 docker ps -a 容器ID标识 每个容器都有一个唯一的 ID 标识，通过 ID 可以对这个容器进行管理和操作。在创建容器时，我们可以通过 \u0026ndash;name 参数指定一个容器名称，如果没有指定系统将会分配一个，就像这里的「trusting_morse」。\n启动/退出/移除容器 启动：start\n1 docker start -i trusting_morse 注意：每次执行 docker run 命令都会创建新的容器，建议一次创建后，使用 docker start/stop 来启动和停用容器。\n退出： 按 Ctrl+D 退出\n移除：rmID/name\n1 docker rm [CONTAINER ID/NAMES] 重命名：rename\n1 docker rename 容器ID newName 创建管理镜像 Docker 强大的威力在于可以把自己开发的应用随同各种依赖环境一起打包、分发、运行。要创建一个新的 Docker 镜像，通常基于一个已有的 Docker 镜像来创建。 Docker 提供了两种方式来创建镜像：\n把容器创建为一个新的镜像 使用 Dockerfile 创建镜像。 将容器创建为镜像 为了创建一个新的镜像，我们先创建一个新的容器作为基底： 1 docker run -it ubuntu:latest sh -c \u0026#39;/bin/bash\u0026#39; 定制这个容器，例如我们可以配置 PHP 环境、将我们的项目代码部署在里面等： 1 2 apt-get install php # some other opreations ... 当执行完操作之后，我们按 Ctrl+D 退出容器. 3. 获取定制后的容器ID\n1 2 3 4 5 docker ps -a [root@localhost ~]# docker ps -a CONTAINER ID IMAGE COMMAND CREATED STATUS PORTS NAMES cb2b06c83a50 ubuntu:latest \u0026#34;sh -c /bin/bash\u0026#34; 7 minutes ago Exited (0) 7 seconds ago trusting_morse 执行docker commit 把这个容器变为一个镜像： 1 docker commit cb2b06c83a50 ubuntu:myubuntu 这时候 docker 容器会被创建为一个新的 Ubuntu 镜像，版本名称为 myubuntu。以后我们可以随时使用这个镜像来创建容器了，新的容器将自动包含上面对容器的操作。 5. 打包/发布镜像\n1 docker save -o myubuntu.tar.gz ubuntu:myubuntu 导入打包镜像 1 docker import myubuntu.tar.gz Dockerfile 通过Dockerfile创建镜像 1 docker build yourDir/Dockerfile 确保Dockerfile文件在一个目录中，否则会提示错误\nDocker Hub 提供了类似 GitHub 的镜像存管服务。一个镜像发布到 Docker Hub 不仅可以供更多人使用，而且便于镜像的版本管理。在一个企业内部可以通过自建 Docker Registry 的方式来统一管理和发布镜像。将 Docker Registry 集成到版本管理和上线发布的工作流之中，还有许多工作要做，在我整理出最佳实践后会第一时间分享。 使用命令行的方式创建 Docker 镜像通常难以自动化操作。在更多的时候，我们使用 Dockerfile 来创建 Docker 镜像。Dockerfile 是一个纯文本文件，它记载了从一个镜像创建另一个新镜像的步骤。撰写好 Dockerfile 文件之后，我们就可以轻而易举的使用 docker build 命令来创建镜像了。 Dockerfile 非常简单，仅有以下命令在 Dockerfile 中常被使用：\n命令 参数 说明 # - 注释说明 FROM [:] 从一个已有镜像创建，例如ubuntu:latest MAINTAINER Author some-one@example.com 镜像作者名字，如Max Liu some-one@example.com RUN 或者[\u0026lsquo;cmd1\u0026rsquo;, \u0026lsquo;cmd2\u0026rsquo;…] 在镜像创建用的临时容器里执行单行命令 ADD 将本地的添加到镜像容器中的位置 VOLUME 或者[\u0026rsquo;/var\u0026rsquo;, \u0026lsquo;home\u0026rsquo;] 将指定的路径挂载为数据卷 EXPOSE [\u0026hellip;] 将指定的端口暴露给主机 ENV 或者 = 指定环境变量值 CMD [\u0026ldquo;executable\u0026rdquo;,\u0026ldquo;param1\u0026rdquo;,\u0026ldquo;param2\u0026rdquo;] 容器启动时默认执行的命令。注意一个Dockerfile中只有最后一个CMD生效。 ENTRYPOINT [\u0026ldquo;executable\u0026rdquo;, \u0026ldquo;param1\u0026rdquo;, \u0026ldquo;param2\u0026rdquo;] 容器的进入点 配置Dockerfile 下面是一个 Dockerfile 的例子：\n1 2 3 4 5 # This is a comment FROM ubuntu:14.04 MAINTAINER Kate Smith \u0026lt;ksmith@example.com\u0026gt; RUN apt-get update \u0026amp;\u0026amp; apt-get install -y ruby ruby-dev RUN gem install sinatra CMD命令 CMD: 命令可用指定 Docker 容器启动时默认的命令\n1 docker run -it ubuntu:latest sh -c \u0026#39;/bin/bash\u0026#39; 其中 sh -c '/bin/bash' 就是手工指定的CMD,否则容器将会使用默认 CMD 指定的命令启动。\nENTRYPOINT命令 用来指定可执行文件、Shell 脚本，同时会并把启动参数或 CMD 指定的默认值，当作附加参数传递给 执行文件、Shell 脚本。\n1 2 ENTRYPOINT [\u0026#39;/usr/bin/mysql\u0026#39;] CMD [\u0026#39;-h 192.168.100.128\u0026#39;, \u0026#39;-p\u0026#39;] 执行mysql启动程序，连接192.168.100.128 主机,也可以通过指定参数，来连接别的主机。\n因此，我们在使用 Dockerfile 创建文件的时候，可以创建一个 entrypoint.sh 脚本，作为系统入口。在这个文件里面，我们可以进行一些基础性的自举操作，比如检查环境变量，根据需要初始化数据库等等。下面两个文件是我在日常工作的项目中添加的 Dockerfile 和 entrypoint.sh，仅供参考： https://github.com/starlight36/SimpleOA/blob/master/Dockerfile https://github.com/starlight36/SimpleOA/blob/master/docker-entrypoint.sh 在准备好 Dockerfile 之后，我们就可以创建镜像了：\n创建镜像 1 docker build -t starlight36/simpleoa . ","date":"2016-12-21T21:25:29Z","permalink":"https://it-boyer.github.io/post/old/%E5%85%B6%E4%BB%96/Docker%E4%BD%BF%E7%94%A8/","section":"post","tags":["docker"],"title":"Docker使用"},{"categories":["博客站务"],"contents":"編輯 快速鍵 跟又快又方便的Sublime text很像\n更多訊息請至 這裡\n自動完成 提供完整的 Markdown 自動完成與提示\n表情符號：輸入 : 顯示提示 程式碼區塊：輸入 3个 ` 加上一個字元 顯示提示 標頭：輸入 # 顯示提示 參考：輸入 [] 顯示提示 外部：輸入 {} 顯示提示 圖片：輸入 ! 顯示提示 標題 會使用 第一個第一級標頭 作為筆記標題\n標籤 如同以下方式來使用標籤，它們會顯示在您的 歷史紀錄\ntags: 功能 酷 更新 YAML metadata 提供描述筆記的資訊，以進階設定瀏覽行為，詳細請至上連結\nrobots: 設定網路機器人 meta lang: 設定瀏覽器顯示語言 dir: 設定文字方向 breaks: 設定是否使用分行 mathjax: 設定是否使用 mathjax 表情符號 您可以像是這樣使用表情符號 \u0026#x1f604; \u0026#x1f603; \u0026#x1f622; \u0026#x1f609;\n完整的表情符號列表 在這裡\n待辦清單 待辦 買些沙拉 刷牙 喝水 程式碼區塊 我們支援非常多程式語言，使用自動完成來看看有些什麼\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); function $initHighlight(block, cls) { try { if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + \u0026#39; class=\u0026#34;\u0026#34;\u0026#39;; } catch (e) { /* handle exception */ } for (var i = 0 / 2; i \u0026lt; classes.length; i++) { if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } } 如果想要 行號，在表明程式語言之後輸入 = 您也可以指定開始行號，如下所示，行號從101開始\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 var s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); function $initHighlight(block, cls) { try { if (cls.search(/\\bno\\-highlight\\b/) != -1) return process(block, true, 0x0F) + \u0026#39; class=\u0026#34;\u0026#34;\u0026#39;; } catch (e) { /* handle exception */ } for (var i = 0 / 2; i \u0026lt; classes.length; i++) { if (checkCondition(classes[i]) === undefined) return /\\d+[\\s/]/g; } } 或是可以接續上一個程式碼區塊的行號，使用 =+\n1 2 var s = \u0026#34;JavaScript syntax highlighting\u0026#34;; alert(s); 引用區塊標籤 您可以使用以下語法，表明自己的 姓名、時間與顏色 並與其他的引用區塊做區別 [name=ChengHan Wu] [time=Sun, Jun 28, 2015 9:59 PM] [color=#907bf7]\n也支援巢狀引用區塊喔！ [name=ChengHan Wu] [time=Sun, Jun 28, 2015 10:00 PM] [color=red]\n外部 Youtube {%youtube 1G4isv_Fylg %}\nVimeo {%vimeo 124148255 %}\nGist {%gist schacon/4277%}\nSlideShare 1 {%slideshare briansolis/26-disruptive-technology-trends-2016-2018-56796196 %} Speakerdeck 1 {%speakerdeck sugarenia/xxlcss-how-to-scale-css-and-keep-your-sanity %} PDF 注意：請使用 https 的網址，否則可能會被您的瀏覽器阻擋載入\n1 {%pdf https://papers.nips.cc/paper/5346-sequence-to-sequence-learning-with-neural-networks.pdf %} MathJax 您可以使用 MathJax 語法 來產生 LaTeX 數學表達式，如同 math.stackexchange.com：\nThe Gamma function satisfying $\\Gamma(n) = (n-1)!\\quad\\forall n\\in\\mathbb N$ is via the Euler integral\n$$ x = {-b \\pm \\sqrt{b^2-4ac} \\over 2a}. $$\n$$ \\Gamma(z) = \\int_0^\\infty t^{z-1}e^{-t}dt,. $$\n更多關於 LaTeX 數學表達式 請至這裡\nUML 圖表 循序圖 您可以像是以下使用循序圖：\n1 2 3 4 5 艾莉絲-\u0026gt;包柏: 哈摟，你好嗎？ Note right of 包柏: 包柏思考中 包柏--\u0026gt;艾莉絲: 我很好，謝謝！ Note left of 艾莉絲: 艾莉絲回應 艾莉絲-\u0026gt;包柏: 最近過得怎樣？ 流程圖 您可以像是以下使用流程圖：\n1 2 3 4 5 6 7 8 9 st=\u0026gt;start: 開始 e=\u0026gt;end: 結束 op=\u0026gt;operation: 我的操作 op2=\u0026gt;operation: 啦啦啦 cond=\u0026gt;condition: 是或否？ st-\u0026gt;op-\u0026gt;op2-\u0026gt;cond cond(yes)-\u0026gt;e cond(no)-\u0026gt;op2 Graphviz 1 2 3 4 5 6 7 8 9 10 11 12 digraph hierarchy { nodesep=1.0 // increases the separation between nodes node [color=Red,fontname=Courier,shape=box] //All nodes will this shape and colour edge [color=Blue, style=dashed] //All the lines look like this Headteacher-\u0026gt;{Deputy1 Deputy2 BusinessManager} Deputy1-\u0026gt;{Teacher1 Teacher2} BusinessManager-\u0026gt;ITManager {rank=same;ITManager Teacher1 Teacher2} // Put them on the same level } Mermaid 1 2 3 4 5 6 7 8 9 gantt title A Gantt Diagram section Section A task :a1, 2014-01-01, 30d Another task :after a1 , 20d section Another Task in sec :2014-01-12 , 12d anther task : 24d 更多關於 循序圖 語法 在這裡. 更多關於 流程圖 語法 在這裡. 更多關於 Graphviz 語法 在這裡 更多關於 Mermaid 語法 在這裡\n警告區塊 :::success 耶 \u0026#x1f389; :::\n:::info 這是訊息 \u0026#x1f4e3; :::\n:::warning 注意 \u0026#x26a1; :::\n:::danger 喔不 \u0026#x1f525; :::\n排版 標頭 1 2 3 4 5 6 # h1 標頭 ## h2 標頭 ### h3 標頭 #### h4 標頭 ##### h5 標頭 ###### h6 標頭 水平分隔線 字形替換 (c) (C) (r) (R) (tm) (TM) (p) (P) +-\n測試.. 測試\u0026hellip; 測試\u0026hellip;.. 測試?\u0026hellip;.. 測試!\u0026hellip;.\n!!!!!! ???? ,,\nRemarkable \u0026ndash; awesome\n\u0026ldquo;Smartypants, 雙引號\u0026rdquo;\n\u0026lsquo;Smartypants, 單引號\u0026rsquo;\n強調 這是粗體文字\n這是粗體文字\n這是斜體文字\n這是斜體文字\n這是刪除文字\n上標： 19^th^\n下標： H2O\n++這是底線文字++\n==這是標記文字==\n引用區塊 引用區塊也可以是巢狀的喔\u0026hellip;\n\u0026hellip;可以多層次的使用\u0026hellip;\n\u0026hellip;或是用空白隔開\n清單 項目 在行開頭使用 + - 或是 * 來建立清單 空兩個空白就可以產生子清單 當清單標記使用的字元不同，會強制建立新的清單 Ac tristique libero volutpat at Facilisis in pretium nisl aliquet Nulla volutpat aliquam velit 非常簡單！ 編號 Lorem ipsum dolor sit amet\nConsectetur adipiscing elit\nInteger molestie lorem at massa\n您可以逐次增加項目數字\u0026hellip;\n\u0026hellip;或是全部都使用 1.\nfeafw\n332\n242\n2552\ne2\n從其他範圍開始編號清單\nfoo bar 程式碼 行內 程式碼\n縮排程式碼\n// Some comments line 1 of code line 2 of code line 3 of code 程式碼區塊\n1 Sample text here... 語法標色\n1 2 3 4 5 var foo = function (bar) { return bar++; }; console.log(foo(5)); 表格 選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 向右對齊\n選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 向左對齊\n選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 置中對齊\n選項 描述 data path to data files to supply the data that will be passed into templates. engine engine to be used for processing templates. Handlebars is the default. ext extension to be used for dest files. 連結 連結文字 加上標題的連結文字 自動轉換連結 https://github.com/nodeca/pica\n圖片 如同連結一般，圖片也可以用註腳語法 使用參考，可以在稍後的文件中再定義圖片網址\n![Minion](https://octodex.github.com/images/minion.png =200x200) 使用指定的大小顯示圖片\n註腳 註腳 1 連結1. 註腳 2 連結2. 行內註腳^[行內註腳的文字] 定義 重複的註腳參考2.\n定義清單 名詞 1 定義 1 快速連續項目\n名詞 2 加上 行內標記 定義 2\n{ 這些程式碼屬於 定義 2 的一部分 } 定義 2 的第三段落\n緊密樣式：\n名詞 1 ~ 定義 1\n名詞 2 ~ 定義 2a ~ 定義 2b\n縮寫 這是 HTML 的縮寫範例 它會轉換 \u0026ldquo;HTML\u0026rdquo;，但是縮寫旁邊其他的部分，例如：\u0026ldquo;xxxHTMLyyy\u0026rdquo;，不受影響\n*[HTML]: Hyper Text Markup Language\n註腳 也可以標記 還可以有很多段落\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n註腳 文字\u0026#160;\u0026#x21a9;\u0026#xfe0e;\u0026#160;\u0026#x21a9;\u0026#xfe0e;\n","date":"2016-12-21T10:49:32Z","permalink":"https://it-boyer.github.io/post/old/hexo/hackmd%E4%BD%BF%E7%94%A8/","section":"post","tags":["hexo"],"title":"hackmd使用"},{"categories":["博客站务"],"contents":"什么是 Hexo？ Hexo 是一个快速、简洁且高效的博客框架。Hexo 使用 Markdown（或其他渲染引擎）解析文章，在几秒内，即可利用靓丽的主题生成静态网页。 Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\nQuick Start 安装 Node.js 安装 Node.js 的最佳方式是使用 nvm,或者您也可以下载 node.js安装包来安装。\n安装nvm 方式一：cURL命令 1 $ curl https://raw.github.com/creationix/nvm/master/install.sh | sh 方式二：linux方法Wget命令\n1 $ wget -qO- https://raw.github.com/creationix/nvm/master/install.sh | sh 安装完成后，重启终端并执行下列命令即可安装 Node.js。\n1 $ nvm install stable 更新npm命令工具至最新版本 1 npm install -g npm 安装 Hexo 所有必备的应用程序安装完成后，即可使用 npm 安装 Hexo。\n1 $ npm install -g hexo-cli 建站 安装 Hexo 完成后，请执行下列命令，Hexo 将会在指定文件夹中新建所需要的文件。\n1 2 3 $ hexo init \u0026lt;folder\u0026gt; $ cd \u0026lt;folder\u0026gt; $ npm install 为了便于在多台电脑上部署博客，可以使用使用git版本库来管理个人博客的内容：\n具体部署过程：\n1 2 3 git clone https://xxxxx/boyer.git boyer cd boyer npm install #安装package.json是插件包，使用git管理更加便于管理安装的完整性。 新建完成后，指定文件夹的目录如下： . ├── _config.yml # 网站的 配置 信息，您可以在此配置大部分的参数。 ├── package.json # 应用程序的信息。EJS, Stylus 和 Markdown renderer 已默认安装。 ├── scaffolds # 模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 ├── source | ├── _drafts | └── _posts └── themes\nscaffolds\n模版 文件夹。当您新建文章时，Hexo 会根据 scaffold 来建立文件。 Hexo的模板是指在新建的markdown文件中默认填充的内容。例如，如果您修改scaffold/post.md中的Front-matter内容，那么每次新建一篇文章时都会包含这个修改。\nsource\n资源文件夹是存放用户资源的地方。除 _posts 文件夹之外，开头命名为 _ (下划线)的文件 / 文件夹和隐藏的文件将会被忽略。Markdown 和 HTML 文件会被解析并放到 public 文件夹，而其他文件会被拷贝过去。\nthemes\n主题 文件夹。Hexo 会根据主题来生成静态页面。\nCreate a new post 1 $ hexo new \u0026#34;My New Post\u0026#34; 1 $ hexo new draft \u0026#34;草稿名\u0026#34; 1 $ hexo publish \u0026#34;草稿名\u0026#34; #Moves a draft post from _drafts to _posts folder. More info: Writing\nRun server 1 $ hexo server More info: Server\nGenerate static files 1 $ hexo generate More info: Generating\nDeploy to remote sites 1 $ hexo deploy 在我们开始之前,你必须在 _config.yml 修改设置。一个有效的部署设置必须有 type 字段。例如:\n1 2 deploy: type: git 你可用同时部署到多个type，Hexo将依次执行每个部署。\n1 2 3 4 5 deploy: - type: git repo: - type: heroku repo: 安装插件 安装同步到git 插件 1 $ npm install hexo-deployer-git --save 编辑_config.yml设置：\n1 2 3 4 5 deploy: type: git repo: \u0026lt;repository url\u0026gt; branch: [branch] message: [message] 安装生成RSS支持插件 1 $ npm install hexo-generator-feed --save 编辑_config.yml设置：\n1 2 3 4 5 feed: type: atom path: atom.xml limit: 20 hub: More info: Deployment\n","date":"2016-12-20T18:02:13Z","permalink":"https://it-boyer.github.io/post/old/hexo/Hexo-hello-world/","section":"post","tags":["hexo"],"title":"Hexo-hello-world"},{"categories":["解决方案"],"contents":"什么是GTD？ GTD 的基本理论是把一个人所要要完成的任务和事件全部从大脑中移出来，记录到纸上。这样，大脑便会不被多余的事情打搅而集中于现在所需完成的事情上面。\nGTD守则： 收集任务 设置每天最重要的任务 （把所有你需要做的和需要完成的事情全部记录下来，放在一个“收集箱”里） ↓ 过程 （每次按照顺序，一次只做一件事） ↓ 管理任务 （列出有详细内容的to-do列表） ↓ 复习任务 （复习你所有完成的任务，计划方案和等待完成的事情。确保每一件新进入的任务都有很好的安排） ↓ 开始行动！ 建立有强行动性的任务清单 任务清单（To-do List）的重要性毋庸置疑，建立有强行动性的任务清单可以让你更清楚地明白自己需要完成的任务，同时还保持了你去完成任务的激情和动力。\n分解任务：就像走远路时，以每一段路程为目标，让人更有动力去追求一样。如果你要阅读一本书，便可以将任务分成“读完第一章”，“读完第二章”等等。 使用有力的动词：比如说联系某个人，就要写上“给某某打电话”或者“发邮件给某某”而不是写“联系某某”。 有限的清单：谁都不希望有一张写满几大页的任务清单，你需要找出那些有强动力的行动。 清理已完成的任务：已完成的任务要及时清理，否者会阻碍你的下一步行动任务。 7W3H 7W3H是一个用于项目规划和管理的专业术语。公司管理者邀请相关员工一起进行分析讨论，按照7W3H进行各述己见，收集、归纳、再收集、再归纳，这样一种互动、发散性思维的工作方法极大调动下属员工的积极性、责任感。否则，公司管理者单方面出台项目计划，对下属员工解释耗费时力不说，项目计划的有效性、完善性、可行性也都可能存在质疑。\n7W what 指目标与内容，包括主体，目标，机能，性能等 why 指原因，包括任务，期望，背景，技术等 who 指人员，包括制造，行销，流通，负责的主体等 where 指地点类，包括 环境，市场，区域，渠道等 when 指时间，包括期限，时机，预期等 whom 买家，消费者，接收者 which 附属品 3H how to 如何做，指方式和手段，包括集体方案，详实计划，战略方针 how much 价格成本，投入产出，综效成果 how many 负面效益，各种量（问题，业务，工作） 案例6W1H 截自《5个图表解决12大难题》\n十二个赛博学习问题 赛博学习法是一种动态的学习过程，在这个过程中你（不是你的老师，也不是某些教科书的作者）会掌握控制权，成为你自己教育的“引航员”。 这种方法的第一步是对话：你会针对正在学习的材料，提出一系列具体的问题。慢慢地，通过信息的整理和再整理，以及在新材料与你学过的知识之间建立新的联系，你将真正理解材料。 用这种方法改进你的笔记，只要回答12个问题就能掌握科教书的要点：\n个人常用的工具类 ","date":"2016-01-07T16:00:53+08:00","permalink":"https://it-boyer.github.io/post/old/%E5%AF%BC%E5%9B%BE/GTD%E4%BB%BB%E5%8A%A1%E6%B8%85%E5%8D%95%E6%95%B4%E7%90%86%E6%8A%80%E5%B7%A7/","section":"post","tags":["管理"],"title":"GTD任务清单整理技巧"},{"categories":["解决方案"],"contents":"git svn\n通过几个简单的工作流程了解到git svn常见命令： 值得警戒的是，在使用 git svn 的时候，你实际是在与 Subversion 交互，Git 比它要高级复杂的多。尽管可以在本地随意的进行分支和合并，最好还是通过衍合保持线性的提交历史，\n尽量避免类似与远程 Git 仓库动态交互这样的操作。 避免修改历史再重新推送的做法，也不要同时推送到并行的 Git 仓库来试图与其他 Git 用户合作。 Subersion 只能保存单一的线性提交历史，一不小心就会被搞糊涂。 合作团队中同时有人用 SVN 和 Git，一定要确保所有人都使用 SVN 服务来协作——这会让生活轻松很多。 ","date":"2016-01-05T14:18:00+08:00","permalink":"https://it-boyer.github.io/post/old/git/gitsvn%E6%A1%A5%E6%8E%A5%E5%91%BD%E4%BB%A4%E7%9A%84%E5%9F%BA%E7%A1%80/","section":"post","tags":["git"],"title":"git svn桥接命令的基础"},{"categories":null,"contents":"读书笔记 kindle笔记 swift-zh文档 下载mobi 项目文档 猜字游戏终端demo 智能设备文档 网络引擎文档 弱网暂存机制 工具文档 自动布局UI 日志工具LogSwift osx版 ShareWXQQ 大话设计 计算器设计 VIPER-SWIFT VIPER-OBJC 测试安装iPA 金和测试 ","date":"2015-12-22T12:39:04Z","permalink":"https://it-boyer.github.io/iDocs/","section":"","tags":null,"title":"文档库"},{"categories":["学习笔记"],"contents":"中心思想： 继承RLMObject新建数据模型，添加相应属性，即可使用realm数据库引擎，对用户数据创建持久化，更新，删除等操作。\n简介： Realm 是一个跨平台的移动数据库引擎，于 2014 年 7 月发布，准确来说，它是专门为移动应用所设计的数据持久化解决方案之一。\n特点：它拥有自己的数据库存储引擎\nRealm 并不是对 Core Data 的简单封装，相反地， Realm 并不是基于 Core Data ，也不是基于 SQLite 所构建的。它拥有自己的数据库存储引擎，可以高效且快速地完成数据库的构建操作。 Realm 支持 Swift 、 Objective-C 以及 Java 语言来编写（ Android 平台和 iOS 平台使用不同的 SDK ）。 Realm 比使用 SQLite 以及 Core Data 要快很多。 可视化工具Realm Browser ：可以让您轻松地读写 Realm 数据库的逻辑结构以及其中的数据（以 .realm 结尾），虽然 Realm Browser 的功能还十分简陋，真的只能读写而已。 RealmPlugin：是 Xcode 建模插件，通过 Alcatraz安装“RealmPlugin” 目的： 学习如何导入 Realm 框架、创建数据模型，实现 Swift 执行查询以及插入、更新和删除记录，以及使用既有的数据库。\n实例学习： 测试APP物种监测 用于记录这个 “ 动植物王国 ” 当中所发现物种的相关信息，包括种群数量、发现区域、年龄结构等等。\n在 Xcode 当中打开我们的起始项目。此时， MapKit 已经在项目当中建立好了，而且项目已经拥有了一些简单的创建、更新和删除物种信息的功能.\ncocoapods安装（Swift 2.1）： 在项目中创建Podfile配置文件，添加RealmSwift支持\n1 2 use_frameworks! // pod \u0026#39;RealmSwift\u0026#39; 执行 pod install下载realmSwift框架，生成**.xcworkspace**文件，自动重启原始项目。 设置Xcode项目在git版本控制中的忽略配置：详见.gitignore\nuse_frameworks!\n如果在cocoapods 里面不使用 use_frameworks!,则是通过static libraries 这个方式来管理pod的代码。这样就需要在app-Bridging-Header.h 文件里面去import相应的.h 文件。而如果使用了use_frameworks!,则cocoapods 使用了frameworks 来取代static libraries 方式。 开始使用： 编译并运行这个应用，然后尝试定位到某个您感兴趣的位置（使用模拟器的位置模拟），然后点击右上角的 “+” 按钮创建一个新的标记点。点选地图上的这个标记点，然后点击其弹出来的气泡，接下来会弹出这个标记点的详细信息。随后，点击类别文本框，就可以看到如下图所示的类别列表了: 使用Realm数据库将类别列表持久化 打开**CategoriesTableViewController.swift **文件添加方法： 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 private func populateDefaultCategories() { self.results = CategoryModel.allObjects() // 1 查询数据返回包含类别对象的RLMResults数组 if results.count == 0 { // 2 通过返回结果的个数，初始化本地realm数据库 let realm = RLMRealm.defaultRealm() // 3 访问默认的 realm 单例对象 realm.beginWriteTransaction() // 4 在默认 realm 数据库中启动一个事务 let defaultCategories = Categories.allValues // 5 使用Categories 枚举来创建一个含有全部默认类别的数组 for category in defaultCategories { // 6 初始化类别实例对象，设置其 name 属性，加入realm中 let newCategory = CategoryModel() newCategory.name = category realm.addObject(newCategory) } realm.commitWriteTransaction() // 7 调用 commitWriteTransaction() 方法来关闭事务，并且向数据库提交数据 self.results = CategoryModel.allObjects() } } 在 viewDidLoad() 方法的底部加入以下代码： 1 populateDefaultCategories() ","date":"2015-12-16T05:56:15+08:00","permalink":"https://it-boyer.github.io/post/old/%E5%BC%80%E6%BA%90%E5%BA%93/Realm%E6%95%B0%E6%8D%AE%E5%BA%93%E5%BC%95%E6%93%8E-swift/","section":"post","tags":["数据库"],"title":"Realm数据库引擎-swift"},{"categories":["解决方案"],"contents":"Swift中使用OC的类声明 \u0026ndash; 实现配置 桥接的头文件 方式一：自动添加桥接头文件 在一个全新的Swift，利用第一次新建提示的方式自动添加桥接头文件。 点确定这后就会生成一个以\u0026lt;produceName-Bridging-Header.h\u0026gt;的头文件。 在targets-\u0026gt;build settings -\u0026gt;Object-C Bridging Header 设为生成的个桥接的头文件即可。 把想要在swift类中调用的OC头文件放使用import \u0026quot;\u0026quot; 写到这个桥接文件中： 1 2 3 // Use this file to import your target\u0026#39;s public headers that you would like to expose to Swift. //MixDemo/MixDemo-Bridging-Header.h #import \u0026#34;OCChannel.h\u0026#34; 方式二：手动添加桥接头文件 同样的，当你知道这个swift搜索头文件的关系后，就不需要再理会这个-Bridging-Header.h的文件了。 完全可以手工建一个并取自己喜欢的名字：\n新建一个头文件，名为:OCContainerHeader.h 在targets-\u0026gt;build settings -\u0026gt;Object-C Bridging Header 设为生成的个桥接的头文件即可。 把想要在swift类中调用的OC头文件放使用import \u0026quot;\u0026quot; 写到这个桥接文件中： 1 2 3 // Use this file to import your target\u0026#39;s public headers that you would like to expose to Swift. //MixDemo/MixDemo-Bridging-Header.h #import \u0026#34;OCChannel.h\u0026#34; OC如何调用Swift写的类 \u0026ndash; 为了在 Objective-C 中可用， Swift 类必须是 Objective-C 类的子类，或者用 @Objective-C 标记； 选中targets-\u0026gt;build settings -\u0026gt;packing-\u0026gt;Product Module Name 中设置模块名（可以自定义），这个名称很重要 swift 的头文件就是根据这个来命名的，例如：SwiftModule。 在OC头文件类中，添加import \u0026ldquo;SwiftModule-swift.h\u0026quot;但你在整个工程中是找不到这个文件的，但可以使用CMD+ 鼠标点击可看这个头文件中的内容。 总结： 这样，工程中如查Swift要使用OC,则把需要使用的OC类的头文件，全写在MixDemo-Bridging-Header.h里。同样如果OC中所使用的swift类，只需要Clean一把，再编就可以了，但不要忘了导入SwiftModule-swift.h哦（名称自取，但-swift.h是固定的），另外还有一个需要读者注意的。\n注： 凡是用Swift写的类，如果不继成自NSObject或NSObject 的派生类，哪么编译后将不会生成对应的转换类。从而使得OC 中找不到相应的声明。 如我的例子中 class Act 这样不会被编译到SwiftModule-swift.h中，但写为 class Act : NSObject，就可以编译出相应的声明。另外可以使用@objc加以声明，但这个还是一样，类最好继承NSObject下来。\n","date":"2015-12-01T11:42:18+08:00","permalink":"https://it-boyer.github.io/post/old/swift/OC%E4%B8%8Eswift%E7%9B%B8%E4%BA%92%E8%B0%83%E7%94%A8/","section":"post","tags":["swift","oc"],"title":"OC与swift相互调用"},{"categories":["学习笔记"],"contents":" 苹果官方 中文版 背景 Apple基于已有的编译器、调试器、框架作为其基础架构。通过ARC(Automatic Reference Counting，自动引用计数)来简化内存管理。我们的框架栈则一直基于Cocoa，且Objective-C进化支持了块、collection literal和模块，允许现代语言的框架无需深入即可使用。 (by gashero)感谢这些基础工作，才使得可以在Apple软件开发中引入新的编程语言Swift。\nswift有点 编译器是按照性能优化的，而语言是为开发优化的\nSwift采用了Objective-C的命名参数和动态对象模型。提供了对Cocoa框架和mix-and-match的互操作性。基于这些基础，Swift引入了很多新功能和结合面向过程和面向对象的功能。 Swift对新的程序员也是友好的：\n它是工业级品质的系统编程语言，却又像脚本语言一样的友好。 它支持playground，允许程序员实验一段Swift代码功能并立即看到结果，而无需麻烦的构建和运行一个应用。 Swift集成了现代编程语言思想，以及Apple工程文化的智慧，编译器是按照性能优化的，而语言是为开发优化的，无需互相折中。 swift语法 Playground允许你编辑代码并立即看到结果,可以从”Hello, world”开始学起并过渡到整个系统。 在Xcode的playground中打开:\n1 println(\u0026#34;Hello, world\u0026#34;) 在Swift，这就是完整的程序:\n无需导入(import)输入输出和字符串处理的系统库。 全局范围的代码就是用于程序的入口，所以你无需编写一个 main() 函数。也无需在每个语句后写分号。 所有这些使得Swift成为Apple软件开发者创新的源泉。\n简单值 \u0026ndash; 使用 let 来定义常量， var 定义变量 提供一个值就可以创建常量或变量，并让编译器推断其类型,一个常量或变量必须与赋值时拥有相同的类型。因此你不用严格定义类型。 常量定义类似于函数式编程语言中的变量,常量的值无需在编译时指定，但是至少要赋值一次,赋值后就无法修改。\n1 2 3 var myVariable = 42 myVariable = 50 let myConstant = 42 在上面例子中，编译其会推断myVariable是一个整数类型，因为其初始化值就是个整数。\n1. 显示/隐式 初始化数据类型 \u0026mdash; 类型与变量名绑定，属于静态类型语言 类型与变量名绑定，属于静态类型语言。有助于静态优化。与Python、JavaScript等有所区别。 例如：初始化值没有提供足够的信息(或没有初始化值)，可以在变量名后写类型，以冒号分隔。\n1 2 3 let imlicitInteger = 70 let imlicitDouble = 70.0 let explicitDouble: Double = 70 2. 变量 拼接到字符串 \u0026ndash; 变量值永远不会隐含转换到其他类型 String(变量名) 1 2 3 let label = \u0026#34;The width is \u0026#34; let width = 94 let widthLabel = label + String(width) 以小括号来写值，并用反斜线(“”)放在小括号之前 1 2 3 4 let apples = 3 let oranges = 5 //by gashero let appleSummary = \u0026#34;I have \\(apples) apples.\u0026#34; let fruitSummary = \u0026#34;I have \\(apples + oranges) pieces of fruit.\u0026#34; 数组和字典的用法 声明并初始化 1 2 3 let emptyArray = String[]() let emptyDictionary = Dictionary\u0026lt;String, Float\u0026gt;() shoppingList = [] //去购物并买些东西 如果数组类型无法推断，你可以写空的数组为 “[]” 和空的字典为 “[:]“。 2. 访问\n创建一个数组和字典使用方括号 “[]”，访问其元素则是通过方括号中的索引或键。\n1 2 3 4 5 6 7 var shoppingList = [\u0026#34;catfish\u0026#34;, \u0026#34;water\u0026#34;, \u0026#34;tulips\u0026#34;, \u0026#34;blue paint\u0026#34;] shoppingList[1] = \u0026#34;bottle of water\u0026#34; var occupations = [ \u0026#34;Malcolm\u0026#34;: \u0026#34;Captain\u0026#34;, \u0026#34;Kaylee\u0026#34;: \u0026#34;Mechanic\u0026#34;, ] occupations[\u0026#34;Jayne\u0026#34;] = \u0026#34;Public Relations\u0026#34; 控制流 \u0026ndash; 条件控制，循环控制 1. 条件控制 if 条件必须是布尔表达式\n在 if 语句中，条件必须是布尔表达式，这意味着 if score { … } 是错误的，不能隐含的与0比较。 你可以一起使用 if 和 let 来防止值的丢失。这些值是可选的。 可选值可以包含一个值或包含一个 nil 来指定值还不存在。写一个问号 “?” 在类型后表示值是可选的。 1 2 3 4 5 6 7 var optionalString: String? = \u0026#34;Hello\u0026#34; optionalString == nil var optionalName: String? = \u0026#34;John Appleseed\u0026#34; var greeting = \u0026#34;Hello!\u0026#34; if let name = optionalName { greeting = \u0026#34;Hello, \\(name)\u0026#34; } switch 支持多种数据以及多种比较，不限制必须是整数和测试相等 1 2 3 4 5 6 7 8 9 10 11 let vegetable = \u0026#34;red pepper\u0026#34; switch vegetable { case \u0026#34;celery\u0026#34;: let vegetableComment = \u0026#34;Add some raisins and make ants on a log.\u0026#34; case \u0026#34;cucumber\u0026#34;, \u0026#34;watercress\u0026#34;: let vegetableComment = \u0026#34;That would make a good tea sandwich.\u0026#34; case let x where x.hasSuffix(\u0026#34;pepper\u0026#34;): let vegetableComment = \u0026#34;Is it a spicy \\(x)?\u0026#34; default: //by gashero let vegetableComment = \u0026#34;Everything tastes good in soup.\u0026#34; } 在执行匹配的情况后，程序会从 switch 跳出，而不是继续执行下一个情况。所以不再需要 break 跳出 switch 。\n2. 循环控制 for-in 来迭代字典中的每个元素\n可使用 for-in 来迭代字典中的每个元素，提供一对名字来使用每个键值对。 1 2 3 4 5 6 7 8 9 10 11 12 13 let interestingNumbers = [ \u0026#34;Prime\u0026#34;: [2, 3, 5, 7, 11, 13], \u0026#34;Fibonacci\u0026#34;: [1, 1, 2, 3, 5, 8], \u0026#34;Square\u0026#34;: [1, 4, 9, 16, 25], ] var largest = 0 for (kind, numbers) in interestingNumbers { for number in numbers { if number \u0026gt; largest { largest = number } } } 你可以在循环中保持一个索引，通过“..”来表示索引范围或明确声明一个初始值、条件、增量。\n这两个循环做相同的事情:\n1 2 3 4 5 6 7 8 9 var firstForLoop = 0 for i in 0..3 { firstForLoop += i } firstForLoop var secondForLoop = 0 for var i = 0; i \u0026lt; 3; ++i { secondForLoop += 1 } 使用 .. 构造范围忽略最高值，而用 … 构造的范围则包含两个值。\nwhile 来重复执行代码块直到条件改变\n使用 while 来重复执行代码块直到条件改变。循环的条件可以放在末尾来确保循环至少执行一次。 1 2 3 4 5 6 7 8 9 10 var n = 2 while n \u0026lt; 100 { n = n * 2 } n var m = 2 do { m = m * 2 } while m \u0026lt; 100 m 函数与闭包 \u0026ndash; 函数是闭包的特殊情况 1. 闭包 无需名字，只需要放在大括号中即可 编写闭包时有多种选项:\n使用 in 到特定参数和主体的返回值。 1 2 3 4 5 numbers.map({ (number: Int) -\u0026gt; Int in let result = 3 * number return result }) 单一语句的闭包可以直接返回值\n例如：当一个闭包的类型是已知时，例如代表回调，你可以忽略其参数和返回值，或两者 1 numbers.map({number in 3 * number}) 通过数字而不是名字来引用一个参数，这对于很短的闭包很有用。\n例如：一个闭包传递其最后一个参数到函数作为返回值。 1 sort([1, 5, 3, 12, 2]) { $0 \u0026gt; $1 } 2. 函数 函数的声明 \u0026ndash; 使用func 声明一个函数 使用 -\u0026gt;分隔参数的名字和返回值类型, 调用函数使用他的名字加上小括号中的参数列表 1 2 3 4 func greet(name: String, day: String) -\u0026gt; String { return \u0026#34;Hello \\(name), today is \\(day).\u0026#34; } greet(\u0026#34;Bob\u0026#34;, \u0026#34;Tuesday\u0026#34;) 函数的嵌套\n内嵌函数可以访问其定义所在函数的变量。 你可以使用内嵌函数来组织代码，避免过长和过于复杂： 1 2 3 4 5 6 7 8 func returnFifteen() -\u0026gt; Int { var y = 10 func add() { y += 5 } add() return y } 函数接收的参数 可变参数的个数 sumOf(numbers: Int\u0026hellip;) -\u0026gt; Int{}\n函数可以接受可变参数个数，收集到一个数组中 1 2 3 4 5 6 7 8 9 func sumOf(numbers: Int...) -\u0026gt; Int { var sum = 0 for number in numbers { sum += number } return sum } //例子 sumOf(42, 597, 12) 其他函数作为参数 func hasAnyMatches(list: Int[], condition: Int -\u0026gt; Bool) -\u0026gt; Bool{} 1 2 3 4 5 6 7 8 9 10 11 12 13 func hasAnyMatches(list: Int[], condition: Int -\u0026gt; Bool) -\u0026gt; Bool { for item in list { if condition(item) { return true } } return false } func lessThanTen(number: Int) -\u0026gt; Bool { return number \u0026lt; 10 } var numbers = [20, 19, 7, 12] hasAnyMatches(numbers, lessThanTen) 函数实际是闭包的特殊情况。你可以写一个闭包而无需名字，只需要放在大括号中即可。使用 in 到特定参数和主体的返回值。\n函数的返回值 返回多个值 ： getGasPrices() -\u0026gt; (Double, Double, Double) 使用元组(tuple)来返回多个值 1 2 3 func getGasPrices() -\u0026gt; (Double, Double, Double) { return (3.59, 3.69, 3.79) } 返回另一个函数 ： makeIncrementer() -\u0026gt; (Int -\u0026gt; Int) 函数是第一类型的 1 2 3 4 5 6 7 8 func makeIncrementer() -\u0026gt; (Int -\u0026gt; Int) { func addOne(number: Int) -\u0026gt; Int { return 1 + number } return addOne } var increment = makeIncrementer() increment(7) 对象与类 1. 类的创建 ：class 类名 使用 class 可以创建一个类。 一个属性的声明则是在类里作为常量或变量声明的，除了是在类的上下文中。方法和函数也是这么写的。 1 2 3 4 5 6 class Shape { var numberOfSides = 0 func simpleDescription() -\u0026gt; String { return \u0026#34;A shape with \\(numberOfSides) sides.\u0026#34; } } 类的构造器 ： 构造器来在创建实例时设置类，使用 init 来创建 1 2 3 4 5 6 7 8 9 10 11 12 class NamedShape { var numberOfSides: Int = 0 var name: String init(name: String) { self.name = name } //by gashero func simpleDescription() -\u0026gt; String { return \u0026#34;A Shape with \\(numberOfSides) sides.\u0026#34; } } self 用来区分 name 属性和 name 参数。 构造器的声明跟函数一样，除了会创建类的实例。每个属性都需要赋值，无论在声明里还是在构造器里。 3. 类的析构器，来执行对象销毁时的清理工作，使用 deinit 来创建 使用 deinit 来创建一个析构器，来执行对象销毁时的清理工作。 4. 超类的继承 * 子类包括其超类的名字，以冒号分隔。在继承标准根类时无需声明，所以你可以忽略超类。\n* 子类的方法可以通过标记 override 重载超类中的实现，而没有 override 的会被编译器看作是错误,编译器也会检查那些没有被重载的方法。\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 class Square: NamedShape { var sideLength: Double init(sideLength: Double, name: String) { self.sideLength = sideLength super.init(name: name) numberOfSides = 4 } func area() -\u0026gt; Double { return sideLength * sideLength } override func simpleDescription() -\u0026gt; String { return \u0026#34;A square with sides of length \\(sideLength).\u0026#34; } } let test = Square(sideLength: 5.2, name: \u0026#34;my test square\u0026#34;) test.area() test.simpleDescription() 2. 类的实例创建 : 类名() ,点语法来访问实例的属性和方法 通过在类名后加小括号来创建类的实例。使用点语法来访问实例的属性和方法。\n1 2 3 var shape = Shape() shape.numberOfSides = 7 var shapeDescription = shape.simpleDescription() 可选类型 Int? 可选绑定 if while\n强制取值表达式 expression! 可选链表达式 expression?\n类型转换运算符 is , as, is?, as!\n标示符模式 值绑定模式 可选模式 类型转换模式\n实例方法 func 类型方法 class func\n","date":"2015-11-27T17:18:21+08:00","permalink":"https://it-boyer.github.io/post/old/swift/Swift%E5%85%A5%E9%97%A8/","section":"post","tags":["swift"],"title":"Swift入门"},{"categories":["解决方案"],"contents":"设置UIImage的渲染模式：UIImage.renderingMode 在 iOS 7 中 UIImage 添加了一个 renderingMode 属性。我们可以使用 imageWithRenderingMode:并传入一个合适的UIImageRenderingMode 来指定这个 image 要不要以 Template 的方式进行渲染。\n1 2 3 4 5 6 7 8 9 10 11 UIImageRenderingModeAutomatic // 根据图片的使用环境和所处的绘图上下文自动调整渲染模式。 UIImageRenderingModeAlwaysOriginal // 始终绘制图片原始状态，不使用Tint Color。 UIImageRenderingModeAlwaysTemplate // 始终根据Tint Color绘制图片，忽略图片的颜色信息。 UIImage *img = [UIImage imageNamed:@\u0026#34;myimage\u0026#34;]; img = [img imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; //实际效果，效果依旧显示为baritem的Tint Color UIBarButtonItem *barButtonItem = [[UIBarButtonItem alloc] initWithImage:setImage style:UIBarButtonItemStylePlain target:self action:@selector(setAction:)]; 在新的 Xcode 中，我们可以直接在 Image Asset 里的 Render As 选项来指定是不是需要作为 template 使用。相应的，在UIApperance中，Apple 也为我们对于 Size Classes 添加了相应的方法。使用 +appearanceForTraitCollection: 方法，我们就可以针对不同 trait 下的应用的 apperance 进行很简单的设定。\n1 2 UIView.appearanceForTraitCollection(UITraitCollection(verticalSizeClass:.Compact)).tintColor = UIColor.redColor() UIView.appearanceForTraitCollection(UITraitCollection(verticalSizeClass:.Regular)).tintColor = UIColor.greenColor() ","date":"2015-11-26T16:15:11+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/UI/UIImage%E7%9A%84%E6%B8%B2%E6%9F%93%E6%A8%A1%E5%BC%8F/","section":"post","tags":["API"],"title":"UIImage的渲染模式"},{"categories":["解决方案"],"contents":"SmartSVN有以下版本：\nSmartSVN enterprise 9 企业版 SmartSVN foundation 8 基础版 由于企业版只能建立本地的版本库，无法创建\u0026amp;使用svn://localhost方式。\n用基础版来说明创建版本库。 参考：Create Repository in SmartSVN – Tutorial\n启动SmartSVN SmartSVN foundation 8 基础版 菜单栏Project-\u0026gt; set up Local Repository\u0026hellip; 需要设置如下两个参数：\n3. svnadmin 在终端执行： whereis svnadmin\n4. svnserve 在终端执行： whereis svnserve\n￼ 指定版本库的目录位置：\n初始化账户密码：\n完成。\n开始导入项目源码，来跟踪版本变化，实现版本控制。 新建SmartSVNRepos目录，存放APP源码，用于导入版本库的原始目录。导入后，该目录源码就被版本跟踪了，在开发时，不用再从版本库导出，可以用该目录的代码直接在版本上开发了。\n菜单栏Project -\u0026gt; Import Into Repository\u0026hellip;\n选择以上新建的SmartSVN版本库：svn://localhost\n查看是否安装SVN服务：\nsvnserve —version SVN随系统一起启动：\nvi /etc/rc.local //(此文件Mac系统中默认是不存在的，需手动创建) 添加启动SVN服务： svnserve -d -r /data/svn/repos 关闭svn服务:\n直接ps aux | grep svn，然后kill -9 进程号 创建库:\n打印应用目录命令：\nwhereis svn 新建版本库目录：\nsudo mkdir -p /data/svn/repos/local\tchmod u+w 文件名 创建：\nsudo svnadmin create /data/svn/repos/local 查看文件权限： ls -l 配置版本库的访问权限\ncd conf/ 开启密码权限，普通用户/匿名用户\nsudo vi svnserve.conf 设置用户：密码\nsudo vi passwd 分组设置，组权限\nsudo vi authz 启动svnserve服务\nsudo svnserve -d -r /data/svn/repos —log-file=/var/log/svn.log 测试端口：\ntelnet localhost 3690 重启必先kill ：\nsudo kill PID 版本库路径：\nsvn://localhost/local 其他：\nsvn ls svn://svnpath 可以查询snv仓库内容 lsof -i :3690 查看svn是否启动 ps aux | grep ‘svn’ 查找所有svn启动的进程id kill -9 pid 将pid替换为上面查到的进程id可以杀掉svn进程 ","date":"2015-10-05T19:16:47+08:00","permalink":"https://it-boyer.github.io/post/old/git/%E4%BD%BF%E7%94%A8SmartSVN%E5%88%9B%E5%BB%BA%E7%89%88%E6%9C%AC%E5%BA%93/","section":"post","tags":["git"],"title":"使用SmartSVN创建版本库"},{"categories":["学习笔记"],"contents":"[英文][SwiftCommunityBestPractices] [SwiftCommunityBestPractices]: https://github.com/schwa/Swift-Community-Best-Practices [SwiftCommunity]: http://swift-lang.schwa.io/ [swiftCaptureLists]: http://www.russbishop.net/swift-capture-lists [SwiftURL]: https://developer.apple.com/library/prerelease/ios/documentation/Swift/Conceptual/Swift_Programming_Language/index.html [驼峰命名法URL]: http://www.wikiwand.com/en/Studly_caps [匈牙利命名法URL]: http://www.wikiwand.com/en/Hungarian_notation\n黄金法则 Apple 通常是对的。应紧随苹果所推荐的或他的 Demo 中所展示的方式。您应该尽可能地遵守 Apple 在 [The Swift Programming Language][SwiftURL] 一书中所定义的代码风格。但我们还是可以看到他们的示例代码中有不符合这些规则的地方，毕竟 Apple 是一家大公司嘛。 不要仅仅为了减少字符的键入数量而使用模棱两可的简短命名，较长的命名都可以依赖自动完成、自我暗示、复制粘贴来减低键入的难度。命名的详细程度往往对代码维护者很有帮助。但过于冗长的命名却会绕过Swift的主要特性之一: 类型推导,所以命名的原则应该是简洁明了。 最佳实践 命名 按照 [The Swift Programming Language][SwiftURL] 所推荐的命名法则，类型名称应该使用[首字母大写的驼峰命名法][uppercamelcaseURL] (例如: \u0026ldquo;VehicleController\u0026rdquo;)。\n变量与常量应该使用首字母小写的驼峰命名法(例如: \u0026quot; vehicleName \u0026quot; )。\n推荐使用 Swift 模块来定义代码的命名空间，而非在 Swift 代码上使用 Objective-C 样式的类前缀(除非接口要与 Objective-C 交互)。\n不推荐使用任何形式的[匈牙利命名法][匈牙利命名法URL]（比如：k 代表常量，m 代表方法）,取代代之我们应该使用短而简洁的名字并使用 Xcode 的类型快速帮助 (⌥ + 左击)。同样我们也不要使用类似 SNAKE_CASE 这样的名字。\n这些法则之上，唯一例外的情况就是枚举值了，枚举值在这里应该首字母大写(这是 Apple 的 [The Swift Programming Language][SwiftURL] 中的规范)：\n{%codeblock lang:swift%} enum Planet { case Mercury, Venus, Earth, Mars, Jupiter, Saturn, Uranus, Nepture } {%endcodeblock%}\n有必要的话命名不要缩写 实际上在 Xcode 的\u0026quot;文本自动补全\u0026quot;功能下你可以轻而易举地键入 类似 ViewController 的长命名。 极为常见的缩写 例如: URL 缩写应该是全部大写 ( \u0026ldquo;URL\u0026rdquo; )或者酌情全部小写( \u0026ldquo;url\u0026rdquo; )。 URL 的类型和变量命名推荐的规则： 如果 url 是一个类型，它应该被大写，如果是一个变量，那么应该小写。\n注释 不应该使用注释来禁用代码,被注释掉的代码会污染你的源代码。 如果你当前想要删除一段代码，但将来又可能会用到，推荐你依赖 git 或你的 bug 追踪系统来管理。\n(TODO: 追加一个关于文档注释的小节，使用 nshipster 的链接)\n类型推导 如果可能的话，使用 Swift 的类型推导，以避免冗余的类型信息。例如： {%codeblock lang:swift%} var currentLocation = Location() {%endcodeblock%}\n而非：\n{%codeblock lang:swift %} var currentLocation: Location = Location() {%endcodeblock%}\n内省 让编译器自动推断所有的情况，这是可以做到的。在一些领域 self 应该被显式地使用，包括在 init 中设置参数，或者 non-escaping闭包。 例如： {%codeblock lang:swift%} struct Example{ let name: String init(name: String) { self.name = name } } {%endcodeblock%}\n捕获列表的类型推导 在一个捕获列表( capture list )中指定参数类型会导致代码冗余。如果需要的话，仅指定类型即可。\n{%codeblock lang:swift%} let people = [ (\u0026ldquo;Mary\u0026rdquo;, 42), (\u0026ldquo;Susan\u0026rdquo;, 27), (\u0026ldquo;Charlie\u0026rdquo;, 18), ]\nlet strings = people.map() { (name: String, age: Int) -\u0026gt; String in return \u0026quot;\\(name) is \\(age) years old\u0026quot; } {%endcodeblock%}\n如果编译器可以推导出来的话，完全可以把类型删掉： (name: String, age: Int) -\u0026gt; String {%codeblock lang:swift%} let strings = people.map() { (name, age) in return \u0026ldquo;(name) is (age) years old\u0026rdquo; } {%endcodeblock%}\n使用编号的参数名 (\u0026quot;$0\u0026quot;) 进一步降低冗长，往往能彻底消除捕获列表的代码冗余。在闭包中当参数名没有附带任何更多信息时仅使用编号形式即可( 如非常简单的映射和过滤器 )。\nApple 能够并且将会改变闭包的参数类型，通过他们的 Objective-C 框架的 Swift 变种提供出来。 例如，optionals 被删除或更改为 auto-unwrapping 等。故意 under-specifying 可选并依赖 Swift 来推导类型，可以减少在这些情况下代码被破译的风险。\n你应该避免指定返回类型，例如这个捕获列表( capture list )就是完全多余的:\n{%codeblock lang:swift%} dispatch_async(queue) { ()-\u0026gt;Void in print(\u0026ldquo;Fired.\u0026rdquo;) } {%endcodeblock%} (以上内容也可以参考:[这里][swiftCaptureLists])\n常量 类型定义中使用的常量应当被申明成静态类型。例如: {%codeblock lang:swift%} struct PhysicsModel { static var speedOfLightInAVacuum = 299_792_458 }\nclass Spaceship { static let topSpeed = PhysicsModel.speedOfLightInAVacuum var speed: Double func fullSpeedAhead() { speed = Spaceship.topSpeed } } {%endcodeblock%} 将常量标示为 static ，允许它们可以被无类型的实例引用。\n一般应该避免生成全局范围的常量，单例除外。\n","date":"2015-09-29T17:05:21+08:00","permalink":"https://it-boyer.github.io/post/old/swift/%E8%BD%ACSwift%E6%9C%80%E4%BD%B3%E5%AE%9E%E8%B7%B5/","section":"post","tags":["swift"],"title":"[转]Swift最佳实践"},{"categories":["解决方案"],"contents":"必要配置 *创建一个名称为\u0026quot;gitlab\u0026quot;管理员用户，然后再创建一个名称为\u0026quot;gitlab\u0026quot;的群组 *开启gitlab用户的远程登录 在系统启动界面:\n隐藏gitlab用户\nsudo defaults write /Library/Preferences/com.apple.loginwindow HiddenUsersList -array-add gitlab 显示git用户\nsudo defaults delete /Library/Preferences/com.apple.loginwindow HiddenUsersList 添加系统账户gitlab 生成gitlab服务器目录，即用户根目录 进入系统偏好设置\u0026hellip;,在管理用户与群组中，添加其他用户，暂时定为：gitlab ，登录密码假设为：gitlab，添加完成后，会自动在/Users目录下，生成用户根目录gitlab.\n安装 Gitlab Shell cd /Users/gitlab sudo -u gitlab git clone https://github.com/gitlabhq/gitlab-shell.git cd gitlab-shell sudo -u gitlab git checkout v1.9.1 sudo -u gitlab cp config.yml.example config.yml 打开 config.yml,然后进行编辑\n设置 gitlab_url. 把 gitlab.example.com 替换成你自己的域名 （如果本地就不用了）\n把所有的/home 替换成 /Users\nsudo -u gitlab sed -i \u0026quot;\u0026quot; \u0026quot;s/\\/home\\//\\/Users\\//g\u0026quot; config.yml sudo -u gitlab sed -i \u0026quot;\u0026quot; \u0026quot;s/\\/usr\\/bin\\/redis-cli/\\/usr\\/local\\/bin\\/redis-cli/\u0026quot; config.yml 然后执行安装脚本：sudo -u gitlab -H ./bin/install //需在gitlab-shell目录下载执行\n安装gitlab 先下载gitlab\ncd /Users/gitlab sudo -u gitlab git clone https://github.com/gitlabhq/gitlabhq.git cd gitlab sudo -u gitlab git checkout 6-7-stable 配置gitlab\nsudo -u gitlab cp config/gitlab.yml.example config/gitlab.yml sudo -u gitlab sed -i \u0026quot;\u0026quot; \u0026quot;s/\\/usr\\/bin\\/git/\\/usr\\/local\\/bin\\/git/g\u0026quot; config/gitlab.yml sudo -u gitlab sed -i \u0026quot;\u0026quot; \u0026quot;s/\\/home/\\/Users/g\u0026quot; config/gitlab.yml sudo -u gitlab sed -i \u0026quot;\u0026quot; \u0026quot;s/localhost/domain.com/g\u0026quot; config/gitlab.yml 配置MySQL数据库，创建gitlab用户，数据库，和gitlab用户的管理权限\n# Login to MySQL $ mysql -u root -p # Create the GitLab production database mysql\u0026gt; CREATE DATABASE IF NOT EXISTS `gitlabhq_production` DEFAULT CHARACTER SET `utf8` COLLATE `utf8_unicode_ci`; # Create the MySQL User change $password to a real password mysql\u0026gt; CREATE USER 'gitlab'@'localhost' IDENTIFIED BY '$password'; # Grant proper permissions to the MySQL User mysql\u0026gt; GRANT SELECT, INSERT, UPDATE, DELETE, CREATE, DROP, INDEX, ALTER ON `gitlabhq_production`.* TO 'gitlab'@'localhost'; 安装 Gitolite帮助管理git内部用户 克隆gitlab的gitolite分支源代码：\nsudo -H -u gitlab git clone -b gl-v304 https://github.com/gitlabhq/gitolite.git /Users/gitlab/gitolite 安装：\ncd /Users/gitlab sudo -u gitlab -H mkdir bin sudo -u gitlab sh -c 'echo -e \u0026quot;PATH=\\$PATH:/Users/gitlab/bin\\nexport PATH\u0026quot; \u0026gt;\u0026gt; /Users/gitlab/.profile' sudo -u gitlab sh -c 'gitolite/install -ln /Users/gitlab/bin' sudo cp ~/.ssh/id_rsa.pub /Users/gitlab/gitlab.pub sudo chmod 0444 /Users/gitlab/gitlab.pub sudo -u gitlab -H sh -c \u0026quot;PATH=/Users/gitlab/bin:$PATH; gitolite setup -pk /Users/gitlab/gitlab.pub\u0026quot; 为 Git 创建用户：\nsudo adduser \\ --system \\ --shell /bin/sh \\ --gecos 'git version control' \\ --group \\ --disabled-password \\ --home /home/git \\ git 若干问题解决办法：Mac搭建Git服务器—开启SSH\nCloning into '/tmp/gitolite-admin'... ssh: connect to host localhost port 22: Connection refused fatal: Could not read from remote repository. SSH无密码登陆设置：\n$ cd /etc $ chmod 666 sshd_config $ vim sshd_config #PermitRootLogin yes 改为：PermitRootLogin no #UsePAM yes\t改为: UsePAM no Remove the # from the following\n#RSAAuthentication yes #PubkeyAuthentication yes #AuthorizedKeysFile .ssh/authorized_keys\t#PasswordAuthentication no #PermitEmptyPasswords no ","date":"2015-09-27T19:25:38+08:00","permalink":"https://it-boyer.github.io/post/old/git/Mac%E5%AE%89%E8%A3%85gitLab%E6%9C%8D%E5%8A%A1%E5%99%A8/","section":"post","tags":["git"],"title":"Mac安装gitLab服务器"},{"categories":["解决方案"],"contents":"常用命令 ssh登录\n局域网登录: ssh [user@]hostname [command] 例如：ssh root@192.168.31.1 或 远程登录：ssh root@222.35.145.28 -p 2195 回车 输入密码 **修改密码：** root@xiaoqiang:~#passwd 回车 输入新密码 回车 再次输入新密码 远程拷贝数据\nscp Desktop/ar71xx/* root@192.168.31.1:/userdisk/myWorkspace/ar71xx 每次重启路由获取IP:\nvi /etc/rc.local sh /etc/getIP.sh //启动后，等待20秒，然后，获取当前时间作为文件名称 //使用ifconfig 获取路由器的ip信息 //使用 | grep 通道，和grep正则来过滤出，wan口的ip所在行 // \u0026gt; 使用重定向，将过滤的ip行，写入路由硬盘/userdisk/data/my/ip目录中 //通过小米路由手机客户端，找到该txt文件，并下载到手机sd卡中 //查看该文件，既有路由重启后的当前IP\n详见getIP.sh\n#!/bin/sh sleep 20 current_date=`date +%Y_%m_%d` current_time=`date +%H_%M_%S` echo $current_date echo $current_time #local_ip=`ifconfig |grep '[0-9]\\{1,3\\}.*P-t-P'` local_ip=`ifconfig | grep P-t-P` echo $local_ip \u0026gt; /userdisk/data/my/ip/$current_date:$current_time.txt 修改防火墙设置**/etc/config目录下的dropbear和firewall**\ncd /etc/config //把备份文件内容覆盖新文件即可 1.cat dropbear.bak \u0026gt; dropbear 增加如下内容： config dropbear option PasswordAuth 'on' option RootPasswordAuth 'on' option Interface 'wan' option Port '2195' 2.保存文件修改后，再重启dropbear服务，一次输入下面两行命令： /etc/init.d/dropbear reload /etc/init.d/dropbear restart 1.cat firewall.bak \u0026gt; firewall 增加如下内容： config rule option name 'Allow-wan-ssh' option src 'wan' option proto 'tcp' option dest_port '2195' option target 'ACCEPT' 2.保存文档的更改后，重启防火墙服务，依次输入以下两条命令： /etc/init.d/firewall reload /etc/init.d/firewall restart 5.由于铁通机制，分配的独立iP，并不能被外网访问\nssh登录数据库\t转 先确保能访问LLMP搭建的个人网站地址\n修复教程：\n登录路由： ssh root@192.168.31.1 mm:admin\n执行命令：/userdisk/data/lamp.sh fix\n再次访问个人网站地址。 LLMP搭建的个人网站地址 。\n1./userdisk/data/lamp.sh (安装本插件，一键开启llmp，具体安装过程可见前面的安装步骤） 2./userdisk/data/lamp.sh a（卸载本插件，恢复安装前，注：卸载本插件时路由器会自动重启一次，自动断网几分钟） 3./userdisk/data/lamp.sh fix（升级小米路由器固件后，能瞬间恢复自己搭建的网站功能，另外，如果在极特殊的情况的情况下，本功能无效，可使用如下方法恢复自建网站的功能：先尝试重新安装本插件，如果提示不能重复安装，可先卸载本插件，再重新安装本插件，并按说明3对数据库执行修改密码命令，改回原来的密码，原来自己搭建网站就可恢复使用） 4./userdisk/data/lamp.sh help (插件用法的帮助信息） 登录数据库：ssh mysql@192.168.31.1 -p 2222\n正确日志：\nAdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222 The authenticity of host '[192.168.31.1]:2222 ([192.168.31.1]:2222)' can't be established. RSA key fingerprint is SHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M. Are you sure you want to continue connecting (yes/no)? yes Warning: Permanently added '[192.168.31.1]:2222' (RSA) to the list of known hosts. mysql@192.168.31.1's password:admin BusyBox v1.19.4 (2015-05-08 18:41:26 CST) built-in shell (ash) Enter 'help' for a list of built-in commands. ~ $ 错误日志： 需要修改本地的ssh配置。\nvi /Users/admin/.ssh/known_hosts文件\n删除包含[192.168.31.1]:2222的一行内容。\n重新登录数据库：ssh mysql@192.168.31.1 -p 2222。\nAdmindeMacBook-Air:~ admin$ ssh mysql@192.168.31.1 -p 2222 @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ @ WARNING: REMOTE HOST IDENTIFICATION HAS CHANGED! @ @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@ IT IS POSSIBLE THAT SOMEONE IS DOING SOMETHING NASTY! Someone could be eavesdropping on you right now (man-in-the-middle attack)! It is also possible that a host key has just been changed. The fingerprint for the RSA key sent by the remote host is SHA256:bLH9smUb7sD9CZLWCsT6t9YqPy2jciznepkscFNd59M. Please contact your system administrator. Add correct host key in /Users/admin/.ssh/known_hosts to get rid of this message. Offending RSA key in /Users/admin/.ssh/known_hosts:10 RSA host key for [192.168.31.1]:2222 has changed and you have requested strict checking. Host key verification failed. 客户端MySQLWorkbench无法连接LLMP个人网站的MySql数据库","date":"2015-09-25T23:59:16+08:00","permalink":"https://it-boyer.github.io/post/old/%E6%99%BA%E8%83%BD%E8%AE%BE%E5%A4%87/%E5%B0%8F%E7%B1%B3%E8%B7%AF%E7%94%B1%E5%B8%B8%E7%94%A8%E6%93%8D%E4%BD%9C/","section":"post","tags":["智能设备"],"title":"小米路由常用操作"},{"categories":["解决方案"],"contents":"Xcode7编译发布问题 ERROR ITMS-90535: \u0026ldquo;Unexpected CFBundleExecutable Key. The bundle at \u0026lsquo;Payload/PBBReader.app/TencentOpenApi_IOS_Bundle.bundle\u0026rsquo; does not contain a bundle executable. If this bundle intentionally does not contain an executable, consider removing the CFBundleExecutable key from its Info.plist and using a CFBundlePackageType of BNDL. If this bundle is part of a third-party framework, consider contacting the developer of the framework for an update to address this issue.\u0026rdquo;\n解决办法：搜索CFBundleExecutable 字段，删除所有第三方框架中的info.plist文件中包含的字段，重新打包上传。\nERROR ITMS-90475: \u0026ldquo;Invalid Bundle. iPad Multitasking support requires launch story board in bundle \u0026lsquo;pyc.com.cn.pbbReader\u0026rsquo;.\u0026rdquo;\f苹果邮件：We have discovered one or more issues with your recent delivery for \u0026ldquo;PBB Reader\u0026rdquo;. To process your delivery, the following issues must be corrected: Invalid Bundle - A nested bundle doesn\u0026rsquo;t have the right platforms listed in CFBundleSupportedPlatforms Info.plist key.\nIOS9访问网络设置：NSAppTransportSecurity 字典，字段：NSAllowsArbitraryLoads 字段值：YES\n搜索Target对应的build setting中，把bitCode支持设置为NO\niPad 中的多任务适配\n如果你不想你的 app 可以作为多任务的副 app 被使用的话，你可以在 Info.plist 中添加 UIRequiresFullScreen 并将其设为 YES\n对第三方SDK后台运行，有严格的把控，要求bundle资源必须为最新有效，上传包时必要条件\n解决办法： 退回Xcode6.4,进行打包发布\nCannot proceed with delivery: an existing transporter instance is currently uploading this package 把Application Loader(XCode-\u0026gt;Organizer-\u0026gt;Archived Applications-\u0026gt;Submit)中正在上传的文件中断或者删除，再次Submit提示：\nCannot proceed with delivery: an existing transporter instance is currently uploading this package。 无论如何Clean All、重新Submit都失败，给出上述提示。\n原因：上传的动作被记录在UploadToken中了。\n解决方法：\n（1）打开终端，输入cd，到达个人用户目录下。\n（2）输入ls -a，可以看到一个隐藏的目录 .itmstransporter\n（3）cd .itmstransporter/UploadTokens\n（4）ls ，可以看到一个类似 xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token文件\n（5）nano xxxxx.local_itunesConnectUSERxxxxxx.itmsp.token，在里面把内容都删除，保存。\n（6）重新在Organizer里面submit，ok了\n","date":"2015-09-25T15:58:17+08:00","permalink":"https://it-boyer.github.io/post/old/%E7%BC%96%E8%AF%91/Xcode7%E7%BC%96%E8%AF%91%E5%8F%91%E5%B8%83%E9%97%AE%E9%A2%98/","section":"post","tags":null,"title":"Xcode7编译发布问题"},{"categories":["学习笔记"],"contents":"CI服务器 写到这儿，对于iOS开发者来说，需要准备好：\n一个比较容易获取的源代码仓库(包含源代码) 一套自动化构建脚本 一系列围绕构建的可执行测试 接下来就需要一个CI服务器来根据源代码的变更触发构建，监控测试结果。\n目前，业界比较流行的，支持iOS构建的CI服务器有\nTravis CI：是一个免费的云服务平台，基本上支持所有目前主流的语言，Object-C自然也在其中，但是只支持github极大的限制了其应用场景。目前国内无法访问，详见 Jenkins：经过多年的发展，其活跃的社区和丰富的插件让其成为了业界最受欢迎的CI服务器。通过使用Xcode插件，可以非常方便在Jenkins中运行iOS项目的构建脚本。 xcode 持续集成的实现 Setting Up Xcode Server\njenkins使用配置：\n下载：http://mirrors.jenkins-ci.org/war/lastest/jenkins.war\n运行命令行：\n1 nohup java -jar ~/Downloads/jenkins.war —httpPort=8081 —ajp13Port=8010 \u0026gt; /tmp/jenkins.log 2\u0026gt;\u0026amp;1 \u0026amp; 写入启动文件中，起别名\n1 2 vi /Users/(username)/.bash_profile 输入:alias jenkins=\u0026#34;nohup java -jar ~/Downloads/SVNRepos/jenkins.war --httpPort=8081 --ajp13Port=8010 \u0026gt; /tmp/jenkins.log 2\u0026gt;\u0026amp;1 \u0026amp;” 启动时，在命令行中输入：jenkins 回车 即可启动\n访问：http://127.0.0.1:8081/\n重启：http://[jenkins-server]/[command] exit推出，restart重启，reload重载。\n方法二： 安装jenkins还是使用brew\nbrew install jenkins 安装好之后，可以通过使用命令行启动\njava -jar /usr/local/opt/jenkins/libexec/jenkins.war 如果想开机自动启动，需要先执行以下命令，创建启动项：\nln -sfv /usr/local/opt/jenkins/*.plist ~/Library/LaunchAgents 可以编辑一下~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist这个文件\nopen ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist 具体内容：\n\u0026lt;?xml version=\u0026quot;1.0\u0026quot; encoding=\u0026quot;UTF-8\u0026quot;?\u0026gt; \u0026lt;!DOCTYPE plist PUBLIC \u0026quot;-//Apple//DTD PLIST 1.0//EN\u0026quot; \u0026quot;http://www.apple.com/DTDs/PropertyList-1.0.dtd\u0026quot;\u0026gt; \u0026lt;plist version=\u0026quot;1.0\u0026quot;\u0026gt; \u0026lt;dict\u0026gt; \u0026lt;key\u0026gt;Label\u0026lt;/key\u0026gt; \u0026lt;string\u0026gt;homebrew.mxcl.jenkins\u0026lt;/string\u0026gt; \u0026lt;key\u0026gt;ProgramArguments\u0026lt;/key\u0026gt; \u0026lt;array\u0026gt; \u0026lt;string\u0026gt;/usr/bin/java\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;-Dmail.smtp.starttls.enable=true\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;-jar\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;/usr/local/opt/jenkins/libexec/jenkins.war\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;--httpListenAddress=127.0.0.1\u0026lt;/string\u0026gt; \u0026lt;string\u0026gt;--httpPort=8088\u0026lt;/string\u0026gt; \u0026lt;/array\u0026gt; \u0026lt;key\u0026gt;RunAtLoad\u0026lt;/key\u0026gt; \u0026lt;true/\u0026gt; \u0026lt;/dict\u0026gt; \u0026lt;/plist\u0026gt; 想要让局域网都可以访问或修改端口号，需要把—httpListenAddress=127.0.0.1改成自己的局域网IP\n手动启动启动项可以执行,制作替身：\nlaunchctl load ~/Library/LaunchAgents/homebrew.mxcl.jenkins.plist 之后用浏览器就可以访问 http://localhost:8088/ 来登录jenkins了\n方法三： 使用tomcat 制作替身：\ncd ~/Downloads/soft/Tomcat/ ln -sfv apache-tomcat-8.0.27 tomcat 将jenkins.war拷贝到 $tomcat/webapp下面。\n$tomcat/bin/start.sh 用浏览器打开 localhost:8080/jenkins tomcat默认端口号为8080，就可以看到 jenkin运行了。\n自动化构建和依赖管理参考 作为以GUI和命令行操作结合的完美性著称的苹果公司来说，当然也不会忘记为自己的封闭的iOS系统提供开发环境下命令行编译工具：xcodebuild 在介绍xcodebuild之前，需要先弄清楚一些在XCode环境下的一些概念【4】：\nWorkspace：简单来说，Workspace就是一个容器，在该容器中可以存放多个你创建的Xcode Project， 以及其他的项目中需要使用到的文件。使用Workspace的好处有，1),扩展项目的可视域，即可以在多个项目之间跳转，重构，一个项目可以使用另一个项目的输出。Workspace会负责各个Project之间提供各种相互依赖的关系;2),多个项目之间共享Build目录。 Project：指一个项目，该项目会负责管理生成一个或者多个软件产品的全部文件和配置，一个Project可以包含多个Target。 Target：一个Target是指在一个Project中构建的一个产品，它包含了构建该产品的所有文件，以及如何构建该产品的配置。 Scheme：一个定义好构建过程的Target成为一个Scheme。可在Scheme中定义的Target的构建过程有：Build/Run/Test/Profile/Analyze/Archive BuildSetting：配置产品的Build设置，比方说，使用哪个Architectures？使用哪个版本的SDK？。在Xcode Project中，有Project级别的Build Setting，也有Target级别的Build Setting。Build一个产品时一定是针对某个Target的，因此，XCode中总是优先选择Target的Build Setting，如果Target没有配置，则会使用Project的Build Setting。 xcodebuild就是用了构建产品的命令行工具，其用法可以归结为3个部分：\n可构建的对象 构建行为 一些其他的辅助命令 可以构建的对象有，默认情况下会运行project下的第一个target：\nworkspace：必须和“-scheme”一起使用，构建该workspace下的一个scheme。 project：当根目录下有多个Project的时候，必须使用“-project”指定project，然后会运行 target：构建某个Target scheme：和“-workspace”一起使用，指定构建的scheme。 …… 构建行为包括：\nclean:清除build目录下的\nbuild: 构建\ntest: 测试某个scheme，必须和\u0026quot;-scheme\u0026quot;一起使用\narchive:打包，必须和“-scheme”一起使用\n…… 辅助命令包括：\n-sdk：指定构建使用的SDK\n-list：列出当前项目下所有的Target和scheme。\n-version：版本信息\n…\u0026hellip; 关于xcodebuild更多详细的命令行请参见：点击\nxcodebuild的主要缺陷：\n其脚本输出的可读性极差， 只能要么完整的运行一个target或者scheme，要么全部不运行。不能指定运行Target中特定的测试。 安装xctool\nxctool的安装非常简单，只需要clone xctool的repository到项目根目录就可以使用， 如果你的机器上安装有Homebrew，可以通过“brew install xctool”命令直接安装。（注意：使用xctool前一定要首先确认xcodebuild已安装且能正确工作）。\n用法\n关于xctool的用法就更加人性化了，几乎可以重用所有的xcodebuild的指令，配置。只需要注意一下几点：\nxctool不支持target构建，只能使用scheme构建。 支持“-only”指令运行指定的测试。 支持多种格式的build报告。 例子： 1 2 3 4 path/to/xctool.sh -workspaceYourWorkspace.xcworkspace -schemeYourScheme test -only SomeTestTarget:SomeTestClass/testSomeMethod 自动化部署 这儿的想谈的“部署”不是传统意义上的直接部署到产品环境的部署，而是指如何把最新版本的应用快速的部署到测试用户的机器上以收集反馈，或者做一些探索性的测试。\n在我写第一个iOS应用的时候，我想把应用安装到多个机器上测试的时候，需要非常繁琐的步骤：\n需要申请到苹果开发者账号，获得开发者证书。 需要在苹果的开发者网站上注册我想使用的设备。 使用开发者证书打包应用，使用Ad-HOC部署模式，生成ipa文件。 通过ipa文件把应用安装到iTunes上。 通过iTunes把应用同步到多台测试机器上。 如果是测试机器在多个地理位置的时候，还需要把ipa文件发送到对应的地点，每个地点都需要重复的做第4，5步。 这样一个繁琐，且低效的过程让开发者非常痛苦，直到TestFlight的出现。\nTestFlight TestFlight：就是一个专门解决上面提到的痛点的云服务方案，它可以帮助开发者：\n轻松采集测试用户的UDID和iOS 版本、硬件版本，并发送给开发者。 实时反馈应用是否成功安装到测试机器 轻松部署最新版本应用到测试用机上。 开发者可以灵活选择部署哪个版本到哪部分测试机器上。 使用使用Test Flight服务非常简单，只需要到Test Flight注册一个账号。然后把链接发送给测试设备，测试设备只要打开该链接，并授权给Test Flight，在Test Flight的设备中心就可以看到这些设备。\n使用jenkins+calabash+cocoapods搭建ios持续集成环境 calabash 是一款开源的跨平台UI测试工具，目前支持iOS和Android。它使用Cucumber作为测试核心，Cucumber是一个在敏捷团队十分流行的自动化的功能测试工具，它使用接近于自然语言的特性文档进行用例的书写和测试，支持多语言和多平台。 安装Calabash 1 sudo gem install calabash-cucumber 安装Calabash中文支持包 1 sudo gem install calabash-cucumber-cn For automatic setup: In a terminal, go to your iOS project\n1 cd path-to-my-ios-project (i.e. directory containing .xcodeproj file) Install calabash-cucumber gem (this make take some time because of dependencies)\n1 gem install calabash-cucumber Setup your project for Calabash-iOS.\n1 calabash-ios setup //Answer the questions and read the output :) Generate a skeleton features folder for your tests\n1 calabash-ios gen In Xcode, build your project using the -cal scheme\nRun the generated test!\n1 cucumber If all goes well, you are now ready to write your first test. Start by editing the file features/my_first.feature.\ncucumber官网 * Feature（功能） * Scenario（情景） * Given（给定） * When（当） * Then（则） 运行原理 cucumber是一种BDD测试框架，核心为cucumber的calabash的脚本在运行测试的时候会在虚拟机/真机上预装一个web服务器，这个web服务器就是解释calabash的脚本，将其解释为robotium的脚本，然后这个web服务器会想测试app发送robotium的脚本，测试app拿到robotium脚本后，将其解释为instumentation命令向被测试的app发送这些命令，被测试的app执行这些命令，然后将结果返回给测试app，然后一级一级返得到最后的测试结果。\n结构框架 calabash完全采用了cucumber的结构模式，calabash是脚本与TC分离设计，在业务变化的情况下，只要功能存在基本只需要修改TC逻辑，在业务不变，功能变化的情况下，基本只需要修改脚本。\nfeature为主件夹，step_definitions目录内是你封装的脚本，my_first.feature文件就是你的TC逻辑。\n再看一下其中的内容：\nmy_first.feature Feature： 登陆 Scenario： 输入正确的用户名密码能够正常登陆 When 打开登陆页面 And 输入用户名XXX输入密码XXX And 点击登陆 Then 验证登陆成功 看起来很简单吧，想要验证其他功能也是类似的语言描述即可。\n如果你没有用过cucumber或者calabash那么你肯定现在有一个疑问，计算机怎么能识别汉字来进行测试的呢，\n那么看一下step_definition，以 输入用户名XXX输入密码XXX为例：\nWhen /^ 输入用户名\\\u0026quot;([^\\\\\\\u0026quot;]*)\\\u0026quot; 输入密码\\\u0026quot;([^\\\\\\\u0026quot;]*)\\\u0026quot; $/ do |username，password| performAction('enter_text_into_numbered_field'，username，1) performAction('enter_text_into_numbered_field'，password，2) end 现在应该能明白为什么你需要写汉字的脚本就可以了吧。\n在这里解释一下为什么如果业务存在功能修改这种情况，自动化脚本的修改量会小。\n还是以这个登录脚本为例：\n假如现在输入用户名和密码的输入框顺序变了，在你的页面显示上，可能是从左下角移到中间了，这种变化，那么feature文件你不用改，只需要改step_definition脚本就好了 运行报告 alabash-android支持很多报告生成模式，支持html，json，junit等等报告模式，只需要你在run的时候添加-f参数-o参数就可以了。\n例如 calabash-android run xxxx.apk -f html -o l，上图展示一下强大html报告\n【cucumber解析features文件】\nmy_first.feature: 描述在这个条件下需要做什么事情；\nFeature: Running a test As an iOS developer I want to have a sample feature file So I can begin testing quickly Scenario: Example steps1 Given I am on the Welcome Screen Then I swipe left And I wait until I don't see \u0026quot;Please swipe left\u0026quot; And take picture Scenario: Example steps2 Given I am on the Welcome Screen #ASSERTION Then I should see a \u0026quot;login\u0026quot; button #INPUT TEXT Then I enter \u0026quot;my_username\u0026quot; into text field number 1 # Then I touch \u0026quot;Return\u0026quot; #TOGGLE SWITCH Then I toggle the switch Then I touch \u0026quot;Login\u0026quot; And I touch \u0026quot;Second\u0026quot; And take picture 该文件描述了在“on the Welcome Screen”这个Step中需要做的事情，两个场景:steps1 和 steps2.\nmy_first_step.rb: 解释了Given的具体条件\nGiven /^I am on the Welcome Screen$/ do element_exists(\u0026quot;view\u0026quot;) check_element_exists(\u0026quot;label text:'First View'\u0026quot;) sleep(STEP_PSEAU) end 这个语句，判定了当前条件\u0026quot;on the Welcome Screen\u0026quot;是否满足，如果element存在，则就在\u0026quot;Welcome Screen\u0026quot;；\n","date":"2015-09-18T23:52:06+08:00","permalink":"https://it-boyer.github.io/post/old/macOS/Xcode%E5%92%8CJenkins%E6%8C%81%E7%BB%AD%E9%9B%86%E6%88%90%E7%9A%84%E5%87%A0%E7%A7%8D%E5%AE%9E%E7%8E%B0%E6%96%B9%E5%BC%8F/","section":"post","tags":["单元测试"],"title":"Xcode和Jenkins持续集成的几种实现方式"},{"categories":["解决方案"],"contents":"安装ruby环境： 方法一：下载源码，编译安装：配置中制定安装目录\n方法二：使用rvm安装：可以提供一个便捷的多版本 Ruby 环境的管理和切换\n方法三：使用macport安装 port install ruby\n详细教程\n问题：\nERROR: While executing gem ... (Errno::EPERM) Operation not permitted - /usr/bin/rake stackoverflow方法测试结果没走通。\n最终通过OS X 10.11中Rootless的实现与解释以及关闭方法解决.\nGem介绍 Gem是一个ruby库和程序的标准包，它通过RubyGem来定位、安装、升级和卸载，非常的便捷。\nRuby 1.9.2版本默认安装RubyGem，如果你使用其它版本，请参考如何安装RubyGem。\n升级RubyGem {%codeblock lang:ruby%} $ gem update \u0026ndash;system {%endcodeblock%}\n安装新的Gem {%codeblock lang:ruby%} $ gem install rai\n//指定安装某一版本的Gem包 gem install [gemname] \u0026ndash;version=1.3.2 {%endcodeblock%}\n在安装过程中可以看到如下提示，说明它是从rubygems.org内去寻找并安装gem package的。 Fetching source index for http://rubygems.org/\ngem 的安装方式 MacPorts安装和使用 http://ccvita.com/434.html\nhttp://guide.macports.org\nhttp://www.fantageek.com/318/install-pkg-config-for-mac-osx/\nMac下面除了用dmg、pkg来安装软件外，比较方便的还有用MacPorts来帮助你安装其他应用程序，跟BSD中的ports道理一样。MacPorts就像apt-get、yum一样，可以快速安装些软件。\n安装后，配置：\nsudo vi /etc/profile export PATH=/opt/local/bin:$PATH export PATH=/opt/local/sbin:$PATH MacPorts使用 http://witcheryne.iteye.com/blog/991821\n更新ports tree和MacPorts版本，强烈推荐第一次运行的时候使用-v参数，显示详细的更新过程。 sudo port -v selfupdate\n搜索索引中的软件\nport search name\n安装新软件\nsudo port install name\n卸载软件\nsudo port uninstall name\n查看有更新的软件以及版本\nport outdated\n升级可以更新的软件\nsudo port upgrade outdated\n实例：\nEclipse的插件需要subclipse需要JavaHL，下面通过MacPorts来安装\nsudo port install subversion-javahlbindings installed 列出全部或者指定的已经安装的软件：\nport installed port -v installed atlas dependents 查看哪些软件时依赖与这个软件的\n删除一个软件时候，最好先执行一下这个命令. port dependents openssl ","date":"2015-01-21T23:00:39+08:00","permalink":"https://it-boyer.github.io/post/old/shell/%E5%BF%AB%E9%80%9F%E6%AD%A3%E7%A1%AE%E7%9A%84%E5%AE%89%E8%A3%85RubyRails%E8%BF%90%E8%A1%8C%E7%8E%AF%E5%A2%83/","section":"post","tags":["pod"],"title":"快速正确的安装Ruby,Rails运行环境"},{"categories":["学习笔记"],"contents":" Stashing 储藏工作 应用储藏 被暂存的文件重新暂存 应用后，移除储藏的内容 取消储藏(Un-applying a Stash) 新建stash-unapply别名 从储藏中创建分支 Git工具 - 储藏（Stashing）git 原文 场景：当项目中某一部分正在编码中，突然接到新任务，又必须换至其他分支去完成。\n问题：你不想提交进行了一半的工作，否则以后你无法回到这个工作点。\n解决：**git stash **命令。\n“Stashing”可以获取工作目录的中间状态，即：将修改过的被追踪的文件和暂存的变更，保存到一个未完结变更的堆栈中，随时可以重新应用。\n储藏工作 进入项目目录，修改某个文件，有可能还暂存其中的一个变更。 **git status **命令,查看中间状态： {%codeblock lang:bash %} $ git status On branch master Changes to be committed: (use \u0026ldquo;git reset HEAD \u0026hellip;\u0026rdquo; to unstage) modified: index.html Changes not staged for commit: (use \u0026ldquo;git add \u0026hellip;\u0026rdquo; to update what will be committed) modified: lib/simplegit.rb {%endcodeblock%} 3. 切换分支，但不提交step 1 中的变更，所以储藏这些变更。 执行**git stash 命令，往堆栈中推送一个新的储藏： {%codeblock lang:bash %} $ git stash Saved working directory and index state \u0026ldquo;WIP on master: 049d078 added the index file\u0026rdquo; HEAD is now at 049d078 added the index file (To restore them type \u0026ldquo;git stash apply\u0026rdquo;) {%endcodeblock%} 4. 执行step 2查看目录库，中间状态就不见了： {%codeblock lang:bash %} $ git status #######On branch master nothing to commit, working directory clean {%endcodeblock%} 这时，你可以方便地切换到其他分支工作；你的变更都保存在栈上。 5. 使用git stash list**要查看现有的储藏： {%codeblock lang:bash%} $ git stash list stash@{0}: WIP on master: 049d078 added the index file stash@{1}: WIP on master: c264051 Revert \u0026ldquo;added file_size\u0026rdquo; stash@{2}: WIP on master: 21d80a5 added number to log {%endcodeblock%} 在这个案例中，之前已经进行了两次储藏，所以你可以访问到三个不同的储藏。\n应用储藏 执行**git stash apply命令, 可以重新应用最近的一次储藏； 执行git stash apply stash@{2}**命令，即通过指定储藏的名字，来应用更早的储藏。 {%codeblock lang:bash%} $ git stash apply\nOn branch master Changes not staged for commit: (use \u0026ldquo;git add \u0026hellip;\u0026rdquo; to update what will be committed) modified: index.html modified: lib/simplegit.rb {%endcodeblock%}\n可以看到 Git 重新修改了你所储藏的那些当时尚未提交的文件。在这个案例里，你尝试应用储藏的工作目录是干净的，并且属于同一分支；但是一个干净的工作目录和应用到相同的分支上并不是应用储藏的必要条件。你可以在其中一个分支上保留一份储藏，随后切换到另外一个分支，再重新应用这些变更。在工作目录里包含已修改和未提交的文件时，你也可以应用储藏——Git 会给出归并冲突如果有任何变更无法干净地被应用。\n被暂存的文件重新暂存 执行**git stash apply命令,虽然对文件的变更被重新应用，但是被暂存的文件没有重新被暂存。 执行git stash apply \u0026ndash;index**命令,即可让被暂存的文件重新暂存。 \u0026ndash;index选项告诉命令重新应用被暂存的变更： {%codeblock lang:bash%} $ git stash apply \u0026ndash;index\nOn branch master Changes to be committed: (use \u0026ldquo;git reset HEAD \u0026hellip;\u0026rdquo; to unstage) modified: index.html Changes not staged for commit: (use \u0026ldquo;git add \u0026hellip;\u0026rdquo; to update what will be committed) modified: lib/simplegit.rb {%endcodeblock%}\n应用后，移除储藏的内容 **apply 选项只尝试应用储藏的工作——储藏的内容仍然在栈上。 执行git stash drop 储藏的名字**命令，，即可从栈中彻底移除储藏内容： {%codeblock lang:bash%} $ git stash list stash@{0}: WIP on master: 049d078 added the index file stash@{1}: WIP on master: c264051 Revert \u0026ldquo;added file_size\u0026rdquo; stash@{2}: WIP on master: 21d80a5 added number to log $ git stash drop stash@{0} Dropped stash@{0} (364e91f3f268f0900bc3ee613f9f733e82aaed43) {%endcodeblock%} 你也可以运行 **git stash pop**命令，来重新应用储藏，同时立刻将其从堆栈中移走。\n取消储藏(Un-applying a Stash) 在某些情况下，重新应用了之前的储藏的变更，进行了一些其他的修改后，又想要取消之前所应用储藏的修改。 Git没有提供类似于 **stash unapply**的命令，但是可以通过取消该储藏的补丁达到同样的效果： {%codeblock lang:bash%} $ git stash show -p stash@{0} | git apply -R {%endcodeblock%} 同样的，如果你沒有指定具体的某个储藏，Git 会选择最近的储藏： {%codeblock lang:bash%} $ git stash show -p | git apply -R {%endcodeblock%}\n新建stash-unapply别名 你可能会想要新建一个別名，在你的 Git 里增加一个**stash-unapply** 命，这样更有效率。例如： {%codeblock lang:bash%} $ git config \u0026ndash;global alias.stash-unapply \u0026lsquo;!git stash show -p | git apply -R\u0026rsquo; $ git stash apply $ #\u0026hellip; work work work $ git stash-unapply {%endcodeblock%}\n从储藏中创建分支 如果你储藏了一些工作，暂时不去理会，然后继续在你储藏工作的分支上工作，你在重新应用工作时可能会碰到一些问题。如果尝试应用的变更是针对一个你那之后修改过的文件，你会碰到一个归并冲突并且必须去化解它。如果你想用更方便的方法来重新检验你储藏的变更，你可以运行 git stash branch，这会创建一个新的分支，检出你储藏工作时的所处的提交，重新应用你的工作，如果成功，将会丢弃储藏。 {%codeblock lang:bash%} $ git stash branch testchanges Switched to a new branch \u0026ldquo;testchanges\u0026rdquo;\nOn branch testchanges Changes to be committed: (use \u0026ldquo;git reset HEAD \u0026hellip;\u0026rdquo; to unstage) modified: index.html Changes not staged for commit: (use \u0026ldquo;git add \u0026hellip;\u0026rdquo; to update what will be committed) modified: lib/simplegit.rb Dropped refs/stash@{0} (f0dfc4d5dc332d1cee34a634182e168c4efc3359) {%endcodeblock%} 这是一个很棒的捷径来恢复储藏的工作然后在新的分支上继续当时的工作。\n","date":"2015-01-19T19:57:04+08:00","permalink":"https://it-boyer.github.io/post/old/git/Git%E4%B8%AD%E7%9A%84%E5%82%A8%E8%97%8F%E5%B7%A5%E5%85%B7stash/","section":"post","tags":["git"],"title":"Git中的储藏工具stash"},{"categories":["学习笔记"],"contents":"最近想做一个游戏服务器和 IM 互通的服务。最初的想法是可以增进游戏帐号的安全，比如游戏用户可以通过绑定一个 IM 帐号，从而不用登陆游戏就向游戏服务器发一些指令。这些指定通常是用来冻结一些帐号的功能。而游戏服务器也可以通过 IM 帐号向离线用户发送一些关键消息。这样，只需要解除绑定 IM 帐号需要一定的时间，或使用更安全的途径，即可以让游戏帐号更加安全。（至少，游戏用户可以从 IM 上获知他的游戏帐号每次登陆登出的时间、IP 等等）\n后来细想，这里面可以做的东西还有许多。玩家会因为多一个信息通道，而更轻松的去玩那些需要长期驻留的游戏。游戏厂商也可以多一个挽留玩家的渠道，甚至用来宣传新游戏或游戏的增值服务，等等。好处不再列举。\n其实、绑定 IM 帐号和绑定手机号本质上区别不大。只不过，IM 帐号几乎是零费用，又不像 SMS ，控制权掌控在移动手里。IM 更适合做双向交流（SMS 的双向交流不那么方便，而且对用户和游戏运营商都有经济负担）。独立提供一个 Game2IM 的服务供众多游戏运营商使用也是个有趣的主意。和 SMS 一样，只要给出一个简单接口让游戏运营商调用，把游戏网络和 IM 网络互联就可以了。\n实现这个想法有两个方案。其一是制作各种 IM 的机器人，通过机器人和用户 IM 沟通。这个方案技术门槛稍低，有许多现成的机器人可以使用。缺点是，受 IM 提供商的限制（比如好友数量限制）。无法使用机器人的签名针对性的向用户传递特有的消息。除非你为每个游戏用户定制一个机器人，但那样，每个机器人都需要单独一个连接，对资源消耗过大。 ￼\n第二个方案就是使用已有的 IM 互通方案，自己提供一个特有的 Game-IM 网络，跟已有的 IM 网络互通。比较流行的 IM 互通协议用基于 SIP 的 SIMPLE 和起源于 Jabber 的 XMPP 。\n我最常用的 IM 是 google talk ，本身就实现了标准的 XMPP Client 和 XMPP Server 协议；而我们的 网易 popo 也实现了 XMPP 的 s2s 网关。我想研究一下 XMPP 是个不错的选择。\n花了一整天的时间，把 XMPP 核心协议 仔细通读了一遍，收获颇多。原来以为 XMPP 是个可怕的巨无霸。我对 XML 原本也没有太多好感。最后，看法有所改变。\n其实，XMPP 仅仅是定义了一个网络服务间相互通讯的协议。它已经把服务间需要关心的东西减少到了最少。具体的应用每家服务提供商可以随意扩展。popo 在制作新版本时，我曾多次建议采用已有的标准协议，再此基础上开发自己的东西。当时或许大家都认为标准协议容易促手促脚，我当时也没啥研究，没有多言。今天看来，我更觉得这是一个决策失误。本来我们有一个很好的机会，利用 popo 联系起网易的各种服务，现在这条路将走的更为艰辛。其实，XMPP 定义的东西，即使自己去设计也会定义出类似的一套来。而把各种网络服务互通本该是发展的重点，为 IM Client 增添专有花哨的特性就有些舍本逐末了。更为恼火的是，popo 到现在也没有一个很好的非 Windows 平台解决方案。怎能让诸多把握着互联网上部分话语权的技术人士接受？（或者，同在杭州的 IT 圈子，popo 的开发人员是不是应该看看支付宝的同行们做了些什么？）\n谈谈我对 XMPP 的粗浅理解。这些仅仅建立在我对 RFC3920 的一天阅读的基础上，难免会有错误，不足以做技术参考。\nXMPP 抽象出一个在互联网上唯一的对象实体，用 JID 来表达。通常一个 JID 由三部分组成，node@domain/resource 。比 email 的表达形式多了一个 /resource 。这是因为 email 地址本身虽然可以表达一个实体，都是往往不够表达这个实体下的具体服务。就好比一个 ip 地址可以表示一台机器，但是我们还需要 port 号来表达这台机器具体提供的服务一样。\n用过 gtalk 的人应该很喜欢 gtalk 可以在不同的地方同时登陆这个不错的特性。用过以后，才能体会，无论是 qq 还是 msn 还是 popo ，只允许一个登陆是多么愚蠢的设定。gtalk 其实遵守了标准的 XMPP 协议，它用来区别一个帐号（一般是一个 gmail 邮件地址）的多处登陆，正是利用了不同的 resource 标识。\nXMPP 规范的最重要的一条通信协议就是，如何把消息从一个 JID 发送到另一个 JID (message)。这有点像 email 协议，但不同的是，它强调了实时性和安全性（虽然不是必须的）。因为 JID 可以在不同的 domain 下，这就需要 domain 间相互协作。对于 IM 网络来说（XMPP 远不只用于 IM 协议），就是不同的 IM 服务间互通。\n对于 domain 下的 xmpp 服务的发现，利用了 DNS 协议的一些功能。xmpp 的 s2s 服务提供位置，放在了 DNS 的 SRV 记录里。你可以用 nslookup 做个试验，启动 nslookup ，输入 set type=SRV\n然后查询 _xmpp-server._tcp.gmail.com 你会发现 gmail.com 的 xmpp s2s 服务地址已经端口号 5269 。同样，也可以查询 _xmpp-server._tcp.163.com 或 _xmpp-server._tcp.popo.163.com 查到网易 popo 的 xmpp 中转服务器地址。\nbtw, 查询 _xmpp-client._tcp.gmail.com 可以查到 gtalk 的 client 登陆地址，而网易 popo 则没有提供 xmpp client 登陆点。\n按 RFC3920 所述，在 xmpp server 互联的时候，会优先尝试获取 domain 的 SRV 记录，如果失败就直接去连默认的 6259 端口。然后就可以开始握手协议。\nxmpp 比较强调 s2s 的安全性，所以推荐的握手都是建立在 TLS 层之上，使用 SASL 认证。TLS 层需要服务器有一个数字证书，为了安全可信，建议是找个根证书签名。不过自己签名也行，只需要服务器缓存证书即可。握手过程在 RFC3920 中描述的非常细致，可以按照其编码，问题不大。需要注意的是，这里的 XML 流格式要求很精确，不允许传输多余的东西。我一度认为采用 XML 会导致协议的实现上非常臃肿，其实不然。采用 XML 只是一个表象，适合人阅读和调错而已。RFC 中特别要求不去实现 XML 中的某某特性就是一例。我们不应该为了 XML 而去 XML 。\n其实 XMPP 的 c2s 和 s2s 并无太大区别，s2s 做的人手我想是因为开源项目和开源库比较少吧。而开源的 client 实现则是一大堆。c2s 和 s2s 的通讯都是基于那几条协议而已，s2s 的实现难点在于握手比较复杂（其实 c2s 也一样，只是很多库帮你做好了）。c2s 是共享一个 tcp 连接做双向通讯；而 s2s 则是用两条 TCP 连接。两条连接也一定程度上避免了 s2s 的欺骗，当然真正的安全来至于 TLS 和 SASL 的保障。DNS 毕竟是一个很脆弱的东西。\n除了点对点消息外，XMPP 定义了消息的组播。也就是一个 JID 可以以自己的名义发布消息 (presence)。而服务器来决定该发给谁。发送目标是由订阅消息决定的。其它多个 JID 可以订阅某个 JID 的消息。对于 IM 来说，最常用的就是上线下线等状态变化消息了。\n第三条即是对某个 JID 的状态进行设置和获取 (iq)。于 IM 应用来说，设置签名，昵称，状态等都依赖于它。\nXMPP 的核心协议无非规定了以上三种通讯协议，此外规范了服务器间互连的握手认证方案。然后给出了一些错误信息的表述方法。稍微了解过之后，很容易编写。如果希望重造轮子的话，对于 C 语言开发者来说，最繁琐的可能是 XML 的解析于生成。我自己稍微考察了一下，有个叫 LoudMouth 的库还不错。\n如果实现 s2s 网关的话，有些细节做起来可能很麻烦，比如查询 DNS 的 SRV 记录。这个在 jabberd 1.x 里其实有独立的模块实现好了，取来用即可 (见 dnsrv) 。而 TLS SASL 层的实现则早就有现成的开源库了。\n实现一个 jabber server 或许比你想象的还简单。in.jabberd 居然只用 600 多行 C 代码就从零实现了一个 jabber 服务器。当然功能非常的简陋了。\n至于我想做的东西，我希望一个在名为 xyz 的梦幻西游服务器上的 12345 号玩家，一旦选择绑定他的 popo 帐号 player@popo.163.com ，他在他的 popo 上就会收到名叫 12345.xyz@xyq.163.com 的好友请求。当他通过好友认证后，就可以从这个通道获取游戏里的信息，也可以对游戏帐号做有限的操作。我想有了这样一项服务，对玩家对运营商都会有极大的好处的。 其他资源： 使用 XMPP 构建一个基于 web 的通知工具 ","date":"2015-01-06T14:36:06+08:00","permalink":"https://it-boyer.github.io/post/old/%E5%BC%80%E6%BA%90%E5%BA%93/XMPP%E7%AE%80%E5%8D%95%E7%A0%94%E7%A9%B6%E8%BD%AC/","section":"post","tags":[],"title":"XMPP简单研究[转]"},{"categories":["解决方案"],"contents":"按比例缩放 按比例缩放，这是在Interface Builder中无法设置的内容。\n而在代码中，有如下两种实现方式:\n使用NSLayoutConstraint类型的初始化函数中的multiplier参数就可以非常简单的设置按比例缩放。 同时也可以设置不同NSLayoutAttribute参数来达到意想不到的效果，比如“A的Width等于B的Height的2倍”这样的效果。 现在就拿一个简单的**UIButton**做示例，在ViewController中创建一个UIButton字段：\n{%codeblock lang:objc%} UIButton *btn;\n{%endcodeblock%}\n需求 1： 要求**UIButton水平居中，始终距离父View底部20**单位，其高度是父View高度的三分之一。 使用KVO来监控**UIButton**的大小并实时输出到屏幕上。\n{%codeblock lang:objc%} (void)viewDidLoad { [super viewDidLoad];\n//创建UIButton，不需要设置frame btn = [UIButton buttonWithType:UIButtonTypeRoundedRect]; [btn setTitle:@\u0026ldquo;mgen\u0026rdquo; forState:UIControlStateNormal]; btn.backgroundColor = [UIColor greenColor]; [self.view addSubview:btn];\n//禁止自动转换AutoresizingMask btn.translatesAutoresizingMaskIntoConstraints = NO;\n//居中 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeCenterX relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeCenterX multiplier:1 constant:0]];\n//距离底部20单位 //注意NSLayoutConstraint创建的constant是加在toItem参数的，所以需要-20。 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeBottom relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeBottom multiplier:1 constant:-20]];\n//定义高度是父View的三分之一 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeHeight multiplier:0.3 constant:0]];\n//注册KVO方法 [btn addObserver:self forKeyPath:@\u0026ldquo;bounds\u0026rdquo; options:NSKeyValueObservingOptionNew | NSKeyValueObservingOptionInitial context:nil]; }\n//KVO回调\n(void)observeValueForKeyPath:(NSString *)keyPath ofObject:(id)object change:(NSDictionary *)change context:(void *)context { if (object == btn \u0026amp;\u0026amp; [keyPath isEqualToString:@\u0026ldquo;bounds\u0026rdquo;]) { [btn setTitle:NSStringFromCGSize(btn.bounds.size) forState:UIControlStateNormal]; } } {%endcodeblock%}\n运行结果： 需求 2： 在横向的显示中，Button的高度只有96，所以要求Button的最小高度为150。 涉及到的相关特性：\n优先级：当两个**Constraint同时作用在一个控件时，在某些情况下是有冲突的，可以通过设置Constraint的优先级来解决。 优先级对应NSLayoutConstraint类型的priority属性，默认值是UILayoutPriorityRequired，数值上等于1000**. 设置一个低的值代表更低的优先级。 最小值的定义：使用**NSLayoutRelationGreaterThanOrEqual作为NSLayoutConstraint类型创建时的relatedBy**参数。 修改上面的比例Constraint，并在下方加入一个新的限制最小值的Constraint，代码：\n{%codeblock lang:objc%} //定义高度是父View的三分之一 //设置优先级低于UILayoutPriorityRequired(1000)，UILayoutPriorityDefaultHigh是750 NSLayoutConstraint *con = [NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationEqual toItem:self.view attribute:NSLayoutAttributeHeight multiplier:0.3 constant:0]; con.priority = UILayoutPriorityDefaultHigh; [self.view addConstraint:con];\n//设置btn最小高度为150 [btn addConstraint:[NSLayoutConstraint constraintWithItem:btn attribute:NSLayoutAttributeHeight relatedBy:NSLayoutRelationGreaterThanOrEqual toItem:nil attribute:NSLayoutAttributeNotAnAttribute multiplier:1 constant:150]]; {%endcodeblock%}\n运行后，横向屏幕中的Button高度成了150：\nintrinsicContentSize 控件的内置大小 控件的内置大小是由控件本身的内容所决定的，比如一个UILabel的文字很长，那么该UILabel的内置大小自然会很长。\n在代码中获取控件的内置大小的方法：\n通过UIView的intrinsicContentSize属性来获取； 通过invalidateIntrinsicContentSize方法来在下次UI规划事件中重新计算intrinsicContentSize。 注意：如果直接创建一个原始的UIView对象，它的内置大小为0。\n先写一个辅助方法来快速设置UIView的边距限制：\n{%codeblock lang:objc%} //设置Autolayout中的边距辅助方法\n(void)setEdge:(UIView*)superview view:(UIView*)view attr:(NSLayoutAttribute)attr constant:(CGFloat)constant { [superview addConstraint:[NSLayoutConstraint constraintWithItem:view attribute:attr relatedBy:NSLayoutRelationEqual toItem:superview attribute:attr multiplier:1.0 constant:constant] ]; } {%endcodeblock%}\n接下来，创建一个UIView，利用上面的辅助方法快速设置其在父控件的左，上，右边距为20单位。如下代码：\n{%codeblock lang:objc%} //view1 UIView view1 = [UIView new]; view1.backgroundColor = [UIColor yellowColor]; //不允许AutoresizingMask转换成Autolayout view1.translatesAutoresizingMaskIntoConstraints = NO; [self.view addSubview:view1]; //设置左，上，右边距为20. [self setEdge:self.view view:view1 attr:NSLayoutAttributeLeft constant:20]; [self setEdge:self.view view:view1 attr:NSLayoutAttributeTop constant:20]; [self setEdge:self.view view:view1 attr:NSLayoutAttributeRight constant:-20]; {%endcodeblock%}\n但是运行后会发现，界面上不会显示任何东西。原因就是上面讲的，UIView默认是没有*intrinsicContentSize**的。 创建一个自定义的UIView来改写**intrinsicContentSize：MyView:\n然后在.m文件中改写intrinsicContentSize**方法，并返回有效值，比如这样：\n{%codeblock lang:objc%} //改写UIView的intrinsicContentSize\n(CGSize)intrinsicContentSize { return CGSizeMake(70, 40); }\n{%endcodeblock%}\n接着修改最上面的代码，把上面view1变量的类型从UIView替换成我们自定义的View：MyView类型：\n{%codeblock lang:objc%} MyView *view1 = [MyView new];\n{%endcodeblock%}\n再次运行代码，View会按照要求显示在屏幕上：\n按照同样的方式，在下方添加另一个MyView，要求其距离父控件边距左，下，右各为20，代码：\n{%codeblock lang:objc%} //view2\nMyView *view2 = [MyView new];\nview2.backgroundColor = [UIColor yellowColor];\n//不允许AutoresizingMask转换成Autolayout\nview2.translatesAutoresizingMaskIntoConstraints = NO;\n[self.view addSubview:view2];\n//设置左，下，右边距为20.\n[self setEdge:self.view view:view2 attr:NSLayoutAttributeLeft constant:20];\n[self setEdge:self.view view:view2 attr:NSLayoutAttributeBottom constant:-20];\n[self setEdge:self.view view:view2 attr:NSLayoutAttributeRight constant:-20];\n{%endcodeblock%} 需求： 通过代码加入Autolayout中的间距，命令view1和view2上下必须间隔20个单位。 2. - 这里要求view2在view1之下的20单位，所以创建NSLayoutConstraint中view2参数在前面。\n2. - view2的**attribute参数是NSLayoutAttributeTop，而view1的attribute参数是NSLayoutAttributeBottom**\n拉伸view2,而不拉伸view1。\n控件的**Content Hugging Priority**拒绝拉伸的优先级，优先级越高，控件会越不容易被拉伸。 控件的**Content Compression Resistance Priority**拒绝压缩内置空间(intrinsicContentSize)的优先级。优先级越高，控件的内置空间(intrinsicContentSize)会越不容易被压缩。 {%codeblock lang:objc%} //设置两个View上下间距为20 [self.view addConstraint:[NSLayoutConstraint constraintWithItem:view2 attribute:NSLayoutAttributeTop relatedBy:NSLayoutRelationEqual toItem:view1 attribute:NSLayoutAttributeBottom multiplier:1.0 constant:20] ]; {%endcodeblock%}\nOK，的确，此时view1和view2相互间隔20单位，但是view1被拉伸了。\n使用控件的**Content Hugging Priority，如下图：\n如图,把view1（上图中被拉伸的，在上面的View）的Content Hugging Priority设置一个更高的值，那么当Autolayout遇到这种决定谁来拉伸的情况时，view1不会被优先拉伸，而优先级稍低的view2才会被拉伸。\n可以直接通过UIView的setContentHuggingPriority:forAxis方法来设置控件的Content Hugging Priority，其中forAxis参数代表横向和纵向，本例中只需要设置纵向，所以传入UILayoutConstraintAxisVertical**。整句代码：\n{%codeblock lang:objc%} //提高view1的Content Hugging Priority [view1 setContentHuggingPriority:UILayoutPriorityDefaultHigh forAxis:UILayoutConstraintAxisVertical]; {%endcodeblock%}\n","date":"2014-09-02T15:53:11+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/UI/%E4%BB%A3%E7%A0%81%E5%AE%9E%E7%8E%B0AutoLayout%E7%9B%B8%E5%85%B3%E7%89%B9%E6%80%A7/","section":"post","tags":[],"title":"代码实现AutoLayout相关特性"},{"categories":["学习笔记"],"contents":"URL Schemes iPhone SDK中最酷的功能之一是一个应用程序能够把自己和自定义的URL协议绑定，这个URL协议可用于启动该应用程序（通过浏览器或者iPhone上的另一个程序）。创建这样的绑定并不难，难得的是你忍不住要在你的程序里用它！\n首先，你需要说明你想如何在程序中响应这个URL。最简单的自定义协议的方法是“唤醒”，而且可以通过URL把数据信息传递给程序，这样，程序被唤醒后能做更多的事情。\n注册自定义URL协议 首先需要向iPhone注册一个自定义URL协议。这是在你的项目文件夹的info.plist文件进行的（就是你改变应用程序图标的同一个文件）。\n默认，Xcode在图形窗口中打开info.pllist，当然也可以直接用文本模式打开——对有的人来说这反而更简单。\nStep1. 右键，选择“Add Row”,在下拉选框中选择“URL types”，类型为Array: Step2. 打开“Item 0″类型为Dic,添加新key为\u0026quot;URL identifier\u0026quot;,类型为String。可以是任何值，但建议用“反域名”(例如 “com.myapp”)。 Step3. 打开“Item 0″类型为Dic,添加新key为“URL Schemes”,类型为Array: 类型为Array: Step4. 在URL Schemes数组中添加Value，输入你的URL协议名 (例如“myapp://” 应写做“myapp”)。如果有必要，你可以在这里加入多个协议。 完成后如图所示： 另两种视图浏览方式： 在info.plist页面上右击，选择Raw Keys/Values显示如下：\nxml 处理URL 现在，URL已经注册好了。任何人都可以用打开URL的方式通过你的协议去启动一个应用程序。\n使用Safari 方式启动 app:Calling Custom URL Scheme from Safari【下载】 Using the simulator, here’s how to call the app:\nRun the application from within Xcode Once installed, the custom URL scheme will now be registered Close the app via the Hardware menu in simulator and choose Home Start Safari Enter the URL scheme defined previously in the browser address bar (see below) 通过其他应用启动：Calling Custom URL Scheme from Another iPhone App【下载】 按钮的实现： {%codeblock lang:objc%} - (void)buttonPressed:(UIButton *)button { NSString *customURL = @\u0026ldquo;iOSDevTips://\u0026rdquo;;\nif ([[UIApplication sharedApplication] canOpenURL:[NSURL URLWithString:customURL]]) { [[UIApplication sharedApplication] openURL:[NSURL URLWithString:customURL]]; } else { UIAlertView *alert = [[UIAlertView alloc] initWithTitle:@\u0026quot;URL error\u0026quot; message:[NSString stringWithFormat: @\u0026quot;No custom URL defined for %@\u0026quot;, customURL] delegate:self cancelButtonTitle:@\u0026quot;Ok\u0026quot; otherButtonTitles:nil]; [alert show]; } } {%endcodeblock%} Line 5 we check to see if the custom URL is defined, and if so, use the shared application instance to open the URL (line 8).\nThe **openURL:**method starts the application and passes the URL into the app. The current application is exited during this process.\n通过URL Schemes 传递参数启动应用：Passing Parameters To App Via Custom URL Scheme Chances are you’ll need to pass parameters into the application with the custom URL definition. Let’s look at how we can do this with.\nThe **NSURL **class which is the basis for calling from one app to another conforms to the RFC 1808 (Relative Uniform Resource Locators). Therefore the same URL formatting you may be familiar with for web-based content will apply here as well.\nIn the application with the custom URL scheme, the app delegate must implement the method with the signature below: {%codeblock lang:objc%}\n(BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation {%endcodeblock%}\nThe trick to passing in parameters from one app to another is via the URL.\nFor example, assume we are using the following custom URL scheme and want to pass in a value for a ‘token’ and a flag indicating registration state, we could create URL as follows: {%codeblock lang:objc%} NSString *customURL = @\u0026ldquo;iOSDevTips://?token=123abct\u0026amp;registered=1\u0026rdquo;; {%endcodeblock%}\nAs in web development, the string ?token=123abct\u0026amp;registered=1 is known as the query string. Inside the app delegate of the app being called (the app with the custom URL), the code to retrieve the parameters would be as follows: {%codeblock lang:objc%} - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { NSLog(@\u0026ldquo;Calling Application Bundle ID: %@\u0026rdquo;, sourceApplication); NSLog(@\u0026ldquo;URL scheme:%@\u0026rdquo;, [url scheme]); NSLog(@\u0026ldquo;URL query: %@\u0026rdquo;, [url query]);\nreturn YES; } {%endcodeblock%}\nThe output from the app with the custom URL (using my Bundle ID), when called from another app, is as follows: {%codeblock lang:objc%} Calling Application Bundle ID: com.3Sixty.CallCustomURL URL scheme:iOSDevTips URL query: token=123abct\u0026amp;registered=1 {%endcodeblock%}\nTake note of the ‘Calling Application Bundle ID’ as you could use this to ensure that only an application that you define can interact directly with your app.\nLet’s change up the delegate method to verify the calling application Bundle ID is known: {%codeblock lang:objc%} - (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation { // Check the calling application Bundle ID if ([sourceApplication isEqualToString:@\u0026ldquo;com.3Sixty.CallCustomURL\u0026rdquo;]) { NSLog(@\u0026ldquo;Calling Application Bundle ID: %@\u0026rdquo;, sourceApplication); NSLog(@\u0026ldquo;URL scheme:%@\u0026rdquo;, [url scheme]); NSLog(@\u0026ldquo;URL query: %@\u0026rdquo;, [url query]);\nreturn YES; } else return NO; } {%endcodeblock%} It’s important to note that you cannot prevent another application from calling your app via custom URL scheme, however you can skip any further processing and return NO as shown above. With that said, if you desire to keep other apps from calling your app, create a unique (non-obvious) URL scheme. Although this will guarantee you app won’t be called, it will make it more unlikely.\nCustom URL Scheme Example Projects\nI realize it can be a little tricky to follow all the steps above. I’ve included two (very basic) iOS apps, one that has the custom URL scheme defined and one that calls the app, passing in a short parameter list (query string). These are good starting points to experiment with custom URL’s.\nDownload Xcode project for app with Custom URL scheme\nDownload Xcode project for app to call custom URL scheme\n","date":"2014-08-28T20:32:48+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/%E5%9C%A8IOS%E4%B8%AD%E8%87%AA%E5%AE%9A%E4%B9%89URLSchemes%E6%95%99%E7%A8%8B/","section":"post","tags":["iOS"],"title":"在IOS中自定义URLSchemes教程"},{"categories":["学习笔记"],"contents":"HeaderDoc 是在Xcode 5 和 iOS7 发布时，新增的一个命令行工具，功能：可以从代码中自动生成格式良好的HTML文档——当然，必须依赖于特定格式的注释来完成的。\n另外，Xcode 还会在 quick look 面板中以HeaderDoc风格显示你的注释。\n通过本教程，将学习如下几点：\n如何书写 HeaderDoc 风格的注释 分如何在 Xcode 中预览文档 如何生成 HTML 文档 如何使用 VVDocumenter-Xcode(一个易于使用的第3方文档制作工具) 准备工作 下载本教程中用到的 示例项目\n这个简单的示例程序只包含了两个类：\nCar: 包含几个属性及一个 “drive” 方法以及一个 completion 块。 MathAPI: 包含了1个方法，用于累加两个数。 现在，这两个类还没有任何注释。以便演示如何通过 HeaderDoc 为这两个类创建文档。 HeaderDoc 注释 HeaderDoc 可以从命令行中运行，也可以通过 Xcode 运行。它扫描文件中以某种格式书写的注释,包括这3种形式： 这3中语法在 Xcode 中产生同样效果的文档\n注释 1. 一般用于单行注释 /// Your documentation comment will go here 注释 2. /** * Your documentation comment will go here */ 注释 3: 一般用于较长的注释块 /*! * Your documentation comment will go here */ 注意：在注释2和注释3中，在每一行开头都会有一个额外的*，直至结尾的 */。这仅仅是为了美观，而不是必须的。 HeaderDoc 标签 当 HeaderDoc 发现上述3种注释，它就开始寻找其中的HeaderDoc 标签。HeaderDoc 标签 用来修饰HeaderDoc 注释。\nHeaderDoc 标签以 @ 符号开头，然后是关键字，然后是一个空格，最后才是相应的文本（例如 @param foo）。 HeaderDoc 标签可以分为两种：\n顶级标签: 这些标签声明所要注释的对象的类型（例如头部声明、类、方法等等）。\n顶级标签，例如 @typedef，用于表示 typedef 定义的类型，比如枚举、结构体和函数指针。 HeaderDoc 能够根据上下文自动产生顶级标签，因此通常不是必须的。 二级标签:这些标签才是具体的注释内容。\n@brief: 简单描述你准备文档化的数据的类型，方法等等。 @abstract: 等于 @brief。 @discussion: 类似 @abstract 和 @brief，但允许多行。它不是必须的，仅仅是为了使描述更清晰。 @param: 描述方法、回调或函数的参数名称。 @return: 描述方法或函数的返回值。（等同于 @result） 具体实现 属性的文档化 用 Xcode 打开DocumentationExamples 项目, 打开ViewController.h, 在** car **属性的前面，加入一行注释:\n/*! * @brief The ViewController class' car object. */ @property (nonatomic) Car *car; 编译项目。编译结束，按住 alt/option 键，点击car 变量名。你将看到pop菜单中显示了刚才的注释内容。 另一种方法:切换到Utitlities 面板的Quick Help 检查器窗口。点击 car 变量名，通过Quick Help,你将看到如下效果：\n方法的文档化 MathAPI包含一个方法需要文档化。打开MathAPI.h,找到addNumber:toNumber:。\n这个方法有两个参数及一个返回值。因此需要一个 @description 标签、两个@param标签，以及一个@return 标签，如下面所示：\n/*! * @discussion A really simple way to calculate the sum of two numbers. * @param firstNumber An NSInteger to be used in the summation of two numbers * @param secondNumber The second half of the equation. * @return The sum of the two numbers passed in. */ + (NSInteger)addNumber:(NSInteger)firstNumber toNumber:(NSInteger)secondNumber; 编译，再 alt + 左键：\n问题: 在 Xcode 文本编辑窗口，很多地方都支持 alt+左键。请确保你点击在正确的地方。在上面的例子里，你应当在addNumber: 和 toNumber: 两处使用 alt+左键。\n你也许不知道，这个方法的实现真的很恶心。它只能使用非负数作为参数。为了让用户明白这一点，你应当在注释中添加更多的说明。因此，我们可以在 @return 前面加入一个 @warning 标签。\n* @warning Please make note that this method is only good for adding non-negative numbers. 编译项目，然后使用 alt+左键。我们添加的 @warning 标签效果如下：\nCode Snippets，让一切变得更简单: 一个snippet 是一个可以重用的代码块（存储在 snippet 库中）。Snippets 甚至可以包含一些需要你去填充的占位符。 这意味着, 可以用 snipppet来进行文档化。\n在 MathAPI.h 中，在原有的注释上面加入以下内容：\n/*! * @discussion * @param * @return */ 注意，当粘贴上述代码时，“”之间的内容会变成一个token,意味着可以通过 tab 键在 token 之间来回切换。就像编写代码时的自动完成功能。\n学习使用Code Snippets工具 打开 Utilities 面板中的 CodeSnippets Library 检查器窗口，选中上述注释块，将它拖到该检查器窗口中（从某个 token 例如开始拖）: 将会弹出一个编辑窗口让输入 snippet 的某些信息，并以此来创建一个自动完成快捷方式。要修改某个snippet时,直接点击 Code Snippet Library 中的 snippet，然后点 Edit 按钮。按照如下形式填写：\n要想让 snippet 生效，首先删除原有注释，然后将鼠标放到addNumber:toNumber: 方法的 + 号前面,输入doccomment，然后回车，该snippet 将自动生成。然后，通过 Tab 键在3个 token 间移动，并填充它们。最终完成的文档化结果如下:\n/*! * @discussion A really simple way to calculate the sum of two numbers. * @param firstNumber An NSInteger to be used in the summation of two numbers. * @param secondNumber The second half of the equation. * @warning Please make note that this method is only good for adding non-negative numbers. * @return The sum of the two numbers passed in. */ @param 标签和 @warning 标签需要手动书写。\nTypedefs的文档化 打开 Car.h，在 class 之,有一个NS_ENUM，即 typedef enum，一个块，几个属性，一个空方法等，需要文档化。\n还记得 @typedef 标签吗？ 这个顶级标签稍微特殊一点。它可以对typedef enum 或者 typedef struct 的类型进行注释。 根据注释的对象的不同，它会包含与定义的类型相关的二级标签。\n以 enum 为例，它会包含 @constant 标签，用于每个常量（对于struct，则会是 @field 标签）。\n找到 enum OldCarType。它包含两个常量，是用于古典汽车的。在typedef 声明之上，将原来的注释替换为：\n/*! * @typedef OldCarType * @brief A list of older car types. * @constant OldCarTypeModelT A cool old car. * @constant OldCarTypeModelA A sophisticated old car. */ typedef enum { /// A cool, old car. OldCarTypeModelT, /// A sophisticated older car. OldCarTypeModelA } OldCarType; 编译，然后在 OldCarType 或上OldCarTypeModelT使用alt + 左键。\n在这个类中只有一个 NS_ENUM，因此接下来进行进行文档化。常量已经注释了，只要对整个NS_ENUM 进行一个总体的注释就可以了。\n/*! * @typedefCarType * @brief Alist of newer car types. * @constantCarTypeHatchback Hatchbacks are fun, but small. * @constantCarTypeSedan Sedans should have enough room to put your kids, and your golfclubs * @constantCarTypeEstate Estate cars should hold your kids, groceries, sport equipment,etc. * @constantCarTypeSport Sport cars should be fast, fun, and hard on the back. */ 注意:这个enum 是通过宏来声明的，悲催的 Xcode 不能完全支持和 typedef enum 一样的文档特性，虽然NS_ENUM 实际上是声明 enums 的推荐的方法。\ntypedef block 文档化 /*! * @brief A block that makes the car drive. * @param distance The distance is equal to a distance driven when the block is ready to execute. It could be miles, or kilometers, but not both. Just pick one and stick with it. ;] */ typedef void(^driveCompletion)(CGFloat distance); typedef block 的文档化和之前的并无多少不同，它包含了：\n一个 @brief 标签，简单说明了一下这个块的作用。 一个 @param 标签，说明调用块时需要传递的参数。 添加格式化代码到文档中 例如，Car 类的 driveCarWithComplete: 方法。\n这个方法以块作为参数，因为块对于新手来说一般比较困难，因此最好是告诉程序员如何使用这个方法。\n这需要使用 @code 标签。在 driveCarWithCompletion方法声明之前添加如下内容：\n/*! * @brief The car will drive, and then execute the drive block * @param completion A driveCompletion block * @code [car driveCarWithCompletion:^(CGFloat distance){ NSLog(@\u0026quot;Distance driven %f\u0026quot;, distance); }]; */ 编译，在方法名上使用alt+左键。如下图所示：\n检查文档 学会了如何添加注释，如果 Xcode 能帮你检查你的工作，就像Xcode会自动检查代码中的语法错误，那岂不是更好？有一个好消息，Clang 有一个标志，叫做“CLANG_WARN_DOCUMENTATION_COMMENTS”,可以用于检查 HeaderDoc 格式的注释。\n打开 DocumentationExamples的项目设置，点击 Build Settings，找到 DocumentationComments, 将值设置为 YES。 如下，打开 MathAPI.h，将第一个 @param 标签的参数名由firstNumber 修改为 thirdNumber,然后编译。 有一个警告发生，甚至提出了修改建议。它不会影响任何事情，但有助于检查文档中的错误。\n特殊注释 Xcode 还支持几种特殊注释，对于你或者使用你代码的人非常有用。\n打开 Car.m，在 driveCarWithCompletion: 方法中，在调用completion 块之前添加下列注释：\n// FIXME: This is broken // !!!: Holy cow, it should be checked! // ???: Perhaps check if the block is not nil first? 这里出现了3中注释：\nFIXME: 某个地方需要修正 !!!: 某个地方需要注意。 ???: 代码中有问题，或者代码是可疑的。 这些注释不但有助于浏览代码，而且 Xcode 绘制 Jump Bar 中显示它们。点击Jump Bar，如下图所示：\n你将看到这3个注释以粗体显示：\n到此，你已经完全掌握了如何对项目进行文档化。花一些时间对项目的其他属性和方法操作一番，并加入一些自己的东西。看看在注释块中改变一些东西或者删除某个标签会发生什么。这将让你明白注释格式如何对文档造成影响的。\n#用headerdoc2html 创建 HTML文档 文档化是由一个 HeaderDoc 工具完成的。当 Xcode 安装时，它就已经安装好了。 它除了解释已添加的注释，显示一个弹出菜单以及将注释在Quick Help 中显示之外，还可以在文档化之后创建 HTML、XML 以及联机帮助手册。\n本节介绍 HTML 文件的制作。如果你对用 HeaderDoc 如何创建在线文档感兴趣，请参考HeaderDoc 用户指南.\n打开终端，转到 DocumentationExamples 项目目录：\ncd /path/to/your/folder 确保该路径下包含了 Xcodeproject 文件(“DocumentationExamples.xcodeproj”)。 然后用下列命令创建 HTML 文档：\nheaderdoc2html -o ~/Desktop/documentation DocumentationExamples/ 此时终端会有许多输出。当创建完毕，返回桌面，出现一个名为documentation 的目录。双击打开，找到 Car_h 目录，打开 index.html：\nheaderdoc2html 脚本有两个参数：\nSo what justhappened? Well, you ran the headerdoc2htmlscript with 2 options:\n-o ~/Desktop/documentation – 这个参数指定输出的 Html 文件路径——即桌面的 documentation 目录。 DocumentationExamples/ – 该参数指定要解析的源文件位于 DocumentationExamples 目录（不包含项目目录下的其他目录，因为它们并不包含源代码） 问题:\n最新版本headerdoc2html有个问题，用 google chrome打开 index.html后，左边的目录显示不正常，但 Safari打开正常。 最新版本的headerdoc2html 不能正确解析 /// 类的注释，可以使用 /*! 类型的注释代替。 这很酷，但还可以更进一步。除了手动进入到输出目录中进行导航，HeaderDoc还会创建一个主目录索引。 返回终端，导航至新建的 documentation 目录，输入：\ncd ~/Desktop/documentation 然后输入命令，创建内容索引:\ngatherheaderdoc . gatherheaderdoc自动查找目录，为 . 目录（表示当前目录）创建索引。 用 Finder 打开 documentation 目录。你会发现多出一个 masterTOC.html 文件。打开它，它将列出所有已文档化的属性、方法、枚举和块的链接。 你可以将所有 HTML 文件放到 web 服务器上，然后所有人都可以访问你的文档！\n#VVDocumenter-Xcode\n最后的内容是 VVDocumenter-Xcode，一个第三方 Xcode插件，它能让你的文档化工作简单至比使用早先介绍的 Code Snippet 更容易。\n首先，从 Github 下载插件。\n你所需要做的全部工作就是打开项目，然后 Build。它会将插件自动安装到~/Library/ApplicationSupport/Developer/Shared/Xcode/Plug-ins 目录。\n然后重启 Xcode。再次打开 DocumentationExamples项目。在 MathAPI.h，删除 addNumber:toNumber 方法的注释块，然后在方法声明上面输入：\n/// VVDocumenter-Xcode 将自动创建注释块，包括所有必要的 @param 标签以及自动完成 token。\n打开 Car.h，删除 NS_ENUM CarType 的注释，以及每个常量的注释。在NS_ENUM 声明之上，输入：\n/// 这回，它会在 enum 之上创建 discussion 标签，甚至还每个常量上面放入了必要的注释！\nVVDocumenter-Xcode 使你的生活更加轻松。如果你想定制VVDocumenter-Xcode，在Xcode中，使用 Window\u0026gt;VVDocumenter菜单。\n这里，你可以改变自动完成关键字、注释风格以及其他。你想怎样定制 VVDocumenter-Xcode都行。VVDocumenter-Xcode 为我省下了大量的时间！ 接下来做什么？\n最终完成的示例项目在 这里下载。\n在你自己的代码中进行文档化。尝试自己编写 code snippet 并使用VVDocumentor。\n","date":"2014-08-28T15:18:41+08:00","permalink":"https://it-boyer.github.io/post/old/xcode/XcodeHeaderDoc%E6%95%99%E7%A8%8B/","section":"post","tags":["工具","文档"],"title":"XcodeHeaderDoc教程"},{"categories":["学习笔记"],"contents":"Segue原理: 在iOS开发中，segue用来实现storyboard中源视图控制器和目标视图控制器连接，当segue被触发时，系统将完成下列操作：\n实例化目标视图控制器 实例化一个新segue对象，该对象持有所有的信息 调用源视图控制器的prepareForSegue:sender:方法， 调用segue的 perform 方法将目标控制器带到屏幕上。\n这个动作行为依赖segue的类型如modal,push,custom,modal segue告诉源视图控制器present目标视图控制器。 在源视图控制器的prepareForSegue:sender:的方法中，执行对目标视图控制器所有必要的属性配置，包括委托设置（如目标视图控制器有协议）。\n在apple的文档库中第二个示例应用开发文档中，介绍了这样一个segue的使用例子。 {%codeblock lang:objc%}\n(void) prepareForSegue:(UIStoryboardSegue *)segue sender:(id)sender\n{\nif ([[segue identifier] isEqualToString:@\u0026ldquo;ShowSightingsDetails\u0026rdquo;])\n{\n//当用户选择表视图中的一行时，触发segue事件，传输数据到目标视图控制器，使目标控制器上能显示sighting DetailViewController *detailViewController = [segue destinationViewController];\ndetailViewController.sighting = [self.dataController objectInListAtIndex:[self.tableView indexPathForSelectedRow].row];\n}\nif ([[segue identifier] isEqualToString:@\u0026ldquo;ShowAddSightingView\u0026rdquo;])\n{\nAddSightingViewController *addSightingViewController = [[[segue destinationViewController] viewControllers] objectAtIndex:0];\naddSightingViewController.delegate = self;\n}\n}\n{%endcodeblock%}\n在storyboard中，这个实现方法代码是用来处理从主视图控制器到两个不同的目标视图控制器的segue。这两个segue通过它们的identifier属性进行判断，具体解释如下：\nidentifier为\u0026quot;ShowSightingsDetails\u0026ldquo;时，目标视图控制器是一个展示明细信息的视图控制器,使用的segue类型为push。这种通常用于navigator视图控制器中。\n在identifier为\u0026rdquo;ShowAddSightingView\u0026ldquo;时，目标视图控制器管理的是一个新加的sighting信息视图，我们称之为add视图控制器。它是不需要从主视图控制器（源）传什么数据过来的。但是，主视图控制器需要获取在add视图控制器（目标）上输入的数据。\n实现方式是采用delegate，将主视图控制器设置为add视图控制器(目标)的委托。在add目标视图控制器上执行它的委托中方法，该方法需要先在主视图控制器的实现代码中实现，方法包括如何读取add视图控制器的数据，并dismiss掉add视图控制器。 在add视图控制器上，有两个按钮，用于执行cancel和done操作。这两个按钮操作的方法在主视图控制器中实现。 {%codeblock lang:objc%} //\n(void)addSightingViewControllerDidCancel:(AddSightingViewController *)controller\n{\n[self dismissViewControllerAnimated:YES completion:NULL];\n} //\n(void)addSightingViewControllerDidFinish:(AddSightingViewController *)controller name:(NSString *)name location:(NSString *)location {\nif ([name length] || [location length]) {\n[self.dataController addBirdSightingWithName:name location:location];\n[[self tableView] reloadData];\n}\n[self dismissModalViewControllerAnimated:YES];\n} {%endcodeblock%}\n在add视图控制器实现代码中，调用它的委托中这两个方法。 segue三种类型:modal segue、push segue、custom segue modal segue 是一个视图控制器（源）为了完成一个任务而模态地（modally）呈现另一个视图控制器（目标）。这个目标视图控制器不是导航视图控制器(navigation view controller)的栈中的一部分。\n在任务完成后，使用delegate将呈现的视图控制器（目标）释放掉，应用界面切换到原来的视图控制器（源）上。 这个过程的实现代码可以看成是present和dismiss两个操作。\npush segue 是将另一个视图控制器压入到导航控制器的栈中。它通常和导航视图控制器(navigation view controller)一起使用。\n新压入的视图控制器会有一个回退按钮，可以退回来上一层。\n这个过程的实现代码可以看成是push和pop两个操作。\n","date":"2014-07-22T10:59:49+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/UI/Storyboard%E4%B9%8BSegue/","section":"post","tags":["iOS"],"title":"Storyboard之Segue"},{"categories":["项目总结"],"contents":"便笺练习功能点: 通过实现以下特效，练习并掌握布局管理器（layout manger），文本容器（text containers）和文本存储器（text storage）等用法。\n动态样式（Dynamic type） 凸版印刷效果（Letterpress effects） 环绕路径（Exclusion paths） 动态文本格式及存储（Dynamic text formatting and storage） 这个应用中我们将实现回流文本，字体大小的动态变换，以及闪回文本等效果。 效果图:\nApp开始运行后自动生成一组便笺实例并利用tableViewController显示出来。Storyboards和segues会将被选中的单元格所对应的便笺内容显示出来以供用户编辑。 项目开发包：Notepad.zip\n动态样式 动态样式（Dynamic type）是iOS 7里面变化最大的特性之一; 它使得app可以遵从用户选择的字体大小和粗细。 选择 通用-\u0026gt;文字大小 或 通用-\u0026gt;辅助功能 来查看app中的字体设置。\niOS 7 支持通过粗体、设置字体大小等方式提高支持动态文本的应用的易读性。 例如**UIFont**新增的一个方法： preferredFontForTextStyle 用来根据用户对字体大小的设置来自动制定字体样式。\n下面表格中是六种可用字体样式的示例：\n最左边一列是最小字体；中间一列是最大字体；最右边一列是粗体效果。\n使用系统动态字体样式 使用动态文本，是通过给文本字体设置字体样式style而不是指定具体的字体名称和大小。这样，系统会在运行时自动根据这一样式以及用户的字体大小设置来选择使用合适的字体。\npreferredFontForTextStyle:方法设置字体样式 打开 NoteEditorViewController.m/swift 在viewDidLoad：方法实现的最后面加入以下代码： {%codeblock lang:objc%} self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; {%endcodeblock%} {% codeblock lang:swift %} self.textView.font = UIFont.preferredFont(forTextStyle: .body) {% endcodeblock %} 打开 NotesListViewController.m/swift 在 tableView:cellForRowAtIndexPath: 方法中增加如下代码: {%codeblock lang:objc%} cell.textLabel.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline]; {%endcodeblock%} {% codeblock lang:swift %} cell.textLabel?.font = UIFont.preferredFont(forTextStyle: .headline) {% endcodeblock %} 上面两行代码都用到了新版iOS的字体样式. 字体样式：通过语义法命名字体，例如 UIFontTextStyleSubHeadline, 可以避免在代码里每一处都指定具体的字体名称和样式， 而且确保app能对用户的字体大小设置做出恰当的回应。\nAPP响应用户字体设置 设置系统字体 返回到通用-\u0026gt;文字大小重新修改字体设置. 再运行App, Note页面的文字大小是当前设定的字体大小；前后截屏对比,分辨率小了一半。\n设置系统字体生效 当我们返回到通用-\u0026gt;文字大小重新修改字体设置. 再打开Note页面, 会发现app并没有立即对字体设置的变化做出相应反应。 监听系统通知：实现APP响应用户字体设置 当用户修改了他们的字体大小设置之后，这一样式对应的字体并不会自动更新，必须重新请求才能获取新的值。用户设置变化后，preferredFontForTextStyle:方法返回的字体也会变化。\n添加监听系统通知UIContentSizeCategoryDidChangeNotification通知APP响应用户字体设置的变化 打开 NoteEditorViewController.m 并在 viewDidLoad 方法的实现的最后加入以下代码： {%codeblock lang:objc%} [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(preferredContentSizeChanged:) name:UIContentSizeCategoryDidChangeNotification object:nil]; {%endcodeblock%} {%codeblock lang:swift%} //字体变化通知:调用preferredContentSizeChanged:方法 NotificationCenter.default.addObserver(self, selector: #selector(NoteEditorViewController.preferredContentSizeChanged(_:)), name: NSNotification.Name.UIContentSizeCategoryDidChange, object: nil) {%endcodeblock%} 添加系统通知响应事件 收到用于指定本类接收字体设定变化的通知后，调用preferredContentSizeChanged:方法 在NoteEditorViewController.m中viewDidLoad方法之后紧接着添加以下方法： {%codeblock lang:objc%} (void)preferredContentSizeChanged:(NSNotification *)notification { self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; } {%endcodeblock%} {%codeblock lang:swift %} //字体变化通知时调用 func preferredContentSizeChanged(_ notification:NSNotification) { self.textView.font = UIFont.preferredFont(forTextStyle: .body) } {%endcodeblock%} 这一方法作用是根据新的字体设置来设定textView中的字体。 Build并运行app，修改字体大小设置，Note页面就可以即时更新字体大小了。 更新布局 现在，如果你把字体设置到很小，那每个单元格的空白区域是不是太多了，看上去文字比较稀疏，如下面所示：\n这是动态样式有点小复杂的部分：要保证App在字体大小变化后，同时也修改文字表格的行高。\n在NotesListViewController.m中实现tableView:heightForRowAtIndexPath: 代理方法: {%codeblock lang:objc%}\n(CGFloat)tableView:(UITableView *)tableView heightForRowAtIndexPath:(NSIndexPath )indexPath { static UILabel label; if (!label) { label = [[UILabel alloc] initWithFrame:CGRectMake(0, 0, FLT_MAX, FLT_MAX)]; label.text = @\u0026ldquo;test\u0026rdquo;; } label.font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline]; [label sizeToFit]; //自适应文本内容大小 return label.frame.size.height * 1.7; } {%endcodeblock%} {% codeblock lang:swift %} override func tableView(_ tableView: UITableView, heightForRowAt indexPath: IndexPath) -\u0026gt; CGFloat { let label = UILabel.init(frame: CGRect.init(x: 0, y: 0, width: FLT_MAX, height: FLT_MAX)) label.text = \u0026ldquo;test\u0026rdquo; let font = UIFont.preferredFont(forTextStyle: .headline) label.font = font label.sizeToFit() return label.frame.size.height * 1.7 } {% endcodeblock %} 以上代码创建了一个共享的——或者说静态的——UILabel实例，设定它的字体和表中单元格内文本字体一致。然后调用它的sizeToFit方法，使这个label的frame恰好能放得下它的内容文字, 然后把这个label的高度乘个1.7作为表内单元格高度。\nBuild并运行app，修改字体大小设置，行高也会随着字体大小的变化而变化。 如下图所示：\n凸版印刷效果（Letterpress effects） 凸版印刷效果（Letterpress effects）给文字加上精致的阴影和高光是文字看上去有一定立体感——就好像轻轻嵌入屏幕里一样。\n注: 使用“凸版印刷（letterpress）”这一印刷术语是向早期印刷业的致敬。所谓凸版印刷，就是将涂上油墨的图文凸版嵌在印版上，然后在纸面上按压就把图文凸版上的油墨转移到纸面上了——纸面受力在文字边缘形成好看的突起。现在这一工艺已广泛被数码打印所取代。\n打开NotesListViewController.m 将tableView:cellForRowAtIndexPath: 方法中的代码用以下代码替换:\n{%codeblock lang:objc%} static NSString *CellIdentifier = @\u0026ldquo;Cell\u0026rdquo;; UITableViewCell cell = [tableView dequeueReusableCellWithIdentifier:CellIdentifier forIndexPath:indexPath]; Note note = [self notes][indexPath.row];\nUIFont* font = [UIFont preferredFontForTextStyle:UIFontTextStyleHeadline]; UIColor* textColor = [UIColor colorWithRed:0.175f green:0.458f blue:0.831f alpha:1.0f]; NSDictionary *attrs = @{ NSForegroundColorAttributeName : textColor, NSFontAttributeName : font, NSTextEffectAttributeName : NSTextEffectLetterpressStyle}; NSAttributedString* attrString = [[NSAttributedString alloc] initWithString:note.title attributes:attrs]; cell.textLabel.attributedText = attrString; return cell; {%endcodeblock%} {% codeblock lang:swift %} override func tableView(_ tableView: UITableView, cellForRowAt indexPath: IndexPath) -\u0026gt; UITableViewCell { let cell = tableView.dequeueReusableCell(withIdentifier: \u0026ldquo;noteListCell\u0026rdquo;, for: indexPath) // Configure the cell\u0026hellip; let note = notes[indexPath.row] as! NoteModel //cell.textLabel?.text = note.title let font = UIFont.preferredFont(forTextStyle: .headline) let textColor = UIColor.init(red: 0.175, green: 0.458, blue: 0.831, alpha: 1.0) //字体凸版印刷效果 let store:[String:Any] = [NSForegroundColorAttributeName:textColor, NSFontAttributeName:font, NSTextEffectAttributeName:NSTextEffectLetterpressStyle] cell.textLabel?.attributedText = NSAttributedString.init(string: note.title, attributes: store) return cell } {% endcodeblock %}\n上面的代码为单元格的标题创建了一个使用了凸版印刷效果的**NSAttributedString**。 Build并运行app， 表格将显示凸版印刷效果，如下图所示：\n凸版印刷效果是很精巧——但是并不表示你可以随意过度使用它。视觉特效能让文字看上去更有趣，但并不表示一定能让你的文字更清晰易读。\n环绕路径（Exclusion paths） 文字环绕图片或其它内容分布是大多数文字处理软件的标准特性之一。Text Kit允许你通过环绕路径（exclusion paths）将文字按照复杂路径和形状分布。\n在便笺右上角添加一个曲线形视图，告知用户便笺创建的日期：\n首先添加一个视图 创建一个环绕路径，使文字按照这个路径分布。 添加视图 打开 NoteEditorViewController.m 在顶部的imports和接口实现中添加变量加入以下代码： {%codeblock lang:objc%} #import \u0026ldquo;TimeIndicatorView.h\u0026rdquo;\n@implementation NoteEditorViewController { TimeIndicatorView* _timeView; } {%endcodeblock%} 实例化这个用以显示文本创建日期的视图实例，并把它作为一个子视图添加进去 在NoteEditorViewController.m的viewDidLoad方法的最后添加以下代码： {%codeblock objc lang:objc%} _timeView = [[TimeIndicatorView alloc] initWithDate:_note.timestamp]; [self.view addSubview:_timeView]; {%endcodeblock%}\n设置视图位置及自动适应布局：viewDidLayoutSubviews 当NoteEditor视图的控件调用系统方法viewDidLayoutSubviews方法，对子视图进行布局时，TimeIndicatorView作为子控件也需要有相应的变化。\n在控件接收到文本内容的尺寸发生了变化的时候调用updateTimeIndicatorFrame：\n第一调用updateSize来设定_timeView的尺寸 第二将_timeView放在右上角\n在NoteEditorViewController.m 的最后添加如下代码： {%codeblock objc lang:objc%} (void)viewDidLayoutSubviews { [self updateTimeIndicatorFrame]; } (void)updateTimeIndicatorFrame { [_timeView updateSize]; _timeView.frame = CGRectOffset(_timeView.frame, self.view.frame.size.width - _timeView.frame.size.width, 0.0); } {%endcodeblock%} {% codeblock swift lang:swift %} //视图的控件调用viewDidLayoutSubviews对子视图进行布局时，TimeIndicatorView作为子控件也需要有相应的变化。 override func viewDidLayoutSubviews() { updateTimeIndicatorFrame() } func updateTimeIndicatorFrame() { //第一调用updateSize来设定_timeView的尺寸 timeIndicatorView.updateSize() //通过偏移frame参数，将timeIndicatorView放在右上角 timeIndicatorView.frame = timeIndicatorView.frame.offsetBy(dx: ibTextView.frame.width - timeIndicatorView.frame.width, dy: 0.0) } {% endcodeblock %}\n响应系统偏好设置字体样式 修改NoteEditorViewController.m中preferredContentSizeChanged:方法如下： {%codeblock lang:objc%}\n(void)preferredContentSizeChanged:(NSNotification *)n { self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; [self updateTimeIndicatorFrame]; } {%endcodeblock%} Build并运行app，点击选择一个便笺，日期显示视图将出现在右上角，如下图所示：\n文本环绕视图 根据日期视图_timeView创建基于贝赛尔路径的环绕路径 设置文本容器的环绕路径：使用文本容器的exclusionPaths属性指定。它是一个UIBezierPath数组类型。 curvePathWithOrigin:创建文本容器的赛尔路径 根据日期视图_timeView创建基于贝赛尔路径的环绕路径 添加curvePathWithOrigin:方法，定义文本遵循的环绕路径： {%codeblock objc lang:objc%}\n(UIBezierPath *)curvePathWithOrigin:(CGPoint)origin { return [UIBezierPath bezierPathWithArcCenter:origin radius: [self radiusToSurroundFrame:_label.frame] startAngle: -180.0f endAngle: 180.0f clockwise: YES]; } {%endcodeblock%} {% codeblock swift lang:swift %} func curvePathWithOrigin(origin:CGPoint)-\u0026gt;UIBezierPath { //画弧形 let path = UIBezierPath.init(arcCenter: origin, radius: radiusToSurroundFrame(frame: timeLabel.frame), startAngle: -180, //-180.0 endAngle: 180.0, //CGFloat(M_PI * 2), //180.0 clockwise: true) // UIColor.blueColor().set() // path.fill() // UIColor.blueColor().set() return path } {% endcodeblock %}\n设置文本容器的环绕路径：exclusionPaths exclusionPaths是NSArray类型，因此一个文本容器是可以支持多个环绕路径，文本环绕路径发生改变后会通知文本管理器，然后环绕路径的变化就可以动态地，甚至是动画式地体现到文本上！ 在updateTimeIndicatorFrame方法实现的最后面添加如下代码： {%codeblock objc lang:objc%} { UIBezierPath* exclusionPath = [_timeView curvePathWithOrigin:_timeView.center]; _textView.textContainer.exclusionPaths = @[exclusionPath]; } {%endcodeblock%} {%codeblock swift lang:swift %} { let exclusionPath = timeIndicatorView.curvePathWithOrigin(origin: timeIndicatorView.center) ibTextView.textContainer.exclusionPaths = [exclusionPath] } {%endcodeblock%} Build并运行app，选择一个便笺项，如下图所示：\n动态文本格式及存储（Dynamic text formatting and storage） 你已经看到了Text Kit可以根据用户设置的字体大小动态地调整字体。但是如果字体也可以根据实际的文字本身来进行动态更新是不是会更酷呢？\n实现类似markdown语法的效果：\n把波浪线(~)之间的文本变为艺术字体 把下划线(_)之间的文本变为斜体 为破折号(-)之间的文本添加删除线 把字母全部大写的单词变为红色\nText Kit文本系统工作机制 Text Kit 堆栈存储、处理以及显示文本：\n当你创建UITextView, UILabel or UITextField的时候，Apple系统自动在后台帮你创建了这些类。你可以使用这些默认的实现或者是自定义一部分，以便达到想要的效果。\nNSTextStorage文本存储器: 作为一个NSMutableAttributedString的子类，动态处理的文本可以通过attributedString的方式存储，并且将文本内容的任何变化都通知给布局管理器。可以自定义NSTextStorage的子类，当文本发生变化时，动态地对文本属性做出相应改变。 NSLayoutManager布局引擎: 获取存储的文本并经过修饰处理再显示在屏幕上； NSTextContainer文本容器: 描述所要处理的文本在屏幕上的位置信息。每一个文本容器都有一个关联的UITextView. 可以创建 NSTextContainer的子类来定义一个复杂的形状，然后在这个形状内处理文本。 NSTextStorage文本存储器动态添加文本属性 需要创建一个NSTextStorage的子类，用以在用户输入文本的时候，动态地添加文本属性。 将UITextView的默认文本存储器,用自定义的实现替换掉。 创建文本存储器NSTextStorage子类 新建**NSTextStorage的子类，类命名为SyntaxHighlightTextStorage** 打开SyntaxHighlightTextStorage.m并添加实例变量并初始化： {%codeblock lang:objc%} #import \u0026ldquo;SyntaxHighlightTextStorage.h\u0026rdquo; @implementation SyntaxHighlightTextStorage { NSMutableAttributedString *\t_backingStore; }\n(id)init { if (self = [super init]) { _backingStore = [NSMutableAttributedString new]; } return self; } @end {%endcodeblock%} {% codeblock swift lang:swift %} class SyntaxHighlightTextStorage: NSTextStorage { //文本存储器子类必须提供它自己的“数据持久化层”。 var backingStore = NSMutableAttributedString() }\n{% endcodeblock %}\n重载文本存储器的数据持久化层方法 要使用**NSMutableAttributedString**作为“后台存储” (后面会详细讲解)，文本存储器子类必须提供它自己的“数据持久化层”： {%codeblock lang:objc%}\n(NSString *)string { return [_backingStore string]; }\n(NSDictionary *)attributesAtIndex:(NSUInteger)location effectiveRange:(NSRangePointer)range { return [_backingStore attributesAtIndex:location effectiveRange:range]; } {%endcodeblock%} {% codeblock swift lang:swift %} override var string: String { return backingStore.string }\noverride func attributes(at location: Int, effectiveRange range: NSRangePointer?) -\u0026gt; [String : Any] { if range == nil { return [:] } //print(\u0026ldquo;backingStore:location(location),effectiveRange:(range!)\u0026rdquo;) return backingStore.attributes(at: location, effectiveRange: range!) }\n{% endcodeblock %} 上面两个方法直接把任务代理给了后台存储。\n重载编辑文本时通知布局管理器的方法 同样的，这些方法也是把任务代理给后台存储。它们通过调用beginEditing / edited / endEditing这些方法来完成一些编辑任务。这样做是为了在编辑发生后让文本存储器的类通知相关的布局管理器。 最后，还在这个文件中，重载以下方法： {%codeblock lang:objc%}\n(void)replaceCharactersInRange:(NSRange)range withString:(NSString *)str { NSLog(@\u0026ldquo;replaceCharactersInRange:%@ withString:%@\u0026rdquo;, NSStringFromRange(range), str);\n[self beginEditing]; [_backingStore replaceCharactersInRange:range withString:str]; [self edited:NSTextStorageEditedCharacters | NSTextStorageEditedAttributes range:range changeInLength:str.length - range.length]; [self endEditing]; }\n(void)setAttributes:(NSDictionary *)attrs range:(NSRange)range { NSLog(@\u0026ldquo;setAttributes:%@ range:%@\u0026rdquo;, attrs, NSStringFromRange(range));\n[self beginEditing]; [_backingStore setAttributes:attrs range:range]; [self edited:NSTextStorageEditedAttributes range:range changeInLength:0]; [self endEditing]; } {%endcodeblock%}\n{% codeblock swift lang:swift %} override func replaceCharacters(in range: NSRange, with str: String) { print(\u0026ldquo;replaceCharactersInRange:(NSStringFromRange(range)) withString:(str)\u0026rdquo;) beginEditing() backingStore.replaceCharacters(in: range, with: str) edited([.editedAttributes,.editedCharacters], range: range, changeInLength: str.utf16.count - range.length) endEditing() }\noverride func setAttributes(_ attrs: [String : Any]?, range: NSRange) { //Sets the attributes for the characters in the specified range to the specified attributes. print(\u0026ldquo;setAttributes:(attrs!) range:(NSStringFromRange(range))\u0026rdquo;) beginEditing() backingStore.setAttributes(attrs!, range: range) edited(.editedAttributes, range: range, changeInLength: 0) endEditing() } {% endcodeblock %}\n类族介绍 类族是Apple的framework中广泛用到的一种设计模式。类族就是抽象工厂模式的实现，无需指定具体的类就可以为创建一族相关或从属的对象提供一个公共接口。一些我们很熟悉的类NSArray和NSNumber类似的就是一族类的公共接口。\n上例中NSTextStorage文本存储器就是一个类族的公共接口，需要大量代码来创建文本存储器的子类。在扩展功能时，通过创建子类及重载几个方法之外，有些特定需求是要自己实现的，比方attributedString数据的后台存储。\nApple使用类族来封装同一个公共抽象超类下的私有具体子类，抽象超类声明了客户在创建私有子类实例时必须要实现的方法。客户是完全无法知道工厂正在用哪一个私有类，它只和公共接口相互协作。\n使用类族当然可以简化接口，使学习和使用类更加容易，但是必须要需要指出的是要在功能扩展和接口简化之间达到平衡。创建一个类族的抽象超类的定制子类也常常是非常难的。\n创建UITextView使用自定义Text Kit堆栈 现在有了一个自定义的NSTextStorage，还需创建一个UITextView来使用它。\nstoryboard创建UITextView时，Text Kit组件只读问题 从storyboard编辑器实例化UITextView会自动创建**NSTextStorage, NSLayoutManager和NSTextContainer (例如Text Kit堆栈)实例以及所有的这三个只读属性。\n虽然没有办法从storyboard编辑器中改变这种设定，但可以手动编程创建UITextView和Text Kit**堆栈。\n在UITextView中使用自定义的SyntaxHighlightTextStorage 清理IB相关设置 在IB中打开Main.storyboard 找到NoteEditorViewController。 删除UITextView实例。 然后，打开NoteEditorViewController.m删除UITextView outlet。 既然不再为文本视图使用IBOutlet，而是要编程添加，所以也就不需要这些代码了。 从viewDidLoad 方法中删除以下代码： {%codeblock lang:objc%} self.textView.text = self.note.contents; self.textView.delegate = self; self.textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; {%endcodeblock%} 手动创建UITextView和Text Kit堆栈 在NoteEditorViewController.m最上面，添加下面一行代码: {%codeblock objc lang:objc %} #import \u0026ldquo;SyntaxHighlightTextStorage.h\u0026rdquo; {%endcodeblock%} 在NoteEditorViewController.m中TimeIndicatorView实例变量后面紧接着添加以下代码： {%codeblock lang:objc%} SyntaxHighlightTextStorage* _textStorage; UITextView* _textView; {%endcodeblock%} 文本存储器子类有两个实例变量，还有一个文本视图稍后需要添加。 创建Text Kit堆栈 创建自定义的NSTextStorage文本存储器实例，一个用来承载便笺内容的NSAttributedString 创建一个NSLayoutManager布局管理器，并添加到文本存储器。 创建一个NSTextContainer文本容器，并添加到布局管理器。然后把布局管理器和文本存储器联系起来 最后用你自定义的文本容器和代理组创建实际的文本视图， 并把文本视图添加为子视图\n在NoteEditorViewController.m中，添加下面方法： {%codeblock lang:objc%} (void)createTextView { // 1. Create the text storage that backs the editor NSDictionary* attrs = @{NSFontAttributeName: [UIFont preferredFontForTextStyle:UIFontTextStyleBody]}; NSAttributedString* attrString = [[NSAttributedString alloc] initWithString:_note.contents attributes:attrs]; _textStorage = [SyntaxHighlightTextStorage new]; [_textStorage appendAttributedString:attrString];\nCGRect newTextViewRect = self.view.bounds;\n// 2. Create the layout manager NSLayoutManager *layoutManager = [[NSLayoutManager alloc] init];\n// 3. Create a text container CGSize containerSize = CGSizeMake(newTextViewRect.size.width, CGFLOAT_MAX); NSTextContainer *container = [[NSTextContainer alloc] initWithSize:containerSize]; container.widthTracksTextView = YES; [layoutManager addTextContainer:container]; [_textStorage addLayoutManager:layoutManager];\n// 4. Create a UITextView _textView = [[UITextView alloc] initWithFrame:newTextViewRect textContainer:container]; _textView.delegate = self; [self.view addSubview:_textView]; } {%endcodeblock%} {% codeblock swift lang:swift %} //创建文本区域 func createTextView() { // 1. Create the text storage that backs the editor let bodyFont = UIFont.preferredFont(forTextStyle: UIFontTextStyle.body) let attrs = [NSFontAttributeName:bodyFont] let attrString = NSAttributedString(string: note.contents,attributes: attrs) textStorage = SyntaxHighlightTextStorage() textStorage.append(attrString)\n// \u0026mdash;\u0026mdash;\u0026ndash;使用Storyboard声明TextView时,只需一行，可惜为只读属性\u0026mdash;\u0026mdash;\u0026mdash;- textStorage.addLayoutManager(ibTextView.layoutManager)\n/**\u0026mdash;\u0026mdash;\u0026ndash;使用代码声明TextView时，4步骤\u0026mdash;\u0026mdash;\u0026mdash;- let newTextViewRect = view.bounds\n// 2. Create the layout manager let layoutManager = NSLayoutManager()\n// 3. Create a text container //文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于CGFloat.max，它的值可以是无限大。 let containerSize = CGSize.init(width: newTextViewRect.size.width, height: CGFloat.greatestFiniteMagnitude)\nlet container = NSTextContainer.init(size: containerSize) //A Boolean that controls whether the receiver adjusts the width of its bounding rectangle when its text view is resized. container.widthTracksTextView = true // layoutManager.addTextContainer(container) textStorage.addLayoutManager(layoutManager)\n// 4. Create a UITextView textView = UITextView()//.init(frame: newTextViewRect, textContainer: container) textView.isScrollEnabled = true textView.delegate = self view.addSubview(textView) */ } {% endcodeblock %}\n现在回顾之前那个图表所展示的四个关键类(文本存储器storage, 布局管理器layout manager, 文本容器container 和文本视图textView)之间的关系，是不是觉得理解起来容易多了。\n注意:文本容器的宽度会自动匹配视图的宽度，但是它的高度是无限高的——或者说无限接近于CGFLOAT_MAX，它的值可以是无限大。不管怎么说，它的高度足够让UITextView上下滚动以容纳很长的文本。\n在viewDidLoad方法中调用超类的viewDidLoad方法的语句后面添加以下一行代码： {%codeblock lang:objc%} [self createTextView]; {%endcodeblock%} 然后修改preferredContentSizeChanged的第一行代码为： {%codeblock lang:objc%} _textView.font = [UIFont preferredFontForTextStyle:UIFontTextStyleBody]; {%endcodeblock%}\n自定义视图实现在storyboard中自动布局约束的效果 用自定义的实例变量来替换掉旧的outlet属性。自定义视图不会自动继承storyboard中的布局约束组的规则。当设备方向变化后，视图的边界是不会自动随之改变的，这样就需要自己来编程设定视图边界。\n可以在viewDidLayoutSubviews方法的最后添加以下代码来实现： {%codeblock lang:objc%} _textView.frame = self.view.bounds; {%endcodeblock%} Build并运行app，打开一个便笺项，在Xcode控制台上有SyntaxHighlightTextStorage生成的运行日志，用来告诉你这些文本处理的代码确实被调用：\n看来你的文本解析器的基础非常可靠了 —— 那现在来添加动态格式。\n通过正则修改文本存储器的动态格式（Dynamic formatting） 接下来将对你的自定义文本存储器进行修改以将＊星号符之间的文本＊变为黑体：\nprocessEditing：将文本的变化通知给布局管理器 processEditing 将文本的变化通知给布局管理器。它也为文本编辑之后的处理提供便利。 打开SyntaxHighlightTextStorage.m 添加以下方法： {%codeblock lang:objc%} -(void)processEditing { [self performReplacementsForRange:[self editedRange]]; [super processEditing]; } {%endcodeblock%}\nNSUnionRange：在range1和range2之间比较，如果一个range完全包含在另一个range内，则返回较大的range 上面的代码拓展了受黑体格式类型影响的文本范围。因为changedRange一般只是作用到单独的一个字符； 而lineRangeForRange 则扩展到一整行 在 processEditing方法之后紧接着添加以下代码： {%codeblock lang:objc%}\n(void)performReplacementsForRange:(NSRange)changedRange { NSRange extendedRange = NSUnionRange(changedRange, [[_backingStore string] lineRangeForRange:NSMakeRange(changedRange.location, 0)]); extendedRange = NSUnionRange(changedRange, [[backingStore string] lineRangeForRange:NSMakeRange(NSMaxRange(changedRange), 0)]); [self applyStylesToRange:extendedRange]; } {%endcodeblock%} {% codeblock swift lang:swift %} //在指定的区域中进行替换 func performReplacementsForRange( changedRange:NSRange) { //定位正在编辑文本的位置区间 let locationRange = NSMakeRange(changedRange.location, 0) //定位到文本当前行的位置区间 let range1 = (backingStore.string as NSString).lineRange(for: locationRange)\n//扩展范围 var extendedRange = NSUnionRange(changedRange, range1)\nlet maxRange = NSMakeRange(NSMaxRange(changedRange), 0)\nlet range2 = (backingStore.string as NSString).lineRange(for: maxRange) extendedRange = NSUnionRange(changedRange, range2)\nprint(\u0026ldquo;在指定的区域中进行替换:(extendedRange)\u0026rdquo;) applyStylesToRange(searchRange: extendedRange) }\n{% endcodeblock %}\n在 performReplacementsForRange方法之后紧接着添加以下代码： {%codeblock lang:objc%}\n(void)applyStylesToRange:(NSRange)searchRange { // 1. create some fonts UIFontDescriptor* fontDescriptor = [UIFontDescriptor preferredFontDescriptorWithTextStyle:UIFontTextStyleBody]; UIFontDescriptor* boldFontDescriptor = [fontDescriptor fontDescriptorWithSymbolicTraits:UIFontDescriptorTraitBold]; UIFont* boldFont = [UIFont fontWithDescriptor:boldFontDescriptor size: 0.0]; UIFont* normalFont = [UIFont preferredFontForTextStyle:UIFontTextStyleBody];\n// 2. match items surrounded by asterisks NSString* regexStr = @\u0026quot;(w+(sw+)**)s\u0026quot;; NSRegularExpression regex = [NSRegularExpression regularExpressionWithPattern:regexStr options:0 error:nil];\nNSDictionary* boldAttributes = @{ NSFontAttributeName : boldFont }; NSDictionary* normalAttributes = @{ NSFontAttributeName : normalFont };\n// 3. iterate over each match, making the text bold [regex enumerateMatchesInString:[_backingStore string] options:0 range:searchRange usingBlock:^(NSTextCheckingResult *match, NSMatchingFlags flags, BOOL *stop){\nNSRange matchRange = [match rangeAtIndex:1]; [self addAttributes:boldAttributes range:matchRange]; // 4. reset the style to the original if (NSMaxRange(matchRange)+1 \u0026lt; self.length) { [self addAttributes:normalAttributes range:NSMakeRange(NSMaxRange(matchRange)+1, 1)]; } }]; } {%endcodeblock%} 上面的代码有以下作用：\n创建一个粗体及一个正常字体并使用字体描述器（Font descriptors）来格式化文本。字体描述器能使你无需对字体手动编码来设置字体和样式。 创建一个正则表达式来定位星号符包围的文本。例如，在字符串“iOS 7 is *awesome*”中，存储在regExStr中的正则表达式将会匹配并返回文本“*awesome*”。 对正则表达式匹配到并返回的文本进行枚举并添加粗体属性。 将后一个星号符之后的文本都重置为“常规”样式。以保证添加在后一个星号符之后的文本不被粗体风格所影响。\n注： 字体描述器（Font descriptors）是一种描述性语言，它使你可以通过设置属性来修改字体，或者无需初始化UIFont实例便可获取字体规格的细节。\nBuild并运行app；向便笺中输入文本，并将其中一个词用星号符包围。这个词将会自动变为黑体，如下面截图所示：\n##进一步添加样式 为限定文本添加风格的基本原则很简单：使用正则表达式来寻找和替换限定字符，然后用applyStylesToRange来设置想要的文本样式即可。\n在SyntaxHighlightTextStorage.m中添加以下实例变量： {%codeblock lang:objc%}\n(void) createHighlightPatterns { UIFontDescriptor *scriptFontDescriptor = [UIFontDescriptor fontDescriptorWithFontAttributes: @{UIFontDescriptorFamilyAttribute: @\u0026ldquo;Zapfino\u0026rdquo;}];\n// 1. base our script font on the preferred body font size UIFontDescriptor* bodyFontDescriptor = [UIFontDescriptor preferredFontDescriptorWithTextStyle:UIFontTextStyleBody]; NSNumber* bodyFontSize = bodyFontDescriptor. fontAttributes[UIFontDescriptorSizeAttribute]; UIFont* scriptFont = [UIFont fontWithDescriptor:scriptFontDescriptor size:[bodyFontSize floatValue]];\n// 2. create the attributes NSDictionary* boldAttributes = [self createAttributesForFontStyle:UIFontTextStyleBody withTrait:UIFontDescriptorTraitBold]; NSDictionary* italicAttributes = [self createAttributesForFontStyle:UIFontTextStyleBody withTrait:UIFontDescriptorTraitItalic]; NSDictionary* strikeThroughAttributes = @{ NSStrikethroughStyleAttributeName : @1}; NSDictionary* scriptAttributes = @{ NSFontAttributeName : scriptFont}; NSDictionary* redTextAttributes = @{ NSForegroundColorAttributeName : [UIColor redColor]};\n// construct a dictionary of replacements based on regexes _replacements = @{ @\u0026quot;(*w+(sw+)**)s\u0026quot; : boldAttributes, @\u0026quot;(w+(sw+)*)s\u0026quot; : italicAttributes, @\u0026quot;([0-9]+.)s\u0026quot; : boldAttributes, @\u0026quot;(-w+(sw+)*-)s\u0026quot; : strikeThroughAttributes, @\u0026quot;(w+(sw+)*)s\u0026quot; : scriptAttributes, @\u0026ldquo;s([A-Z]{2,})s\u0026rdquo; : redTextAttributes}; } {%endcodeblock%}\n这个方法的作用：\n首先，它使用Zapfino字体来创建了“script”风格。Font descriptors会决定当前正文的首选字体，以保证script不会影响到用户的字体大小设置。 然后，它会为每种匹配的字体样式构造各个属性。你稍后将用到 createAttributesForFontStyle:withTrait:。 最后，它将创建一个NSDictionary并将正则表达式映射到上面声明的属性上。 如果你对正则表达式不是非常熟悉，上面的的dictionary对你来说可能很陌生。但是，如果你一点一点仔细分析它其中包含的正则表达式，其实不用很费力就能理解了。\n以上面实现的第一个正则表达式为例，它的工作是匹配星号符包围的文本：\n(*w+(sw+)**)s\n上面两个两个相连的斜杠，其中一个是用来将Objective-C中的特殊字符转义成实体字符。去掉用来转义的斜杠，来看下这个正则表达式的核心部分：\n(*w+(sw+)**)s\n现在，逐步来分析这个正则表达式：\n{%codeblock lang:js%} (*\t—— 匹配星号符\nw+ —— 后接一个或多个 “word”式 字符串\n(sw+)*\t—— 后接零个或多组空格然后再接 “word” 式字符串\n*) —— 后接星号符\ns —— 以空格结尾\n{%endcodeblock%}\n注：如果你想对正则表达式有更多了解，请参考 NSRegularExpression tutorial and cheat sheet.\n现在你需要调用createHighlightPatterns： 将SyntaxHighlightTextStorage.m 中的init方法更新如下： {%codeblock lang:objc%}\n(id)init { if (self = [super init]) { _backingStore = [NSMutableAttributedString new]; [self createHighlightPatterns]; } return self; } {%endcodeblock%} 在SyntaxHighlightTextStorage.m方法中添加以下代码： {%codeblock lang:objc%}\n(NSDictionary*)createAttributesForFontStyle:(NSString*)style withTrait:(uint32_t)trait { UIFontDescriptor *fontDescriptor = [UIFontDescriptor preferredFontDescriptorWithTextStyle:UIFontTextStyleBody];\nUIFontDescriptor *descriptorWithTrait = [fontDescriptor fontDescriptorWithSymbolicTraits:trait];\nUIFont* font = [UIFont fontWithDescriptor:descriptorWithTrait size: 0.0]; return @{ NSFontAttributeName : font }; } {%endcodeblock%}\n上面的代码作用是将提供的字体样式作用到正文字体上。它给fontWithDescriptor:size: 提供的size值为0，这样做会迫使UIFont返回用户设置的字体大小。\n","date":"2014-07-03T17:29:00+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/UI/TextKit%E4%B9%8B%E4%BE%BF%E7%AC%BA%E5%AE%9E%E6%88%98/","section":"post","tags":["API"],"title":"TextKit之便笺实战"},{"categories":["学习笔记"],"contents":"关于 Document Interaction iOS支持在你的app中通过调用其他app来预览和显示文档。iOS还支持文件关联，允许其他app调用你的app打开文件。这些技术包括了UIKit中提供的UIDocumentInteractionController类，以及Quick Look框架。\n######预览文档和呈现选项菜单\n如果app需要打开自身并不支持的文件时，就需要使用UIDocumentInteractionController。一个document interaction controller通过Quick Look框架判断文档是否能被另一个app打开和预览。也就是说，app可以通过documentinteraction controller提供一些支持打开该文件方式的菜单。 具体实现需要以下步骤：\n需要通过其他APP打开的文件，来实例化UIDocumentInteractionController实例对象。 在自己的APP UI中提供一个代表这种文件的图像标（一般显示文件名或者图标）。 用户交互，如触摸这个控件，则调用documentinteractioncontroller对象。 三种交互界面: 1. 预览文件的内容。 2. 一个包含预览和打开操作的菜单。可以通过实现某些委托方法，向菜单中加入其他操作，比如复制、打印。 3. 一个菜单，仅包含“以其它方式打开”操作。\n同时，documentinteractioncontroller内置了一些手势，必要时可以直接实现它们。\n######使用documentinteractioncontroller的场景:与文件交互的app都可以使用。\n需要从网络下载文件的APP:\n例如，email程序需要打开和预览邮件附件。 不下载文件的APP:\n例如，APP需要支持文件共享（参考“File-Sharing Support” in iOS Technology Overview), 即可以对同步到app Documents/Shared目录下的文件使用documentinteractioncontroller。 创建Document Interaction Controller 创建时，通过需要其他APP打开的文件，来实例化UIDocumentInteractionController实例对象，并设置它的delegate属性。\ndelegate对象负责告诉document interaction controller呈现视图时需要的信息，以及当视图显示和用户交互时要执行的动作。\n如以下代码所示。注意方法的调用者必须返回对象。\n1 2 3 4 5 6 7 8 9 - (UIDocumentInteractionController *) setupControllerWithURL: (NSURL) fileURL usingDelegate: (id \u0026lt;UIDocumentInteractionControllerDelegate\u0026gt;) interactionDelegate { UIDocumentInteractionController *interactionController = [UIDocumentInteractionController interactionControllerWithURL: fileURL]; interactionController.delegate = interactionDelegate; return interactionController; } 实例创建后，可以通过它的属性来读取与之关联的文件信息，包括文件名、类型和URL。该实例中还有一个icons属性，其中包含了多个 UIImage 对象,可以用于表示该文档的多个大小的图标。这些信息可用于UI。\n如果用其他APP打开该文件，可以利用该实例的 annotation 属性，该属性包含了其他APP所需的附加信息。当然信息的格式必须能够被该APP识别。\n例如:当程序想与套件中的其他程序进行交互时，就可以使用annotation 属性。当被调用应用程序打开一个文件时，option 字典中会包含 annotation 的值，可以使用UIApplicationLaunchOptionsAnnotationKey 作为键在option字典中检索它。\n呈现 Document Interaction Controller 用户可以通过 Document interaction controller实例，来预览该文件，或者通过弹出菜单让用户选择相应的动作。\n模式化显示文件预览窗口，调用如下方法: {%codeblock lang:objc 模式化预览窗口调用的方法 Declared In UIDocumentInteractionController.h %} //Displays a full-screen preview of the target document. (BOOL)presentPreviewAnimated:(BOOL)animated; {%endcodeblock%} 预览窗口是以模式视图显示的，同时必须实现以下协议方法: {%codeblock lang:objc Declared In UIDocumentInteractionController.h%} //Called when a document interaction controller needs the starting point for animating the display of a document preview. (UIViewController *) documentInteractionControllerViewControllerForPreview: (UIDocumentInteractionController *) controller {%endcodeblock%} 注:该方法最终需要返回一个**VC，来作为预览窗口的父窗口。假如没有实现该方法，或者在该方法中返回 nil，或者返回的VC无法呈现模式窗口，则该预览窗口不会显示。 最终会被documentinteractioncontroller **会自动解散它呈现出来的窗口。或调用系统提供销毁模态视图的方法，手动销毁如下： {%codeblock lang:objc Declared In UIDocumentInteractionController.h%} //Dismisses the currently active menu.\n(void)dismissMenuAnimated:(BOOL)animated\n//Dismisses the currently active document preview. (void)dismissPreviewAnimated:(BOOL)animated {%endcodeblock%} 通过弹出菜单提示用户选择相应动作，调用如下方法: {%codeblock lang:objc 弹出\u0026quot;通过其他方式打开\u0026quot;菜单 Declared In UIDocumentInteractionController.h%} //Displays an options menu and anchors it to the specified location in the view. (BOOL)presentOptionsMenuFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated //Displays an options menu and anchors it to the specified bar button item. (BOOL)presentOptionsMenuFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated {%endcodeblock%} 提示用户用其他程序打开该文件，调用如下方法: {%codeblock lang:objc 提示用户用其他程序打开 Declared In UIDocumentInteractionController.h%} //Displays a menu for opening the document and anchors that menu to the specified view. (BOOL)presentOpenInMenuFromRect:(CGRect)rect inView:(UIView *)view animated:(BOOL)animated //Displays a menu for opening the document and anchors that menu to the specified bar button item. (BOOL)presentOpenInMenuFromBarButtonItem:(UIBarButtonItem *)item animated:(BOOL)animated {%endcodeblock%} 以上几种方法都会显示一个视图或一个预览窗口或是弹出菜单。任何一个方法的调用，都要检查返回值。返回值为 NO，表示这个视图没有任何内容，将不能显示。\n例如，**presentOpenInMenuFromRect:inView:animated:**方法返回NO,表明已安装的程序中没有任何程序能够打开该文档。 注册应用程序支持的文档类型 如果你的程序可以打开某种特定的文件类型，则可以通过Info.plist文件注册程序所能打开的文档类型。当其他程序向系统询问哪些程序可以识别该类型的文件时，你的程序就会被列到选项菜单中，供用户选择。\n有如下概念:\n需要在程序的**Info.plist文件中添加新字段CFBundleDocumentTypes** 键 (查看 “CoreFoundation Keys”) 。系统会将该键中包含的内容进行登记，这样其他程序就可以通过**document interaction controller**访问到这些信息。 CFBundleDocumentTypes 键是一个dictionary数组，一个dictionary表示了一个指定的文档类型。一个文档类型通常与某种文件类型是一一对应的。但是，如果你的程序对多个文件类型采用同样的处理方式，你也可以把这些类型都分成一个组，统一视作一个文档类型。\n例如，你的程序中使用到的本地文档类型，有一个是旧格式的，还有一个新格式（似乎是影射微软office文档），这样就可以将二者分成一组，都放到同一个文档类型下。这样，旧格式和新格式的文件都将显示为同一个文档类型，并以同样的方式打开。 CFBundleDocumentTypes 数组中的每个dictionary包含以下键： {%codeblock lang:objc 字典键名称%} CFBundleTypeName //指定文档类型名称。 CFBundleTypeIconFiles //是一个数组，包含多个图片文件名，用于作为该文档的图标。 LSItemContentTypes //是一个数组，包含多个 UTI 类型的字符串。UTI 类型是本文档类型（组）所包含的文件类型。 LSHandlerRank //表示应用程序是“拥有”还是仅仅是“打开”这种类型而已。 {%endcodeblock%} 在应用程序的角度而言，一个文档类型其实就是一种文件类型（或者多个文件类型），该程序将一个文档类型的文件都视作同样的东西对待。例如，一个图片处理程序可能将各种图片文件都看成不同的文档类型，这样便于根据每个类型进行相应的优化。但是，对于字处理程序来说，它并不关心真正的图形格式，它把所有的图片格式都作为一个文档类型对待。\n**CFBundleDocumentTypes**字典数组示例: {%codeblock lang:html 自定义文件格式的文档类型 %} CFBundleTypeName My File Format CFBundleTypeIconFiles MySmallIcon.png MyLargeIcon.png LSItemContentTypes com.example.myformat LSHandlerRank Owner {%endcodeblock%} 打开支持的文件类型 系统可能会请求某个程序打开某种文件，并呈现给用户。这种情况通常发生在某个应用程序调用 document interaction controller 去处理某个文件的时候。\n这时应用程序可以通过委托方法: {%codeblock lang:objc 获得文件的信息 Declared In UIApplication.h https://developer.apple.com/library/ios/documentation/UIKit/Reference/UIApplicationDelegate_Protocol/Reference/Reference.html#//apple_ref/occ/intfm/UIApplicationDelegate/application:didFinishLaunchingWithOptions: %} //Tells the delegate that the launch process is almost done and the app is almost ready to run.\n(BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions {%endcodeblock%} 注:如果你的程序要处理某些自定义的文件类型，就必须实现这个委托方法（而不是**applicationDidFinishLaunching:**方法) 并用这个方法启动应用程序\n该方法的**option包含了要打开的文件的相关信息，可以通过以下键名一一解析： {%codeblock lang:objc %} UIApplicationLaunchOptionsURLKey //该文件的NSURL UIApplicationLaunchOptionsSourceApplicationKey //发送请求的应用程序的Bundle ID UIApplicationLaunchOptionsSourceApplicationKey\t//源程序向目标程序传递的与该文件相关的属性列表对象 {%endcodeblock%} 如果 UIApplicationLaunchOptionsURLKey 键存在，你的程序应当立即用该URL**打开该文件并将内容呈现给用户。其他键可用于收集与打开的文件相关的参数和信息。\n使用 Quick Look 框架 **Quick Look**框架提供了增强的预览功能，可以选择呈现预览窗口时的动画风格，并可以像预览单个文件一样预览多个文件。\n该框架主要提供了 QLPreviewController 类。该类依赖于委托对象响应预览动作，以及一个用于提供预览文件的数据源，内置了所支持的文件类型的 AirPrint 打印。\nQuick Look Previews 中的预览及打印 从 iOS 4.2 开始，QLPreviewController 提供了包含了一个 action 按钮（即打印按钮）的预览视图。对于 QLPreviewController 能预览的文件，不用编写任何打印代码，只需点击action按钮就能直接打印该文档。\n通过以下方式显示**QLPreviewController**:\n通过导航控制器，将预览窗口以“push 方式”显示。 通过 UIViewController 的 **presentModalViewController:animated:**方法，将预览窗口以模态窗口的方式全屏显示。 显示一个**document interaction controller(如 “预览及打开文件” 中所述），再在选项菜单中选择“Quick Look**”即可。 预览窗口中会包括一个标题，显示文件 URL 的最后一段路径。如果要重载标题，可以定制**PreviewItem** 类，并实现**QLPreviewItem** 协议中的 previewItemTitle方法。\n**QLPreviewController**能够预览下列文件： iWork 文档 Microsoft Office 文档(Office ‘97 以后版本) Rich Text Format (RTF) 文档 PDF 文档 图片 文本文件，其 uniform type identifier (UTI) 在 public.text 文件中定义 (查看UniformType Identifiers 参考) Comma-separated value (csv) 文件 使用**QLPreviewController，必须指定数据源对象（即实现 QLPreviewControllerDataSource 协议，请查看QLPreviewControllerDataSource协议参考）。数据源为 QLPreviewController提供预览对象（preivew item），及指明它们的数量以便在一个预览导航列表中包含它们。在这个列表中包含多个对象，在模态预览窗口（全屏显示）显示了导航箭头，以便用户在多个预览对象间切换。对于用导航控制器“push方式”显示的QLPreviewController**，你可以在导航条上提供按钮以便在预览对象列表见切换。\n","date":"2014-07-01T23:12:01+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/iOSDocumentInteraction%E7%BC%96%E7%A8%8B%E6%8C%87%E5%8D%97/","section":"post","tags":["文档","API"],"title":"iOS Document Interaction 编程指南"},{"categories":["解决方案"],"contents":"Zombie:针对僵尸对象导致应用程序崩溃，即已经deallocated的对象，它们的retainCount计数器已经为0，通过正常的手段是无法在debug中跟踪和观察到的。\n如果你开启了 Zombie Enabled ，则当 Zombie 问题出现时，控制台会输出 Zombie 对象的地址，且程序会在此处产生断点：\n-[CALayer retainCount]: message sent to deallocated instance \u0026lt;memoryaddress\u0026gt; 虽然可以看到内存地址，知道是某个指针导致了 Zombie 引用，但对于解决问题却毫无帮助，因为仍不知道该地址到底是哪个对象？原因很显然，既然该对象已经deallocated，就无法再从内存中找回它来。虽然可以以对象的形式打印这个指针：\n（GDB）po \u0026lt;内存地址\u0026gt; 仍然会得到一个 message sent to deallocated instance 的错误消息。\n可以在 Instrument 用 Zombie 模板，来观察到这些 Zombie 对象。\n提示：只能在模拟器中使用 Zombie 模板，对于在设备中运行的程序， 你只能手动找出Zombie对象，Zombie模板对物理设备无效。\n使用操作如下： 点击 Xcode 的 Project \u0026ndash;\u0026gt; Profile 菜单。在 Instrument 的“模板选择窗口”中，选择“iOSSimulator”下面的 Zombie 模板。 在模拟器中调试程序，如果 Zombie 问题出现，程序将崩溃，同时 Instrument 会弹出一个“Zombie 消息报告”，同时程序将在此处中断，如下图所示。 点击地址 (0x158b3c00) 右边的箭头，将列出该 Zombie 对象曾经发生过的 retain/release 动作。\n从列表中找到 retain count 在变为 -1 之前的那行,打开 View -\u0026gt; Extended detail，将显示导致了过渡释放的代码调用： 双击这句代码，将在源文件中高亮显示该语句：\n现在，知道问题出在哪里了吧？\n","date":"2014-07-01T19:54:02+08:00","permalink":"https://it-boyer.github.io/post/old/%E8%B0%83%E8%AF%95/instrument%E4%B9%8BZombie%E5%B7%A5%E5%85%B7/","section":"post","tags":["instrument","工具"],"title":"instrument之Zombie工具"},{"categories":["学习笔记"],"contents":"UIDevice.h 1 2 3 4 5 6 7 8 9 + (UIDevice *)currentDevice; // 获取当前设备 NSString *name; // e.g. \u0026#34;My iPhone\u0026#34; NSString *model; // e.g. @\u0026#34;iPhone\u0026#34;, @\u0026#34;iPod touch\u0026#34; NSString *localizedModel; // localized version of model NSString *systemName; // e.g. @\u0026#34;iOS\u0026#34; NSString *systemVersion; // e.g. @\u0026#34;4.0\u0026#34; UIDeviceOrientation orientation; //除非正在生成设备方向的通知，否则返回UIDeviceOrientationUnknown NSUUID *identifierForVendor //可用于唯一标识该设备，同一供应商不同应用具有相同的UUID 1 2 3 4 5 6 7 UIDeviceOrientationUnknown, UIDeviceOrientationPortrait, // 竖向，头向上 UIDeviceOrientationPortraitUpsideDown, // 竖向，头向下 UIDeviceOrientationLandscapeLeft, // 横向，头向左 UIDeviceOrientationLandscapeRight, // 横向，头向右 UIDeviceOrientationFaceUp, // 平放，屏幕朝下 UIDeviceOrientationFaceDown // 平放，屏幕朝下 //使用内置的宏定义的函数，根据orientation判断设备方向,返回值类型BOOL.\n{%codeblock lang:java 纵向宏定义,返回YES:纵向%} #define UIDeviceOrientationIsPortrait(orientation) ((orientation) == UIDeviceOrientationPortrait || (orientation) == UIDeviceOrientationPortraitUpsideDown) {%endcodeblock %} {%codeblock lang:java 横向宏定义,返回YES:横向%} #define UIDeviceOrientationIsLandscape(orientation) ((orientation) == UIDeviceOrientationLandscapeLeft || (orientation) == UIDeviceOrientationLandscapeRight) {%endcodeblock%}\n横竖屏相关参数,方法与通知 检测当前设备是否生成设备转向通知 {%codeblock lang:objc%} BOOL generatesDeviceOrientationNotifications {%endcodeblock%} 设备方向开始改变时，触发该方法，可以重写实现一些操作。 {%codeblock lang:objc%} (void)beginGeneratingDeviceOrientationNotifications; {%endcodeblock%} 设备结束方向改变时，触发的事件，可以重写该实现一些操作。 {%codeblock lang:objc%} (void)endGeneratingDeviceOrientationNotifications; {%endcodeblock%} 通知 {%codeblock lang:objc 屏幕方向变化通知%} UIKIT_EXTERN NSString *const UIDeviceOrientationDidChangeNotification; {%endcodeblock%} ####手机电池相关属性与通知 电池属性 {%codeblock lang:objc 电池属性%} BOOL batteryMonitoringEnabled\t// 是否启动电池监控，默认为NO UIDeviceBatteryState batteryState //电池状态 float batteryLevel //电量百分比， 0 .. 1.0,监控禁用时为-1 {%endcodeblock%} {%codeblock lang:objc 电池状态UIDeviceBatteryState属性值%} UIDeviceBatteryStateUnknown,\t//禁用电池监控 UIDeviceBatteryStateUnplugged, // 未充电 UIDeviceBatteryStateCharging, // 正在充电 UIDeviceBatteryStateFull, // 满电 {%endcodeblock%} 电池通知 {%codeblock lang:objc 电池状态变化通知%} UIKIT_EXTERN NSString *const UIDeviceBatteryStateDidChangeNotification NS_AVAILABLE_IOS(3_0); {%endcodeblock%} {%codeblock lang:objc 电池电量变化通知%} UIKIT_EXTERN NSString *const UIDeviceBatteryLevelDidChangeNotification NS_AVAILABLE_IOS(3_0); {%endcodeblock%} 设备的其他属性及方法 {%codeblock lang:objc %} BOOL proximityMonitoringEnabled // 是否启动接近监控（例如接电话时脸靠近屏幕），默认为NO\nBOOL proximityState // 如果设备不具备接近感应器，则总是返回NO\nBOOL multitaskingSupported // 是否支持多任务\nUIUserInterfaceIdiom userInterfaceIdiom // 当前用户界面模式\n(void)playInputClick // 播放一个输入的声音 {%endcodeblock%} //用户界面类型 {%codeblock lang:objc iOS3.2以上有效%} #if __IPHONE_3_2 \u0026lt;= __IPHONE_OS_VERSION_MAX_ALLOWED UIUserInterfaceIdiomPhone, // iPhone 和 iPod touch 风格 UIUserInterfaceIdiomPad, // iPad 风格 #endif {%endcodeblock%} {%codeblock lang:java 获取当前用户界面模式的宏定义%} #define UI_USER_INTERFACE_IDIOM() ([[UIDevice currentDevice] respondsToSelector:@selector(userInterfaceIdiom)] ? [[UIDevice currentDevice] userInterfaceIdiom] : UIUserInterfaceIdiomPhone) {%endcodeblock%}\n一些协议的定义 {%codeblock lang:objc%} @protocol UIInputViewAudioFeedback @optional // 实现该方法，返回YES则自定义的视图能够播放输入的声音 @property (nonatomic, readonly) BOOL enableInputClicksWhenVisible; @end {%endcodeblock%}\n其他通知 {%codeblock lang:objc 接近状态变化通知%} UIKIT_EXTERN NSString *const UIDeviceProximityStateDidChangeNotification NS_AVAILABLE_IOS(3_0); {%endcodeblock%}\n","date":"2014-06-17T15:12:53+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/UIDevice%E7%B1%BB%E4%BB%8B%E7%BB%8D/","section":"post","tags":["iOS"],"title":"UIDevice类介绍"},{"categories":["学习笔记"],"contents":"Text Kit Text Kit：是个庞大的framework，继承了Core Text的全部功能，构建了快速、先进的文本排版和渲染引擎，更让开发者们高兴的是，设计者把它封装在了一个面向对象的API中。并且与UIKit框架很好的集成，它让程序能够通过NSTextStorage对象存储文本排版和显示文本等主要信息，并支持排版所需要的所有特性，包括字距调整、连写、换行和对齐等。\n更直观的理解，UITextView，UITextField、UILabel等UIKit控件都已经基于Text Kit重新构建，是为UIKit框架提供高质量排版服务而扩展的一些类和协议.\n例如：NSTextStorage对象，它本身是NSMutableAttributedString的子类，支持分批编辑，这就意味着在改变一个范围内的字符样式时，不用整体替换文本内容，就能完成排版效果。其中支持分页文本、文本包装、富文本编辑、交互式文本着色、文本折叠和自定义截取等特性。\nIOS6之前，想实现一些丰富的文本排版，例如在textView中显示不同样式的文本，或者图片和文字混排等，就需要借助于UIWebView或者深入研究一下Core Text。后来iOS6，增加一个很棒的属性:NSAttributedString，主要用于支持UILabel、UITextField、UITextView等UIKit控件自主排版的功能。很显然，IOS7并没有满足于这一改进，同时推出一款功能更为齐全，易用的Text Kit新宠。\n在iOS 6中, 用于文本的UIKit控件是基于WebKit和Core Graphics的字符串绘制方法来实现的。如下面层级体系图所示：\niOS 7的整体构架要更清晰，所有基于文本的UIKit控件（除了UIWebView）现在都可以使用Text Kit，如下图所示：\nText Kit中4个重要的角色 Text Views: 用来显示文本内容的控件，主要包括UILabel、UITextView和UITextField。 Text containers: 对应着NSTextContainer类。NSTextContainer定义了文本可以排版的区域。一般来说，都是矩形区域，当然，也可以根据需求，通过子类化NSTextContainer来创建别的一些形状，例如圆形、不规则的形状等。NSTextContainer不仅可以创建文本可以填充的区域，它还维护着一个数组——该数组定义了一个区域，排版的时候文字不会填充该区域，因此，我们可以在排版文字的时候，填充非文本元素。 Layout manager: 对应着NSLayoutManager类。该类负责对文字进行编辑排版处理——通过将存储在NSTextStorage中的数据转换为可以在视图控件中显示的文本内容，并把统一的字符编码映射到对应的字形(glyphs)上，然后将字形排版到NSTextContainer定义的区域中。 Text storage: 对应着NSTextStorage类。该类定义了Text Kit扩展文本处理系统中的基本存储机制。NSTextStorage继承自NSmutableAttributedString，主要用来存储文本的字符和相关属性。另外，当NSTextStorage中的字符或属性发生了改变，会通知NSLayoutManager，进而做到文本内容的显示更新。\n通常情况下，NSTextStorage、NSLayoutManager和NSTextContainer是一一对应关系:\n如果将文字显示为多列，或多页，可以按照下图关系，使用多个NSTextContainer: 如果针对不同的排版方式，可以按照下图关系，使用多个**NSLayoutManager: 通常由NSLayoutManager从NSTextStorage中读取出文本数据，然后根据一定的排版方式，将文本排版到NSTextContainer中，再由NSTextContainer**结合UITextView将最终效果显示出来。 如下图，为了更直观理解，对UITextView的组成做了分解: Text Kit示例 打开Xcode 5，新建一个Single View Application模板的程序，将工程命名为ExclusionPath。 打开Main.storyboard文件，然后再默认View Controller的View里面分别添加一个UITextView和UIImageView。并将这两个控件连接到ViewController.h中(名称分别为textView何imageView)。然后给textView设置一些字符串，imageView设置一个图片。 打开ViewController.m文件，找到viewDidLoad方法，用如下代码替换该方法： {%codeblock lang:objc%} (void)viewDidLoad { [super viewDidLoad];\n//创建一个平移手势对象，该对象可以调用imagePanned：方法 UIPanGestureRecognizer *panGes = [[UIPanGestureRecognizer alloc] initWithTarget:self action:@selector(imagePanned:)]; [self.imageView addGestureRecognizer:panGes];\nself.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; } {%endcodeblock%} 在上面的代码中，给imageView添加了一个平移手势。另外通过调用translatedBezierPath方法，给textView的textContainer设置exclusionPaths属性值。表示需要排除的区域（也就是图片在排版中显示的位置）。\n3. 2. translatedBezierPath方法实现如下： {%codeblock lang:objc%}\n(UIBezierPath *)translatedBezierPath { CGRect butterflyImageRect = [self.textView convertRect:self.imageView.frame fromView:self.view]; UIBezierPath *newButterflyPath = [UIBezierPath bezierPathWithRect:butterflyImageRect];\nreturn newButterflyPath; } {%endcodeblock%} 在上面的代码中，利用imageView的frame属性创建了一个UIBezierPath，然后将该值返回。\n3. 3. **imagePanned:**方法实现如下： {%codeblock lang:objc%}\n(void)imagePanned:(id)sender { if ([sender isKindOfClass:[UIPanGestureRecognizer class]]) { UIPanGestureRecognizer *localSender = sender;\nif (localSender.state == UIGestureRecognizerStateBegan) { self.gestureStartingPoint = [localSender translationInView:self.textView]; self.gestureStartingCenter = self.imageView.center; } else if (localSender.state == UIGestureRecognizerStateChanged) { CGPoint currentPoint = [localSender translationInView:self.textView]; CGFloat distanceX = currentPoint.x - self.gestureStartingPoint.x; CGFloat distanceY = currentPoint.y - self.gestureStartingPoint.y; CGPoint newCenter = self.gestureStartingCenter; newCenter.x += distanceX; newCenter.y += distanceY; self.imageView.center = newCenter; self.textView.textContainer.exclusionPaths = @[[self translatedBezierPath]]; } else if (localSender.state == UIGestureRecognizerStateEnded) { self.gestureStartingPoint = CGPointZero; self.gestureStartingCenter = CGPointZero; } } } {%endcodeblock%} 在上面的代码中首先根据平移的距离来设置imageView的位置，然后利用translatedBezierPath方法重新计算了一下排除区域。\n示例效果:\n","date":"2014-06-16T22:24:48+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/UI/IOS7%E6%96%B0%E5%AE%A0TextKit/","section":"post","tags":["API"],"title":"IOS7新宠TextKit"},{"categories":["学习笔记"],"contents":"性能提高以及被遗弃的功能 新增截屏通知:UIApplicationUserDidTakeScreenshotNotification 在IOS 7之前，开发者使用了一种**很赞的方法，来拦截截屏事件的.\n比如，Snapchat的实现原理: 用户通过Snapchat**发送的照片将会在数秒内自动被删除，而且在浏览照片时，必须将手指按在屏幕上，否则会立即关闭。然而，在 iOS 6 中，截屏将打断触控操作，开发者就利用这个功能点，在恰当时机捕捉到了截屏事件。\n在iOS 7中，专门为截屏完成后提供了一个通知: UIApplicationUserDidTakeScreenshotNotification.同时，也规避了IOS 6中截屏将打断触控操作的关键功能点。以至于在截屏之前，无法拦截用户的截屏操作。\n注册截屏完成后通知:\n1 2 3 4 [[NSNotificationCenter defaultCenter] addObserver:self selector:@selector(mymethod:) name:UIApplicationUserDidTakeScreenshotNotification object:nil]; Note:\n1.This notification is posted after the screenshot is taken. 2.This notification does not contain a userInfo dictionary.\n新增手势: UIScreenEdgePanGestureRecognizer UIScreenEdgePanGestureRecognizer inherits from UIPanGestureRecognizer and lets you detect gestures starting near the edge of the screen. Using this new gesture recognizer is quite simple, as shown below:\n1 2 3 4 5 6 UIScreenEdgePanGestureRecognizer *recognizer = [[UIScreenEdgePanGestureRecognizer alloc] initWithTarget:self action:@selector(handleScreenEdgeRecognizer:)]; // accept gestures that start from the left; we\u0026#39;re probably building another hamburger menu! recognizer.edges = UIRectEdgeLeft; [self.view addGestureRecognizer:recognizer]; 新增返回类型 – instancetype 苹果改变了大部分 initializer和简易构造函数（convenience constructors），instancetype可以代替id作返回类型。\ninstancetype 作用： 1.作为从Objective-C方法的返回类型。 2.在编译时，该方法的返回类型将是该方法所属的类的实例，编译器就会对返回的实例做一些检查，有bug及时发现及时解决。这一点优于id类型。 3.在调用子类方法时，就可以省去对返回值的强制类型转换。 举例:\n1 2 NSDictionary *d = [NSArray arrayWithObjects:@(1),@(2), nil]; NSLog(@\u0026#34;%i\u0026#34;, d.count); 这段代码显然有错误，但在Xcode4.6上是可以编译通过的。是由于Objective-C是动态性语言。\n1 + (id)arrayWithObjects:(id)firstObj, ...; 并且，arrayWithObjects:返回id类型：是运行时的动态类型，编译器无法知道它的真实类型，即使调用一个id类型没有的方法，也不会产生编译警告。\n那么，为什么arrayWithObjects:方法的返回类型还是id类型？来看看NSArray子类：\n1 2 @interface MyArray : NSArray @end Now consider the use of your new subclass in the code below:\n1 MyArray *array = [MyArray arrayWithObjects:@(1), @(2), nil]; 如果方法arrayWithObjects:返回值的类型是NSArray *，那么子类MyArray就需要被强制转换为所需的类NSArray。这是正是instancetype返回类型的用武之地。 在iPhone 7.0 SDK的NSArray中的头文件，已更新为：\n1 + (instancetype)arrayWithObjects:(id)firstObj, ...; 唯一的区别是返回类instancetype取代id。这种新的返回类型会告知编译器，返回值是该方法所属的类的实例对象。\n也就是说:当NSArray调用arrayWithObjects:时，返回类型推断为NSArray*; 当MyArray调用arrayWithObjects:时，返回类型推断为MyArray*。\ninstancetype解决id类型的问题，同时也继承id类型功能。如果编译在Xcode 5的原代码，你会看到下面的警告：\n1 2 3 warning: incompatible pointer types initializing \u0026#39;NSDictionary *\u0026#39; with an expression of type \u0026#39;NSArray *\u0026#39; [-Wincompatible-pointer-types] NSDictionary *d = [NSArray arrayWithObjects:@(1), @(2), nil]; ^ ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ w00t — now that’s helpful! You now have the opportunity to fix the problem before it turns into a crash later down the line.\nInitializers are also candidates for using this new return type. The compiler has warned you for some time now if you set the return type of an initializer to that of an incompatible type. But presumably it’s just implicitly converting the id return type to instancetype under the hood. You should still use instancetype for initializers though, because it’s better to be explicit for habit’s sake.\nStrive to use instancetype as much as possible going forward; it’s become a standard for Apple — and you never know when it will save you some painful debugging time later on.\nUIScrollView新增属性：UIScrollViewKeyboardDismissMode 像Messages app一样在滚动的时候，将键盘隐藏，是一种非常好的体验。\n在以前，将这项功能整合到app很难，现在仅仅只需要在Storyboard中简单的改变一个属性值，或者增加一行代码即可。\n这个属性使用了新的UIScrollViewKeyboardDismissMode enum枚举类型。这个enum枚举类型可能的值如下：\n1 2 3 4 5 6 // the keyboard is not dismissed automatically when scrolling UIScrollViewKeyboardDismissModeNone // dismisses the keyboard when a drag begins UIScrollViewKeyboardDismissModeOnDrag // the keyboard follows the dragging touch off screen, and may be pulled upward again to cancel the dismiss UIScrollViewKeyboardDismissModeInteractive 在storyboard中设置该属性值:\nUIKit使用[NSAttributedString]((http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/)显示HTML，TextKit 在app中使用Webviews有时会让人非常沮丧，即使只是显示少量的HTML内容 ,Webviews也会消耗大量的内存。 现在提供了一种全新的简单易用的方式来展示HTML内容，适用于任意的UIKit控件，如UILabel或UITextField等。\n1.用少量HTML片段，初始化NSAttributedString对象:\n{% codeblock lang:objc Time to be Awesome - awesome.rb %} NSString *html = @\u0026quot;Wow! Now iOS can create NSAttributedString from HTMLs!\u0026quot;; NSDictionary *options = @{NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType}; {% endcodeblock %}\n``` objc 用少量HTML片段，初始化NSAttributedString对象 http://developer.apple.com/documentation/Cocoa/Reference/Foundation/Classes/NSAttributedString_Class/ NSString *html = @\u0026quot;Wow! Now iOS can create NSAttributedString from HTMLs!\u0026quot;; NSDictionary *options = @{NSDocumentTypeDocumentAttribute: NSHTMLTextDocumentType}; NSData *htmlData = [html dataUsingEncoding:NSUTF8StringEncoding]; NSAttributedString *attrString = [[NSAttributedString alloc] initWithData:htmlData options:options documentAttributes:nil error:nil];\n1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 NSDocumentTypeDocumentAttribute包括: \u0026lt;!--https://gist.githubusercontent.com/it-boyer/ecba275d5e4404678354/raw/1636f62209b056b4acbe07021f596e1ffd5ef301/%E8%A7%A3%E6%9E%90NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%88%90HTML%E7%89%87%E6%AE%B5 --\u0026gt; NSPlainTextDocumentType\t//Plain text document. NSRTFTextDocumentType\t//Rich text format document. NSRTFDTextDocumentType\t//Rich text format with attachments document. 2.相反，也可以将`NSAttributedString`对象，解析成HTML片段： {% gist ecba275d5e4404678354 %E8%A7%A3%E6%9E%90NSAttributedString%E5%AF%B9%E8%B1%A1%EF%BC%8C%E8%8E%B7%E5%8F%96%E6%88%90HTML%E7%89%87%E6%AE%B5.m %}\t### NSLinkAttributeName让标签（UILabel,UITextView）支持超链接 首先，创建一个`NSAttributedString`对象,然后，调用`addAttribute:value:range:`方法，添加 `NSLinkAttributeName`属性并赋值，如下： ``` objc UITextView支持超链接 NSMutableAttributedString *attributedString = [[NSMutableAttributedString alloc] initWithString:@\u0026#34;This is an example by @marcelofabri_\u0026#34;]; [attributedString addAttribute:NSLinkAttributeName value:@\u0026#34;username://marcelofabri_\u0026#34; range:[[attributedString string] rangeOfString:@\u0026#34;@marcelofabri_\u0026#34;]]; NSDictionary *linkAttributes = @{NSForegroundColorAttributeName: [UIColor greenColor], NSUnderlineColorAttributeName: [UIColor lightGrayColor], NSUnderlineStyleAttributeName: @(NSUnderlinePatternSolid)}; // assume that textView is a UITextView previously created (either by code or Interface Builder) textView.linkTextAttributes = linkAttributes; // customizes the appearance of links textView.attributedText = attributedString; textView.delegate = self; 当然，也可以使用UITextViewDelegate新增的协议方法shouldInteractWithURL，来自定义点击事件：\n1 2 3 4 5 6 7 8 9 10 - (BOOL)textView:(UITextView *)textView shouldInteractWithURL:(NSURL *)URL inRange:(NSRange)characterRange { if ([[URL scheme] isEqualToString:@\u0026#34;username\u0026#34;]) { NSString *username = [URL host]; // do something with this username // ... return NO; } return YES; // let the system open this URL } Tint images with UIImage.renderingMode Tinting is a big part of the new look and feel of iOS 7, and you have control whether your image is tinted or not when rendered.\nUIImage now has a read-only property named renderingMode as well as a new method imageWithRenderingMode: which uses the new enum UIImageRenderingMode containing the following possible values:\n1 2 3 4 5 6 // Use the default rendering mode for the context where the image is used UIImageRenderingModeAutomatic // Always draw the original image, without treating it as a template UIImageRenderingModeAlwaysOriginal // Always draw the image as a template image, ignoring its color information UIImageRenderingModeAlwaysTemplate The code below shows how easy it is to create an image with a given rendering mode:\n1 2 UIImage *img = [UIImage imageNamed:@\u0026#34;myimage\u0026#34;]; img = [img imageWithRenderingMode:UIImageRenderingModeAlwaysTemplate]; The default value of renderingMode is UIImageRenderingModeAutomatic.\nWhether the image will be tinted or not depends on where it’s being displayed as shown by the examples below:\nUsage of tintColor vs barTintColor In iOS 7 you can tint your entire app with a given color or even implement color themes to help your app stand out from the rest.Setting the tint color of your app is as easy as using the new property tintColor of UIView.\nDoes that property sound familiar? it should — some classes such as UINavigationBar, UISearchBar, UITabBar and UIToolbar already had a property with this name. They now have a new property: barTintColor.\nIn order to avoid getting tripped up by the new property, you should perform the following check if your app needs to support iOS 6 or earlier:\n1 2 3 4 5 6 7 8 9 10 UINavigationBar *bar = self.navigationController.navigationBar; UIColor *color = [UIColor greenColor]; if ([bar respondsToSelector:@selector(setBarTintColor:)]) { // iOS 7+ bar.barTintColor = color; } else { // iOS 6 or earlier bar.tintColor = color; } Check which wireless routes are available The ability to customize a video player (and friends) has evolved throughout the past few iOS versions. As an example, prior to iOS 6 you couldn’t change the AirPlay icon on a MPVolumeView.\nIn iOS 7, you’re finally able to know if a remote device is available via AirPlay, Bluetooth, or some other wireless mechanism. This allows your app to behave appropriately, such as hiding an AirPlay icon when that service isn’t available on other devices.\nThe following two new properties and notifications have been added to MPVolumeView:\n1 2 3 4 5 6 7 // is there a route that the device can connect to? @property (nonatomic, readonly) BOOL wirelessRoutesAvailable; // is the device currently connected? @property (nonatomic, readonly) BOOL wirelessRouteActive; NSString *const MPVolumeViewWirelessRoutesAvailableDidChangeNotification; NSString *const MPVolumeViewWirelessRouteActiveDidChangeNotification; -[NSArray firstObject]的实现 -[NSArray firstObject]可能是Objective-C中被调用做多的API。 在iOS4.0中firstObject已经被使用，但是那时仅仅是一个私有方法。在iOS7以前，常用方法：\n1 2 3 4 NSArray *arr = @[]; id item = [arr firstObject]; // 前你需要做以下工作 id item = [arr count] \u0026gt; 0 ? arr[0] : nil; 因为上面的方式很常用，一般创建一个类别实现该方法firstObject增加到NSArray中。\n这个方法的问题:方法名必须是唯一的，否则,这个方法所引发的问题无法预估。所以在NSArray中最好不要重载firstObject方法，是有风险的。\nUIButtonTypeRoundRect被UIButtonTypeSystem取代 UIPasteboard由共享变为沙盒化了 UIPasteboard过去是用来做app之间的数据分享的。开发者一般使用它来存储标识符，比如:OpenUDID。\n但在在iOS7中，使用 +[UIPasteboard pasteboardWithName:create:]和 +[UIPasteboard pasteboardWithUniqueName]创建剪贴板，而且只对相同的app group可见，这样再和其他的相关app分享以前的OpenUDID等标识符时，就会出现问题。\nMAC地址:被统一化 在IOS7之前，生成iOS设备唯一标示符的方法是使用iOS设备的Media Access Control（MAC）地址。 一个MAC地址是一个唯一的号码，它是物理网络层级方面分配给网络适配器的。 然而，苹果并不希望有人通过MAC地址来分辨用户，在iOS7以上，查询MAC地址，它现在只会返回02:00:00:00:00:00。\n目前，苹果推荐开发者使用以下两种方式，来获取作为框架和应用的唯一标示符：\n1 2 NSString *identifierForVendor = [[UIDevice currentDevice].identifierForVendor UUIDString]; NSString *identifierForAdvertising = [[ASIdentifierManager sharedManager].advertisingIdentifier UUIDString]; identifierForVendor：由同一个公司发行的的app在相同的设备上运行的时候都会有这个相同的标识符。然而，如果用户删除了这个供应商的app然后再重新安装的话，这个标识符就会不一致。 advertisingIdentifier：返回给在这个设备上所有软件供应商公用的唯一值，所以只能在广告的时候使用。这个值会因为很多情况而有所变化，比如说用户初始化设备的时候便会改变。\napp启动麦克风，需争征得用户同意 以前如果app需要使用用户的位置，通讯录，日历，提醒以及照片，接受推送消息，使用用户的社交网络的时候需要征得用户的同意。 现在在iOS7当中，使用麦克风也需要取得用户同意了。如果用户不允许app使用麦克风的话，那么需要使用麦克风的app就不能接收不到任何声音。 以下的代码是用来查询用户是否允许app使用麦克风：\n1 2 3 4 5 6 7 8 9 10 11 //第一次调用这个方法的时候，系统会提示用户让他同意你的app获取麦克风的数据 // 其他时候调用方法的时候，则不会提醒用户 // 而会传递之前的值来要求用户同意 [[AVAudioSession sharedInstance] requestRecordPermission:^(BOOL granted) { if (granted) { // 用户同意获取数据 } else { // 可以显示一个提示框告诉用户这个app没有得到允许？ } } ]; 如果没有经过用户同意，就调用麦克风，iOS系统自动弹出以下警示栏： ","date":"2014-06-11T10:17:19+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/IOS7%E7%9A%84%E5%8F%98%E9%9D%A9/","section":"post","tags":["IOS"],"title":"IOS7的变革"},{"categories":["解决方案"],"contents":"A number of Stack Overflowquestions were having issues with this, so I figured I’d explain. From reverse engineering, this is the exact method used by SnapChat, but it’s also pretty much what I’d have done myself.\nThe process is pretty simple, and relies on a quirk of iOS: taking a screenshot cancels all touches on the screen. Because of that, anything that you want to protect will require you to have the user to touch the screen to see. If that works for your purposes, the general solution is to simply intercept the touch cancellation, and quickly remove any sensitive information from the screen. If you’re also implementing a screenshot counter, as with SnapChat, you will also need to take into account the other cases when a touch might be cancelled: from a system gesture (Notification Center or the iPad’s multitasking gestures), or by activating other pieces of system UI (the power down menu, or the multitasking switcher).\nOn a technical level, the two basic pieces are UILongPressGestureRecognizer (or -touchesCancelled:withEvent:, if you want) and UIApplicationDelegate. In your long press handler, you should hide your sensitive information when the gesture recognizer’s state is UIGestureRecognizerStateCancelled, and if you want to track the number of screenshots, increment a counter. Then, in the UIApplicationDelegate, decrement that counter when you receive the -applicationWillEnterBackground: or -applicationDidResignActive: notification to account for the other possibilities for a cancelled touch. You might also need to handle other situations where a touch could be cancelled, if other parts of your app might cause that to happen.\n","date":"2014-06-10T18:45:37+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/%E5%9C%A8IOS%E4%B8%AD%E5%83%8FSnapChat%E4%B8%80%E6%A0%B7%E7%9B%91%E6%8E%A7screenshots/","section":"post","tags":["iOS"],"title":"在IOS中像SnapChat一样监控screenshots"},{"categories":["解决方案"],"contents":"iOS 7截图最新变化: 不再影响用户其他操作 在 iOS 7 中，截图动作已经发生了变化，就如苹果在版本说明中描述的那样：用户截图时，有效点击不会再失效了。这个微小的变化对于多款依赖截屏来提醒用户一些不必要动作的应用来说，具有很重要的意义，比如 Snapchat 和 Facebook Poke。\n用户在应用中打开 Snapchat 照片，查看照片时用户需要单指按在屏幕上让照片处于打开的状态。如果用户试图截图，那么照片马上就会关闭。这是 Snapchat 用来检测“非法”截图的办法。用户拍了照片发送给好友后，这些照片会根据用户所预先设定的时间按时自动销毁。如果接收方在此期间试图进行截图的话，用户也将得到通知。\nSnapchat在美国青少年群体中十分流行，因为它拥有一种独特的“阅后即焚”机制。用户通过该应用发送的照片将会在数秒内自动被删除，而且它还将采用一种特殊手段阻止照片接收者截屏，并将其截屏企图报告给发送者。在 iOS 6 中，截屏将打断触控操作，而用户观看 Snapchat 照片时，必须将手指按在屏幕上。\n在 iOS 7 中截图的操作不会迫使 SnapChat 查看照片的窗口关闭，也就是说当用户截图时系统也不会发出提醒通知。截图不会影响用户在屏幕上的操作，照片不会关闭应用也无法识别截图的动作。如果一名 iOS 6 用户试图截图 iOS 7 用户会收到通知，而反过来的话 iOS 6 用户则不会受到通知。这对于 Snapchat 来说，绝对是个恶梦，因为该服务的风靡与阅后即焚机制关系很大。\n虽然 iOS 7 的这个变化对于 iOS 7 Snapchat 用户来说有一定的意义，但是这也对 Snapchat 等应用提出更高的要求，他们必须研究出新的办法来检测截图操作，确保这个新特性不会对他们的应用产生影响。\n所幸 iOS 7 beta 4 的发布可以让开发商放下心来。9to5Mac 的 Scott Buscemi 不久前宣布，新版本中新增了一个截屏侦测 API。开发者并未透露这个其具体特性，但他暗示说这个 API 对 Snapchat 来说非常至关重要.\nUIApplication.h\n// This notification is posted after the user takes a screenshot (for example by pressing both the home and lock screen buttons) UIKIT_EXTERN NSString *const UIApplicationUserDidTakeScreenshotNotification NS_AVAILABLE_IOS(7_0); 据悉，iOS 7 beta 2 发布之后，此前一些无法实现的有趣操作也随之变得可行。由于 iOS 6 的截屏将取消触控操作，使得用户难以截取拉了半截的锁屏界面。而在 iOS 7 beta 2 中，一切变得容易起来（见下图）。\n","date":"2014-06-10T18:29:31+08:00","permalink":"https://it-boyer.github.io/post/old/iOS/IOS7%E6%88%AA%E5%B1%8F%E9%97%AE%E9%A2%98/","section":"post","tags":["iOS"],"title":"IOS7截屏问题"},{"categories":null,"contents":" +++ title = \u0026ldquo;验证ob绘图工具结合双向链接嵌套和Hugo的兼容性\u0026rdquo; description = \u0026ldquo;ob中有很不错的插件，可以实现沉浸式编写博客，现在有个绘图工具，尝试使用ob的嵌套图片和md嵌套两种方式，在Hugo中的效果\u0026rdquo; date = \u0026ldquo;2022-10-20 20:53:13\u0026rdquo; publishDate = \u0026ldquo;2022-10-20\u0026rdquo; lastmod = \u0026ldquo;2022-10-20 20:53:13\u0026rdquo; categories = [\u0026ldquo;日志随笔\u0026rdquo;] draft = false authors = [\u0026ldquo;iTBoyer\u0026rdquo;] +++ 使用ob语法添加图片预览 1 !\\[\\[Drawing2022-10-2020.43.21.excalidraw.png\\]\\] 使用markdown语法嵌套图片预览 1 ![](Excalidraw/Drawing2022-10-2020.43.21.excalidraw.png) 解决双向链接的问题 使用hugo端代码和shell方式配合，在githubworkfow的过程，执行上述操作，实现在发布时做一次双向链接的翻译成支持hugo的格式。\nhttps://zhuanlan.zhihu.com/p/351240588?utm_id=0\nhttps://matnoble.me/tech/hugo/shortcodes-practice-tutorial-for-hugo/\nHugo无法解析Obsidian的双向链接，解决这个问题是本文的目标。\n【解决方案】 我通过shell脚本和Hugo短代码的配合解决这个问题。 通过shell脚本将Obsidian的双向链接转换成Hugo可以识别的自定义格式；Hugo短代码则负责解析这种自定义格式。\nroamlink无效的问题 ob双向链接替换为roamlink之后，hugo server预览看不到效果？ 暂时使用直接替换的处理方法, 仅支持替换Drawing目录下的图片：\n1 2 #图片链接变换 sed -i \u0026#39;s/\\[\\[Drawing\\([^[]*\\)|\\([^[]*\\)\\]\\]/[\\2](\\/Excalidraw\\/Drawing\\1)/g; s/\\[\\[Drawing\\([^[|]*\\)\\]\\]/[\\1](\\/Excalidraw\\/Drawing\\1)/g; \u0026#39; $1\u0026#34;/\u0026#34;$file sed修改文件内容时，语法在mac和linux的用法区别 1 2 3 4 #linux sed -i \u0026#39;替换语\u0026#39; file # mac 终端测试命令, 修改文件时，要有空字符分割。 sed -i \u0026#39;\u0026#39; \u0026#39;替换语\u0026#39; file ","date":"0001-01-01T00:00:00Z","permalink":"https://it-boyer.github.io/post/%E6%97%A5%E5%BF%97%E9%9A%8F%E7%AC%94/%E9%AA%8C%E8%AF%81ob%E7%BB%98%E5%9B%BE%E5%B7%A5%E5%85%B7%E7%BB%93%E5%90%88%E5%8F%8C%E5%90%91%E9%93%BE%E6%8E%A5%E5%B5%8C%E5%A5%97%E5%92%8CHugo%E7%9A%84%E5%85%BC%E5%AE%B9%E6%80%A7/","section":"post","tags":null,"title":""}]